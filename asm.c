/* ------------------------------------------------------------------------
 * asm.c: a tiny assembler for riscv machines. 
 * -------------------------------------------------------------------------
 * This is a digest of the gas assembler (a part of the binutils distribution)
 * for the riscv machine. The full copyright notice is in asm.h, the companion
 * file for this one. I have reformatted the code, and added references to where I 
 * got each function. Some names are changed.
 * All the indirections existing in gas have been eliminated. When you see text
 * like this: "foo(arg);" it is highly likely that that is indeed a call to function
 * "foo" with argument "arg" and not a #defined symbol that points to a vtable that
 * renames it to some function elsewhere.
 * #ifdefs have been eliminated as far as I could do that, to simplify the code
 * and making it  easier to read.
 * All linker code that was getting pulled in by the vtables is gone. This is an 
 * assembler, not a linker.
 * The code has been reformatted to minimize the vertical length. There are already
 * around 40 000 lines, so the less, the better. Of course readability is more
 * important than minimizing vertical space.
 *
 * jacob navia, Villetaneuse, France, summer 2023 
 * jacob at jacob dot remcomp dot fr
 */
#include "asm.h"
/* ======================================================== Global variables */
static char    *buffer;		/* 1st char of each buffer of lines is here.  */
static char    *buffer_limit;	/*->1 + last char in buffer.  */

/* TARGET_BYTES_BIG_ENDIAN is required to be defined to either 0 or 1 in the
 * tc-<CPU>.h file.  See the "Porting GAS" section of the internals manual. */
static int	target_big_endian = TARGET_BYTES_BIG_ENDIAN;

/* Variables for handling include file directory table.  */
/* Length of longest in table.  */
static size_t	include_dir_maxlen;
/* Record the current function so that we can issue an error message for
 * misplaced .func,.endfunc,and also so that .endfunc needs no arguments.  */
static char    *current_name;
static char    *current_label;

static int	dwarf_file;
static int	dwarf_line;

/* Used to control final evaluation of expressions.  */
static int	finalize_syms = 0;
/* This variable is set to be non-zero if the next string we see might be the
 * name of the source file in DWARF debugging information.  See the comment in
 * emit_expr for the format we look for.  */
static int	dwarf_file_string;
/* ============================================================**** as.c */
/*
 * We build a list of defsyms as we read the options,and then define them
 * after we have initialized everything.
 */
struct defsym_list {
	struct defsym_list *next;
	char           *name;
	valueT		value;
};

/* Type of debugging to generate.  */
static enum debug_info_type debug_type = DEBUG_UNSPECIFIED;
static int	use_gnu_debug_info_extensions = 0;
static enum debug_info_type (*md_debug_format_selector) (int *)= NULL;
/* argv[0]  */
static char    *myname;
/*
 * The default obstack chunk size.  If we set this to zero,the obstack code
 * will use whatever will fit in a 4096 byte block.  */
static int	chunksize = 0;

/* To monitor memory allocation more effectively,make this non-zero. Then the
 * chunk sizes for gas and bfd will be reduced.  */
static int	debug_memory = 0;
/* Enable verbose mode.  */
static int	verbose = 0;

/* Which version of DWARF CIE to produce.  This default value of -1 indicates
 * that this value has not been set yet,a default value is provided in
 * dwarf2_init.  A different value can also be supplied by the command line
 * flag --gdwarf-cie-version,or by a target in MD_AFTER_PARSE_ARGS.  */
static int	flag_dwarf_cie_version = -1;

/* The maximum level of DWARF DEBUG information we should manufacture. This
 * defaults to 3 unless overridden by a command line option.  */
static unsigned	dwarf_level = 3;

static int	flag_use_elf_stt_common = 1;
static bool	flag_generate_build_notes = 0;

static segT	reg_section;
static segT	expr_section;
static segT	text_section;
static segT	data_section;
static segT	bss_section;

/* symbols.c -symbol table- */
struct symbol_flags {
	/* Whether the symbol is a local_symbol.  */
	unsigned int	local_symbol:1;

	/* Weather symbol has been written.  */
	unsigned int	written:1;

	/* Whether symbol value has been completely resolved (used during final
	 * pass over symbol table).  */
	unsigned int	resolved:1;

	/* Whether the symbol value is currently being resolved (used to detect
	 * loops in symbol dependencies).  */
	unsigned int	resolving:1;

	/* Whether the symbol value is used in a reloc.  This is used to ensure
	 * that symbols used in relocs are written out,even if they are local
	 * and would otherwise not be.  */
	unsigned int	used_in_reloc:1;

	/* Whether the symbol is used as an operand or in an expression. NOTE:
	 * Not all the backends keep this information accurate; backends which
	 * use this bit are responsible for setting it when a symbol is used in
	 * backend routines.  */
	unsigned int	used:1;

	/* Whether the symbol can be re-defined.  */
	unsigned int	volatil:1;

	/* * Whether the symbol is a forward reference,and whether such has been
	 * determined.  */
	unsigned int	forward_ref:1;
	unsigned int	forward_resolved:1;

	/* This is set if the symbol is set with a .weakref directive.  */
	unsigned int	weakrefr:1;

	/* This is set when the symbol is referenced as part of a .weakref
	 * directive,but only if the symbol was not in the symbol table
	 * before.  It is cleared as soon as any direct reference to the symbol
	 * is present.  */
	unsigned int	weakrefd:1;

	/* Whether the symbol has been marked to be removed by a .symver
	 * directive.  */
	unsigned int	removed:1;

	/* Set when a warning about the symbol containing multibyte characters
	 * is generated.  */
	unsigned int	multibyte_warned:1;
};

/* A pointer in the symbol may point to either a complete symbol (struct symbol
 * below) or to a local symbol (struct local_symbol defined here).  The symbol
 * code can detect the case by examining the first field which is present in
 * both structs.
 * 
 * We do this because we ordinarily only need a small amount of information for a
 * local symbol.  The symbol table takes up a lot of space,and storing less
 * information for a local symbol can make a big difference in assembler memory
 * usage when assembling a large file.  */
struct local_symbol {
	/* Symbol flags.  Only local_symbol and resolved are relevant.  */
	struct symbol_flags flags;
	/* Hash value calculated from name.  */
	hashval_t	hash;
	/* The symbol name.  */
	const char     *name;
	/* The symbol frag.  */
	fragS          *frag;
	/* The symbol section.  */
	asection       *section;
	/* The value of the symbol.  */
	valueT		value;
};

/* The information we keep for a symbol.  The symbol table holds pointers both
 * to this and to local_symbol structures.  The first three fields must be
 * identical to struct local_symbol,and the size should be the same as or
 * smaller than struct local_symbol. Fields that don't fit go to an extension
 * structure.  */
typedef struct symbol {
	/* Symbol flags.  */
	struct symbol_flags flags;
	/* Hash value calculated from name.  */
	hashval_t	hash;
	/* The symbol name.  */
	const char     *name;
	/* Pointer to the frag this symbol is attached to,if any. Otherwise, NULL.  */
	fragS          *frag;
	/* BFD symbol */
	asymbol        *bsym;
	/* Extra symbol fields that won't fit.  */
	struct xsymbol *x;
}		symbolS;
static symbolS	abs_symbol;
static symbolS	dot_symbol;
static struct defsym_list *defsyms;
static long	start_time;
static void	print_version_id(void)
{
	static int	printed;

	if (printed) return;
	printed = 1;

	fprintf(stderr,"tiny GNU assembler version %s (%s) not using BFD\n",
		VERSION,TARGET_ALIAS);
}

#ifdef DEFAULT_FLAG_COMPRESS_DEBUG
enum compressed_debug_section_type flag_compress_debug
= DEFAULT_COMPRESSED_DEBUG_ALGORITHM;
#define DEFAULT_COMPRESSED_DEBUG_ALGORITHM_HELP \
        DEFAULT_COMPRESSED_DEBUG_ALGORITHM
#else
#define DEFAULT_COMPRESSED_DEBUG_ALGORITHM_HELP COMPRESS_DEBUG_NONE
#endif

enum options {
	OPTION_MARCH = OPTION_MD_BASE,OPTION_PIC,OPTION_NO_PIC,OPTION_MABI,
	OPTION_RELAX,OPTION_NO_RELAX,OPTION_ARCH_ATTR,OPTION_NO_ARCH_ATTR,
	OPTION_CSR_CHECK,OPTION_NO_CSR_CHECK,OPTION_MISA_SPEC,OPTION_MPRIV_SPEC,
	OPTION_BIG_ENDIAN,OPTION_LITTLE_ENDIAN,OPTION_END_OF_ENUM
};
/* Since it is easy to do here we interpret the special arg "-" to mean "use
 * stdin" and we set that argv[] pointing to "". After we have munged argv[],
 * the only things left are source file name(s) and ""(s) denoting stdin. These
 * file names are used (perhaps more than once) later.
 * 
 * check for new machine-dep cmdline options in md_parse_option definitions in
 * config/tc-*.c.  */
static struct option md_longopts[] =
{
	{"march",required_argument,NULL,OPTION_MARCH},
	{"fPIC",no_argument,NULL,OPTION_PIC},
	{"fpic",no_argument,NULL,OPTION_PIC},
	{"fno-pic",no_argument,NULL,OPTION_NO_PIC},
	{"mabi",required_argument,NULL,OPTION_MABI},
	{"mrelax",no_argument,NULL,OPTION_RELAX},
	{"mno-relax",no_argument,NULL,OPTION_NO_RELAX},
	{"march-attr",no_argument,NULL,OPTION_ARCH_ATTR},
	{"mno-arch-attr",no_argument,NULL,OPTION_NO_ARCH_ATTR},
	{"mcsr-check",no_argument,NULL,OPTION_CSR_CHECK},
	{"mno-csr-check",no_argument,NULL,OPTION_NO_CSR_CHECK},
	{"misa-spec",required_argument,NULL,OPTION_MISA_SPEC},
	{"mpriv-spec",required_argument,NULL,OPTION_MPRIV_SPEC},
	{"mbig-endian",no_argument,NULL,OPTION_BIG_ENDIAN},
	{"mlittle-endian",no_argument,NULL,OPTION_LITTLE_ENDIAN},

	{NULL,no_argument,NULL,0}
};
static size_t	md_longopts_size = sizeof(md_longopts);
static void	parse_args(int *pargc,char ***pargv)
{
	int		old_argc;
	int		new_argc;
	char          **old_argv;
	char          **new_argv;
	/* Starting the short option string with '-' is for programs that
	 * expect options and other ARGV-elements in any order and that care
	 * about the ordering of the two.  We describe each non-option
	 * ARGV-element as if it were the argument of an option with character
	 * code 1.  */
	char           *shortopts;
	static const char std_shortopts[] = {
		'-','J',
		'L','M','R','W','Z','a',':',':','D','f','g',':',':','I',':','o',':',
		/* -v takes an argument on VMS,so we don't make it a generic
		 * option.  */
		'v',
		'w','X',
#ifdef HAVE_ITBL_CPU
		/*
		 * New option for extending instruction set (see also --itbl
		 * below).
		 */
		't',':',
#endif
		'\0'
	};
	struct option  *longopts;
	/* Codes used for the long options with no short synonyms.  */
	enum option_values {
		OPTION_HELP = OPTION_STD_BASE,OPTION_STATISTICS,OPTION_VERSION,
		OPTION_DUMPCONFIG,OPTION_VERBOSE,OPTION_EMULATION,OPTION_DEBUG_PREFIX_MAP,
		OPTION_DEFSYM,OPTION_LISTING_LHS_WIDTH,
		OPTION_LISTING_LHS_WIDTH2,	/* = STD_BASE + 10 */
		OPTION_LISTING_RHS_WIDTH,OPTION_LISTING_CONT_LINES,OPTION_DEPFILE,
		OPTION_GSTABS,OPTION_GSTABS_PLUS,OPTION_GDWARF_2,OPTION_GDWARF_3,
		OPTION_GDWARF_4,OPTION_GDWARF_5,
		OPTION_GDWARF_SECTIONS,	/* = STD_BASE + 20 */
		OPTION_GDWARF_CIE_VERSION,OPTION_GCODEVIEW,OPTION_STRIP_LOCAL_ABSOLUTE,
		OPTION_TRADITIONAL_FORMAT,OPTION_WARN,OPTION_TARGET_HELP,
		OPTION_EXECSTACK,OPTION_NOEXECSTACK,OPTION_SIZE_CHECK,
		OPTION_ELF_STT_COMMON,OPTION_ELF_BUILD_NOTES,	/* = STD_BASE + 30 */
		OPTION_SECTNAME_SUBST,OPTION_ALTERNATE,OPTION_AL,
		OPTION_HASH_TABLE_SIZE,OPTION_REDUCE_MEMORY_OVERHEADS,
		OPTION_WARN_FATAL,OPTION_COMPRESS_DEBUG,OPTION_NOCOMPRESS_DEBUG,
		OPTION_NO_PAD_SECTIONS,OPTION_MULTIBYTE_HANDLING,	/* = STD_BASE + 40 */
		OPTION_SFRAME
		/* When you add options here,check that they do not collide
		 * with OPTION_MD_BASE.  See asm.h.  */
	};

	static const struct option std_longopts[] = {
		/* Note: commas are placed at the start of the line rather than
		 * the end of the preceding line so that it is simpler to
		 * selectively add and remove lines from this list.  */
		{"alternate",no_argument,NULL,OPTION_ALTERNATE}
		/* The entry for "a" is here to prevent getopt_long_only() from
		 * considering that -a is an abbreviation for --alternate.
		 * This is necessary because -a=<FILE> is a valid switch but
		 * getopt would normally reject it since --alternate does not
		 * take an argument.  */
		,{"a",optional_argument,NULL,'a'}
		/* Handle -al=<FILE>.  */
		,{"al",optional_argument,NULL,OPTION_AL}
		,{"compress-debug-sections",optional_argument,NULL,OPTION_COMPRESS_DEBUG}
		,{"nocompress-debug-sections",no_argument,NULL,OPTION_NOCOMPRESS_DEBUG}
		,{"debug-prefix-map",required_argument,NULL,OPTION_DEBUG_PREFIX_MAP}
		,{"defsym",required_argument,NULL,OPTION_DEFSYM}
		,{"dump-config",no_argument,NULL,OPTION_DUMPCONFIG}
		,{"emulation",required_argument,NULL,OPTION_EMULATION}
#if defined OBJ_ELF || defined OBJ_MAYBE_ELF
		,{"execstack",no_argument,NULL,OPTION_EXECSTACK}
		,{"noexecstack",no_argument,NULL,OPTION_NOEXECSTACK}
		,{"size-check",required_argument,NULL,OPTION_SIZE_CHECK}
		,{"elf-stt-common",required_argument,NULL,OPTION_ELF_STT_COMMON}
		,{"sectname-subst",no_argument,NULL,OPTION_SECTNAME_SUBST}
		,{"generate-missing-build-notes",required_argument,NULL,OPTION_ELF_BUILD_NOTES}
		,{"gsframe",no_argument,NULL,OPTION_SFRAME}
#endif
		,{"fatal-warnings",no_argument,NULL,OPTION_WARN_FATAL}
		,{"gdwarf-2",no_argument,NULL,OPTION_GDWARF_2}
		,{"gdwarf-3",no_argument,NULL,OPTION_GDWARF_3}
		,{"gdwarf-4",no_argument,NULL,OPTION_GDWARF_4}
		,{"gdwarf-5",no_argument,NULL,OPTION_GDWARF_5}
		/* GCC uses --gdwarf-2 but GAS used to to use --gdwarf2,so we
		 * keep it here for backwards compatibility.  */
		,{"gdwarf2",no_argument,NULL,OPTION_GDWARF_2}
		,{"gdwarf-sections",no_argument,NULL,OPTION_GDWARF_SECTIONS}
		,{"gdwarf-cie-version",required_argument,NULL,OPTION_GDWARF_CIE_VERSION}
		,{"gen-debug",no_argument,NULL,'g'}
		,{"gstabs",no_argument,NULL,OPTION_GSTABS}
		,{"gstabs+",no_argument,NULL,OPTION_GSTABS_PLUS}
		,{"hash-size",required_argument,NULL,OPTION_HASH_TABLE_SIZE}
		,{"help",no_argument,NULL,OPTION_HELP}
#ifdef HAVE_ITBL_CPU
		/* New option for extending instruction set (see also -t
		 * above). The "-t file" or "--itbl file" option extends the
		 * basic set of valid instructions by reading "file",a text
		 * file containing a list of instruction formats.  The
		 * additional opcodes and their formats are added to the
		 * built-in set of instructions,and mnemonics for new
		 * registers may also be defined.  */
		,{"itbl",required_argument,NULL,'t'}
#endif
		/* getopt allows abbreviations,so we do this to stop it from
		 * treating -k as an abbreviation for --keep-locals.  Some
		 * ports use -k to enable PIC assembly.  */
		,{"keep-locals",no_argument,NULL,'L'}
		,{"keep-locals",no_argument,NULL,'L'}
		,{"MD",required_argument,NULL,OPTION_DEPFILE}
		,{"no-pad-sections",no_argument,NULL,OPTION_NO_PAD_SECTIONS}
		,{"no-warn",no_argument,NULL,'W'}
		,{"reduce-memory-overheads",no_argument,NULL,OPTION_REDUCE_MEMORY_OVERHEADS}
		,{"strip-local-absolute",no_argument,NULL,OPTION_STRIP_LOCAL_ABSOLUTE}
		,{"version",no_argument,NULL,OPTION_VERSION}
		,{"verbose",no_argument,NULL,OPTION_VERBOSE}
		,{"target-help",no_argument,NULL,OPTION_TARGET_HELP}
		,{"traditional-format",no_argument,NULL,OPTION_TRADITIONAL_FORMAT}
		,{"warn",no_argument,NULL,OPTION_WARN}
		,{"multibyte-handling",required_argument,NULL,OPTION_MULTIBYTE_HANDLING}
	};

	/* Construct the option lists from the standard list and the target
	 * dependent list.  Include space for an extra NULL option and always
	 * NULL terminate.  */
	shortopts = concat(std_shortopts,"O::g::G:",(char *)NULL);
	longopts = (struct option *)xmalloc(sizeof(std_longopts)
				  + md_longopts_size + sizeof(struct option));
	memcpy(longopts,std_longopts,sizeof(std_longopts));
	memcpy(((char *)longopts) + sizeof(std_longopts),md_longopts,md_longopts_size);
	memset(((char *)longopts) + sizeof(std_longopts) + md_longopts_size,
	       0,sizeof(struct option));

	/* Make a local copy of the old argv.  */
	old_argc = *pargc;
	old_argv = *pargv;

	/* Initialize a new argv that contains no options.  */
	new_argv = notes_alloc(sizeof(char *) * (old_argc + 1));
	new_argv[0] = old_argv[0];
	new_argc = 1;
	new_argv[new_argc] = NULL;

	while (1) {
		/* getopt_long_only is like getopt_long,but '-' as well as
		 * '--' can indicate a long option.  */
		int		longind;
		int		optc = getopt_long_only(old_argc,old_argv,shortopts,longopts,
					     &longind);

		if (optc == -1)
			break;

		switch (optc) {
		default:
			/* md_parse_option should return 1 if it recognizes
			 * optc,0 if not.  */
			if (md_parse_option(optc,optarg) != 0)
				break;
			/* `-v' isn't included in the general short_opts list,
			 * so check for it explicitly here before deciding
			 * we've gotten a bad argument.  */
			if (optc == 'v') {
		case 'v':
		case OPTION_VERBOSE:
				print_version_id();
				verbose = 1;
				break;
			} else
				as_bad("unrecognized option -%c%s",optc,optarg ? optarg : "");
			/* Fall through.  */

		case '?':
			exit(EXIT_FAILURE);

		case 1:	/* File name.  */
			if (!strcmp(optarg,"-"))
				optarg = (char *)"";
			new_argv[new_argc++] = optarg;
			new_argv[new_argc] = NULL;
			break;

		case OPTION_TARGET_HELP:
		case OPTION_HELP:
			exit(EXIT_SUCCESS);

		case OPTION_NO_PAD_SECTIONS:
			do_not_pad_sections_to_alignment = 1;
			break;

		case OPTION_STATISTICS:
			flag_print_statistics = 1;
			break;

		case OPTION_STRIP_LOCAL_ABSOLUTE:
			flag_strip_local_absolute = 1;
			break;

		case OPTION_TRADITIONAL_FORMAT:
			flag_traditional_format = 1;
			break;

		case OPTION_MULTIBYTE_HANDLING:
			if (strcmp(optarg,"allow") == 0)
				multibyte_handling = multibyte_allow;
			else
				if (strcmp(optarg,"warn") == 0)
					multibyte_handling = multibyte_warn;
				else
					if (strcmp(optarg,"warn-sym-only") == 0)
						multibyte_handling = multibyte_warn_syms;
					else
						if (strcmp(optarg,"warn_sym_only") == 0)
							multibyte_handling = multibyte_warn_syms;
						else
							as_fatal("unexpected argument to --multibyte-input-option: '%s'",optarg);
			break;

		case OPTION_VERSION:
			/* This output is intended to follow the GNU standards document.  */
			printf("tiny GNU assembler without BFD\n");
			printf("Copyright (C) 2023 Free Software Foundation,Inc.\n");
			printf("Hacked by jacob in the summer of 2023\n");
			printf("\
This program is free software; you may redistribute it under the terms of\n\
the GNU General Public License version 3 or later.\n\
This program has absolutely no warranty.\n");
			printf(("This assembler was configured for a target of `%s' "
				"and default,\ncpu type `%s'.\n"),
			       TARGET_ALIAS,"riscv");
			exit(EXIT_SUCCESS);

		case OPTION_EMULATION:
			as_fatal("emulations not handled in this configuration");
			break;

		case OPTION_DUMPCONFIG:
			fprintf(stderr,"alias = %s\n",TARGET_ALIAS);
			fprintf(stderr,"canonical = %s\n",TARGET_CANONICAL);
			fprintf(stderr,("cpu-type = %s\n"),TARGET_CPU);
#ifdef TARGET_OBJ_FORMAT
			fprintf(stderr,("format = %s\n"),TARGET_OBJ_FORMAT);
#endif
#ifdef TARGET_FORMAT
			fprintf(stderr,("bfd-target = %s\n"),TARGET_FORMAT);
#endif
			exit(EXIT_SUCCESS);

		case OPTION_NOCOMPRESS_DEBUG:
			flag_compress_debug = COMPRESS_DEBUG_NONE;
			break;

		case OPTION_DEBUG_PREFIX_MAP:
			add_debug_prefix_map(optarg);
			break;
		case OPTION_DEFSYM:
		case OPTION_DEPFILE:
		case OPTION_COMPRESS_DEBUG:
			break;
		case 'g':
			/* Some backends,eg Alpha and Mips,use the -g switch
			 * for their own purposes.  So we check here for an
			 * explicit -g and allow the backend to decide if it
			 * wants to process it.  */
			if (old_argv[optind - 1][1] == 'g'
			    && md_parse_option(optc,optarg))
				continue;

			/* We end up here for any
			 * -gsomething-not-already-a-long-option. give some
			 * useful feedback on not (yet) supported -gdwarfxxx
			 * versions/sections/options.  */
			if (startswith(old_argv[optind - 1],"-gdwarf"))
				as_fatal(("unknown DWARF option %s\n"),old_argv[optind - 1]);
			else
				if (old_argv[optind - 1][1] == 'g' && optarg != NULL)
					as_fatal(("unknown option `%s'"),old_argv[optind - 1]);

			if (md_debug_format_selector)
				debug_type = md_debug_format_selector(&use_gnu_debug_info_extensions);
			else
				if (IS_ELF) {
					debug_type = DEBUG_DWARF2;
					dwarf_level = 2;
				} else
					debug_type = DEBUG_STABS;
			break;

		case OPTION_GSTABS_PLUS:
			use_gnu_debug_info_extensions = 1;
			/* Fall through.  */
		case OPTION_GSTABS:
			debug_type = DEBUG_STABS;
			break;

		case OPTION_GDWARF_2:
			debug_type = DEBUG_DWARF2;
			dwarf_level = 2;
			break;

		case OPTION_GDWARF_3:
			debug_type = DEBUG_DWARF2;
			dwarf_level = 3;
			break;

		case OPTION_GDWARF_4:
			debug_type = DEBUG_DWARF2;
			dwarf_level = 4;
			break;

		case OPTION_GDWARF_5:
			debug_type = DEBUG_DWARF2;
			dwarf_level = 5;
			break;

		case OPTION_GDWARF_SECTIONS:
			flag_dwarf_sections = true;
			break;

		case OPTION_GDWARF_CIE_VERSION:
			flag_dwarf_cie_version = atoi(optarg);
			/*
			 * The available CIE versions are 1 (DWARF 2),3 (DWARF
			 * 3),and 4 (DWARF 4 and 5).
			 */
			if (flag_dwarf_cie_version < 1
			    || flag_dwarf_cie_version == 2
			    || flag_dwarf_cie_version > 4)
				as_fatal(("Invalid --gdwarf-cie-version `%s'"),optarg);
			switch (flag_dwarf_cie_version) {
			case 1:
				if (dwarf_level < 2)
					dwarf_level = 2;
				break;
			case 3:
				if (dwarf_level < 3)
					dwarf_level = 3;
				break;
			default:
				if (dwarf_level < 4)
					dwarf_level = 4;
				break;
			}
			break;

		case 'J': flag_signed_overflow_ok = 1; break;
		case 'L': flag_keep_locals = 1; break;
		case 'R': flag_readonly_data_in_text = 1; break;
		case 'W': flag_no_warnings = 1; break;
		case OPTION_WARN: flag_no_warnings = 0; flag_fatal_warnings = 0; break;
		case OPTION_WARN_FATAL:flag_no_warnings=0;flag_fatal_warnings=1; break;

#if defined OBJ_ELF || defined OBJ_MAYBE_ELF
		case OPTION_EXECSTACK:
			flag_execstack = 1;
			flag_noexecstack = 0;
			break;
		case OPTION_NOEXECSTACK:
			flag_noexecstack = 1;
			flag_execstack = 0;
			break;
		case OPTION_SIZE_CHECK:
			if (strcasecmp(optarg,"error") == 0)
				flag_allow_nonconst_size = false;
			else
				if (strcasecmp(optarg,"warning") == 0)
					flag_allow_nonconst_size = true;
				else
					as_fatal(("Invalid --size-check= option: `%s'"),optarg);
			break;
		case OPTION_ELF_STT_COMMON:
			if (strcasecmp(optarg,"no") == 0)
				flag_use_elf_stt_common = 0;
			else
				if (strcasecmp(optarg,"yes") == 0)
					flag_use_elf_stt_common = 1;
				else
					as_fatal(("Invalid --elf-stt-common= option: `%s'"),
						 optarg);
			break;
		case OPTION_SECTNAME_SUBST: flag_sectname_subst = 1; break;
		case OPTION_ELF_BUILD_NOTES:
			if (strcasecmp(optarg,"no") == 0)
				flag_generate_build_notes = false;
			else
				if (strcasecmp(optarg,"yes") == 0)
					flag_generate_build_notes = true;
				else
					as_fatal(("Invalid --generate-missing-build-notes option: `%s'"),
						 optarg);
			break;

		case OPTION_SFRAME:
			as_fatal("sframe not supported!\n");
			//flag_gen_sframe = 1;
			break;
#endif				/* OBJ_ELF */

		case 'Z': flag_always_generate_output = 1; break;
		case OPTION_AL: break;
		case OPTION_ALTERNATE:
			optarg = old_argv[optind - 1];
			while (*optarg == '-')
				optarg++;

			if (strcmp(optarg,"alternate") == 0) {
				flag_macro_alternate = 1;
				break;
			}
			optarg++;
			/* Fall through.  */

		case 'a':
			if (optarg) {
				if (optarg != old_argv[optind] && optarg[-1] == '=')
					--optarg;

				if (md_parse_option(optc,optarg) != 0)
					break;

				while (*optarg) {
					switch (*optarg) {
					case 'c': case 'd': case 'g': case 'h': case 'l':
					case 'm': case 'n': case 's': case '=':
						break;
					default:
						as_fatal(("invalid listing option `%c'"),*optarg);
						break;
					}
					optarg++;
				}
			}
			break;

		case 'D':
			/* DEBUG is implemented: it debugs different things
			 * from other people's assemblers.  */
			flag_debug = 1;
			break;

		case 'f': flag_no_comments = 1; break;
		case 'o': out_file_name = notes_strdup(optarg); break;
		case 'w': break;
		case 'X': /* -X means treat warnings as errors.  */ break;
			break;
		case OPTION_HASH_TABLE_SIZE: break;
		}
	}

	free(shortopts);
	free(longopts);

	*pargc = new_argc;
	*pargv = new_argv;

	riscv_after_parse_args();
}
static enum bfd_error last_error;
static void	bfd_set_error(enum bfd_error e)
{
	last_error = e;
}
static bfd_error_type bfd_get_error(void)
{
	return last_error;
}
static char	last_error_message[256];
static char    *bfd_errmsg(bfd_error_type e)
{
	sprintf(last_error_message,"Error %d\n",e);
	return last_error_message;
}
static void    *zmalloc(size_t siz)
{
	return calloc(1,siz);
}

/* Here to attempt 1 pass over each input file. We scan argv[*] looking for
 * filenames or exactly "" which is shorthand for stdin. Any argv that is NULL
 * is not a file-name. We set need_pass_2 TRUE if,after this,we still have
 * unresolved expressions of the form (unknown value)+-(unknown value).
 * 
 * Note the un*x semantics: there is only 1 logical input file,but it may be a
 * catenation of many 'physical' input files.  */
static void	perform_an_assembly_pass(int argc,char **argv)
{
	int		saw_a_file = 0;
#ifndef OBJ_MACH_O
	uint32_t	applicable;
#endif

	need_pass_2 = 0;

	/* Create the standard sections,and those the assembler uses
	 * internally.  */
	text_section = subseg_new(TEXT_SECTION_NAME,0);
	data_section = subseg_new(DATA_SECTION_NAME,0);
	bss_section = subseg_new(BSS_SECTION_NAME,0);
	/* @@ FIXME -- we're setting the RELOC flag so that sections are
	 * assumed to have relocs,otherwise we don't find out in time.  */
	//applicable = stdoutput->xvec->section_flags;
	applicable = 0x3c1a13f;
	text_section->flags = applicable & (SEC_ALLOC|SEC_LOAD|SEC_RELOC
					   |SEC_CODE|SEC_READONLY);
	data_section->flags = applicable & (SEC_ALLOC|SEC_LOAD|SEC_RELOC
					   |SEC_DATA);
	bss_section->flags = applicable & SEC_ALLOC;
	seg_info(bss_section)->bss = 1;
	subseg_new(BFD_ABS_SECTION_NAME,0);
	subseg_new(BFD_UND_SECTION_NAME,0);
	reg_section = subseg_new("*GAS `reg' section*",0);
	expr_section = subseg_new("*GAS `expr' section*",0);

#ifndef OBJ_MACH_O
	subseg_set(text_section,0);
#endif
	/* This may add symbol table entries,which requires having an open
	 * BFD,and sections already created.  */
	md_begin();
	elf_begin();

	/* Skip argv[0].  */
	argv++;
	argc--;

	while (argc--) {
		if (*argv) {	/* Is it a file-name argument?  */
			saw_a_file++;
			/* argv->"" if stdin desired,else->filename.  */
			read_a_source_file(*argv);
		}
		argv++;		/* Completed that argv.  */
	}
	if (!saw_a_file)
		read_a_source_file("");
}

static void	free_notes(void)
{
	_obstack_free(&notes,NULL);
}

/* Early initialisation,before gas prints messages.  */
static void	gas_early_init(int *argcp ATTRIBUTE_UNUSED,char ***argvp)
{
	start_time = get_run_time();
	signal_init();

#ifdef HAVE_LC_MESSAGES
	setlocale(LC_MESSAGES,"");
#endif
	setlocale(LC_CTYPE,"");

	if (debug_memory)
		chunksize = 64;

	out_file_name = "a.out";

	obstack_begin(&notes,chunksize);
	xatexit(free_notes);

	myname = **argvp;
	xmalloc_set_program_name(myname);

	riscv_init_ext_order();
}

/* The bulk of gas initialisation.  This is after args are parsed.  */
static void	gas_init(void)
{
	symbol_begin();
	frag_init();
	subsegs_begin();
	read_begin();
	input_scrub_begin();
	expr_begin();
	eh_begin();

	//macro_init();

	dwarf2_init();

	local_symbol_make(".gasversion.",absolute_section,
			  &predefined_address_frag,BFD_VERSION / 10000UL);

	/*
	 * Note: Put new initialisation calls that don't depend on stdoutput
	 * being open above this point.  stdoutput must be open for anything
	 * that might use stdoutput objalloc memory,eg. calling bfd_alloc or
	 * creating global symbols (via bfd_make_empty_symbo).
	 */
	xatexit(output_file_close);
	output_file_create(out_file_name);
	gas_assert(stdoutput != 0);

#if 0
	/*
	 * Must be called before output_file_close.  xexit calls the xatexit
	 * list in reverse order.
	 */
	if (flag_print_statistics)
		xatexit(dump_statistics);
#endif
	dot_symbol_init();

#ifdef tc_init_after_args
	tc_init_after_args();
#endif


	/*
	 * Now that we have fully initialized,and have created the output
	 * file,define any symbols requested by --defsym command line
	 * arguments.
	 */
	while (defsyms != NULL) {
		symbolS        *sym;
		struct defsym_list *next;

		sym = symbol_new(defsyms->name,absolute_section,
				 &zero_address_frag,defsyms->value);
		/*
		 * Make symbols defined on the command line volatile,so that
		 * they can be redefined inside a source file.  This makes this
		 * assembler's behaviour compatible with earlier versions,but
		 * it may not be completely intuitive.
		 */
		S_SET_VOLATILE(sym);
		symbol_table_insert(sym);
		next = defsyms->next;
		free(defsyms);
		defsyms = next;
	}
}

int	main(int argc,char **argv)
{
	struct stat	sob;

	gas_early_init(&argc,&argv);

	/* Call parse_args before gas_init so that switches like --hash-size
	 * can be honored.  */
	parse_args(&argc,&argv);

	if (argc > 1 && stat(out_file_name,&sob) == 0) {
		int		i;

		for (i = 1; i < argc; ++i) {
			struct stat	sib;

			/* Check that the input file and output file are
			 * different.
			 */
			if (stat(argv[i],&sib) == 0
			    && sib.st_ino == sob.st_ino
			/* POSIX emulating systems may support stat() but if
			 * the underlying file system does not support a file
			 * serial number of some kind then they will return 0
			 * for the inode.  So two files with an inode of 0 may
			 * not actually be the same. On real POSIX systems no
			 * ordinary file will ever have an inode of 0. */
			    && sib.st_ino != 0
			/* Different files may have the same inode number if
			 * they reside on different devices,so check the
			 * st_dev field as well. */
			    && sib.st_dev == sob.st_dev
			/*
			 * PR 25572: Only check regular files.  Devices,
			 * sockets and so on might actually work as both input
			 * and output.  Plus there is a use case for using
			 * /dev/null as both input and output when checking for
			 * command line option support in a script: as --foo
			 * /dev/null -o /dev/null; if $? then ...  */
			    && S_ISREG(sib.st_mode)) {
				const char     *saved_out_file_name = out_file_name;

				/* Don't let as_fatal remove the output file!  */
				out_file_name = NULL;
				as_fatal(("The input '%s' and output '%s' files are the same"),
					 argv[i],saved_out_file_name);
			}
		}
	}
	gas_init();

	/* Assemble it.  */
	perform_an_assembly_pass(argc,argv);

	riscv_md_finish();

	if ((flag_execstack || flag_noexecstack)
	    && OUTPUT_FLAVOR == bfd_target_elf_flavour) {
		segT		gnustack;

		gnustack = subseg_new(".note.GNU-stack",0);
		gnustack->flags = SEC_READONLY|(flag_execstack ? SEC_CODE : 0);

	}
	/* If we've been collecting dwarf2 .debug_line info,either for
	 * assembly debugging or on behalf of the compiler,emit it now. */
	dwarf2_finish();

	/* If we constructed dwarf2 .eh_frame info,either via .cfi directives
	 * from the user or by the backend,emit it now.  */
	cfi_finish();

	keep_it = 0;
	if (seen_at_least_1_file()) {
		int		n_warns   ,n_errs;
		char		warn_msg  [50];
		char		err_msg   [50];

		write_object_file();

		n_warns = had_warnings();
		n_errs = had_errors();

		sprintf(warn_msg,
		     ngettext("%d warning","%d warnings",n_warns),n_warns);
		sprintf(err_msg,
			ngettext("%d error","%d errors",n_errs),n_errs);
		if (flag_fatal_warnings && n_warns != 0) {
			if (n_errs == 0)
				as_bad(("%s,treating warnings as errors"),warn_msg);
			n_errs += n_warns;
		}
		if (n_errs == 0)
			keep_it = 1;
		else
			if (flag_always_generate_output) {
				/* The -Z flag indicates that an object file
				 * should be generated,regardless of warnings
				 * and errors.  */
				keep_it = 1;
				fprintf(stderr,("%s,%s,generating bad object file\n"),
					err_msg,warn_msg);
			}
	}
	fflush(stderr);

	input_scrub_end();

	/* Use xexit instead of return,because under VMS environments they may
	 * not place the same interpretation on the value given.
	 */
	if (had_errors() != 0)
		xexit(EXIT_FAILURE);

	/* Only generate dependency file if assembler was successful.  */
	xexit(EXIT_SUCCESS);
}
/* ==================================================**** atof-generic.c */
/* atof_generic.c - turn a string of digits into a Flonum */
#ifdef TRACE
static void	flonum_print(const FLONUM_TYPE *);
#endif

#define ASSUME_DECIMAL_MARK_IS_DOT
/* ======================================================================*\ *
 * 
 * Given a string of decimal digits ,with optional decimal	* mark and
 * optional decimal exponent (place value) of the		* lowest_order
 * decimal digit: produce a floating point		* number. The number is
 * 'generic' floating point: our		* caller will encode it for a
 * specific machine architecture.	* *
 * 
 * Assumptions							* uses base
 * (radix) 2					* this machine uses 2's
 * complement binary integers	* target flonums use "      "         "       "		*
 * target flonums exponents fit in a long			* *
 * 
 * \======================================================================
 */

/*
 * Syntax:
 * 
 * <flonum> ::= <optional-sign> <decimal-number> <optional-exponent>
 * <optional-sign> ::= '+'|'-'|{empty} <decimal-number> ::= <integer> |
 * <integer> <radix-character>|<integer> <radix-character> <integer> |
 * <radix-character> <integer>
 * 
 * <optional-exponent> ::= {empty}|<exponent-character> <optional-sign>
 * <integer>
 * 
 * <integer> ::= <digit>|<digit> <integer> <digit> ::= '0'|'1'|'2'|'3' |
 * '4'|'5'|'6'|'7'|'8'|'9' <exponent-character> ::= {one character
 * from "string_of_decimal_exponent_marks"} <radix-character> ::= {one
 * character from "string_of_decimal_marks"}
 * 
 */

static int	atof_generic(	/* return pointer to just AFTER number we read.  */
		      		char        **address_of_string_pointer,
/* At most one per number.  */
	       		const		char  *string_of_decimal_marks,
      		const		char  *string_of_decimal_exponent_marks,
     		FLONUM_TYPE *	address_of_generic_floating_point_number)
{
	int		return_value = 0;	/* 0 means OK.  */
	char           *first_digit;
	unsigned	number_of_digits_before_decimal;
	unsigned	number_of_digits_after_decimal;
	unsigned long	decimal_exponent;
	unsigned	number_of_digits_available;
	char		digits_sign_char;

	/*
	 * Scan the input string,abstracting (1)digits (2)decimal mark (3)
	 * exponent. It would be simpler to modify the string,but we don't;
	 * just to be nice to caller. We need to know how many digits we have,
	 * so we can allocate space for the digits' value.
	 */

	char           *p;
	char		c;
	int		seen_significant_digit;

#ifdef ASSUME_DECIMAL_MARK_IS_DOT
	gas_assert(string_of_decimal_marks[0] == '.'
		   && string_of_decimal_marks[1] == 0);
#define IS_DECIMAL_MARK(c)	((c) == '.')
#else
#define IS_DECIMAL_MARK(c)	(0 != strchr (string_of_decimal_marks,(c)))
#endif

	first_digit = *address_of_string_pointer;
	c = *first_digit;

	if (c == '-' || c == '+') {
		digits_sign_char = c;
		first_digit++;
	} else
		digits_sign_char = '+';

	switch (first_digit[0]) {
	case 's': case 'S': case 'q': case 'Q':
		if (!strncasecmp("nan",first_digit + 1,3)) {
			address_of_generic_floating_point_number->sign =
				digits_sign_char == '+' ? TOUPPER(first_digit[0])
				: TOLOWER(first_digit[0]);
			address_of_generic_floating_point_number->exponent = 0;
			address_of_generic_floating_point_number->leader =
				address_of_generic_floating_point_number->low;
			*address_of_string_pointer = first_digit + 4;
			return 0;
		}
		break;

	case 'n': case 'N':
		if (!strncasecmp("nan",first_digit,3)) {
			address_of_generic_floating_point_number->sign =
				digits_sign_char == '+' ? 0 : 'q';
			address_of_generic_floating_point_number->exponent = 0;
			address_of_generic_floating_point_number->leader =
				address_of_generic_floating_point_number->low;
			*address_of_string_pointer = first_digit + 3;
			return 0;
		}
		break;

	case 'i': case 'I':
		if (!strncasecmp("inf",first_digit,3)) {
			address_of_generic_floating_point_number->sign =
				digits_sign_char == '+' ? 'P' : 'N';
			address_of_generic_floating_point_number->exponent = 0;
			address_of_generic_floating_point_number->leader =
				address_of_generic_floating_point_number->low;

			first_digit += 3;
			if (!strncasecmp("inity",first_digit,5))
				first_digit += 5;

			*address_of_string_pointer = first_digit;

			return 0;
		}
		break;
	}

	number_of_digits_before_decimal = 0;
	number_of_digits_after_decimal = 0;
	decimal_exponent = 0;
	seen_significant_digit = 0;
	for (p = first_digit;
	     (((c = *p) != '\0')
	      && (!c || !IS_DECIMAL_MARK(c))
	      && (!c || !strchr(string_of_decimal_exponent_marks,c)));
	     p++) {
		if (ISDIGIT(c)) {
			if (seen_significant_digit || c > '0') {
				++number_of_digits_before_decimal;
				seen_significant_digit = 1;
			} else {
				first_digit++;
			}
		} else {
			break;	/* p -> char after pre-decimal digits.  */
		}
	}			/* For each digit before decimal mark.  */

	/* Ignore trailing 0's after the decimal point.  The original code here
	 * (ifdef'd out) does not do this,and numbers like
	 * 4.29496729600000000000e+09	(2**31) come out inexact for some
	 * reason related to length of the digit string.  */

	/* The case number_of_digits_before_decimal = 0 is handled for deleting
	 * zeros after decimal.  In this case the decimal mark and the first
	 * zero digits after decimal mark are skipped. */
	seen_significant_digit = 0;
	unsigned long	subtract_decimal_exponent = 0;

	if (c && IS_DECIMAL_MARK(c)) {
		unsigned	zeros = 0;	/* Length of current string of zeros.  */

		if (number_of_digits_before_decimal == 0)
			/* Skip decimal mark.  */
			first_digit++;

		for (p++; (c = *p) && ISDIGIT(c); p++) {
			if (c == '0') {
				if (number_of_digits_before_decimal == 0
				    && !seen_significant_digit) {
					/* Skip '0' and the decimal mark.  */
					first_digit++;
					subtract_decimal_exponent--;
				} else
					zeros++;
			} else {
				seen_significant_digit = 1;
				number_of_digits_after_decimal += 1 + zeros;
				zeros = 0;
			}
		}
	}
	if (c && strchr(string_of_decimal_exponent_marks,c)) {
		char		digits_exponent_sign_char;

		c = *++p;
		if (c && strchr("+-",c)) {
			digits_exponent_sign_char = c;
			c = *++p;
		} else {
			digits_exponent_sign_char = '+';
		}

		for (; (c); c = *++p) {
			if (ISDIGIT(c)) {
				if (decimal_exponent > LONG_MAX / 10
				    || (decimal_exponent == LONG_MAX / 10
					&& c > '0' + (char)(LONG_MAX - LONG_MAX / 10 * 10)))
					return_value = ERROR_EXPONENT_OVERFLOW;
				decimal_exponent = decimal_exponent * 10 + c - '0';
			} else {
				break;
			}
		}

		if (digits_exponent_sign_char == '-') {
			decimal_exponent = -decimal_exponent;
		}
	}
	/* Subtract_decimal_exponent != 0 when number_of_digits_before_decimal
	 * = 0 and first digit after decimal is '0'.  */
	decimal_exponent += subtract_decimal_exponent;

	*address_of_string_pointer = p;

	number_of_digits_available =
		number_of_digits_before_decimal + number_of_digits_after_decimal;
	if (number_of_digits_available == 0) {
		address_of_generic_floating_point_number->exponent = 0;	/* Not strictly necessary */
		address_of_generic_floating_point_number->leader
			= -1 + address_of_generic_floating_point_number->low;
		address_of_generic_floating_point_number->sign = digits_sign_char;
		/* We have just concocted (+/-)0.0E0 */

	} else {
		int		count;	/* Number of useful digits left to scan.  */

		LITTLENUM_TYPE *temporary_binary_low = NULL;
		LITTLENUM_TYPE *power_binary_low = NULL;
		LITTLENUM_TYPE *digits_binary_low;
		unsigned	precision;
		unsigned	maximum_useful_digits;
		unsigned	number_of_digits_to_use;
		unsigned	more_than_enough_bits_for_digits;
		unsigned	more_than_enough_littlenums_for_digits;
		unsigned	size_of_digits_in_littlenums;
		unsigned	size_of_digits_in_chars;
		FLONUM_TYPE	power_of_10_flonum;
		FLONUM_TYPE	digits_flonum;

		precision = (address_of_generic_floating_point_number->high
			     - address_of_generic_floating_point_number->low
			     + 1);	/* Number of destination littlenums.  */

		/*
		 * precision includes two littlenums worth of guard bits,so
		 * this gives us 10 decimal guard digits here.
		 */
		maximum_useful_digits = (precision
					 * LITTLENUM_NUMBER_OF_BITS
					 * 1000000 / 3321928
					 + 1);	/* round up.  */

		if (number_of_digits_available > maximum_useful_digits) {
			number_of_digits_to_use = maximum_useful_digits;
		} else {
			number_of_digits_to_use = number_of_digits_available;
		}

		/*
		 * Cast these to SIGNED LONG first,otherwise,on systems with
		 * LONG wider than INT (such as Alpha OSF/1),unsignedness may
		 * cause unexpected results.
		 */
		decimal_exponent += ((long)number_of_digits_before_decimal
				     - (long)number_of_digits_to_use);

		more_than_enough_bits_for_digits
			= (number_of_digits_to_use * 3321928 / 1000000 + 1);

		more_than_enough_littlenums_for_digits
			= (more_than_enough_bits_for_digits
			   / LITTLENUM_NUMBER_OF_BITS)
			+ 2;

		/* Compute (digits) part. In "12.34E56" this is the "1234"
		 * part. Arithmetic is exact here. If no digits are supplied
		 * then this part is a 0 valued binary integer.  Allocate room
		 * to build up the binary number as littlenums.  We want this
		 * memory to disappear when we leave this function.  Assume no
		 * alignment problems => (room for n objects) == n * (room for
		 * 1 object). */

		size_of_digits_in_littlenums = more_than_enough_littlenums_for_digits;
		size_of_digits_in_chars = size_of_digits_in_littlenums
			* sizeof(LITTLENUM_TYPE);

		digits_binary_low = (LITTLENUM_TYPE *)
			xmalloc(size_of_digits_in_chars);

		memset((char *)digits_binary_low,'\0',size_of_digits_in_chars);

		/* Digits_binary_low[] is allocated and zeroed.  */

		/* Parse the decimal digits as if * digits_low was in the units
		 * position. Emit a binary number into digits_binary_low[].
		 * 
		 * Use a large-precision version of: (((1st-digit) * 10 +
		 * 2nd-digit) * 10 + 3rd-digit ...) * 10 + last-digit */
		for (p = first_digit,count = number_of_digits_to_use; count; p++,--count) {
			c = *p;
			if (ISDIGIT(c)) {
				/* Multiply by 10. Assume can never overflow.
				 * Add this digit to digits_binary_low[].  */

				long		carry;
				LITTLENUM_TYPE *littlenum_pointer;
				LITTLENUM_TYPE *littlenum_limit;

				littlenum_limit = digits_binary_low
					+ more_than_enough_littlenums_for_digits
					- 1;

				carry = c - '0';	/* char -> binary */

				for (littlenum_pointer = digits_binary_low;
				     littlenum_pointer <= littlenum_limit;
				     littlenum_pointer++) {
					long		work;

					work = carry + 10 * (long)(*littlenum_pointer);
					*littlenum_pointer = work & LITTLENUM_MASK;
					carry = work >> LITTLENUM_NUMBER_OF_BITS;
				}

				if (carry != 0) {
					/*
					 * We have a GROSS internal error. This
					 * should never happen.
					 */
					as_fatal(("failed sanity check"));
				}
			} else {
				++count;	/* '.' doesn't alter digits
						 * used count.  */
			}
		}

		/* Digits_binary_low[] properly encodes the value of the
		 * digits. Forget about any high-order littlenums that are 0.  */
		while (digits_binary_low[size_of_digits_in_littlenums - 1] == 0
		       && size_of_digits_in_littlenums >= 2)
			size_of_digits_in_littlenums--;

		digits_flonum.low = digits_binary_low;
		digits_flonum.high = digits_binary_low + size_of_digits_in_littlenums - 1;
		digits_flonum.leader = digits_flonum.high;
		digits_flonum.exponent = 0;
		/* The value of digits_flonum . sign should not be important.
		 * We have already decided the output's sign. We trust that the
		 * sign won't influence the other parts of the number! So we
		 * give it a value for these reasons: (1) courtesy to humans
		 * reading/debugging these numbers so they don't get excited
		 * about strange values (2) in future there may be more meaning
		 * attached to sign,and what was harmless noise may become
		 * disruptive,ill-conditioned (or worse) input.  */
		digits_flonum.sign = '+';

		{
			/* Compute the mantissa (& exponent) of the power of
			 * 10. If successful,then multiply the power of 10 by
			 * the digits giving return_binary_mantissa and
			 * return_binary_exponent.  */

			int		decimal_exponent_is_negative;
			/* This refers to the "-56" in "12.34E-56".  */
			/* FALSE: decimal_exponent is positive (or 0) */
			/* TRUE:  decimal_exponent is negative */
			FLONUM_TYPE	temporary_flonum;
			unsigned	size_of_power_in_littlenums;
			unsigned	size_of_power_in_chars;

			size_of_power_in_littlenums = precision;
			/* Precision has a built-in fudge factor so we get a
			 * few guard bits.  */

			decimal_exponent_is_negative = (long)decimal_exponent < 0;
			if (decimal_exponent_is_negative) {
				decimal_exponent = -decimal_exponent;
			}
			/* From now on: the decimal exponent is > 0. Its sign
			 * is separate.  */

			size_of_power_in_chars = size_of_power_in_littlenums
				* sizeof(LITTLENUM_TYPE) + 2;

			power_binary_low = (LITTLENUM_TYPE *) xmalloc(size_of_power_in_chars);
			temporary_binary_low = (LITTLENUM_TYPE *) xmalloc(size_of_power_in_chars);

			memset((char *)power_binary_low,'\0',size_of_power_in_chars);
			*power_binary_low = 1;
			power_of_10_flonum.exponent = 0;
			power_of_10_flonum.low = power_binary_low;
			power_of_10_flonum.leader = power_binary_low;
			power_of_10_flonum.high = power_binary_low + size_of_power_in_littlenums - 1;
			power_of_10_flonum.sign = '+';
			temporary_flonum.low = temporary_binary_low;
			temporary_flonum.high = temporary_binary_low + size_of_power_in_littlenums - 1;
			/* (power) == 1. Space for temporary_flonum allocated.  */

			/* ... 
			 * WHILE	more bits DO	find next bit (with place
			 * value) multiply into power mantissa OD */
			{
				int		place_number_limit;
				/* Any 10^(2^n) whose "n" exceeds this */
				/* value will fall off the end of */
				/* flonum_XXXX_powers_of_ten[].  */
				int		place_number;
				const FLONUM_TYPE *multiplicand;	/* -> 10^(2^n) */

				place_number_limit = table_size_of_flonum_powers_of_ten;

				multiplicand = (decimal_exponent_is_negative
						? flonum_negative_powers_of_ten
					     : flonum_positive_powers_of_ten);

				for (place_number = 1;	/* Place value of this
							 * bit of exponent.  */
				     decimal_exponent;	/* Quit when no more 1
							 * bits in exponent.  */
				     decimal_exponent >>= 1,place_number++) {
					if (decimal_exponent & 1) {
						if (place_number > place_number_limit) {
						/* The decimal exponent has a magnitude so
						 * great that our tables can't help us fragment it.
						 * Although this routine is in error because it can't
						 * imagine a number* that big,signal an* error as if it is
						 * the user's fault for presenting such a big number.  */
							return_value = ERROR_EXPONENT_OVERFLOW;
							/* quit out of loop gracefully */
							decimal_exponent = 0;
						} else {
							flonum_multip(multiplicand + place_number,
								      &power_of_10_flonum,&temporary_flonum);
							flonum_copy(&temporary_flonum,&power_of_10_flonum);
						}	/* If this bit of
							 * decimal_exponent was
							 * computable. */
					}	/* If this bit of
						 * decimal_exponent was set.  */
				}	/* For each bit of binary
					 * representation of exponent */
			}
		}

		/* power_of_10_flonum is power of ten in binary (mantissa) ,
		 * (exponent). It may be the number 1,in which case we don't
		 * NEED to multiply.
		 * 
		 * Multiply (decimal digits) by power_of_10_flonum.  */

		flonum_multip(&power_of_10_flonum,&digits_flonum,address_of_generic_floating_point_number);
		/* Assert sign of the number we made is '+'.  */
		address_of_generic_floating_point_number->sign = digits_sign_char;

		free(temporary_binary_low);
		free(power_binary_low);
		free(digits_binary_low);
	}
	return return_value;
}
/* end of atof_generic.c */
/* ==================================================** compress-debug.c */
/* compress-debug.c - compress debug sections */
struct z_stream_s;
/* Initialize the compression engine.  */
static void    *compress_init(bool use_zstd ATTRIBUTE_UNUSED)
{
	static struct z_stream_s strm;
	memset(&strm,0,sizeof(strm));
	deflateInit(&strm,Z_DEFAULT_COMPRESSION);
	return &strm;
}

/*
 * Stream the contents of a frag to the compression engine.  Output from the
 * engine goes into the current frag on the obstack.
 */
static int	compress_data(bool use_zstd ATTRIBUTE_UNUSED,
                    void *ctx,const char **next_in,int *avail_in,
			 		char        **next_out,int *avail_out)
{				/* compress-debug.c:71 */
	struct z_stream_s *strm = ctx;

	strm->next_in = (Bytef *) (*next_in);
	strm->avail_in = *avail_in;
	strm->next_out = (Bytef *) (*next_out);
	strm->avail_out = *avail_out;

	int		x = deflate(strm,Z_NO_FLUSH);
	if (x != Z_OK)
		return -1;

	int		out_size = *avail_out - strm->avail_out;
	*next_in = (char *)(strm->next_in);
	*avail_in = strm->avail_in;
	*next_out = (char *)(strm->next_out);
	*avail_out = strm->avail_out;

	return out_size;
}

/* Finish the compression and consume the remaining compressed output. Returns
 * -1 for error,0 when done,1 when more output buffer is needed.  */
static int	compress_finish(bool use_zstd ATTRIBUTE_UNUSED,
                                void *ctx,char **next_out,
			   		int          *avail_out,int *out_size)
{
	int		x;
	struct z_stream_s *strm = ctx;

	strm->avail_in = 0;
	strm->next_out = (Bytef *) (*next_out);
	strm->avail_out = *avail_out;

	x = deflate(strm,Z_FINISH);

	*out_size = *avail_out - strm->avail_out;
	*next_out = (char *)(strm->next_out);
	*avail_out = strm->avail_out;

	if (x == Z_STREAM_END) {
		deflateEnd(strm);
		return 0;
	}
	if (strm->avail_out != 0)
		return -1;
	return 1;
}
/* =======================================================** dw2gencfi.c */
/* dw2gencfi.h - Support for generating Dwarf2 CFI information. */
#ifndef DW2GENCFI_H
#define DW2GENCFI_H
//---------------------------------------------------include "dwarf2.h"
static void	cfi_new_fde(struct symbol *);
static void	cfi_end_fde(struct symbol *);
static void	cfi_set_return_column(unsigned);
static void	cfi_set_sections(void);
static void	cfi_add_advance_loc(struct symbol *);
static void	cfi_add_label(const char *);

static void	cfi_add_CFA_offset(unsigned,offsetT);
static void	cfi_add_CFA_val_offset(unsigned,offsetT);
static void	cfi_add_CFA_def_cfa(unsigned,offsetT);
static void	cfi_add_CFA_register(unsigned,unsigned);
static void	cfi_add_CFA_def_cfa_register(unsigned);
static void	cfi_add_CFA_def_cfa_offset(offsetT);
static void	cfi_add_CFA_restore(unsigned);
static void	cfi_add_CFA_undefined(unsigned);
static void	cfi_add_CFA_same_value(unsigned);
static void	cfi_add_CFA_remember_state(void);
static void	cfi_add_CFA_restore_state(void);
struct symbol;

/* Structures for md_cfi_end.  */

#ifdef tc_cfi_reloc_for_encoding
#define SUPPORT_COMPACT_EH 1
#else
#define SUPPORT_COMPACT_EH 0
#endif

struct cfi_insn_data {
	struct cfi_insn_data *next;
	int		insn;
	union {
		struct {
			unsigned	reg;
			offsetT		offset;
		}		ri;

		struct {
			unsigned	reg1;
			unsigned	reg2;
		}		rr;

		unsigned	r;
		offsetT		i;

		struct {
			symbolS        *lab1;
			symbolS        *lab2;
		}		ll;

		struct cfi_escape_data *esc;

		struct {
			unsigned	reg   ,encoding;
			expressionS	exp;
		}		ea;

		const char     *sym_name;
	}		u;
};

/* An enumeration describing the Compact EH header format.  The least
 * significant bit is used to distinguish the entries.
 * 
 * Inline Compact:			Function offset [0] Four chars of unwind data.
 * Out-of-line Compact:			Function offset [1] Compact unwind data
 * offset [0] Legacy:				Function offset [1] Unwind data
 * offset [1]
 * 
 * The header type is initialized to EH_COMPACT_UNKNOWN until the format is
 * discovered by encountering a .fde_data entry. Failure to find a .fde_data
 * entry will cause an EH_COMPACT_LEGACY header to be generated.  */
enum { EH_COMPACT_UNKNOWN, EH_COMPACT_LEGACY, EH_COMPACT_INLINE,
	EH_COMPACT_OUTLINE, EH_COMPACT_OUTLINE_DONE,
	/* Outline if .cfi_inline_lsda used,otherwise legacy FDE.  */
	EH_COMPACT_HAS_LSDA
};

/* Stack of old CFI data,for save/restore.  */
struct cfa_save_data {
	struct cfa_save_data *next;
	offsetT		cfa_offset;
};

/* Current open FDE entry.  */
struct frch_cfi_data {
	struct fde_entry *cur_fde_data;
	symbolS        *last_address;
	offsetT		cur_cfa_offset;
	struct cfa_save_data *cfa_save_stack;
};

struct fde_entry {
	struct fde_entry *next;
	symbolS        *start_address;
	symbolS        *end_address;
	struct cfi_insn_data *data;
	struct cfi_insn_data **last;
	unsigned char	per_encoding;
	unsigned char	lsda_encoding;
	int		personality_id;
	expressionS	personality;
	expressionS	lsda;
	unsigned	return_column;
	unsigned	signal_frame;
	int		eh_header_type;
	/* Compact unwinding opcodes,not including the PR byte or LSDA.  */
	int		eh_data_size;
	uint8_t        *eh_data;
	/* For out of line tables and FDEs.  */
	symbolS        *eh_loc;
	int		sections;
#ifdef tc_fde_entry_extras
	tc_fde_entry_extras
#endif
};

/* The list of all FDEs that have been collected.  */
extern struct fde_entry *all_fde_data;

/* Fake CFI type; outside the byte range of any real CFI insn.  */
#define CFI_adjust_cfa_offset	0x100
#define CFI_return_column	0x101
#define CFI_rel_offset		0x102
#define CFI_escape		0x103
#define CFI_signal_frame	0x104
#define CFI_val_encoded_addr	0x105
#define CFI_label		0x106

/* By default emit .eh_frame only,not .debug_frame.  */
#define CFI_EMIT_eh_frame               (1 << 0)
#define CFI_EMIT_debug_frame            (1 << 1)
#define CFI_EMIT_target                 (1 << 2)
#define CFI_EMIT_eh_frame_compact       (1 << 3)
#define CFI_EMIT_sframe                 (1 << 4)

#endif				/* DW2GENCFI_H */
static void	output_sframe(segT sframe_seg);


/* By default,use difference expressions if DIFF_EXPR_OK is defined.  */
#ifndef CFI_DIFF_EXPR_OK
#ifdef DIFF_EXPR_OK
#define CFI_DIFF_EXPR_OK 1
#else
#define CFI_DIFF_EXPR_OK 0
#endif
#endif

#ifndef CFI_DIFF_LSDA_OK
#define CFI_DIFF_LSDA_OK CFI_DIFF_EXPR_OK
#endif

#if CFI_DIFF_EXPR_OK == 1 && CFI_DIFF_LSDA_OK == 0
#error "CFI_DIFF_EXPR_OK should imply CFI_DIFF_LSDA_OK"
#endif

/*
 * We re-use DWARF2_LINE_MIN_INSN_LENGTH for the code alignment field of the
 * CIE.  Default to 1 if not otherwise specified.
 */
#ifndef DWARF2_LINE_MIN_INSN_LENGTH
#define DWARF2_LINE_MIN_INSN_LENGTH 1
#endif

/* By default,use 32-bit relocations from .eh_frame into .text.  */
#ifndef DWARF2_FDE_RELOC_SIZE
#define DWARF2_FDE_RELOC_SIZE 4
#endif

/* By default,use a read-only .eh_frame section.  */
#ifndef DWARF2_EH_FRAME_READ_ONLY
#define DWARF2_EH_FRAME_READ_ONLY SEC_READONLY
#endif

#ifndef EH_FRAME_ALIGNMENT
#define EH_FRAME_ALIGNMENT 3
#endif

#ifndef tc_cfi_frame_initial_instructions
#define tc_cfi_frame_initial_instructions() ((void)0)
#endif

#ifndef tc_cfi_startproc
#define tc_cfi_startproc() ((void)0)
#endif

#ifndef tc_cfi_endproc
#define tc_cfi_endproc(fde) ((void) (fde))
#endif

#define EH_FRAME_LINKONCE (compact_eh)

#ifndef DWARF2_FORMAT
#define DWARF2_FORMAT(SEC) dwarf2_format_32bit
#endif

#ifndef DWARF2_ADDR_SIZE
#define DWARF2_ADDR_SIZE(x) (x->arch_info->bits_per_address / 8)
#endif

#define CUR_SEG(structp) NULL
#define SET_CUR_SEG(structp,seg) (void) (0 && seg)
#define HANDLED(structp) 0
#define SET_HANDLED(structp,val) (void) (0 && val)

#ifndef tc_cfi_reloc_for_encoding
#define tc_cfi_reloc_for_encoding(e) BFD_RELOC_NONE
#endif

/* Targets which support SFrame format will define this and return true.  */
#ifndef support_sframe_p
#define support_sframe_p() false
#endif

/* Private segment collection list.  */
struct dwcfi_seg_list {
	segT		seg;
	int		subseg;
	char           *seg_name;
};

#ifdef SUPPORT_COMPACT_EH
static bool	compact_eh;
#else
#define compact_eh 0
#endif

static htab_t	dwcfi_hash;
static htab_t	sy_hash;

/* Emit a single byte into the current segment.  */
static inline void out_one(int byte)
{
	FRAG_APPEND_1_CHAR(byte);
}

/* Emit a two-byte word into the current segment.  */
static inline void out_two(int data)
{
	md_number_to_chars(frag_more(2),data,2);
}

/* Emit a four byte word into the current segment.  */
static inline void out_four(int data)
{
	md_number_to_chars(frag_more(4),data,4);
}
/* Emit an unsigned "little-endian base 128" number.  */
static void	out_uleb128(addressT value)
{
	output_leb128(frag_more(sizeof_leb128(value,0)),value,0);
}
/* Write VAL in uleb128 format to P,returning a pointer to the following byte. */
static bfd_byte *write_uleb128(bfd_byte * p,unsigned int val)
{
	bfd_byte	c;
	do {
		c = val & 0x7f;
		val >>= 7;
		if (val)
			c |= 0x80;
		*(p++) = c;
	}
	while (val);
	return p;
}
/* Emit an unsigned "little-endian base 128" number.  */
static void	out_sleb128(offsetT value)
{
	output_leb128(frag_more(sizeof_leb128(value,1)),value,1);
}

static unsigned	encoding_size(unsigned char encoding)
{
	if (encoding == DW_EH_PE_omit)
		return 0;
	switch (encoding & 0x7) {
	case 0: return 8;
	case DW_EH_PE_udata2: return 2;
	case DW_EH_PE_udata4: return 4;
	case DW_EH_PE_udata8: return 8;
	default:
		abort();
	}
}

/* Emit expression EXP in ENCODING.  If EMIT_ENCODING is true,first emit a
 * byte containing ENCODING. */
static void	emit_expr_encoded(expressionS * exp,int encoding,bool emit_encoding)
{
	unsigned	size = encoding_size(encoding);
	bfd_reloc_code_real_type code;

	if (encoding == DW_EH_PE_omit)
		return;

	if (emit_encoding)
		out_one(encoding);

	code = tc_cfi_reloc_for_encoding(encoding);
	if (code != BFD_RELOC_NONE) {
		reloc_howto_type *howto = riscv_reloc_type_lookup(stdoutput,code);
		char           *p = frag_more(size);
		gas_assert(size == (unsigned)howto->bitsize / 8);
		md_number_to_chars(p,0,size);
		fix_new(frag_now,p - frag_now->fr_literal,size,exp->X_add_symbol,
			exp->X_add_number,howto->pc_relative,code);
	} else
		if ((encoding & 0x70) == DW_EH_PE_pcrel) {
			expressionS	tmp = *exp;
			tmp.X_op = O_subtract;
			tmp.X_op_symbol = symbol_temp_new_now();
			emit_expr(&tmp,size);
		} else
			emit_expr(exp,size);
}

/* Build based on segment the derived .debug_... segment name containing origin
 * segment's postfix name part.  */
static char    *get_debugseg_name(segT seg,const char *base_name)
{
	const char     *name;
	const char     *dollar;
	const char     *dot;

	if (!seg
	    || (name = bfd_section_name(seg)) == NULL
	    || *name == 0)
		return notes_strdup(base_name);

	dollar = strchr(name,'$');
	dot = strchr(name + 1,'.');

	if (!dollar && !dot) {
		if (!strcmp(base_name,".eh_frame_entry")
		    && strcmp(name,".text") != 0)
			return notes_concat(base_name,".",name,NULL);

		name = "";
	} else
		if (!dollar) name = dot;
		else if (!dot) name = dollar;
		else if (dot < dollar) name = dot;
		else name = dollar;

	return notes_concat(base_name,name,NULL);
}

/* Allocate a dwcfi_seg_list structure.  */
static struct dwcfi_seg_list *alloc_debugseg_item(segT seg,int subseg,char *name)
{
	struct dwcfi_seg_list *r;

	r = notes_alloc(sizeof(*r) + strlen(name));
	r->seg = seg;
	r->subseg = subseg;
	r->seg_name = name;
	return r;
}

static segT	is_now_linkonce_segment(void)
{
	if (compact_eh)
		return now_seg;

	if ((now_seg->flags
	     & (SEC_LINK_ONCE|SEC_LINK_DUPLICATES_DISCARD
		| SEC_LINK_DUPLICATES_ONE_ONLY|SEC_LINK_DUPLICATES_SAME_SIZE
		| SEC_LINK_DUPLICATES_SAME_CONTENTS)) != 0)
		return now_seg;
	return NULL;
}

/* Generate debug... segment with same linkonce properties of based segment. */
static segT	make_debug_seg(segT cseg,char *name,int sflags)
{
	segT		save_seg = now_seg;
	int		save_subseg = now_subseg;
	segT		r;
	uint32_t	flags;

	r = subseg_new(name,0);

	/* Check if code segment is marked as linked once.  */
	if (!cseg)
		flags = 0;
	else
		flags = (cseg->flags
			 & (SEC_LINK_ONCE|SEC_LINK_DUPLICATES_DISCARD
		| SEC_LINK_DUPLICATES_ONE_ONLY|SEC_LINK_DUPLICATES_SAME_SIZE
			   |SEC_LINK_DUPLICATES_SAME_CONTENTS));

	/* Add standard section flags.  */
	flags |= sflags;

	/* Apply possibly linked once flags to new generated segment,too.  */
	r->flags = flags;

	/* Restore to previous segment.  */
	if (save_seg != NULL)
		subseg_set(save_seg,save_subseg);
	return r;
}

static struct dwcfi_seg_list *dwcfi_hash_find(char *name)
{
	return (struct dwcfi_seg_list *)str_hash_find(dwcfi_hash,name);
}
/* The default number of entries to use when creating a hash table.  */
#define DEFAULT_SIZE 4051

/* The following function returns a nearest prime number which is greater than
 * N,and near a power of two.  Copied from libiberty. Returns zero for
 * ridiculously large N to signify an error.  */
static uint32_t	higher_prime_number(uint32_t n)
{
	/* These are primes that are near,but slightly smaller than,a power of two. */
	static const uint32_t primes[] = {
		31,61,127,251,509U,1021,2039,4093,8191,16381,
		32749,65521,131071U,262139,524287,1048573U,2097143U,
		4194301,8388593U,16777213U,33554393U,67108859U,134217689U,
		268435399U,536870909U,1073741789U,2147483647U,4294967291U
	};

	const uint32_t *low = &primes[0];
	const uint32_t *high = &primes[sizeof(primes) / sizeof(primes[0])];

	while (low != high) {
		const uint32_t *mid = low + (high - low) / 2;
		if (n >= *mid)
			low = mid + 1;
		else
			high = mid;
	}

	if (n >= *low)
		return 0;

	return *low;
}
static struct bfd_hash_entry *bfd_hash_insert(struct bfd_hash_table *table,
				      		const		char  *string,
				       		unsigned	long	hash)
{
	struct bfd_hash_entry *hashp;
	unsigned int	_index;

	hashp = (*table->newfunc) (NULL,table,string);
	if (hashp == NULL)
		return NULL;
	hashp->string = string;
	hashp->hash = hash;
	_index = hash % table->size;
	hashp->next = table->table[_index];
	table->table[_index] = hashp;
	table->count++;

	if (!table->frozen && table->count > table->size * 3 / 4) {
		unsigned long	newsize = higher_prime_number(table->size);
		struct bfd_hash_entry **newtable;
		unsigned int	hi;
		unsigned long	alloc = newsize * sizeof(struct bfd_hash_entry *);

		/*
		 * If we can't find a higher prime,or we can't possibly alloc
		 * that much memory,don't try to grow the table.
		 */
		if (newsize == 0 || alloc / sizeof(struct bfd_hash_entry *) != newsize) {
			table->frozen = 1;
			return hashp;
		}
		newtable = ((struct bfd_hash_entry **)
		     objalloc_alloc((struct objalloc *)table->memory,alloc));
		if (newtable == NULL) {
			table->frozen = 1;
			return hashp;
		}
		memset(newtable,0,alloc);

		for (hi = 0; hi < table->size; hi++)
			while (table->table[hi]) {
				struct bfd_hash_entry *chain = table->table[hi];
				struct bfd_hash_entry *chain_end = chain;

				while (chain_end->next && chain_end->next->hash == chain->hash)
					chain_end = chain_end->next;

				table->table[hi] = chain_end->next;
				_index = chain->hash % newsize;
				chain_end->next = newtable[_index];
				newtable[_index] = chain;
			}
		table->table = newtable;
		table->size = newsize;
	}
	return hashp;
}
static inline unsigned long bfd_hash_hash(const char *string,unsigned int *lenp)
{
	const unsigned char *s;
	unsigned long	hash;
	unsigned int	len;
	unsigned int	c;

	gas_assert(string != NULL);
	hash = 0;
	len = 0;
	s = (const unsigned char *)string;
	while ((c = *s++) != '\0') {
		hash += c + (c << 17);
		hash ^= hash >> 2;
	}
	len = (s - (const unsigned char *)string) - 1;
	hash += len + (len << 17);
	hash ^= hash >> 2;
	if (lenp != NULL)
		*lenp = len;
	return hash;
}
static struct bfd_hash_entry *bfd_hash_lookup(struct bfd_hash_table *table,
			      		const char *string, bool create , bool copy)
{
	unsigned long	hash;
	struct bfd_hash_entry *hashp;
	unsigned int	len;
	unsigned int	_index;

	hash = bfd_hash_hash(string,&len);
	_index = hash % table->size;
	for (hashp = table->table[_index];
	     hashp != NULL;
	     hashp = hashp->next) {
		if (hashp->hash == hash
		    && strcmp(hashp->string,string) == 0)
			return hashp;
	}

	if (!create)
		return NULL;

	if (copy) {
		char           *new_string;

		new_string = (char *)objalloc_alloc((struct objalloc *)table->memory,
						    len + 1);
		if (!new_string) {
			bfd_set_error(bfd_error_no_memory);
			return NULL;
		}
		memcpy(new_string,string,len + 1);
		string = new_string;
	}
	return bfd_hash_insert(table,string,hash);
}

static struct dwcfi_seg_list *dwcfi_hash_find_or_make(segT cseg,const char *base_name,int flags)
{
	struct dwcfi_seg_list *item;
	char           *name;

	/* Initialize dwcfi_hash once.  */
	if (!dwcfi_hash)
		dwcfi_hash = str_htab_create();

	name = get_debugseg_name(cseg,base_name);

	item = dwcfi_hash_find(name);
	if (!item) {
		item = alloc_debugseg_item(make_debug_seg(cseg,name,flags),0,name);

		str_hash_insert(dwcfi_hash,item->seg_name,item,0);
	} else
		notes_free(name);

	return item;
}

/* ??? Share this with dwarf2cfg.c.  */
#ifndef TC_DWARF2_EMIT_OFFSET
#define TC_DWARF2_EMIT_OFFSET  generic_dwarf2_emit_offset
/* Create an offset to .dwarf2_*.  */
static void	generic_dwarf2_emit_offset(symbolS * symbol,unsigned size)
{
	expressionS	exp;

	exp.X_op = O_symbol;
	exp.X_add_symbol = symbol;
	exp.X_add_number = 0;
	emit_expr(&exp,size);
}
#endif

struct cfi_escape_data {
	struct cfi_escape_data *next;
	expressionS	exp;
};

struct cie_entry {
	struct cie_entry *next;
	symbolS        *start_address;
	unsigned	return_column;
	unsigned	signal_frame;
	unsigned char	fde_encoding;
	unsigned char	per_encoding;
	unsigned char	lsda_encoding;
	expressionS	personality;
	struct cfi_insn_data *first,*last;
};

/* List of FDE entries.  */
struct fde_entry *all_fde_data;
static struct fde_entry **last_fde_data = &all_fde_data;

/* List of CIEs so that they could be reused.  */
static struct cie_entry *cie_root;

/* Construct a new FDE structure and add it to the end of the fde list.  */
static struct fde_entry *alloc_fde_entry(void)
{
	struct fde_entry *fde = XCNEW(struct fde_entry);

	frchain_now->frch_cfi_data = XCNEW(struct frch_cfi_data);
	frchain_now->frch_cfi_data->cur_fde_data = fde;
	*last_fde_data = fde;
	last_fde_data = &fde->next;
	SET_CUR_SEG(fde,is_now_linkonce_segment());
	SET_HANDLED(fde,0);
	fde->last = &fde->data;
	fde->return_column = DWARF2_DEFAULT_RETURN_COLUMN;
	fde->per_encoding = DW_EH_PE_omit;
	fde->lsda_encoding = DW_EH_PE_omit;
	fde->eh_header_type = EH_COMPACT_UNKNOWN;
	return fde;
}

/* The following functions are available for a backend to construct its own
 * unwind information,usually from legacy unwind directives.  
 *
 * Construct a new INSN structure and add it to the end of the insn list for
 * the currently active FDE.  */
static bool	cfi_sections_set = false;
static int	cfi_sections = CFI_EMIT_eh_frame;
static int	all_cfi_sections = 0;
static struct fde_entry *last_fde;

static struct cfi_insn_data *alloc_cfi_insn_data(void)
{
	struct cfi_insn_data *insn = XCNEW(struct cfi_insn_data);
	struct fde_entry *cur_fde_data = frchain_now->frch_cfi_data->cur_fde_data;

	*cur_fde_data->last = insn;
	cur_fde_data->last = &insn->next;
	SET_CUR_SEG(insn,is_now_linkonce_segment());
	return insn;
}

/* Construct a new FDE structure that begins at LABEL.  */
static void	cfi_new_fde(symbolS * label)
{
	struct fde_entry *fde = alloc_fde_entry();
	fde->start_address = label;
	frchain_now->frch_cfi_data->last_address = label;
}

/* End the currently open FDE.  */
static void		cfi_end_fde(symbolS * label)
{
	frchain_now->frch_cfi_data->cur_fde_data->end_address = label;
	free(frchain_now->frch_cfi_data);
	frchain_now->frch_cfi_data = NULL;
}

/* Set the return column for the current FDE.  */
static void	cfi_set_return_column(unsigned regno)
{
	frchain_now->frch_cfi_data->cur_fde_data->return_column = regno;
}

static void	cfi_set_sections(void)
{
	frchain_now->frch_cfi_data->cur_fde_data->sections = all_cfi_sections;
	cfi_sections_set = true;
}

/* Universal functions to store new instructions.  */
static void	cfi_add_CFA_insn(int insn)
{
	struct cfi_insn_data *insn_ptr = alloc_cfi_insn_data();

	insn_ptr->insn = insn;
}
static void	cfi_add_CFA_insn_reg(int insn,unsigned regno)
{
	struct cfi_insn_data *insn_ptr = alloc_cfi_insn_data();

	insn_ptr->insn = insn;
	insn_ptr->u.r = regno;
}

static void	cfi_add_CFA_insn_offset(int insn,offsetT offset)
{
	struct cfi_insn_data *insn_ptr = alloc_cfi_insn_data();

	insn_ptr->insn = insn;
	insn_ptr->u.i = offset;
}

static void	cfi_add_CFA_insn_reg_reg(int insn,unsigned reg1,unsigned reg2)
{
	struct cfi_insn_data *insn_ptr = alloc_cfi_insn_data();

	insn_ptr->insn = insn;
	insn_ptr->u.rr.reg1 = reg1;
	insn_ptr->u.rr.reg2 = reg2;
}

static void	cfi_add_CFA_insn_reg_offset(int insn,unsigned regno,offsetT offset)
{
	struct cfi_insn_data *insn_ptr = alloc_cfi_insn_data();

	insn_ptr->insn = insn;
	insn_ptr->u.ri.reg = regno;
	insn_ptr->u.ri.offset = offset;
}

/* Add a CFI insn to advance the PC from the last address to LABEL.  */
static void	cfi_add_advance_loc(symbolS * label)
{
	struct cfi_insn_data *insn = alloc_cfi_insn_data();

	insn->insn = DW_CFA_advance_loc;
	insn->u.ll.lab1 = frchain_now->frch_cfi_data->last_address;
	insn->u.ll.lab2 = label;

	frchain_now->frch_cfi_data->last_address = label;
}

/* Add a CFI insn to label the current position in the CFI segment.  */
static void	cfi_add_label(const char *name)
{
	unsigned	len = strlen(name) + 1;
	struct cfi_insn_data *insn = alloc_cfi_insn_data();

	insn->insn = CFI_label;
	obstack_grow(&notes,name,len);
	insn->u.sym_name = (char *)obstack_finish(&notes);
}

/* Add a DW_CFA_offset record to the CFI data.  */
static void	cfi_add_CFA_offset(unsigned regno,offsetT offset)
{
	unsigned	abs_data_align;

	gas_assert(DWARF2_CIE_DATA_ALIGNMENT != 0);
	cfi_add_CFA_insn_reg_offset(DW_CFA_offset,regno,offset);

	abs_data_align = (DWARF2_CIE_DATA_ALIGNMENT < 0
		    ? -DWARF2_CIE_DATA_ALIGNMENT : DWARF2_CIE_DATA_ALIGNMENT);
	if (offset % abs_data_align)
		as_bad(("register save offset not a multiple of %u"),abs_data_align);
}

/* Add a DW_CFA_val_offset record to the CFI data.  */
static void	cfi_add_CFA_val_offset(unsigned regno,offsetT offset)
{
	unsigned	abs_data_align;

	gas_assert(DWARF2_CIE_DATA_ALIGNMENT != 0);
	cfi_add_CFA_insn_reg_offset(DW_CFA_val_offset,regno,offset);

	abs_data_align = (DWARF2_CIE_DATA_ALIGNMENT < 0
		    ? -DWARF2_CIE_DATA_ALIGNMENT : DWARF2_CIE_DATA_ALIGNMENT);
	if (offset % abs_data_align)
		as_bad(("register save offset not a multiple of %u"),abs_data_align);
}

/* Add a DW_CFA_def_cfa record to the CFI data.  */
static void	cfi_add_CFA_def_cfa(unsigned regno,offsetT offset)
{
	cfi_add_CFA_insn_reg_offset(DW_CFA_def_cfa,regno,offset);
	frchain_now->frch_cfi_data->cur_cfa_offset = offset;
}

/* Add a DW_CFA_register record to the CFI data.  */
static void	cfi_add_CFA_register(unsigned reg1,unsigned reg2)
{
	cfi_add_CFA_insn_reg_reg(DW_CFA_register,reg1,reg2);
}

/* Add a DW_CFA_def_cfa_register record to the CFI data.  */
static void	cfi_add_CFA_def_cfa_register(unsigned regno)
{
	cfi_add_CFA_insn_reg(DW_CFA_def_cfa_register,regno);
}

/* Add a DW_CFA_def_cfa_offset record to the CFI data.  */
static void	cfi_add_CFA_def_cfa_offset(offsetT offset)
{
	cfi_add_CFA_insn_offset(DW_CFA_def_cfa_offset,offset);
	frchain_now->frch_cfi_data->cur_cfa_offset = offset;
}

static void	cfi_add_CFA_restore(unsigned regno)
{
	cfi_add_CFA_insn_reg(DW_CFA_restore,regno);
}

static void	cfi_add_CFA_undefined(unsigned regno)
{
	cfi_add_CFA_insn_reg(DW_CFA_undefined,regno);
}

static void	cfi_add_CFA_same_value(unsigned regno)
{
	cfi_add_CFA_insn_reg(DW_CFA_same_value,regno);
}

static void	cfi_add_CFA_remember_state(void)
{
	struct cfa_save_data *p;

	cfi_add_CFA_insn(DW_CFA_remember_state);

	p = XNEW(struct cfa_save_data);
	p->cfa_offset = frchain_now->frch_cfi_data->cur_cfa_offset;
	p->next = frchain_now->frch_cfi_data->cfa_save_stack;
	frchain_now->frch_cfi_data->cfa_save_stack = p;
}

static void	cfi_add_CFA_restore_state(void)
{
	struct cfa_save_data *p;

	cfi_add_CFA_insn(DW_CFA_restore_state);

	p = frchain_now->frch_cfi_data->cfa_save_stack;
	if (p) {
		frchain_now->frch_cfi_data->cur_cfa_offset = p->cfa_offset;
		frchain_now->frch_cfi_data->cfa_save_stack = p->next;
		free(p);
	} else
		as_bad(("CFI state restore without previous remember"));
}


/* Parse CFI assembler directives.  */
static void	dot_cfi(int);
static void	dot_cfi_escape(int);
static void	dot_cfi_sections(int);
static void	dot_cfi_startproc(int);
static void	dot_cfi_endproc(int);
static void	dot_cfi_fde_data(int);
static void	dot_cfi_personality(int);
static void	dot_cfi_personality_id(int);
static void	dot_cfi_lsda(int);
static void	dot_cfi_val_encoded_addr(int);
static void	dot_cfi_inline_lsda(int);
static void	dot_cfi_label(int);

static const pseudo_typeS cfi_pseudo_table[] =
{
	{"cfi_sections",dot_cfi_sections,0},
	{"cfi_startproc",dot_cfi_startproc,0},
	{"cfi_endproc",dot_cfi_endproc,0},
	{"cfi_fde_data",dot_cfi_fde_data,0},
	{"cfi_def_cfa",dot_cfi,DW_CFA_def_cfa},
	{"cfi_def_cfa_register",dot_cfi,DW_CFA_def_cfa_register},
	{"cfi_def_cfa_offset",dot_cfi,DW_CFA_def_cfa_offset},
	{"cfi_adjust_cfa_offset",dot_cfi,CFI_adjust_cfa_offset},
	{"cfi_offset",dot_cfi,DW_CFA_offset},
	{"cfi_rel_offset",dot_cfi,CFI_rel_offset},
	{"cfi_register",dot_cfi,DW_CFA_register},
	{"cfi_return_column",dot_cfi,CFI_return_column},
	{"cfi_restore",dot_cfi,DW_CFA_restore},
	{"cfi_undefined",dot_cfi,DW_CFA_undefined},
	{"cfi_same_value",dot_cfi,DW_CFA_same_value},
	{"cfi_remember_state",dot_cfi,DW_CFA_remember_state},
	{"cfi_restore_state",dot_cfi,DW_CFA_restore_state},
	{"cfi_window_save",dot_cfi,DW_CFA_GNU_window_save},
	{"cfi_negate_ra_state",dot_cfi,DW_CFA_AARCH64_negate_ra_state},
	{"cfi_escape",dot_cfi_escape,0},
	{"cfi_signal_frame",dot_cfi,CFI_signal_frame},
	{"cfi_personality",dot_cfi_personality,0},
	{"cfi_personality_id",dot_cfi_personality_id,0},
	{"cfi_lsda",dot_cfi_lsda,0},
	{"cfi_val_encoded_addr",dot_cfi_val_encoded_addr,0},
	{"cfi_inline_lsda",dot_cfi_inline_lsda,0},
	{"cfi_label",dot_cfi_label,0},
	{"cfi_val_offset",dot_cfi,DW_CFA_val_offset},
	{NULL,NULL,0}
};

static void	cfi_parse_separator(void)
{
	SKIP_WHITESPACE();
	if (*input_line_pointer == ',')
		input_line_pointer++;
	else
		as_bad(("missing separator"));
}

static void	tc_parse_to_dw2regnum(expressionS * exp)
{
	SKIP_WHITESPACE();
	if (is_name_beginner(*input_line_pointer)
	    || (*input_line_pointer == '%'
		&& is_name_beginner(*++input_line_pointer))) {
		char           *name,c;

		c = get_symbol_name(&name);

		exp->X_op = O_constant;
		exp->X_add_number = tc_regname_to_dw2regnum(name);

		restore_line_pointer(c);
	} else expression_and_evaluate(exp);
}

static unsigned	cfi_parse_reg(void)
{
	int		regno;
	expressionS	exp;

	tc_parse_to_dw2regnum(&exp);
	switch (exp.X_op) {
	case O_register: case O_constant:
		regno = exp.X_add_number;
		break;
	default:
		regno = -1;
		break;
	}

	if (regno < 0) {
		as_bad(("bad register expression"));
		regno = 0;
	}
	return regno;
}

static		offsetT cfi_parse_const(void)
{
	return get_absolute_expression();
}

static void	dot_cfi(int arg)
{
	offsetT		offset;
	unsigned	reg1  ,reg2;

	if (frchain_now->frch_cfi_data == NULL) {
		as_bad(("CFI instruction used without previous .cfi_startproc"));
		ignore_rest_of_line();
		return;
	}
	/* If the last address was not at the current PC,advance to current.  */
	if (symbol_get_frag(frchain_now->frch_cfi_data->last_address) != frag_now
	    || (S_GET_VALUE(frchain_now->frch_cfi_data->last_address)
		!= frag_now_fix()))
		cfi_add_advance_loc(symbol_temp_new_now());

	switch (arg) {
	case DW_CFA_offset:
		reg1 = cfi_parse_reg();
		cfi_parse_separator();
		offset = cfi_parse_const();
		cfi_add_CFA_offset(reg1,offset);
		break;

	case DW_CFA_val_offset:
		reg1 = cfi_parse_reg();
		cfi_parse_separator();
		offset = cfi_parse_const();
		cfi_add_CFA_val_offset(reg1,offset);
		break;

	case CFI_rel_offset:
		reg1 = cfi_parse_reg();
		cfi_parse_separator();
		offset = cfi_parse_const();
		cfi_add_CFA_offset(reg1,
			 offset - frchain_now->frch_cfi_data->cur_cfa_offset);
		break;

	case DW_CFA_def_cfa:
		reg1 = cfi_parse_reg();
		cfi_parse_separator();
		offset = cfi_parse_const();
		cfi_add_CFA_def_cfa(reg1,offset);
		break;

	case DW_CFA_register:
		reg1 = cfi_parse_reg();
		cfi_parse_separator();
		reg2 = cfi_parse_reg();
		cfi_add_CFA_register(reg1,reg2);
		break;

	case DW_CFA_def_cfa_register:
		reg1 = cfi_parse_reg();
		cfi_add_CFA_def_cfa_register(reg1);
		break;

	case DW_CFA_def_cfa_offset:
		offset = cfi_parse_const();
		cfi_add_CFA_def_cfa_offset(offset);
		break;

	case CFI_adjust_cfa_offset:
		offset = cfi_parse_const();
		cfi_add_CFA_def_cfa_offset(frchain_now->frch_cfi_data->cur_cfa_offset
					   + offset);
		break;

	case DW_CFA_restore:
		for (;;) {
			reg1 = cfi_parse_reg();
			cfi_add_CFA_restore(reg1);
			SKIP_WHITESPACE();
			if (*input_line_pointer != ',')
				break;
			++input_line_pointer;
		}
		break;

	case DW_CFA_undefined:
		for (;;) {
			reg1 = cfi_parse_reg();
			cfi_add_CFA_undefined(reg1);
			SKIP_WHITESPACE();
			if (*input_line_pointer != ',')
				break;
			++input_line_pointer;
		}
		break;

	case DW_CFA_same_value:
		reg1 = cfi_parse_reg();
		cfi_add_CFA_same_value(reg1);
		break;

	case CFI_return_column:
		reg1 = cfi_parse_reg();
		cfi_set_return_column(reg1);
		break;

	case DW_CFA_remember_state:
		cfi_add_CFA_remember_state();
		break;

	case DW_CFA_restore_state:
		cfi_add_CFA_restore_state();
		break;

	case DW_CFA_GNU_window_save:
		cfi_add_CFA_insn(DW_CFA_GNU_window_save);
		break;

	case CFI_signal_frame:
		frchain_now->frch_cfi_data->cur_fde_data->signal_frame = 1;
		break;

	default:
		abort();
	}

	demand_empty_rest_of_line();
}

static void	dot_cfi_escape(int ignored ATTRIBUTE_UNUSED)
{
	struct cfi_escape_data *head,**tail,*e;
	struct cfi_insn_data *insn;

	if (frchain_now->frch_cfi_data == NULL) {
		as_bad(("CFI instruction used without previous .cfi_startproc"));
		ignore_rest_of_line();
		return;
	}
	/* If the last address was not at the current PC,advance to current.  */
	if (symbol_get_frag(frchain_now->frch_cfi_data->last_address) != frag_now
	    || (S_GET_VALUE(frchain_now->frch_cfi_data->last_address)
		!= frag_now_fix()))
		cfi_add_advance_loc(symbol_temp_new_now());

	tail = &head;
	do {
		e = XNEW(struct cfi_escape_data);
		do_parse_cons_expression(&e->exp,1);
		*tail = e;
		tail = &e->next;
	}
	while (*input_line_pointer++ == ',');
	*tail = NULL;

	insn = alloc_cfi_insn_data();
	insn->insn = CFI_escape;
	insn->u.esc = head;

	--input_line_pointer;
	demand_empty_rest_of_line();
}

static void	dot_cfi_personality(int ignored ATTRIBUTE_UNUSED)
{
	struct fde_entry *fde;
	offsetT		encoding;

	if (frchain_now->frch_cfi_data == NULL) {
		as_bad(("CFI instruction used without previous .cfi_startproc"));
		ignore_rest_of_line();
		return;
	}
	fde = frchain_now->frch_cfi_data->cur_fde_data;
	encoding = cfi_parse_const();
	if (encoding == DW_EH_PE_omit) {
		demand_empty_rest_of_line();
		fde->per_encoding = encoding;
		return;
	}
	if ((encoding & 0xff) != encoding
	    || ((((encoding & 0x70) != 0
#if CFI_DIFF_EXPR_OK || defined tc_cfi_emit_pcrel_expr
		  && (encoding & 0x70) != DW_EH_PE_pcrel
#endif
		  )
	/* leb128 can be handled,but does something actually need it?  */
		 || (encoding & 7) == DW_EH_PE_uleb128
		 || (encoding & 7) > DW_EH_PE_udata8)
		&& tc_cfi_reloc_for_encoding(encoding) == BFD_RELOC_NONE)) {
		as_bad(("invalid or unsupported encoding in .cfi_personality"));
		ignore_rest_of_line();
		return;
	}
	if (*input_line_pointer++ != ',') {
		as_bad((".cfi_personality requires encoding and symbol arguments"));
		ignore_rest_of_line();
		return;
	}
	expression_and_evaluate(&fde->personality);
	switch (fde->personality.X_op) {
	case O_symbol:
		break;
	case O_constant:
		if ((encoding & 0x70) == DW_EH_PE_pcrel)
			encoding = DW_EH_PE_omit;
		break;
	default:
		encoding = DW_EH_PE_omit;
		break;
	}

	fde->per_encoding = encoding;

	if (encoding == DW_EH_PE_omit) {
		as_bad(("wrong second argument to .cfi_personality"));
		ignore_rest_of_line();
		return;
	}
	demand_empty_rest_of_line();
}

static void	dot_cfi_lsda(int ignored ATTRIBUTE_UNUSED)
{
	struct fde_entry *fde;
	offsetT		encoding;

	if (frchain_now->frch_cfi_data == NULL) {
		as_bad(("CFI instruction used without previous .cfi_startproc"));
		ignore_rest_of_line();
		return;
	}
	fde = frchain_now->frch_cfi_data->cur_fde_data;
	encoding = cfi_parse_const();
	if (encoding == DW_EH_PE_omit) {
		demand_empty_rest_of_line();
		fde->lsda_encoding = encoding;
		return;
	}
	if ((encoding & 0xff) != encoding
	    || ((((encoding & 0x70) != 0
#if CFI_DIFF_LSDA_OK || defined tc_cfi_emit_pcrel_expr
		  && (encoding & 0x70) != DW_EH_PE_pcrel
#endif
		  )
	/* leb128 can be handled,but does something actually need it?  */
		 || (encoding & 7) == DW_EH_PE_uleb128
		 || (encoding & 7) > DW_EH_PE_udata8)
		&& tc_cfi_reloc_for_encoding(encoding) == BFD_RELOC_NONE)) {
		as_bad(("invalid or unsupported encoding in .cfi_lsda"));
		ignore_rest_of_line();
		return;
	}
	if (*input_line_pointer++ != ',') {
		as_bad((".cfi_lsda requires encoding and symbol arguments"));
		ignore_rest_of_line();
		return;
	}
	fde->lsda_encoding = encoding;

	expression_and_evaluate(&fde->lsda);
	switch (fde->lsda.X_op) {
	case O_symbol:
		break;
	case O_constant:
		if ((encoding & 0x70) == DW_EH_PE_pcrel)
			encoding = DW_EH_PE_omit;
		break;
	default:
		encoding = DW_EH_PE_omit;
		break;
	}

	fde->lsda_encoding = encoding;

	if (encoding == DW_EH_PE_omit) {
		as_bad(("wrong second argument to .cfi_lsda"));
		ignore_rest_of_line();
		return;
	}
	demand_empty_rest_of_line();
}

static void	dot_cfi_val_encoded_addr(int ignored ATTRIBUTE_UNUSED)
{
	struct cfi_insn_data *insn_ptr;
	offsetT		encoding;

	if (frchain_now->frch_cfi_data == NULL) {
		as_bad(("CFI instruction used without previous .cfi_startproc"));
		ignore_rest_of_line();
		return;
	}
	/* If the last address was not at the current PC,advance to current.  */
	if (symbol_get_frag(frchain_now->frch_cfi_data->last_address) != frag_now
	    || (S_GET_VALUE(frchain_now->frch_cfi_data->last_address)
		!= frag_now_fix()))
		cfi_add_advance_loc(symbol_temp_new_now());

	insn_ptr = alloc_cfi_insn_data();
	insn_ptr->insn = CFI_val_encoded_addr;

	insn_ptr->u.ea.reg = cfi_parse_reg();

	cfi_parse_separator();
	encoding = cfi_parse_const();
	if ((encoding & 0xff) != encoding
	    || ((encoding & 0x70) != 0
#if CFI_DIFF_EXPR_OK || defined tc_cfi_emit_pcrel_expr
		&& (encoding & 0x70) != DW_EH_PE_pcrel
#endif
		)
	/* leb128 can be handled,but does something actually need it?  */
	    || (encoding & 7) == DW_EH_PE_uleb128
	    || (encoding & 7) > DW_EH_PE_udata8) {
		as_bad(("invalid or unsupported encoding in .cfi_lsda"));
		encoding = DW_EH_PE_omit;
	}
	cfi_parse_separator();
	expression_and_evaluate(&insn_ptr->u.ea.exp);
	switch (insn_ptr->u.ea.exp.X_op) {
	case O_symbol:
		break;
	case O_constant:
		if ((encoding & 0x70) != DW_EH_PE_pcrel)
			break;
		/* Fall through.  */
	default:
		encoding = DW_EH_PE_omit;
		break;
	}

	insn_ptr->u.ea.encoding = encoding;
	if (encoding == DW_EH_PE_omit) {
		as_bad(("wrong third argument to .cfi_val_encoded_addr"));
		ignore_rest_of_line();
		return;
	}
	demand_empty_rest_of_line();
}

static void	dot_cfi_label(int ignored ATTRIBUTE_UNUSED)
{
	char           *name;

	if (frchain_now->frch_cfi_data == NULL) {
		as_bad(("CFI instruction used without previous .cfi_startproc"));
		ignore_rest_of_line();
		return;
	}
	name = read_symbol_name();
	if (name == NULL)
		return;

	/* If the last address was not at the current PC,advance to current.  */
	if (symbol_get_frag(frchain_now->frch_cfi_data->last_address) != frag_now
	    || (S_GET_VALUE(frchain_now->frch_cfi_data->last_address)
		!= frag_now_fix()))
		cfi_add_advance_loc(symbol_temp_new_now());

	cfi_add_label(name);
	free(name);

	demand_empty_rest_of_line();
}

static void	dot_cfi_sections(int ignored ATTRIBUTE_UNUSED)
{
	int		sections = 0;

	SKIP_WHITESPACE();
	if (is_name_beginner(*input_line_pointer) || *input_line_pointer == '"')
		while (1) {
			char           *saved_ilp;
			char           *name,c;

			saved_ilp = input_line_pointer;
			c = get_symbol_name(&name);

			if (startswith(name,".eh_frame")
			    && name[9] != '_')
				sections |= CFI_EMIT_eh_frame;
			else
				if (startswith(name,".debug_frame"))
					sections |= CFI_EMIT_debug_frame;
#if SUPPORT_COMPACT_EH
				else
					if (startswith(name,".eh_frame_entry")) {
						compact_eh = true;
						sections |= CFI_EMIT_eh_frame_compact;
					}
#endif
#ifdef tc_cfi_section_name
					else
						if (strcmp(name,tc_cfi_section_name) == 0)
							sections |= CFI_EMIT_target;
#endif
						else
							if (startswith(name,".sframe"))
								sections |= CFI_EMIT_sframe;
							else {
								*input_line_pointer = c;
								input_line_pointer = saved_ilp;
								break;
							}

			*input_line_pointer = c;
			SKIP_WHITESPACE_AFTER_NAME();
			if (*input_line_pointer == ',') {
				name = input_line_pointer++;
				SKIP_WHITESPACE();
				if (!is_name_beginner(*input_line_pointer)
				    && *input_line_pointer != '"') {
					input_line_pointer = name;
					break;
				}
			} else
				if (is_name_beginner(*input_line_pointer)
				    || *input_line_pointer == '"')
					break;
		}

	demand_empty_rest_of_line();
	if (cfi_sections_set
	    && (sections & (CFI_EMIT_eh_frame|CFI_EMIT_eh_frame_compact))
	  && ((cfi_sections & (CFI_EMIT_eh_frame|CFI_EMIT_eh_frame_compact))
	      != (sections & (CFI_EMIT_eh_frame|CFI_EMIT_eh_frame_compact))))
		as_bad("inconsistent uses of .cfi_sections");
	cfi_sections = sections;
}

static void	dot_cfi_startproc(int ignored ATTRIBUTE_UNUSED)
{
	int		simple = 0;

	if (frchain_now->frch_cfi_data != NULL) {
		as_bad("previous CFI entry not closed (missing .cfi_endproc)");
		ignore_rest_of_line();
		return;
	}
	cfi_new_fde(symbol_temp_new_now());

	SKIP_WHITESPACE();
	if (is_name_beginner(*input_line_pointer) || *input_line_pointer == '"') {
		char           *saved_ilp = input_line_pointer;
		char           *name,c;

		c = get_symbol_name(&name);

		if (strcmp(name,"simple") == 0) {
			simple = 1;
			restore_line_pointer(c);
		} else
			input_line_pointer = saved_ilp;
	}
	demand_empty_rest_of_line();

	cfi_sections_set = true;
	all_cfi_sections |= cfi_sections;
	cfi_set_sections();
	frchain_now->frch_cfi_data->cur_cfa_offset = 0;
	if (!simple)
		tc_cfi_frame_initial_instructions();

	if ((cfi_sections & CFI_EMIT_target) != 0)
		tc_cfi_startproc();
}

static void	dot_cfi_endproc(int ignored ATTRIBUTE_UNUSED)
{
	if (frchain_now->frch_cfi_data == NULL) {
		as_bad((".cfi_endproc without corresponding .cfi_startproc"));
		ignore_rest_of_line();
		return;
	}
	last_fde = frchain_now->frch_cfi_data->cur_fde_data;

	cfi_end_fde(symbol_temp_new_now());
	demand_empty_rest_of_line();

	cfi_sections_set = true;
	if ((cfi_sections & CFI_EMIT_target) != 0)
		tc_cfi_endproc(last_fde);
}

static	segT get_cfi_seg(segT cseg,const char *base,uint32_t flags,int align)
{
	/* Exclude .debug_frame sections for Compact EH.  */
 	if ((flags & SEC_DEBUGGING) == 0 && compact_eh) {
		struct dwcfi_seg_list *l;

		l = dwcfi_hash_find_or_make(cseg,base,flags);

		cseg = l->seg;
		subseg_set(cseg,l->subseg);

		cseg = subseg_new(base,0);
		cseg->flags = flags;
	}
	else {
		cseg = subseg_new(base,0);
		cseg->flags = flags;
	}
	record_alignment(cseg,align);
	return cseg;
}

static void	dot_cfi_inline_lsda(int ignored ATTRIBUTE_UNUSED)
{
	as_bad((".cfi_inline_lsda is not supported for this target"));
	ignore_rest_of_line();
}

static void	dot_cfi_fde_data(int ignored ATTRIBUTE_UNUSED)
{
	as_bad((".cfi_fde_data is not supported for this target"));
	ignore_rest_of_line();
}

static void	dot_cfi_personality_id(int ignored ATTRIBUTE_UNUSED)
{
	as_bad((".cfi_personality_id is not supported for this target"));
	ignore_rest_of_line();
}

static void	output_cfi_insn(struct cfi_insn_data *insn)
{
	offsetT		offset;
	unsigned int	regno;

	switch (insn->insn) {
	case DW_CFA_advance_loc:
		{
			symbolS        *from = insn->u.ll.lab1;
			symbolS        *to = insn->u.ll.lab2;

			if (symbol_get_frag(to) == symbol_get_frag(from)) {
				addressT	delta = S_GET_VALUE(to) - S_GET_VALUE(from);
				addressT	scaled = delta / DWARF2_LINE_MIN_INSN_LENGTH;

				if (scaled == 0);
				else
					if (scaled <= 0x3F)
						out_one(DW_CFA_advance_loc + scaled);
					else
						if (scaled <= 0xFF) {
							out_one(DW_CFA_advance_loc1);
							out_one(scaled);
						} else
							if (scaled <= 0xFFFF) {
								out_one(DW_CFA_advance_loc2);
								out_two(scaled);
							} else {
								out_one(DW_CFA_advance_loc4);
								out_four(scaled);
							}
			} else {
				expressionS	exp;

				exp.X_op = O_subtract;
				exp.X_add_symbol = to;
				exp.X_op_symbol = from;
				exp.X_add_number = 0;

				/*
				 * The code in ehopt.c expects that one byte of
				 * the encoding is already allocated to the
				 * frag.  This comes from the way that it scans
				 * the .eh_frame section looking first for the
				 * .byte DW_CFA_advance_loc4.  Call frag_grow
				 * with the sum of room needed by frag_more and
				 * frag_var to preallocate space ensuring that
				 * the DW_CFA_advance_loc4 is in the fixed part
				 * of the rs_cfa frag,so that the relax
				 * machinery can remove the advance_loc should
				 * it advance by zero.
				 */
				frag_grow(5);
				*frag_more(1) = DW_CFA_advance_loc4;

				frag_var(rs_cfa,4,0,DWARF2_LINE_MIN_INSN_LENGTH << 3,
				   make_expr_symbol(&exp),frag_now_fix() - 1,
					 (char *)frag_now);
			}
		}
		break;

	case DW_CFA_def_cfa:
		offset = insn->u.ri.offset;
		if (offset < 0) {
			out_one(DW_CFA_def_cfa_sf);
			out_uleb128(insn->u.ri.reg);
			out_sleb128(offset / DWARF2_CIE_DATA_ALIGNMENT);
		} else {
			out_one(DW_CFA_def_cfa);
			out_uleb128(insn->u.ri.reg);
			out_uleb128(offset);
		}
		break;

	case DW_CFA_def_cfa_register:
	case DW_CFA_undefined:
	case DW_CFA_same_value:
		out_one(insn->insn);
		out_uleb128(insn->u.r);
		break;

	case DW_CFA_def_cfa_offset:
		offset = insn->u.i;
		if (offset < 0) {
			out_one(DW_CFA_def_cfa_offset_sf);
			out_sleb128(offset / DWARF2_CIE_DATA_ALIGNMENT);
		} else {
			out_one(DW_CFA_def_cfa_offset);
			out_uleb128(offset);
		}
		break;

	case DW_CFA_restore:
		regno = insn->u.r;
		if (regno <= 0x3F) {
			out_one(DW_CFA_restore + regno);
		} else {
			out_one(DW_CFA_restore_extended);
			out_uleb128(regno);
		}
		break;

	case DW_CFA_offset:
		regno = insn->u.ri.reg;
		offset = insn->u.ri.offset / DWARF2_CIE_DATA_ALIGNMENT;
		if (offset < 0) {
			out_one(DW_CFA_offset_extended_sf);
			out_uleb128(regno);
			out_sleb128(offset);
		} else
			if (regno <= 0x3F) {
				out_one(DW_CFA_offset + regno);
				out_uleb128(offset);
			} else {
				out_one(DW_CFA_offset_extended);
				out_uleb128(regno);
				out_uleb128(offset);
			}
		break;

	case DW_CFA_val_offset:
		regno = insn->u.ri.reg;
		offset = insn->u.ri.offset / DWARF2_CIE_DATA_ALIGNMENT;
		if (offset < 0) {
			out_one(DW_CFA_val_offset_sf);
			out_uleb128(regno);
			out_sleb128(offset);
		} else {
			out_one(DW_CFA_val_offset);
			out_uleb128(regno);
			out_uleb128(offset);
		}
		break;

	case DW_CFA_register:
		out_one(DW_CFA_register);
		out_uleb128(insn->u.rr.reg1);
		out_uleb128(insn->u.rr.reg2);
		break;

	case DW_CFA_remember_state:
	case DW_CFA_restore_state:
		out_one(insn->insn);
		break;

	case DW_CFA_GNU_window_save:
		out_one(DW_CFA_GNU_window_save);
		break;

	case CFI_escape:
		{
			struct cfi_escape_data *e;
			for (e = insn->u.esc; e; e = e->next)
				emit_expr(&e->exp,1);
			break;
		}

	case CFI_val_encoded_addr:
		{
			unsigned	encoding = insn->u.ea.encoding;
			offsetT		enc_size;

			if (encoding == DW_EH_PE_omit)
				break;
			out_one(DW_CFA_val_expression);
			out_uleb128(insn->u.ea.reg);

			switch (encoding & 0x7) {
			case DW_EH_PE_absptr:
				enc_size = 8;
		//64 / 8 = 8:	DWARF2_ADDR_SIZE(stdoutput);
				break;
			case DW_EH_PE_udata2:
				enc_size = 2;
				break;
			case DW_EH_PE_udata4:
				enc_size = 4;
				break;
			case DW_EH_PE_udata8:
				enc_size = 8;
				break;
			default:
				abort();
			}

			/*
			 * If the user has requested absolute encoding,then
			 * use the smaller DW_OP_addr encoding.
			 */
			if (insn->u.ea.encoding == DW_EH_PE_absptr) {
				out_uleb128(1 + enc_size);
				out_one(DW_OP_addr);
			} else {
				out_uleb128(1 + 1 + enc_size);
				out_one(DW_OP_GNU_encoded_addr);
				out_one(encoding);

				if ((encoding & 0x70) == DW_EH_PE_pcrel) {
#if CFI_DIFF_EXPR_OK
					insn->u.ea.exp.X_op = O_subtract;
					insn->u.ea.exp.X_op_symbol = symbol_temp_new_now();
#elif defined (tc_cfi_emit_pcrel_expr)
					tc_cfi_emit_pcrel_expr(&insn->u.ea.exp,enc_size);
					break;
#else
					abort();
#endif
				}
			}
			emit_expr(&insn->u.ea.exp,enc_size);
		}
		break;

	case CFI_label:
		colon(insn->u.sym_name);
		break;

	default:
		abort();
	}
}

static void	output_cie(struct cie_entry *cie,bool eh_frame,int align)
{
	symbolS        *after_size_address,*end_address;
	expressionS	exp;
	struct cfi_insn_data *i;
	offsetT		augmentation_size;
	int		enc;
	enum dwarf2_format fmt = DWARF2_FORMAT(now_seg);

	cie->start_address = symbol_temp_new_now();
	after_size_address = symbol_temp_make();
	end_address = symbol_temp_make();

	exp.X_op = O_subtract;
	exp.X_add_symbol = end_address;
	exp.X_op_symbol = after_size_address;
	exp.X_add_number = 0;

	if (eh_frame || fmt == dwarf2_format_32bit)
		emit_expr(&exp,4);	/* Length.  */
	else {
		if (fmt == dwarf2_format_64bit)
			out_four(-1);
		emit_expr(&exp,8);	/* Length.  */
	}
	symbol_set_value_now(after_size_address);
	if (eh_frame)
		out_four(0);	/* CIE id.  */
	else {
		out_four(-1);	/* CIE id.  */
		if (fmt != dwarf2_format_32bit)
			out_four(-1);
	}
	out_one(flag_dwarf_cie_version);	/* Version.  */
	if (eh_frame) {
		out_one('z');	/* Augmentation.  */
		if (cie->per_encoding != DW_EH_PE_omit)
			out_one('P');
		if (cie->lsda_encoding != DW_EH_PE_omit)
			out_one('L');
		out_one('R');
#ifdef tc_output_cie_extra
		tc_output_cie_extra(cie);
#endif
	}
	if (cie->signal_frame)
		out_one('S');
	out_one(0);
	if (flag_dwarf_cie_version >= 4) {
		/*
		 * For now we are assuming a flat address space with 4 or 8
		 * byte addresses.
		 */
		int		address_size = dwarf2_format_32bit ? 4 : 8;
		out_one(address_size);	/* Address size.  */
		out_one(0);	/* Segment size.  */
	}
	out_uleb128(DWARF2_LINE_MIN_INSN_LENGTH);	/* Code alignment.  */
	out_sleb128(DWARF2_CIE_DATA_ALIGNMENT);	/* Data alignment.  */
	if (flag_dwarf_cie_version == 1) {	/* Return column.  */
		if ((cie->return_column & 0xff) != cie->return_column)
			as_bad(("return column number %d overflows in CIE version 1"),
			       cie->return_column);
		out_one(cie->return_column);
	} else
		out_uleb128(cie->return_column);
	if (eh_frame) {
		augmentation_size = 1 + (cie->lsda_encoding != DW_EH_PE_omit);
		if (cie->per_encoding != DW_EH_PE_omit)
			augmentation_size += 1 + encoding_size(cie->per_encoding);
		out_uleb128(augmentation_size);	/* Augmentation size.  */

		emit_expr_encoded(&cie->personality,cie->per_encoding,true);

		if (cie->lsda_encoding != DW_EH_PE_omit)
			out_one(cie->lsda_encoding);
	}
	switch (DWARF2_FDE_RELOC_SIZE) {
	case 2:
		enc = DW_EH_PE_sdata2;
		break;
	case 4:
		enc = DW_EH_PE_sdata4;
		break;
	case 8:
		enc = DW_EH_PE_sdata8;
		break;
	default:
		abort();
	}
#if CFI_DIFF_EXPR_OK || defined tc_cfi_emit_pcrel_expr
	enc |= DW_EH_PE_pcrel;
#endif
#ifdef DWARF2_FDE_RELOC_ENCODING
	/* Allow target to override encoding.  */
	enc = DWARF2_FDE_RELOC_ENCODING(enc);
#endif
	cie->fde_encoding = enc;
	if (eh_frame)
		out_one(enc);

	if (cie->first) {
		for (i = cie->first; i != cie->last; i = i->next) {
			if (CUR_SEG(i) != CUR_SEG(cie))
				continue;
			output_cfi_insn(i);
		}
	}
	frag_align(align,DW_CFA_nop,0);
	symbol_set_value_now(end_address);
}

static void	output_fde(struct fde_entry *fde,struct cie_entry *cie,
	       		bool		eh_frame,struct cfi_insn_data *first,
		       		int		align)
{
	symbolS        *after_size_address,*end_address;
	expressionS	exp;
	offsetT		augmentation_size;
	enum dwarf2_format fmt = DWARF2_FORMAT(now_seg);
	unsigned int	offset_size;
	unsigned int	addr_size;

	after_size_address = symbol_temp_make();
	end_address = symbol_temp_make();

	exp.X_op = O_subtract;
	exp.X_add_symbol = end_address;
	exp.X_op_symbol = after_size_address;
	exp.X_add_number = 0;
	if (eh_frame || fmt == dwarf2_format_32bit)
		offset_size = 4;
	else {
		if (fmt == dwarf2_format_64bit)
			out_four(-1);
		offset_size = 8;
	}
	emit_expr(&exp,offset_size);	/* Length.  */
	symbol_set_value_now(after_size_address);

	if (eh_frame) {
		exp.X_op = O_subtract;
		exp.X_add_symbol = after_size_address;
		exp.X_op_symbol = cie->start_address;
		exp.X_add_number = 0;
		emit_expr(&exp,offset_size);	/* CIE offset.  */
	} else {
		TC_DWARF2_EMIT_OFFSET(cie->start_address,offset_size);
	}

	exp.X_op = O_symbol;
	if (eh_frame) {
		bfd_reloc_code_real_type code
		= tc_cfi_reloc_for_encoding(cie->fde_encoding);
		addr_size = DWARF2_FDE_RELOC_SIZE;
		if (code != BFD_RELOC_NONE) {
			reloc_howto_type *howto = riscv_reloc_type_lookup(stdoutput,code);
			char           *p = frag_more(addr_size);
			gas_assert(addr_size == (unsigned)howto->bitsize / 8);
			md_number_to_chars(p,0,addr_size);
			fix_new(frag_now,p - frag_now->fr_literal,addr_size,
			     fde->start_address,0,howto->pc_relative,code);
		} else {
			exp.X_op = O_subtract;
			exp.X_add_number = 0;
#if CFI_DIFF_EXPR_OK
			exp.X_add_symbol = fde->start_address;
			exp.X_op_symbol = symbol_temp_new_now();
			emit_expr(&exp,addr_size);	/* Code offset.  */
#else
			exp.X_op = O_symbol;
			exp.X_add_symbol = fde->start_address;

#if defined(tc_cfi_emit_pcrel_expr)
			tc_cfi_emit_pcrel_expr(&exp,addr_size);	/* Code offset.  */
#else
			emit_expr(&exp,addr_size);	/* Code offset.  */
#endif
#endif
		}
	} else {
		exp.X_add_number = 0;
		exp.X_add_symbol = fde->start_address;
		addr_size = 8;
//64 / 8 = 8:	DWARF2_ADDR_SIZE(stdoutput);
		emit_expr(&exp,addr_size);
	}

	exp.X_op = O_subtract;
	exp.X_add_symbol = fde->end_address;
	exp.X_op_symbol = fde->start_address;	/* Code length.  */
	exp.X_add_number = 0;
	emit_expr(&exp,addr_size);

	augmentation_size = encoding_size(fde->lsda_encoding);
	if (eh_frame)
		out_uleb128(augmentation_size);	/* Augmentation size.  */

	emit_expr_encoded(&fde->lsda,cie->lsda_encoding,false);

	for (; first; first = first->next)
		if (CUR_SEG(first) == CUR_SEG(fde))
			output_cfi_insn(first);

	frag_align(align,DW_CFA_nop,0);
	symbol_set_value_now(end_address);
}

/*
 * Allow these insns to be put in the initial sequence of a CIE. If J is
 * non-NULL,then compare I and J insns for a match.
 */

static inline	bool
		initial_cie_insn(const struct cfi_insn_data *i,const struct cfi_insn_data *j)
{
	if (j && i->insn != j->insn)
		return false;
	switch (i->insn) {
	case DW_CFA_offset:
	case DW_CFA_def_cfa:
	case DW_CFA_val_offset:
		if (j) {
			if (i->u.ri.reg != j->u.ri.reg)
				return false;
			if (i->u.ri.offset != j->u.ri.offset)
				return false;
		}
		break;

	case DW_CFA_register:
		if (j) {
			if (i->u.rr.reg1 != j->u.rr.reg1)
				return false;
			if (i->u.rr.reg2 != j->u.rr.reg2)
				return false;
		}
		break;

	case DW_CFA_def_cfa_register:
	case DW_CFA_restore:
	case DW_CFA_undefined:
	case DW_CFA_same_value:
		if (j) {
			if (i->u.r != j->u.r)
				return false;
		}
		break;

	case DW_CFA_def_cfa_offset:
		if (j) {
			if (i->u.i != j->u.i)
				return false;
		}
		break;

	default:
		return false;
	}
	return true;
}

static struct cie_entry *
		select_cie_for_fde(struct fde_entry *fde,bool eh_frame,
		     		struct	cfi_insn_data **pfirst,int align)
{
	struct cfi_insn_data *i,*j;
	struct cie_entry *cie;

	for (cie = cie_root; cie; cie = cie->next) {
		if (CUR_SEG(cie) != CUR_SEG(fde))
			continue;
#ifdef tc_cie_fde_equivalent_extra
		if (!tc_cie_fde_equivalent_extra(cie,fde))
			continue;
#endif
		if (cie->return_column != fde->return_column
		    || cie->signal_frame != fde->signal_frame
		    || cie->per_encoding != fde->per_encoding
		    || cie->lsda_encoding != fde->lsda_encoding)
			continue;
		if (cie->per_encoding != DW_EH_PE_omit) {
			if (cie->personality.X_op != fde->personality.X_op
			    || (cie->personality.X_add_number
				!= fde->personality.X_add_number))
				continue;
			switch (cie->personality.X_op) {
			case O_constant:
				if (cie->personality.X_unsigned != fde->personality.X_unsigned)
					continue;
				break;
			case O_symbol:
				if (cie->personality.X_add_symbol
				    != fde->personality.X_add_symbol)
					continue;
				break;
			default:
				abort();
			}
		}
		for (i = cie->first,j = fde->data;
		     i != cie->last && j != NULL;
		     i = i->next,j = j->next) {
			if (!initial_cie_insn(i,j))
				break;
		}

		if (i == cie->last) {
			*pfirst = j;
			return cie;
		}
	}

	cie = XNEW(struct cie_entry);
	cie->next = cie_root;
	cie_root = cie;
	SET_CUR_SEG(cie,CUR_SEG(fde));
	cie->return_column = fde->return_column;
	cie->signal_frame = fde->signal_frame;
	cie->per_encoding = fde->per_encoding;
	cie->lsda_encoding = fde->lsda_encoding;
	cie->personality = fde->personality;
	cie->first = fde->data;
	for (i = cie->first; i; i = i->next)
		if (!initial_cie_insn(i,NULL))
			break;

	cie->last = i;
	*pfirst = i;

	output_cie(cie,eh_frame,align);

	return cie;
}

#define cfi_change_reg_numbers(insn,cseg) do { } while (0)

static void	cfi_finish(void)
{
	struct cie_entry *cie,*cie_next;
	segT		cfi_seg  ,ccseg;
	struct fde_entry *fde;
	struct cfi_insn_data *first;
	int		save_flag_traditional_format,seek_next_seg;

	if (all_fde_data == 0)
		return;

	cfi_sections_set = true;
	if ((all_cfi_sections & CFI_EMIT_eh_frame) != 0
	    || (all_cfi_sections & CFI_EMIT_eh_frame_compact) != 0) {
		/*
		 * Make sure check_eh_frame doesn't do anything with our
		 * output.
		 */
		save_flag_traditional_format = flag_traditional_format;
		flag_traditional_format = 1;

		if (!EH_FRAME_LINKONCE) {
			/* Open .eh_frame section.  */
			cfi_seg = get_cfi_seg(NULL,".eh_frame",
					      (SEC_ALLOC|SEC_LOAD|SEC_DATA
					      |DWARF2_EH_FRAME_READ_ONLY),
					      EH_FRAME_ALIGNMENT);
			(void)cfi_seg;
		}
		do {
			ccseg = NULL;
			seek_next_seg = 0;

			for (cie = cie_root; cie; cie = cie_next) {
				cie_next = cie->next;
				free((void *)cie);
			}
			cie_root = NULL;

			for (fde = all_fde_data; fde; fde = fde->next) {
				if ((fde->sections & CFI_EMIT_eh_frame) == 0
				    && (fde->sections & CFI_EMIT_eh_frame_compact) == 0)
					continue;

				if (EH_FRAME_LINKONCE) {
					if (HANDLED(fde))
						continue;
					if (seek_next_seg && CUR_SEG(fde) != ccseg) {
						seek_next_seg = 2;
						continue;
					}
					if (!seek_next_seg) {
						ccseg = CUR_SEG(fde);
						/* Open .eh_frame section.  */
						cfi_seg = get_cfi_seg(ccseg,".eh_frame",
								      (SEC_ALLOC|SEC_LOAD|SEC_DATA
						|DWARF2_EH_FRAME_READ_ONLY),
							  EH_FRAME_ALIGNMENT);
						(void)cfi_seg;
						seek_next_seg = 1;
					}
					SET_HANDLED(fde,1);
				}
				if (fde->end_address == NULL) {
					as_bad(("open CFI at the end of file; "
					   "missing .cfi_endproc directive"));
					fde->end_address = fde->start_address;
				}
				cie = select_cie_for_fde(fde,true,&first,2);
				fde->eh_loc = symbol_temp_new_now();
				output_fde(fde,cie,true,first,
				  fde->next == NULL ? EH_FRAME_ALIGNMENT : 2);
			}
		}
		while (EH_FRAME_LINKONCE && seek_next_seg == 2);

		if (EH_FRAME_LINKONCE)
			for (fde = all_fde_data; fde; fde = fde->next)
				SET_HANDLED(fde,0);
		flag_traditional_format = save_flag_traditional_format;
	}
	cfi_sections_set = true;
	/*
	 * Generate SFrame section if the user specifies: - the command line
	 * option to gas,or - .sframe in the .cfi_sections directive.
	 */
	if (flag_gen_sframe || (all_cfi_sections & CFI_EMIT_sframe) != 0) {
		if (support_sframe_p()) {
			segT		sframe_seg;
			int		alignment = 3;

			sframe_seg = get_cfi_seg(NULL,".sframe",
					      (SEC_ALLOC|SEC_LOAD|SEC_DATA
					      |DWARF2_EH_FRAME_READ_ONLY),
						 alignment);
			output_sframe(sframe_seg);
		} else
			as_bad((".sframe not supported for target"));
	}
	cfi_sections_set = true;
	if ((all_cfi_sections & CFI_EMIT_debug_frame) != 0) {
		//int		alignment = ffs(DWARF2_ADDR_SIZE(stdoutput)) - 1;
		int		alignment = 3;

		get_cfi_seg(NULL,".debug_frame",
			    SEC_READONLY|SEC_DEBUGGING,
			    alignment);

		ccseg = NULL;
		seek_next_seg = 0;

		for (cie = cie_root; cie; cie = cie_next) {
			cie_next = cie->next;
			free((void *)cie);
		}
		cie_root = NULL;

		for (fde = all_fde_data; fde; fde = fde->next) {
			if ((fde->sections & CFI_EMIT_debug_frame) == 0)
				continue;

			if (fde->end_address == NULL) {
				as_bad(("open CFI at the end of file; "
				   "missing .cfi_endproc directive"));
				fde->end_address = fde->start_address;
			}
			fde->per_encoding = DW_EH_PE_omit;
			fde->lsda_encoding = DW_EH_PE_omit;
		//disabled:	cfi_change_reg_numbers(fde->data,ccseg);
			cie = select_cie_for_fde(fde,false,&first,alignment);
			output_fde(fde,cie,false,first,alignment);
		}

	}
	if (dwcfi_hash)
		htab_delete(dwcfi_hash);
}
/* =======================================================** dwarf2dbg.c */
/*
 * dwarf2dbg.c - DWARF2 debug support Logical line numbers can be controlled by
 * the compiler via the following directives:
 * 
 * .file FILENO "file.c" .loc  FILENO LINENO [COLUMN] [basic_block] [prologue_end]
 * \ [epilogue_begin] [is_stmt VALUE] [isa VALUE] \ [discriminator VALUE] [view
 * VALUE]
 */

#ifndef DWARF2_FORMAT
#define DWARF2_FORMAT(SEC) dwarf2_format_32bit
#endif

#ifndef DWARF2_FILE_NAME
#define DWARF2_FILE_NAME(FILENAME,DIRNAME) FILENAME
#endif

#ifndef DWARF2_FILE_TIME_NAME
#define DWARF2_FILE_TIME_NAME(FILENAME,DIRNAME) -1
#endif

#ifndef DWARF2_FILE_SIZE_NAME
#define DWARF2_FILE_SIZE_NAME(FILENAME,DIRNAME) -1
#endif

#ifndef DWARF2_VERSION
#define DWARF2_VERSION dwarf_level
#endif

/* The .debug_aranges version has been 2 in DWARF version 2,3 and 4. */
#ifndef DWARF2_ARANGES_VERSION
#define DWARF2_ARANGES_VERSION 2
#endif

/* The .debug_line version is the same as the .debug_info version.  */
#ifndef DWARF2_LINE_VERSION
#define DWARF2_LINE_VERSION DWARF2_VERSION
#endif

/* The .debug_rnglists has only been in DWARF version 5. */
#ifndef DWARF2_RNGLISTS_VERSION
#define DWARF2_RNGLISTS_VERSION 5
#endif



/*
 * Since we can't generate the prolog until the body is complete,we use three
 * different subsegments for .debug_line: one holding the prolog,one for the
 * directory and filename info,and one for the body ("statement program").
 */
#define DL_PROLOG	0
#define DL_FILES	1
#define DL_BODY		2

/*
 * First special line opcode - leave room for the standard opcodes. Note: If
 * you want to change this,you'll have to update the "standard_opcode_lengths"
 * table that is emitted below in out_debug_line().
 */
#define DWARF2_LINE_OPCODE_BASE		(DWARF2_LINE_VERSION == 2 ? 10 : 13)

#ifndef DWARF2_LINE_BASE
/*
 * Minimum line offset in a special line info. opcode.  This value was chosen
 * to give a reasonable range of values.
 */
#define DWARF2_LINE_BASE		-5
#endif

/* Range of line offsets in a special line info. opcode.  */
#ifndef DWARF2_LINE_RANGE
#define DWARF2_LINE_RANGE		14
#endif

#ifndef DWARF2_LINE_MIN_INSN_LENGTH
/*
 * Define the architecture-dependent minimum instruction length (in bytes).
 * This value should be rather too small than too big.
 */
#define DWARF2_LINE_MIN_INSN_LENGTH	1
#endif

/* Flag that indicates the initial value of the is_stmt_start flag.  */
#define	DWARF2_LINE_DEFAULT_IS_STMT	1

#ifndef DWARF2_LINE_MAX_OPS_PER_INSN
#define DWARF2_LINE_MAX_OPS_PER_INSN	1
#endif

/* Given a special op,return the line skip amount.  */
#define SPECIAL_LINE(op) \
	(((op) - DWARF2_LINE_OPCODE_BASE)%DWARF2_LINE_RANGE + DWARF2_LINE_BASE)

/*
 * Given a special op,return the address skip amount (in units of
 * DWARF2_LINE_MIN_INSN_LENGTH.
 */
#define SPECIAL_ADDR(op) (((op) - DWARF2_LINE_OPCODE_BASE)/DWARF2_LINE_RANGE)

/* The maximum address skip amount that can be encoded with a special op.  */
#define MAX_SPECIAL_ADDR_DELTA		SPECIAL_ADDR(255)

#ifndef TC_PARSE_CONS_RETURN_NONE
#define TC_PARSE_CONS_RETURN_NONE BFD_RELOC_NONE
#endif

#define GAS_ABBREV_COMP_UNIT 1
#define GAS_ABBREV_SUBPROG   2
#define GAS_ABBREV_NO_TYPE   3

struct line_entry {
	struct line_entry *next;
	symbolS        *label;
	struct dwarf2_line_info loc;
};

/*
 * Don't change the offset of next in line_entry.  set_or_check_view calls in
 * dwarf2_gen_line_info_1 depend on it.
 */
static char	unused[offsetof(struct line_entry,next)? -1 : 1] ATTRIBUTE_UNUSED;

	struct line_subseg {
		struct line_subseg *next;
		subsegT		subseg;
		struct line_entry *head;
		struct line_entry **ptail;
		struct line_entry **pmove_tail;
	};

	struct line_seg {
		struct line_seg *next;
		segT		seg;
		struct line_subseg *head;
		symbolS        *text_start;
		symbolS        *text_end;
	};

/* Collects data for all line table entries during assembly.  */
	static struct line_seg *all_segs;
	static struct line_seg **last_seg_ptr;

#define NUM_MD5_BYTES       16

	struct file_entry {
		const char     *filename;
		unsigned int	dir;
		unsigned char	md5[NUM_MD5_BYTES];
	};

/* Table of files used by .debug_line.  */
	static struct file_entry *files;
	static unsigned int files_in_use;
	static unsigned int files_allocated;

/* Table of directories used by .debug_line.  */
	static char   **dirs;
	static unsigned int dirs_in_use;
	static unsigned int dirs_allocated;

/*
 * TRUE when we've seen a .loc directive recently.  Used to avoid doing work
 * when there's nothing to do.  Will be reset by dwarf2_consume_line_info.
 */
	static bool	dwarf2_loc_directive_seen;

/*
 * TRUE when we've seen any .loc directive at any time during parsing.
 * Indicates the user wants us to generate a .debug_line section. Used in
 * dwarf2_finish as sanity check.
 */
	static bool	dwarf2_any_loc_directive_seen;

/*
 * TRUE when we're supposed to set the basic block mark whenever a label is
 * seen.
 */
	static bool	dwarf2_loc_mark_labels;

/* Current location as indicated by the most recent .loc directive.  */
	static struct dwarf2_line_info current;

/*
 * This symbol is used to recognize view number forced resets in loc lists.
 */
	static symbolS *force_reset_view;

/*
 * This symbol evaluates to an expression that,if nonzero,indicates some view
 * assert check failed.
 */
	static symbolS *view_assert_failed;

/* The size of an address on the target.  */
	static unsigned int sizeof_address;

/* Find or create (if CREATE_P) an entry for SEG+SUBSEG in ALL_SEGS.  */

	static struct line_subseg *get_line_subseg(segT seg,subsegT subseg,bool create_p)
{
	struct line_seg *s = seg_info(seg)->dwarf2_line_seg;
	struct line_subseg **pss,*lss;

	if (s == NULL) {
		if (!create_p)
			return NULL;

		s = XNEW(struct line_seg);
		s->next = NULL;
		s->seg = seg;
		s->head = NULL;
		*last_seg_ptr = s;
		last_seg_ptr = &s->next;
		seg_info(seg)->dwarf2_line_seg = s;
	}
	gas_assert(seg == s->seg);

	for (pss = &s->head; (lss = *pss) != NULL; pss = &lss->next) {
		if (lss->subseg == subseg)
			goto found_subseg;
		if (lss->subseg > subseg)
			break;
	}

	lss = XNEW(struct line_subseg);
	lss->next = *pss;
	lss->subseg = subseg;
	lss->head = NULL;
	lss->ptail = &lss->head;
	lss->pmove_tail = &lss->head;
	*pss = lss;

found_subseg:
	return lss;
}

/* (Un)reverse the line_entry list starting from H.  */
static struct line_entry *reverse_line_entry_list(struct line_entry *h)
{
	struct line_entry *p = NULL,*e,*n;

	for (e = h; e; e = n) {
		n = e->next;
		e->next = p;
		p = e;
	}
	return p;
}

/*
 * Compute the view for E based on the previous entry P.  If we introduce an
 * (undefined) view symbol for P,and H is given (P must be the tail in this
 * case),introduce view symbols for earlier list entries as well,until one of
 * them is constant.
 */
static void	set_or_check_view(struct line_entry *e,struct line_entry *p,
			      		struct	line_entry *h)
{
	expressionS	viewx;

	memset(&viewx,0,sizeof(viewx));
	viewx.X_unsigned = 1;

	/*
	 * First,compute !(E->label > P->label),to tell whether or not we're
	 * to reset the view number.  If we can't resolve it to a constant,
	 * keep it symbolic.
	 */
	if (!p || (e->loc.u.view == force_reset_view && force_reset_view)) {
		viewx.X_op = O_constant;
		viewx.X_add_number = 0;
		viewx.X_add_symbol = NULL;
		viewx.X_op_symbol = NULL;
	} else {
		viewx.X_op = O_gt;
		viewx.X_add_number = 0;
		viewx.X_add_symbol = e->label;
		viewx.X_op_symbol = p->label;
		resolve_expression(&viewx);
		if (viewx.X_op == O_constant)
			viewx.X_add_number = !viewx.X_add_number;
		else {
			viewx.X_add_symbol = make_expr_symbol(&viewx);
			viewx.X_add_number = 0;
			viewx.X_op_symbol = NULL;
			viewx.X_op = O_logical_not;
		}
	}

	if (S_IS_DEFINED(e->loc.u.view) && symbol_constant_p(e->loc.u.view)) {
		expressionS    *value = symbol_get_value_expression(e->loc.u.view);
		/*
		 * We can't compare the view numbers at this point,because in
		 * VIEWX we've only determined whether we're to reset it so
		 * far.
		 */
		if (viewx.X_op == O_constant) {
			if (!value->X_add_number != !viewx.X_add_number)
				as_bad(("view number mismatch"));
		}
		/*
		 * Record the expression to check it later.  It is the result
		 * of a logical not,thus 0 or 1.  We just add up all such
		 * deferred expressions,and resolve it at the end.
		 */
		else
			if (!value->X_add_number) {
				symbolS        *deferred = make_expr_symbol(&viewx);
				if (view_assert_failed) {
					expressionS	chk;

					memset(&chk,0,sizeof(chk));
					chk.X_unsigned = 1;
					chk.X_op = O_add;
					chk.X_add_number = 0;
					chk.X_add_symbol = view_assert_failed;
					chk.X_op_symbol = deferred;
					deferred = make_expr_symbol(&chk);
				}
				view_assert_failed = deferred;
			}
	}
	if (viewx.X_op != O_constant || viewx.X_add_number) {
		expressionS	incv;
		expressionS    *p_view;

		if (!p->loc.u.view)
			p->loc.u.view = symbol_temp_make();

		memset(&incv,0,sizeof(incv));
		incv.X_unsigned = 1;
		incv.X_op = O_symbol;
		incv.X_add_symbol = p->loc.u.view;
		incv.X_add_number = 1;
		p_view = symbol_get_value_expression(p->loc.u.view);
		if (p_view->X_op == O_constant || p_view->X_op == O_symbol) {
			/*
			 * If we can,constant fold increments so that a chain
			 * of expressions v + 1 + 1 ... + 1 is not created.
			 * resolve_expression isn't ideal for this purpose.
			 * The base v might not be resolvable until later.
			 */
			incv.X_op = p_view->X_op;
			incv.X_add_symbol = p_view->X_add_symbol;
			incv.X_add_number = p_view->X_add_number + 1;
		}
		if (viewx.X_op == O_constant) {
			gas_assert(viewx.X_add_number == 1);
			viewx = incv;
		} else {
			viewx.X_add_symbol = make_expr_symbol(&viewx);
			viewx.X_add_number = 0;
			viewx.X_op_symbol = make_expr_symbol(&incv);
			viewx.X_op = O_multiply;
		}
	}
	if (!S_IS_DEFINED(e->loc.u.view)) {
		symbol_set_value_expression(e->loc.u.view,&viewx);
		S_SET_SEGMENT(e->loc.u.view,expr_section);
		symbol_set_frag(e->loc.u.view,&zero_address_frag);
	}
	/*
	 * Define and attempt to simplify any earlier views needed to compute
	 * E's.
	 */
	if (h && p && p->loc.u.view && !S_IS_DEFINED(p->loc.u.view)) {
		struct line_entry *h2;
		/*
		 * Reverse the list to avoid quadratic behavior going backwards
		 * in a single-linked list.
		 */
		struct line_entry *r = reverse_line_entry_list(h);

		gas_assert(r == p);
		/* Set or check views until we find a defined or absent view.  */
		do {
			/*
			 * Do not define the head of a (sub?)segment view while
			 * handling others.  It would be defined too early,
			 * without regard to the last view of other
			 * subsegments. set_or_check_view will be called for
			 * every head segment that needs it.
			 */
			if (r == h)
				break;
			set_or_check_view(r,r->next,NULL);
		}
		while (r->next
		       && r->next->loc.u.view
		       && !S_IS_DEFINED(r->next->loc.u.view)
		       && (r = r->next));

		/* Unreverse the list,so that we can go forward again.  */
		h2 = reverse_line_entry_list(p);
		gas_assert(h2 == h);

		/*
		 * Starting from the last view we just defined,attempt to
		 * simplify the view expressions,until we do so to P.
		 */
		do {
			/*
			 * The head view of a subsegment may remain undefined
			 * while handling other elements,before it is linked
			 * to the last view of the previous subsegment.
			 */
			if (r == h)
				continue;
			gas_assert(S_IS_DEFINED(r->loc.u.view));
			resolve_expression(symbol_get_value_expression(r->loc.u.view));
		}
		while (r != p && (r = r->next));

		/*
		 * Now that we've defined and computed all earlier views that
		 * might be needed to compute E's,attempt to simplify it.
		 */
		resolve_expression(symbol_get_value_expression(e->loc.u.view));
	}
}

/* Record an entry for LOC occurring at LABEL.  */
static void	dwarf2_gen_line_info_1(symbolS * label,struct dwarf2_line_info *loc)
{
	struct line_subseg *lss;
	struct line_entry *e;
	uint32_t	need_flags = SEC_LOAD|SEC_CODE;

	/*
	 * PR 26850: Do not record LOCs in non-executable or non-loaded
	 * sections.  SEC_ALLOC isn't tested for non-ELF because obj-coff.c
	 * obj_coff_section is careless in setting SEC_ALLOC.
	 */
	if (IS_ELF)
		need_flags |= SEC_ALLOC;
	if ((now_seg->flags & need_flags) != need_flags) {
		/* FIXME: Add code to suppress multiple warnings ?  */
		if (debug_type != DEBUG_DWARF2)
			as_warn("dwarf line number information for %s ignored",
				segment_name(now_seg));
		return;
	}
	e = XNEW(struct line_entry);
	e->next = NULL;
	e->label = label;
	e->loc = *loc;

	lss = get_line_subseg(now_seg,now_subseg,true);

	/*
	 * Subseg heads are chained to previous subsegs in dwarf2_finish.
	 */
	if (loc->filenum != -1u && loc->u.view && lss->head)
		set_or_check_view(e,(struct line_entry *)lss->ptail,lss->head);

	*lss->ptail = e;
	lss->ptail = &e->next;
}

/* Record an entry for LOC occurring at OFS within the current fragment.  */
static unsigned int dw2_line;
static const char *dw2_filename;
static int	label_num;

static void	dwarf2_gen_line_info(addressT ofs,struct dwarf2_line_info *loc)
{
	symbolS        *sym;

	/* Early out for as-yet incomplete location information.  */
	if (loc->line == 0)
		return;
	if (loc->filenum == 0) {
		if (dwarf_level < 5)
			dwarf_level = 5;
		if (DWARF2_LINE_VERSION < 5)
			return;
	}
	/*
	 * Don't emit sequences of line symbols for the same line when the
	 * symbols apply to assembler code.  It is necessary to emit duplicate
	 * line symbols when a compiler asks for them,because GDB uses them to
	 * determine the end of the prologue.
	 */
	if (debug_type == DEBUG_DWARF2) {
		if (dw2_line == loc->line) {
			if (dw2_filename == loc->u.filename)
				return;
			if (filename_cmp(dw2_filename,loc->u.filename) == 0) {
				dw2_filename = loc->u.filename;
				return;
			}
		}
		dw2_line = loc->line;
		dw2_filename = loc->u.filename;
	}
	if (linkrelax) {
		char		name      [32];

		/*
		 * Use a non-fake name for the line number location,so that it
		 * can be referred to by relocations.
		 */
		sprintf(name,".Loc.%u",label_num);
		label_num++;
		sym = symbol_new(name,now_seg,frag_now,ofs);
	} else
		sym = symbol_temp_new(now_seg,frag_now,ofs);
	dwarf2_gen_line_info_1(sym,loc);
}

static const char *get_basename(const char *pathname)
{
	const char     *file;

	file = lbasename(pathname);
	/* Don't make empty string from / or A: from A:/ .  */
	if (file == pathname + 1)
		file = pathname;
	return file;
}

static unsigned int get_directory_table_entry(const char *dirname,
			       		const		char  *file0_dirname,
					      		size_t	dirlen,
				       		bool		can_use_zero)
{
	unsigned int	d;

	if (dirlen == 0)
		return 0;

#ifndef DWARF2_DIR_SHOULD_END_WITH_SEPARATOR
	if (IS_DIR_SEPARATOR(dirname[dirlen - 1])) {
		--dirlen;
		if (dirlen == 0)
			return 0;
	}
#endif

	for (d = 0; d < dirs_in_use; ++d) {
		if (dirs[d] != NULL
		    && filename_ncmp(dirname,dirs[d],dirlen) == 0
		    && dirs[d][dirlen] == '\0')
			return d;
	}

	if (can_use_zero) {
		if (dirs == NULL || dirs[0] == NULL) {
			const char     *pwd = file0_dirname ? file0_dirname : getpwd();

			if (dwarf_level >= 5 && filename_cmp(dirname,pwd) != 0) {
				/*
				 * In DWARF-5 the 0 entry in the directory
				 * table is expected to be the same as the
				 * DW_AT_comp_dir (which is set to the current
				 * build directory).  Since we are about to
				 * create a directory entry that is not the
				 * same,allocate the current directory first.
				 */
				(void)get_directory_table_entry(pwd,file0_dirname,
							   strlen(pwd),true);
				d = 1;
			} else
				d = 0;
		}
	} else
		if (d == 0)
			d = 1;

	if (d >= dirs_allocated) {
		unsigned int	old = dirs_allocated;
#define DIR_TABLE_INCREMENT 32
		dirs_allocated = d + DIR_TABLE_INCREMENT;
		dirs = XRESIZEVEC(char *,dirs,dirs_allocated);
		memset(dirs + old,0,(dirs_allocated - old) * sizeof(char *));
	}
	dirs[d] = xmemdup0(dirname,dirlen);
	if (dirs_in_use <= d)
		dirs_in_use = d + 1;

	return d;
}

static bool	assign_file_to_slot(unsigned int i,const char *file,unsigned int dir)
{
	if (i >= files_allocated) {
		unsigned int	want = i + 32;

		/* Catch wraparound.  */
		if (want < files_allocated
		    || want < i
		    || want > UINT_MAX / sizeof(struct file_entry)) {
			as_bad(("file number %u is too big"),i);
			return false;
		}
		files = XRESIZEVEC(struct file_entry,files,want);
		memset(files + files_allocated,0,
		       (want - files_allocated) * sizeof(struct file_entry));
		files_allocated = want;
	}
	files[i].filename = file;
	files[i].dir = dir;
	memset(files[i].md5,0,NUM_MD5_BYTES);

	if (files_in_use < i + 1)
		files_in_use = i + 1;

	return true;
}

/*
 * Get a .debug_line file number for PATHNAME.  If there is a directory
 * component to PATHNAME,then this will be stored in the directory table,if
 * it is not already present. Returns the slot number allocated to that
 * filename or -1 if there was a problem.
 */
static int	last_used, last_used_dir_len;
static int	allocate_filenum(const char *pathname)
{
	const char     *file;
	size_t		dir_len;
	unsigned int	i ,dir;

	/*
	 * Short circuit the common case of adding the same pathname as last
	 * time.
	 */
	if (last_used != -1) {
		const char     *dirname = NULL;

		if (dirs != NULL)
			dirname = dirs[files[last_used].dir];

		if (dirname == NULL) {
			if (filename_cmp(pathname,files[last_used].filename) == 0)
				return last_used;
		} else {
			if (filename_ncmp(pathname,dirname,last_used_dir_len - 1) == 0
			  && IS_DIR_SEPARATOR(pathname[last_used_dir_len - 1])
			    && filename_cmp(pathname + last_used_dir_len,
					    files[last_used].filename) == 0)
				return last_used;
		}
	}
	file = get_basename(pathname);
	dir_len = file - pathname;

	dir = get_directory_table_entry(pathname,NULL,dir_len,false);

	/* Do not use slot-0.  That is specifically reserved for use by the
	 * '.file 0 "name"' directive.  */
	for (i = 1; i < files_in_use; ++i)
		if (files[i].dir == dir
		    && files[i].filename
		    && filename_cmp(file,files[i].filename) == 0) {
			last_used = i;
			last_used_dir_len = dir_len;
			return i;
		}
	if (!assign_file_to_slot(i,file,dir))
		return -1;
	last_used = i;
	last_used_dir_len = dir_len;
	return i;
}

/* Run through the list of line entries starting at E,allocating file entries
 * for gas generated debug.  */
static void	do_allocate_filenum(struct line_entry *e)
{
	do {
		if (e->loc.filenum == -1u) {
			e->loc.filenum = allocate_filenum(e->loc.u.filename);
			e->loc.u.view = NULL;
		}
		e = e->next;
	}
	while (e);
}

/* Remove any generated line entries.  These don't live comfortably with
 * compiler generated line info.  If THELOT then remove everything,freeing all
 * list entries we have created.  */
static void	purge_generated_debug(bool thelot)
{
	struct line_seg *s,*nexts;

	for (s = all_segs; s; s = nexts) {
		struct line_subseg *lss,*nextlss;

		for (lss = s->head; lss; lss = nextlss) {
			struct line_entry *e,*next;

			for (e = lss->head; e; e = next) {
				if (!thelot)
					know(e->loc.filenum == -1u);
				next = e->next;
				free(e);
			}

			lss->head = NULL;
			lss->ptail = &lss->head;
			lss->pmove_tail = &lss->head;
			nextlss = lss->next;
			if (thelot)
				free(lss);
		}
		nexts = s->next;
		if (thelot) {
			seg_info(s->seg)->dwarf2_line_seg = NULL;
			free(s);
		}
	}
}

/* Allocate slot NUM in the .debug_line file table to FILENAME. If DIRNAME is
 * not NULL or there is a directory component to FILENAME then this will be
 * stored in the directory table,if not already present. if WITH_MD5 is TRUE
 * then there is a md5 value in generic_bignum. Returns TRUE if allocation
 * succeeded,FALSE otherwise.  */
static bool	allocate_filename_to_slot(const char *dirname,
				    		const		char  *filename,
				      		unsigned	int	num,
				      		bool		with_md5)
{
	const char     *file;
	size_t		dirlen;
	unsigned int	i ,d;
	const char     *file0_dirname;

	/*
	 * Short circuit the common case of adding the same pathname as last
	 * time.
	 */
	if (num < files_allocated && files[num].filename != NULL) {
		const char     *dir = NULL;

		if (dirs != NULL)
			dir = dirs[files[num].dir];

		if (with_md5
		&& memcmp(generic_bignum,files[num].md5,NUM_MD5_BYTES) != 0)
			goto fail;

		if (dirname != NULL) {
			if (dir != NULL && filename_cmp(dir,dirname) != 0)
				goto fail;

			if (filename_cmp(filename,files[num].filename) != 0)
				goto fail;

			/*
			 * If the filenames match,but the directory table
			 * entry was empty,then fill it with the provided
			 * directory name.
			 */
			if (dir == NULL) {
				if (dirs == NULL) {
					dirs_allocated = files[num].dir + DIR_TABLE_INCREMENT;
					dirs = XCNEWVEC(char *,dirs_allocated);
				}
				dirs[files[num].dir] = xmemdup0(dirname,strlen(dirname));
			}
			return true;
		} else
			if (dir != NULL) {
				dirlen = strlen(dir);
				if (filename_ncmp(filename,dir,dirlen) == 0
				    && IS_DIR_SEPARATOR(filename[dirlen])
				    && filename_cmp(filename + dirlen + 1,files[num].filename) == 0)
					return true;
			} else {/* dir == NULL  */
				file = get_basename(filename);
				if (filename_cmp(file,files[num].filename) == 0) {
					/*
					 * The filenames match,but the
					 * directory table entry is empty. Fill
					 * it with the provided directory name.
					 */
					if (file > filename) {
						if (dirs == NULL) {
							dirs_allocated = files[num].dir + DIR_TABLE_INCREMENT;
							dirs = XCNEWVEC(char *,dirs_allocated);
						}
						dirs[files[num].dir] = xmemdup0(filename,file - filename);
					}
					return true;
				}
			}

fail:
		as_bad("file table slot %u is already occupied by a different file (%s%s%s vs %s%s%s)",
		       num,
		       dir == NULL ? "" : dir,
		       dir == NULL ? "" : "/",
		       files[num].filename,
		       dirname == NULL ? "" : dirname,
		       dirname == NULL ? "" : "/",
		       filename);
		return false;
	}
	/*
	 * For file .0,the directory name is the current directory and the
	 * file may be in another directory contained in the file name.
	 */
	if (num == 0) {
		file0_dirname = dirname;

		file = get_basename(filename);

		if (dirname && file == filename)
			dirlen = strlen(dirname);
		else {
			dirname = filename;
			dirlen = file - filename;
		}
	} else {
		file0_dirname = NULL;

		if (dirname == NULL) {
			dirname = filename;
			file = get_basename(filename);
			dirlen = file - filename;
		} else {
			dirlen = strlen(dirname);
			file = filename;
		}
	}

	d = get_directory_table_entry(dirname,file0_dirname,dirlen,num == 0);
	i = num;

	if (!assign_file_to_slot(i,file,d))
		return false;

	if (with_md5) {
		if (target_big_endian) {
			/* md5's are stored in litte endian format.  */
			unsigned int	bits_remaining = NUM_MD5_BYTES * BITS_PER_CHAR;
			unsigned int	byte = NUM_MD5_BYTES;
			unsigned int	bignum_index = 0;

			while (bits_remaining) {
				unsigned int	bignum_bits_remaining = LITTLENUM_NUMBER_OF_BITS;
				valueT		bignum_value = generic_bignum[bignum_index];
				bignum_index++;

				while (bignum_bits_remaining) {
					files[i].md5[--byte] = bignum_value & 0xff;
					bignum_value >>= 8;
					bignum_bits_remaining -= 8;
					bits_remaining -= 8;
				}
			}
		} else {
			unsigned int	bits_remaining = NUM_MD5_BYTES * BITS_PER_CHAR;
			unsigned int	byte = 0;
			unsigned int	bignum_index = 0;

			while (bits_remaining) {
				unsigned int	bignum_bits_remaining = LITTLENUM_NUMBER_OF_BITS;
				valueT		bignum_value = generic_bignum[bignum_index];

				bignum_index++;

				while (bignum_bits_remaining) {
					files[i].md5[byte++] = bignum_value & 0xff;
					bignum_value >>= 8;
					bignum_bits_remaining -= 8;
					bits_remaining -= 8;
				}
			}
		}
	} else
		memset(files[i].md5,0,NUM_MD5_BYTES);

	return true;
}

/* Returns the current source information.  If .file directives have been
 * encountered,the info for the corresponding source file is returned.
 * Otherwise,the info for the assembly source file is returned.  */
static void	dwarf2_where(struct dwarf2_line_info *line)
{
	if (debug_type == DEBUG_DWARF2) {
		line->u.filename = as_where(&line->line);
		line->filenum = -1u;
		line->column = 0;
		line->flags = DWARF2_FLAG_IS_STMT;
		line->isa = current.isa;
		line->discriminator = current.discriminator;
	} else
		*line = current;
}

/* Called for each machine instruction,or relatively atomic group of machine
 * instructions (ie built-in macro).  The instruction or group is SIZE bytes in
 * length.  If dwarf2 line number generation is called for,emit a line
 * statement appropriately.  */
static void	dwarf2_emit_insn(int size)
{
	struct dwarf2_line_info loc;

	if (debug_type != DEBUG_DWARF2
	    ? !dwarf2_loc_directive_seen
	    : !seen_at_least_1_file())
		return;

	dwarf2_where(&loc);

	dwarf2_gen_line_info((frag_now_fix_octets() - size) / OCTETS_PER_BYTE,&loc);
	dwarf2_consume_line_info();
}

/* Called after the current line information has been either used with
 * dwarf2_gen_line_info or saved with a machine instruction for later use. This
 * resets the state of the line number information to reflect that it has been
 * used.  */
static void	dwarf2_consume_line_info(void)
{
	/*
	 * Unless we generate DWARF2 debugging information for each assembler
	 * line,we only emit one line symbol for one LOC.
	 */
	dwarf2_loc_directive_seen = false;

	current.flags &= ~(DWARF2_FLAG_BASIC_BLOCK
			  |DWARF2_FLAG_PROLOGUE_END
			  |DWARF2_FLAG_EPILOGUE_BEGIN);
	current.discriminator = 0;
	current.u.view = NULL;
}

/* Called for each (preferably code) label.  If dwarf2_loc_mark_labels is
 * enabled,emit a basic block marker.  */
static void	dwarf2_emit_label(symbolS * label)
{
	struct dwarf2_line_info loc;

	if (!dwarf2_loc_mark_labels)
		return;
	if (S_GET_SEGMENT(label) != now_seg)
		return;
	if (!(now_seg->flags & SEC_CODE))
		return;
	if (files_in_use == 0 && debug_type != DEBUG_DWARF2)
		return;

	dwarf2_where(&loc);

	loc.flags |= DWARF2_FLAG_BASIC_BLOCK;

	dwarf2_gen_line_info_1(label,&loc);
	dwarf2_consume_line_info();
}

/* Handle two forms of .file directive: - Pass .file "source.c" to s_file -
 * Handle .file 1 "source.c" by adding an entry to the DWARF-2 file table
 * 
 * If an entry is added to the file table,return a pointer to the filename.  */
static char    *dwarf2_directive_filename(void)
{
	bool		with_md5 = false;
	valueT		num;
	char           *filename;
	const char     *dirname = NULL;
	int		filename_len;

	/* Continue to accept a bare string and pass it off.  */
	SKIP_WHITESPACE();
	if (*input_line_pointer == '"') {
		s_file(0);
		return NULL;
	}
	num = get_absolute_expression();

	if ((offsetT) num < 1) {
		if (num == 0 && dwarf_level < 5)
			dwarf_level = 5;
		if ((offsetT) num < 0 || DWARF2_LINE_VERSION < 5) {
			as_bad(("file number less than one"));
			ignore_rest_of_line();
			return NULL;
		}
	}
	/*
	 * FIXME: Should we allow ".file <N>\n" as an expression meaning
	 * "switch back to the already allocated file <N> as the current file"
	 * ?
	 */

	filename = demand_copy_C_string(&filename_len);
	if (filename == NULL)
		/*
		 * demand_copy_C_string will have already generated an error
		 * message.
		 */
		return NULL;

	/*
	 * For DWARF-5 support we also accept: .file <NUM> ["<dir>"] "<file>"
	 * [md5 <NUM>]
	 */
	if (DWARF2_LINE_VERSION > 4) {
		SKIP_WHITESPACE();
		if (*input_line_pointer == '"') {
			dirname = filename;
			filename = demand_copy_C_string(&filename_len);
			if (filename == NULL)
				return NULL;
			SKIP_WHITESPACE();
		}
		if (startswith(input_line_pointer,"md5")) {
			input_line_pointer += 3;
			SKIP_WHITESPACE();

			expressionS	exp;
			expression_and_evaluate(&exp);
			if (exp.X_op != O_big)
				as_bad(("md5 value too small or not a constant"));
			else
				with_md5 = true;
		}
	}
	demand_empty_rest_of_line();

	/*
	 * A .file directive implies compiler generated debug information is
	 * being supplied.  Turn off gas generated debug info.
	 */
	if (debug_type == DEBUG_DWARF2)
		purge_generated_debug(false);
	debug_type = DEBUG_NONE;

	if (num != (unsigned int)num
	    || num >= (size_t) - 1 / sizeof(struct file_entry) - 32) {
		as_bad(("file number %lu is too big"),(unsigned long)num);
		return NULL;
	}
	if (!allocate_filename_to_slot(dirname,filename,(unsigned int)num,
				       with_md5))
		return NULL;

	return filename;
}

/* Calls dwarf2_directive_filename,but discards its result. Used in pseudo-op
 * tables where the function result is ignored.  */
static void	dwarf2_directive_file(int dummy ATTRIBUTE_UNUSED)
{
	(void)dwarf2_directive_filename();
}

static void	dwarf2_directive_loc(int dummy ATTRIBUTE_UNUSED)
{
	offsetT		filenum,line;

	/*
	 * If we see two .loc directives in a row,force the first one to be
	 * output now.
	 */
	if (dwarf2_loc_directive_seen)
		dwarf2_emit_insn(0);

	filenum = get_absolute_expression();
	SKIP_WHITESPACE();
	line = get_absolute_expression();

	if (filenum < 1) {
		if (filenum == 0 && dwarf_level < 5)
			dwarf_level = 5;
		if (filenum < 0 || DWARF2_LINE_VERSION < 5) {
			as_bad(("file number less than one"));
			return;
		}
	}
	if ((valueT) filenum >= files_in_use || files[filenum].filename == NULL) {
		as_bad(("unassigned file number %ld"),(long)filenum);
		return;
	}
	/*
	 * debug_type will be turned off by dwarf2_directive_filename,and if
	 * we don't have a dwarf style .file then files_in_use will be zero and
	 * the above error will trigger.
	 */
	gas_assert(debug_type == DEBUG_NONE);

	current.filenum = filenum;
	current.line = line;
	current.discriminator = 0;

	SKIP_WHITESPACE();
	if (ISDIGIT(*input_line_pointer)) {
		current.column = get_absolute_expression();
		SKIP_WHITESPACE();
	}
	while (ISALPHA(*input_line_pointer)) {
		char           *p,c;
		offsetT		value;

		c = get_symbol_name(&p);

		if (strcmp(p,"basic_block") == 0) {
			current.flags |= DWARF2_FLAG_BASIC_BLOCK;
			*input_line_pointer = c;
		} else
			if (strcmp(p,"prologue_end") == 0) {
				if (dwarf_level < 3)
					dwarf_level = 3;
				current.flags |= DWARF2_FLAG_PROLOGUE_END;
				*input_line_pointer = c;
			} else
				if (strcmp(p,"epilogue_begin") == 0) {
					if (dwarf_level < 3)
						dwarf_level = 3;
					current.flags |= DWARF2_FLAG_EPILOGUE_BEGIN;
					*input_line_pointer = c;
				} else
					if (strcmp(p,"is_stmt") == 0) {
						(void)restore_line_pointer(c);
						value = get_absolute_expression();
						if (value == 0)
							current.flags &= ~DWARF2_FLAG_IS_STMT;
						else
							if (value == 1)
								current.flags |= DWARF2_FLAG_IS_STMT;
							else {
								as_bad(("is_stmt value not 0 or 1"));
								return;
							}
					} else
						if (strcmp(p,"isa") == 0) {
							if (dwarf_level < 3)
								dwarf_level = 3;
							(void)restore_line_pointer(c);
							value = get_absolute_expression();
							if (value >= 0)
								current.isa = value;
							else {
								as_bad(("isa number less than zero"));
								return;
							}
						} else
							if (strcmp(p,"discriminator") == 0) {
								(void)restore_line_pointer(c);
								value = get_absolute_expression();
								if (value >= 0)
									current.discriminator = value;
								else {
									as_bad(("discriminator less than zero"));
									return;
								}
							} else
								if (strcmp(p,"view") == 0) {
									symbolS        *sym;

									(void)restore_line_pointer(c);
									SKIP_WHITESPACE();

									if (ISDIGIT(*input_line_pointer)
									    || *input_line_pointer == '-') {
										bool		force_reset = *input_line_pointer == '-';

										value = get_absolute_expression();
										if (value != 0) {
											as_bad("numeric view can only be asserted to zero");
											return;
										}
										if (force_reset && force_reset_view)
											sym = force_reset_view;
										else {
											sym = symbol_temp_new(absolute_section,&zero_address_frag,
													      value);
											if (force_reset)
												force_reset_view = sym;
										}
									} else {
										char           *name = read_symbol_name();

										if (!name)
											return;
										sym = symbol_find_or_make(name);
										free(name);
										if (S_IS_DEFINED(sym) || symbol_equated_p(sym)) {
											if (S_IS_VOLATILE(sym))
												sym = symbol_clone(sym,1);
											else
												if (!S_CAN_BE_REDEFINED(sym)) {
													as_bad(("symbol `%s' is already defined"),
													       S_GET_NAME(sym));
													return;
												}
										}
										S_SET_SEGMENT(sym,undefined_section);
										S_SET_VALUE(sym,0);
										symbol_set_frag(sym,&zero_address_frag);
									}
									current.u.view = sym;
								} else {
									as_bad(("unknown .loc sub-directive `%s'"),p);
									(void)restore_line_pointer(c);
									return;
								}

		SKIP_WHITESPACE_AFTER_NAME();
	}
	demand_empty_rest_of_line();
	dwarf2_any_loc_directive_seen = dwarf2_loc_directive_seen = true;
	/* If we were given a view id,emit the row right away.  */
	if (current.u.view)
		dwarf2_emit_insn(0);
}

static void	dwarf2_directive_loc_mark_labels(int dummy ATTRIBUTE_UNUSED)
{
	offsetT		value = get_absolute_expression();

	if (value != 0 && value != 1) {
		as_bad(("expected 0 or 1"));
		ignore_rest_of_line();
	} else {
		dwarf2_loc_mark_labels = value != 0;
		demand_empty_rest_of_line();
	}
}

static struct frag *first_frag_for_seg(segT seg)
{
	return seg_info(seg)->frchainP->frch_root;
}

static struct frag *last_frag_for_seg(segT seg)
{
	frchainS       *f = seg_info(seg)->frchainP;

	while (f->frch_next != NULL)
		f = f->frch_next;

	return f->frch_last;
}

/* Emit a single byte into the current segment.  */
static inline void out_byte(int byte)
{
	FRAG_APPEND_1_CHAR(byte);
}

/* Emit a statement program opcode into the current segment.  */
static inline void out_opcode(int opc)
{
	out_byte(opc);
}

/* Emit a signed "little-endian base 128" number.  */
static void	out_leb128(addressT value)
{
	output_leb128(frag_more(sizeof_leb128(value,1)),value,1);
}

/* Emit a tuple for .debug_abbrev.  */
static inline void out_abbrev(int name,int form)
{
	out_uleb128(name);
	out_uleb128(form);
}

/* Get the size of a fragment.  */
static offsetT	get_frag_fix(fragS * frag,segT seg)
{
	frchainS       *fr;

	if (frag->fr_next)
		return frag->fr_fix;

	/*
	 * If a fragment is the last in the chain,special measures must be
	 * taken to find its size before relaxation,since it may be pending on
	 * some subsegment chain.
	 */
	for (fr = seg_info(seg)->frchainP; fr; fr = fr->frch_next)
		if (fr->frch_last == frag)
			return (char *)obstack_next_free(&fr->frch_obstack) - frag->fr_literal;

	abort();
}

/* Set an absolute address (may result in a relocation entry).  */
static void	out_set_addr(symbolS * sym)
{
	expressionS	exp;

	memset(&exp,0,sizeof exp);
	out_opcode(DW_LNS_extended_op);
	out_uleb128(sizeof_address + 1);

	out_opcode(DW_LNE_set_address);
	exp.X_op = O_symbol;
	exp.X_add_symbol = sym;
	exp.X_add_number = 0;
	emit_expr(&exp,sizeof_address);
}

static void	scale_addr_delta(int line_delta,addressT * addr_delta)
{
	static int	printed_this = 0;
	if (DWARF2_LINE_MIN_INSN_LENGTH > 1) {
		/* Don't error on non-instruction bytes at end of section.  */
		if (line_delta != INT_MAX
		    && *addr_delta % DWARF2_LINE_MIN_INSN_LENGTH != 0 && !printed_this) {
			as_bad("unaligned opcodes detected in executable segment");
			printed_this = 1;
		}
		*addr_delta /= DWARF2_LINE_MIN_INSN_LENGTH;
	}
}

/* Encode a pair of line and address skips as efficiently as possible. Note
 * that the line skip is signed,whereas the address skip is unsigned.
 * 
 * The following two routines *must* be kept in sync.  This is enforced by making
 * emit_inc_line_addr abort if we do not emit exactly the expected number of
 * bytes.  */
static int	size_inc_line_addr(int line_delta,addressT addr_delta)
{
	unsigned int	tmp,opcode;
	int		len = 0;

	/* Scale the address delta by the minimum instruction length.  */
	scale_addr_delta(line_delta,&addr_delta);

	/*
	 * INT_MAX is a signal that this is actually a DW_LNE_end_sequence. We
	 * cannot use special opcodes here,since we want the end_sequence to
	 * emit the matrix entry.
	 */
	if (line_delta == INT_MAX) {
		if (addr_delta == MAX_SPECIAL_ADDR_DELTA)
			len = 1;
		else
			if (addr_delta)
				len = 1 + sizeof_leb128(addr_delta,0);
		return len + 3;
	}
	/* Bias the line delta by the base.  */
	tmp = line_delta - DWARF2_LINE_BASE;

	/*
	 * If the line increment is out of range of a special opcode,we must
	 * encode it with DW_LNS_advance_line.
	 */
	if (tmp >= DWARF2_LINE_RANGE) {
		len = 1 + sizeof_leb128(line_delta,1);
		line_delta = 0;
		tmp = 0 - DWARF2_LINE_BASE;
	}
	/* Bias the opcode by the special opcode base.  */
	tmp += DWARF2_LINE_OPCODE_BASE;

	/* Avoid overflow when addr_delta is large.  */
	if (addr_delta < 256U + MAX_SPECIAL_ADDR_DELTA) {
		/* Try using a special opcode.  */
		opcode = tmp + addr_delta * DWARF2_LINE_RANGE;
		if (opcode <= 255)
			return len + 1;

		/* Try using DW_LNS_const_add_pc followed by special op.  */
		opcode = tmp + (addr_delta - MAX_SPECIAL_ADDR_DELTA) * DWARF2_LINE_RANGE;
		if (opcode <= 255)
			return len + 2;
	}
	/* Otherwise use DW_LNS_advance_pc.  */
	len += 1 + sizeof_leb128(addr_delta,0);

	/* DW_LNS_copy or special opcode.  */
	len += 1;

	return len;
}

static void	emit_inc_line_addr(int line_delta,addressT addr_delta,
			       		char         *p,int len)
{
	unsigned int	tmp,opcode;
	int		need_copy = 0;
	char           *end = p + len;

	/*
	 * Line number sequences cannot go backward in addresses.  This means
	 * we've incorrectly ordered the statements in the sequence.
	 */
	gas_assert((offsetT) addr_delta >= 0);

	/* Scale the address delta by the minimum instruction length.  */
	scale_addr_delta(line_delta,&addr_delta);

	/*
	 * INT_MAX is a signal that this is actually a DW_LNE_end_sequence. We
	 * cannot use special opcodes here,since we want the end_sequence to
	 * emit the matrix entry.
	 */
	if (line_delta == INT_MAX) {
		if (addr_delta == MAX_SPECIAL_ADDR_DELTA)
			*p++ = DW_LNS_const_add_pc;
		else
			if (addr_delta) {
				*p++ = DW_LNS_advance_pc;
				p += output_leb128(p,addr_delta,0);
			}
		*p++ = DW_LNS_extended_op;
		*p++ = 1;
		*p++ = DW_LNE_end_sequence;
		goto done;
	}
	/* Bias the line delta by the base.  */
	tmp = line_delta - DWARF2_LINE_BASE;

	/*
	 * If the line increment is out of range of a special opcode,we must
	 * encode it with DW_LNS_advance_line.
	 */
	if (tmp >= DWARF2_LINE_RANGE) {
		*p++ = DW_LNS_advance_line;
		p += output_leb128(p,line_delta,1);

		line_delta = 0;
		tmp = 0 - DWARF2_LINE_BASE;
		need_copy = 1;
	}
	/*
	 * Prettier,I think,to use DW_LNS_copy instead of a "line +0,addr
	 * +0" special opcode.
	 */
	if (line_delta == 0 && addr_delta == 0) {
		*p++ = DW_LNS_copy;
		goto done;
	}
	/* Bias the opcode by the special opcode base.  */
	tmp += DWARF2_LINE_OPCODE_BASE;

	/* Avoid overflow when addr_delta is large.  */
	if (addr_delta < 256U + MAX_SPECIAL_ADDR_DELTA) {
		/* Try using a special opcode.  */
		opcode = tmp + addr_delta * DWARF2_LINE_RANGE;
		if (opcode <= 255) {
			*p++ = opcode;
			goto done;
		}
		/* Try using DW_LNS_const_add_pc followed by special op.  */
		opcode = tmp + (addr_delta - MAX_SPECIAL_ADDR_DELTA) * DWARF2_LINE_RANGE;
		if (opcode <= 255) {
			*p++ = DW_LNS_const_add_pc;
			*p++ = opcode;
			goto done;
		}
	}
	/* Otherwise use DW_LNS_advance_pc.  */
	*p++ = DW_LNS_advance_pc;
	p += output_leb128(p,addr_delta,0);

	if (need_copy)
		*p++ = DW_LNS_copy;
	else
		*p++ = tmp;

done:
	gas_assert(p == end);
}

/* Handy routine to combine calls to the above two routines.  */
static void	out_inc_line_addr(int line_delta,addressT addr_delta)
{
	int		len = size_inc_line_addr(line_delta,addr_delta);
	emit_inc_line_addr(line_delta,addr_delta,frag_more(len),len);
}

/* Write out an alternative form of line and address skips using
 * DW_LNS_fixed_advance_pc opcodes.  This uses more space than the default line
 * and address information,but it is required if linker relaxation could
 * change the code offsets.  The following two routines *must* be kept in sync.  */
#define ADDR_DELTA_LIMIT 50000
static int	size_fixed_inc_line_addr(int line_delta,addressT addr_delta)
{
	int		len = 0;

	/* INT_MAX is a signal that this is actually a DW_LNE_end_sequence.  */
	if (line_delta != INT_MAX)
		len = 1 + sizeof_leb128(line_delta,1);

	if (addr_delta > ADDR_DELTA_LIMIT) {
		/* DW_LNS_extended_op */
		len += 1 + sizeof_leb128(sizeof_address + 1,0);
		/* DW_LNE_set_address */
		len += 1 + sizeof_address;
	} else
		/* DW_LNS_fixed_advance_pc */
		len += 3;

	if (line_delta == INT_MAX)
		/* DW_LNS_extended_op + DW_LNE_end_sequence */
		len += 3;
	else
		/* DW_LNS_copy */
		len += 1;

	return len;
}

static void	emit_fixed_inc_line_addr(int line_delta,addressT addr_delta,
				   		fragS *	frag ,char *p,int len)
{
	expressionS    *pexp;
	char           *end = p + len;

	/*
	 * Line number sequences cannot go backward in addresses.  This means
	 * we've incorrectly ordered the statements in the sequence.
	 */
	gas_assert((offsetT) addr_delta >= 0);

	/* Verify that we have kept in sync with size_fixed_inc_line_addr.  */
	gas_assert(len == size_fixed_inc_line_addr(line_delta,addr_delta));

	/* INT_MAX is a signal that this is actually a DW_LNE_end_sequence.  */
	if (line_delta != INT_MAX) {
		*p++ = DW_LNS_advance_line;
		p += output_leb128(p,line_delta,1);
	}
	pexp = symbol_get_value_expression(frag->fr_symbol);

	/*
	 * The DW_LNS_fixed_advance_pc opcode has a 2-byte operand so it can
	 * advance the address by at most 64K.  Linker relaxation (without
	 * which this function would not be used) could change the operand by
	 * an unknown amount.  If the address increment is getting close to the
	 * limit,just reset the address.
	 */
	if (addr_delta > ADDR_DELTA_LIMIT) {
		symbolS        *to_sym;
		expressionS	exp;

		memset(&exp,0,sizeof exp);
		gas_assert(pexp->X_op == O_subtract);
		to_sym = pexp->X_add_symbol;

		*p++ = DW_LNS_extended_op;
		p += output_leb128(p,sizeof_address + 1,0);
		*p++ = DW_LNE_set_address;
		exp.X_op = O_symbol;
		exp.X_add_symbol = to_sym;
		exp.X_add_number = 0;
		emit_expr_fix(&exp,sizeof_address,frag,p,TC_PARSE_CONS_RETURN_NONE);
		p += sizeof_address;
	} else {
		*p++ = DW_LNS_fixed_advance_pc;
		emit_expr_fix(pexp,2,frag,p,TC_PARSE_CONS_RETURN_NONE);
		p += 2;
	}

	if (line_delta == INT_MAX) {
		*p++ = DW_LNS_extended_op;
		*p++ = 1;
		*p++ = DW_LNE_end_sequence;
	} else
		*p++ = DW_LNS_copy;

	gas_assert(p == end);
}

/* Generate a variant frag that we can use to relax address/line increments
 * between fragments of the target segment.  */
static void	relax_inc_line_addr(int line_delta,symbolS * to_sym,symbolS * from_sym)
{
	expressionS	exp;
	int		max_chars;

	memset(&exp,0,sizeof exp);
	exp.X_op = O_subtract;
	exp.X_add_symbol = to_sym;
	exp.X_op_symbol = from_sym;
	exp.X_add_number = 0;

	/* The maximum size of the frag is the line delta with a maximum sized
	 * address delta.  */
	max_chars = size_fixed_inc_line_addr(line_delta,-DWARF2_LINE_MIN_INSN_LENGTH);
	frag_var(rs_dwarf2dbg,max_chars,max_chars,1,
		 make_expr_symbol(&exp),line_delta,NULL);
}

/* The function estimates the size of a rs_dwarf2dbg variant frag based on the
 * current values of the symbols.  It is called before the relaxation loop.  We
 * set fr_subtype to the expected length.  */
static int	dwarf2dbg_estimate_size_before_relax(fragS * frag)
{
	offsetT		addr_delta;
	int		size;

	addr_delta = resolve_symbol_value(frag->fr_symbol);
	size = size_fixed_inc_line_addr(frag->fr_offset,addr_delta);

	frag->fr_subtype = size;

	return size;
}

/* This function relaxes a rs_dwarf2dbg variant frag based on the current
 * values of the symbols.  fr_subtype is the current length of the frag.  This
 * returns the change in frag length.  */
static int	dwarf2dbg_relax_frag(fragS * frag)
{
	int		old_size  ,new_size;

	old_size = frag->fr_subtype;
	new_size = dwarf2dbg_estimate_size_before_relax(frag);

	return new_size - old_size;
}

/* This function converts a rs_dwarf2dbg variant frag into a normal fill frag.
 * This is called after all relaxation has been done. fr_subtype will be the
 * desired length of the frag.  */
static void	dwarf2dbg_convert_frag(fragS * frag)
{
	offsetT		addr_diff;

	{ //DWARF2_use_fixed_ADVANCE_PC is 1
	/* If linker relaxation is enabled then the distance between
	 * the two symbols in the frag->fr_symbol expression might
	 * change.  Hence we cannot rely upon the value computed by
	 * resolve_symbol_value. Instead we leave the expression
	 * unfinalized and allow emit_fixed_inc_line_addr to create a
	 * fixup (which later becomes a relocation) that will allow the
	 * linker to correctly compute the actual address difference.
	 * We have to use a fixed line advance for this as we cannot
	 * (easily) relocate leb128 encoded values.  */
	int		saved_finalize_syms = finalize_syms;

	finalize_syms = 0;
	addr_diff = resolve_symbol_value(frag->fr_symbol);
	finalize_syms = saved_finalize_syms;
	}

	/*
	 * fr_var carries the max_chars that we created the fragment with.
	 * fr_subtype carries the current expected length.  We must,of course,
	 * have allocated enough memory earlier.
	 */
	gas_assert(frag->fr_var >= (int)frag->fr_subtype);

	emit_fixed_inc_line_addr(frag->fr_offset,addr_diff,frag,
					 frag->fr_literal + frag->fr_fix,
					 frag->fr_subtype);

	frag->fr_fix += frag->fr_subtype;
	frag->fr_type = rs_fill;
	frag->fr_var = 0;
	frag->fr_offset = 0;
}
/*
 * Generate .debug_line content for the chain of line number entries beginning
 * at E,for segment SEG.
 */
static void	process_entries(segT seg,struct line_entry *e)
{
	unsigned	filenum = 1;
	unsigned	line = 1;
	unsigned	column = 0;
	unsigned	isa = 0;
	unsigned	flags = DWARF2_LINE_DEFAULT_IS_STMT ? DWARF2_FLAG_IS_STMT : 0;
	fragS          *last_frag = NULL,*frag;
	addressT	last_frag_ofs = 0,frag_ofs;
	symbolS        *last_lab = NULL,*lab;

	if (flag_dwarf_sections) {
		char           *name;
		const char     *sec_name;

		/* Switch to the relevant sub-section before we start to emit
		 * the line number table.
		 * 
		 * FIXME: These sub-sections do not have a normal Line Number
		 * Program Header,thus strictly speaking they are not valid
		 * DWARF sections.  Unfortunately the DWARF standard assumes a
		 * one-to-one relationship between compilation units and line
		 * number tables.  Thus we have to have a .debug_line section,
		 * as well as our sub-sections,and we have to ensure that all
		 * of the sub-sections are merged into a proper .debug_line
		 * section before a debugger sees them.  */
		sec_name = bfd_section_name(seg);
		if (strcmp(sec_name,".text") != 0) {
			name = concat(".debug_line",sec_name,(char *)NULL);
			subseg_set(subseg_get(name,false),0);
		} else
			/* Don't create a .debug_line.text section - that is
			 * redundant.  Instead just switch back to the normal
			 * .debug_line section.  */
			subseg_set(subseg_get(".debug_line",false),0);
	}
	do {
		int		line_delta;

		if (filenum != e->loc.filenum) {
			filenum = e->loc.filenum;
			out_opcode(DW_LNS_set_file);
			out_uleb128(filenum);
		}
		if (column != e->loc.column) {
			column = e->loc.column;
			out_opcode(DW_LNS_set_column);
			out_uleb128(column);
		}
		if (e->loc.discriminator != 0) {
			out_opcode(DW_LNS_extended_op);
			out_leb128(1 + sizeof_leb128(e->loc.discriminator,0));
			out_opcode(DW_LNE_set_discriminator);
			out_uleb128(e->loc.discriminator);
		}
		if (isa != e->loc.isa) {
			isa = e->loc.isa;
			out_opcode(DW_LNS_set_isa);
			out_uleb128(isa);
		}
		if ((e->loc.flags ^ flags) & DWARF2_FLAG_IS_STMT) {
			flags = e->loc.flags;
			out_opcode(DW_LNS_negate_stmt);
		}
		if (e->loc.flags & DWARF2_FLAG_BASIC_BLOCK)
			out_opcode(DW_LNS_set_basic_block);

		if (e->loc.flags & DWARF2_FLAG_PROLOGUE_END)
			out_opcode(DW_LNS_set_prologue_end);

		if (e->loc.flags & DWARF2_FLAG_EPILOGUE_BEGIN)
			out_opcode(DW_LNS_set_epilogue_begin);

		/* Don't try to optimize away redundant entries; gdb wants two
		 * entries for a function where the code starts on the same
		 * line as the opening brace,and there's no way to identify
		 * that case here.  Trust gcc to optimize appropriately.  */
		line_delta = e->loc.line - line;
		lab = e->label;
		frag = symbol_get_frag(lab);
		frag_ofs = S_GET_VALUE(lab);

		if (last_frag == NULL
		    || (e->loc.u.view == force_reset_view && force_reset_view
		/* If we're going to reset the view,but we know we're
		 * advancing the PC,we don't have to force with set_address.
		 * We know we do when we're at the same address of the same
		 * frag,and we know we might when we're in the beginning of a
		 * frag,and we were at the end of the previous frag.  */
			&& (frag == last_frag
			    ? (last_frag_ofs == frag_ofs)
			    : (frag_ofs == 0
			       && ((offsetT) last_frag_ofs
				   >= get_frag_fix(last_frag,seg)))))) {
			out_set_addr(lab);
			out_inc_line_addr(line_delta,0);
		} else
			relax_inc_line_addr(line_delta,lab,last_lab);

		line = e->loc.line;
		last_lab = lab;
		last_frag = frag;
		last_frag_ofs = frag_ofs;

		e = e->next;
	} while (e);

	/* Emit a DW_LNE_end_sequence for the end of the section.  */
	frag = last_frag_for_seg(seg);
	frag_ofs = get_frag_fix(frag,seg);
	lab = symbol_temp_new(seg,frag,frag_ofs);
	relax_inc_line_addr(INT_MAX,lab,last_lab);
}

/* Switch to LINE_STR_SEG and output the given STR.  Return the symbol pointing
 * to the new string in the section.  */
static symbolS *add_line_strp(segT line_str_seg,const char *str)
{
	char           *cp;
	size_t		size;
	symbolS        *sym;

	subseg_set(line_str_seg,0);
	sym = symbol_temp_new_now_octets();
	size = strlen(str) + 1;
	cp = frag_more(size);
	memcpy(cp,str,size);
	return sym;
}

/* Emit the directory and file tables for .debug_line.  */
static void	out_dir_and_file_list(segT line_seg,int sizeof_offset)
{
	size_t		size;
	char           *dir;
	char           *cp;
	unsigned int	i ,j;
	bool		emit_md5 = false;
	bool		emit_timestamps = true;
	bool		emit_filesize = true;
	segT		line_str_seg = NULL;
	symbolS        *line_strp,*file0_strp = NULL;

	/* Output the Directory Table.  */
	if (DWARF2_LINE_VERSION >= 5) {
		/* We only have one column in the directory table.  */
		out_byte(1);

		/* Describe the purpose and format of the column.  */
		out_uleb128(DW_LNCT_path);
		/* Store these strings in the .debug_line_str section so they
		 * can be shared.  */
		out_uleb128(DW_FORM_line_strp);

		/* Now state how many rows there are in the table.  We need at
		 * least 1 if there is one or more file names to store the
		 * "working directory".  */
		if (dirs_in_use == 0 && files_in_use > 0)
			out_uleb128(1);
		else
			out_uleb128(dirs_in_use);
	}
	/* Emit directory list.  */
	if (DWARF2_LINE_VERSION >= 5 && (dirs_in_use > 0 || files_in_use > 0)) {
		line_str_seg = subseg_new(".debug_line_str",0);
		line_str_seg->flags = SEC_READONLY|SEC_DEBUGGING|SEC_OCTETS
			| SEC_MERGE|SEC_STRINGS;
		line_str_seg->entsize = 1;

		/* DWARF5 uses slot zero,but that is only set explicitly using
		 * a .file 0 directive.  Otherwise use pwd as main file
		 * directory.  */
		if (dirs_in_use > 0 && dirs[0] != NULL)
			dir = remap_debug_filename(dirs[0]);
		else
			dir = remap_debug_filename(getpwd());

		line_strp = add_line_strp(line_str_seg,dir);
		free(dir);
		subseg_set(line_seg,0);
		TC_DWARF2_EMIT_OFFSET(line_strp,sizeof_offset);
	}
	for (i = 1; i < dirs_in_use; ++i) {
		dir = remap_debug_filename(dirs[i]);
		if (DWARF2_LINE_VERSION < 5) {
			size = strlen(dir) + 1;
			cp = frag_more(size);
			memcpy(cp,dir,size);
		} else {
			line_strp = add_line_strp(line_str_seg,dir);
			subseg_set(line_seg,0);
			TC_DWARF2_EMIT_OFFSET(line_strp,sizeof_offset);
		}
		free(dir);
	}

	if (DWARF2_LINE_VERSION < 5)
		/* Terminate it.  */
		out_byte('\0');

	/* Output the File Name Table.  */
	if (DWARF2_LINE_VERSION >= 5) {
		unsigned int	columns = 4;

		if (((unsigned long)DWARF2_FILE_TIME_NAME("","")) == -1UL) {
			emit_timestamps = false;
			--columns;
		}
		if (DWARF2_FILE_SIZE_NAME("","") == -1) {
			emit_filesize = false;
			--columns;
		}
		for (i = 0; i < files_in_use; ++i)
			if (files[i].md5[0] != 0)
				break;
		if (i < files_in_use) {
			emit_md5 = true;
			++columns;
		}
		/* The number of format entries to follow.  */
		out_byte(columns);
		/* The format of the file name.  */
		out_uleb128(DW_LNCT_path);
		/* Store these strings in the .debug_line_str section so they
		 * can be shared.  */
		out_uleb128(DW_FORM_line_strp);

		/* The format of the directory index.  */
		out_uleb128(DW_LNCT_directory_index);
		out_uleb128(DW_FORM_udata);

		if (emit_timestamps) {
			/* The format of the timestamp.  */
			out_uleb128(DW_LNCT_timestamp);
			out_uleb128(DW_FORM_udata);
		}
		if (emit_filesize) {
			/* The format of the file size.  */
			out_uleb128(DW_LNCT_size);
			out_uleb128(DW_FORM_udata);
		}
		if (emit_md5) {
			/* The format of the MD5 sum.  */
			out_uleb128(DW_LNCT_MD5);
			out_uleb128(DW_FORM_data16);
		}
		/* The number of entries in the table.  */
		out_uleb128(files_in_use);
	}
	for (i = DWARF2_LINE_VERSION > 4 ? 0 : 1; i < files_in_use; ++i) {
		const char     *fullfilename;

		if (files[i].filename == NULL) {
			if (DWARF2_LINE_VERSION < 5 || i != 0) {
				as_bad(("unassigned file number %ld"),(long)i);
				continue;
			}
			/* DWARF5 uses slot zero,but that is only set
			 * explicitly using a .file 0 directive.  If that isn't
			 * used,but file 1 is,then use that as main file
			 * name.  */
			if (files_in_use > 1 && files[1].filename != NULL) {
				files[0].filename = files[1].filename;
				files[0].dir = files[1].dir;
				if (emit_md5)
					for (j = 0; j < NUM_MD5_BYTES; ++j)
						files[0].md5[j] = files[1].md5[j];
			} else
				files[0].filename = "";
		}
		fullfilename = DWARF2_FILE_NAME(files[i].filename,
				      files[i].dir ? dirs[files[i].dir] : "");
		if (DWARF2_LINE_VERSION < 5) {
			size = strlen(fullfilename) + 1;
			cp = frag_more(size);
			memcpy(cp,fullfilename,size);
		} else {
			if (!file0_strp)
				line_strp = add_line_strp(line_str_seg,fullfilename);
			else
				line_strp = file0_strp;
			subseg_set(line_seg,0);
			TC_DWARF2_EMIT_OFFSET(line_strp,sizeof_offset);
			if (i == 0 && files_in_use > 1
			    && files[0].filename == files[1].filename)
				file0_strp = line_strp;
			else
				file0_strp = NULL;
		}

		/* Directory number.  */
		out_uleb128(files[i].dir);

		/* Output the last modification timestamp.  */
		if (emit_timestamps) {
			offsetT		timestamp;

			timestamp = DWARF2_FILE_TIME_NAME(files[i].filename,
				      files[i].dir ? dirs[files[i].dir] : "");
			if (timestamp == -1)
				timestamp = 0;
			out_uleb128(timestamp);
		}
		/* Output the filesize.  */
		if (emit_filesize) {
			offsetT		filesize;
			filesize = DWARF2_FILE_SIZE_NAME(files[i].filename,
				      files[i].dir ? dirs[files[i].dir] : "");
			if (filesize == -1)
				filesize = 0;
			out_uleb128(filesize);
		}
		/* Output the md5 sum.  */
		if (emit_md5) {
			int		b;

			for (b = 0; b < NUM_MD5_BYTES; b++)
				out_byte(files[i].md5[b]);
		}
	}

	if (DWARF2_LINE_VERSION < 5)
		/* Terminate filename list.  */
		out_byte(0);
}

/* Switch to SEC and output a header length field.  Return the size of offsets
 * used in SEC.  The caller must set EXPR->X_add_symbol value to the end of the
 * section.  EXPR->X_add_number will be set to the negative size of the header. */
static int	out_header(asection * sec,expressionS * exp)
{
	symbolS        *start_sym;
	symbolS        *end_sym;

	subseg_set(sec,0);

	if (flag_dwarf_sections) {
		/*
		 * If we are going to put the start and end symbols in
		 * different sections,then we need real symbols,not just
		 * fake,local ones.
		 */
		frag_now_fix();
		start_sym = symbol_make(".Ldebug_line_start");
		end_sym = symbol_make(".Ldebug_line_end");
		symbol_set_value_now(start_sym);
	} else {
		start_sym = symbol_temp_new_now_octets();
		end_sym = symbol_temp_make();
	}

	/* Total length of the information.  */
	exp->X_op = O_subtract;
	exp->X_add_symbol = end_sym;
	exp->X_op_symbol = start_sym;

	switch (DWARF2_FORMAT(sec)) {
	case dwarf2_format_32bit:
		exp->X_add_number = -4;
		emit_expr(exp,4);
		return 4;

	case dwarf2_format_64bit:
		exp->X_add_number = -12;
		out_four(-1);
		emit_expr(exp,8);
		return 8;

	case dwarf2_format_64bit_irix:
		exp->X_add_number = -8;
		emit_expr(exp,8);
		return 8;
	}

	as_fatal(("internal error: unknown dwarf2 format"));
	return 0;
}

/* Emit the collected .debug_line data.  */
static void	out_debug_line(segT line_seg)
{
	expressionS	exp;
	symbolS        *prologue_start,*prologue_end;
	symbolS        *line_end;
	struct line_seg *s;
	int		sizeof_offset;

	memset(&exp,0,sizeof exp);
	sizeof_offset = out_header(line_seg,&exp);
	line_end = exp.X_add_symbol;

	/* Version.  */
	out_two(DWARF2_LINE_VERSION);

	if (DWARF2_LINE_VERSION >= 5) {
		out_byte(sizeof_address);
		out_byte(0);	/* Segment Selector size.  */
	}
	/* Length of the prologue following this length.  */
	prologue_start = symbol_temp_make();
	prologue_end = symbol_temp_make();
	exp.X_op = O_subtract;
	exp.X_add_symbol = prologue_end;
	exp.X_op_symbol = prologue_start;
	exp.X_add_number = 0;
	emit_expr(&exp,sizeof_offset);
	symbol_set_value_now(prologue_start);

	/* Parameters of the state machine.  */
	out_byte(DWARF2_LINE_MIN_INSN_LENGTH);
	if (DWARF2_LINE_VERSION >= 4)
		out_byte(DWARF2_LINE_MAX_OPS_PER_INSN);
	out_byte(DWARF2_LINE_DEFAULT_IS_STMT);
	out_byte(DWARF2_LINE_BASE);
	out_byte(DWARF2_LINE_RANGE);
	out_byte(DWARF2_LINE_OPCODE_BASE);

	/* Standard opcode lengths.  */
	out_byte(0);		/* DW_LNS_copy */
	out_byte(1);		/* DW_LNS_advance_pc */
	out_byte(1);		/* DW_LNS_advance_line */
	out_byte(1);		/* DW_LNS_set_file */
	out_byte(1);		/* DW_LNS_set_column */
	out_byte(0);		/* DW_LNS_negate_stmt */
	out_byte(0);		/* DW_LNS_set_basic_block */
	out_byte(0);		/* DW_LNS_const_add_pc */
	out_byte(1);		/* DW_LNS_fixed_advance_pc */
	if (DWARF2_LINE_VERSION >= 3) {
		out_byte(0);	/* DW_LNS_set_prologue_end */
		out_byte(0);	/* DW_LNS_set_epilogue_begin */
		out_byte(1);	/* DW_LNS_set_isa */
		/* We have emitted 12 opcode lengths,so make that this matches
		 * up to the opcode base value we have been using.  */
		gas_assert(DWARF2_LINE_OPCODE_BASE == 13);
	} else
		gas_assert(DWARF2_LINE_OPCODE_BASE == 10);

	out_dir_and_file_list(line_seg,sizeof_offset);
	symbol_set_value_now(prologue_end);

	/* For each section,emit a statement program.  */
	for (s = all_segs; s; s = s->next)
		/*
		 * Paranoia - this check should have already have been handled
		 * in dwarf2_gen_line_info_1().
		 */
		if (s->head->head && SEG_NORMAL(s->seg))
			process_entries(s->seg,s->head->head);

	if (flag_dwarf_sections)
		/* * We have to switch to the special .debug_line_end section
		 * before emitting the end-of-debug_line symbol.  The linker
		 * script arranges for this section to be placed after all the
		 * (potentially garbage collected) .debug_line.<foo> sections.
		 * This section contains the line_end symbol which is used to
		 * compute the size of the linked .debug_line section,as seen
		 * in the DWARF Line Number header.  */
		subseg_set(subseg_get(".debug_line_end",false),0);

	symbol_set_value_now(line_end);
}

static void	out_debug_ranges(segT ranges_seg,symbolS ** ranges_sym)
{
	unsigned int	addr_size = sizeof_address;
	struct line_seg *s;
	expressionS	exp;
	unsigned int	i;

	memset(&exp,0,sizeof exp);
	subseg_set(ranges_seg,0);

	/* For DW_AT_ranges to point at (there is no header,so really start of
	 * section,but see out_debug_rnglists).  */
	*ranges_sym = symbol_temp_new_now_octets();

	/* Base Address Entry.  */
	for (i = 0; i < addr_size; i++)
		out_byte(0xff);
	for (i = 0; i < addr_size; i++)
		out_byte(0);

	/* Range List Entry.  */
	for (s = all_segs; s; s = s->next) {
		fragS          *frag;
		symbolS        *beg,*end;

		frag = first_frag_for_seg(s->seg);
		beg = symbol_temp_new(s->seg,frag,0);
		s->text_start = beg;

		frag = last_frag_for_seg(s->seg);
		end = symbol_temp_new(s->seg,frag,get_frag_fix(frag,s->seg));
		s->text_end = end;

		exp.X_op = O_symbol;
		exp.X_add_symbol = beg;
		exp.X_add_number = 0;
		emit_expr(&exp,addr_size);

		exp.X_op = O_symbol;
		exp.X_add_symbol = end;
		exp.X_add_number = 0;
		emit_expr(&exp,addr_size);
	}

	/* End of Range Entry.   */
	for (i = 0; i < addr_size; i++)
		out_byte(0);
	for (i = 0; i < addr_size; i++)
		out_byte(0);
}

static void	out_debug_rnglists(segT ranges_seg,symbolS ** ranges_sym)
{
	expressionS	exp;
	symbolS        *ranges_end;
	struct line_seg *s;

	/* Unit length.  */
	memset(&exp,0,sizeof exp);
	out_header(ranges_seg,&exp);
	ranges_end = exp.X_add_symbol;

	out_two(DWARF2_RNGLISTS_VERSION);
	out_byte(sizeof_address);
	out_byte(0);		/* Segment Selector size.  */
	out_four(0);		/* Offset entry count.  */

	/* For DW_AT_ranges to point at (must be after the header).   */
	*ranges_sym = symbol_temp_new_now_octets();

	for (s = all_segs; s; s = s->next) {
		fragS          *frag;
		symbolS        *beg,*end;

		out_byte(DW_RLE_start_length);

		frag = first_frag_for_seg(s->seg);
		beg = symbol_temp_new(s->seg,frag,0);
		s->text_start = beg;

		frag = last_frag_for_seg(s->seg);
		end = symbol_temp_new(s->seg,frag,get_frag_fix(frag,s->seg));
		s->text_end = end;

		exp.X_op = O_symbol;
		exp.X_add_symbol = beg;
		exp.X_add_number = 0;
		emit_expr(&exp,sizeof_address);

		exp.X_op = O_symbol;
		exp.X_add_symbol = end;
		exp.X_add_number = 0;
		emit_leb128_expr(&exp,0);
	}

	out_byte(DW_RLE_end_of_list);

	symbol_set_value_now(ranges_end);
}

/* Emit data for .debug_aranges.  */
static void	out_debug_aranges(segT aranges_seg,segT info_seg)
{
	unsigned int	addr_size = sizeof_address;
	offsetT		size;
	struct line_seg *s;
	expressionS	exp;
	symbolS        *aranges_end;
	char           *p;
	int		sizeof_offset;

	memset(&exp,0,sizeof exp);
	sizeof_offset = out_header(aranges_seg,&exp);
	aranges_end = exp.X_add_symbol;
	size = -exp.X_add_number;

	/* Version.  */
	out_two(DWARF2_ARANGES_VERSION);
	size += 2;

	/* Offset to .debug_info.  */
	TC_DWARF2_EMIT_OFFSET(section_symbol(info_seg),sizeof_offset);
	size += sizeof_offset;

	/* Size of an address (offset portion).  */
	out_byte(addr_size);
	size++;

	/* Size of a segment descriptor.  */
	out_byte(0);
	size++;

	/* Align the header.  */
	while ((size++ % (2 * addr_size)) > 0)
		out_byte(0);

	for (s = all_segs; s; s = s->next) {
		fragS          *frag;
		symbolS        *beg,*end;

		frag = first_frag_for_seg(s->seg);
		beg = symbol_temp_new(s->seg,frag,0);
		s->text_start = beg;

		frag = last_frag_for_seg(s->seg);
		end = symbol_temp_new(s->seg,frag,get_frag_fix(frag,s->seg));
		s->text_end = end;

		exp.X_op = O_symbol;
		exp.X_add_symbol = beg;
		exp.X_add_number = 0;
		emit_expr(&exp,addr_size);

		exp.X_op = O_subtract;
		exp.X_add_symbol = end;
		exp.X_op_symbol = beg;
		exp.X_add_number = 0;
		emit_expr(&exp,addr_size);
	}

	p = frag_more(2 * addr_size);
	md_number_to_chars(p,0,addr_size);
	md_number_to_chars(p + addr_size,0,addr_size);

	symbol_set_value_now(aranges_end);
}

/*
 * Emit data for .debug_abbrev.  Note that this must be kept in sync with
 * out_debug_info below.
 */
static void	out_debug_abbrev(segT abbrev_seg,
			 		segT		info_seg ATTRIBUTE_UNUSED,
			 		segT		line_seg ATTRIBUTE_UNUSED,
			     		unsigned	char *func_formP)
{
	int		secoff_form;
	bool		have_efunc = false,have_lfunc = false;

	/* Check the symbol table for function symbols which also have their
	 * size specified.  */
	if (symbol_rootP) {
		symbolS        *symp;

		for (symp = symbol_rootP; symp; symp = symbol_next(symp)) {
			/* A warning construct is a warning symbol followed by
			 * the symbol warned about.  Skip this and the
			 * following symbol.  */
			if (symbol_get_bfdsym(symp)->flags & BSF_WARNING) {
				symp = symbol_next(symp);
				if (!symp)
					break;
				continue;
			}
			if (!S_IS_DEFINED(symp) || !S_IS_FUNCTION(symp))
				continue;

#if defined (OBJ_ELF)		/* || defined (OBJ_MAYBE_ELF) */
			if (S_GET_SIZE(symp) == 0) {
				if (!IS_ELF || symbol_get_obj(symp)->size == NULL)
					continue;
			}
#else
			continue;
#endif

			if (S_IS_EXTERNAL(symp))
				have_efunc = true;
			else
				have_lfunc = true;
		}
	}
	subseg_set(abbrev_seg,0);

	out_uleb128(GAS_ABBREV_COMP_UNIT);
	out_uleb128(DW_TAG_compile_unit);
	out_byte(have_efunc || have_lfunc ? DW_CHILDREN_yes : DW_CHILDREN_no);
	if (DWARF2_VERSION < 4) {
		if (DWARF2_FORMAT(line_seg) == dwarf2_format_32bit)
			secoff_form = DW_FORM_data4;
		else
			secoff_form = DW_FORM_data8;
	} else
		secoff_form = DW_FORM_sec_offset;
	out_abbrev(DW_AT_stmt_list,secoff_form);
	if (all_segs->next == NULL) {
		out_abbrev(DW_AT_low_pc,DW_FORM_addr);
		if (DWARF2_VERSION < 4)
			out_abbrev(DW_AT_high_pc,DW_FORM_addr);
		else
			out_abbrev(DW_AT_high_pc,DW_FORM_udata);
	} else
		out_abbrev(DW_AT_ranges,secoff_form);
	out_abbrev(DW_AT_name,DW_FORM_strp);
	out_abbrev(DW_AT_comp_dir,DW_FORM_strp);
	out_abbrev(DW_AT_producer,DW_FORM_strp);
	out_abbrev(DW_AT_language,DW_FORM_data2);
	out_abbrev(0,0);

	if (have_efunc || have_lfunc) {
		out_uleb128(GAS_ABBREV_SUBPROG);
		out_uleb128(DW_TAG_subprogram);
		out_byte(DW_CHILDREN_no);
		out_abbrev(DW_AT_name,DW_FORM_strp);
		if (have_efunc) {
			if (have_lfunc || DWARF2_VERSION < 4)
				*func_formP = DW_FORM_flag;
			else
				*func_formP = DW_FORM_flag_present;
			out_abbrev(DW_AT_external,*func_formP);
		} else
			/* Any non-zero value other than DW_FORM_flag will do.  */
			*func_formP = DW_FORM_block;

		/* PR 29517: Provide a return type for the function.  */
		if (DWARF2_VERSION > 2)
			out_abbrev(DW_AT_type,DW_FORM_ref_udata);

		out_abbrev(DW_AT_low_pc,DW_FORM_addr);
		out_abbrev(DW_AT_high_pc,
			   DWARF2_VERSION < 4 ? DW_FORM_addr : DW_FORM_udata);
		out_abbrev(0,0);

		if (DWARF2_VERSION > 2) {
			/* PR 29517: We do not actually know the return type of
			 * these functions,so provide an abbrev that uses
			 * DWARF's unspecified type.  */
			out_uleb128(GAS_ABBREV_NO_TYPE);
			out_uleb128(DW_TAG_unspecified_type);
			out_byte(DW_CHILDREN_no);
			out_abbrev(0,0);
		}
	}
	/* Terminate the abbreviations for this compilation unit.  */
	out_byte(0);
}

/* Emit a description of this compilation unit for .debug_info.  */
static void	out_debug_info(segT info_seg,segT abbrev_seg,segT line_seg,segT str_seg,
		  		symbolS *	ranges_sym,symbolS * name_sym,
	    		symbolS *	comp_dir_sym,symbolS * producer_sym,
			   		unsigned	char	func_form)
{
	expressionS	exp;
	symbolS        *info_end;
	int		sizeof_offset;

	memset(&exp,0,sizeof exp);
	sizeof_offset = out_header(info_seg,&exp);
	info_end = exp.X_add_symbol;

	/* DWARF version.  */
	out_two(DWARF2_VERSION);

	if (DWARF2_VERSION < 5) {
		/* .debug_abbrev offset */
		TC_DWARF2_EMIT_OFFSET(section_symbol(abbrev_seg),sizeof_offset);
	} else {
		/* unit (header) type */
		out_byte(DW_UT_compile);
	}

	/* Target address size.  */
	out_byte(sizeof_address);

	if (DWARF2_VERSION >= 5) {
		/* .debug_abbrev offset */
		TC_DWARF2_EMIT_OFFSET(section_symbol(abbrev_seg),sizeof_offset);
	}
	/* DW_TAG_compile_unit DIE abbrev */
	out_uleb128(GAS_ABBREV_COMP_UNIT);

	/* DW_AT_stmt_list */
	TC_DWARF2_EMIT_OFFSET(section_symbol(line_seg),
			      (DWARF2_FORMAT(line_seg) == dwarf2_format_32bit
			       ? 4 : 8));

	/* These two attributes are emitted if all of the code is contiguous.  */
	if (all_segs->next == NULL) {
		/* DW_AT_low_pc */
		exp.X_op = O_symbol;
		exp.X_add_symbol = all_segs->text_start;
		exp.X_add_number = 0;
		emit_expr(&exp,sizeof_address);

		/* DW_AT_high_pc */
		if (DWARF2_VERSION < 4)
			exp.X_op = O_symbol;
		else {
			exp.X_op = O_subtract;
			exp.X_op_symbol = all_segs->text_start;
		}
		exp.X_add_symbol = all_segs->text_end;
		exp.X_add_number = 0;
		if (DWARF2_VERSION < 4)
			emit_expr(&exp,sizeof_address);
		else
			emit_leb128_expr(&exp,0);
	} else {
		/* This attribute is emitted if the code is disjoint.  */
		/* DW_AT_ranges.  */
		TC_DWARF2_EMIT_OFFSET(ranges_sym,sizeof_offset);
	}

	/* DW_AT_name,DW_AT_comp_dir and DW_AT_producer.  Symbols in
	 * .debug_str setup in out_debug_str below.  */
	TC_DWARF2_EMIT_OFFSET(name_sym,sizeof_offset);
	TC_DWARF2_EMIT_OFFSET(comp_dir_sym,sizeof_offset);
	TC_DWARF2_EMIT_OFFSET(producer_sym,sizeof_offset);

	/* DW_AT_language.  Yes,this is probably not really MIPS,but the
	 * dwarf2 draft has no standard code for assembler.  */
	out_two(DW_LANG_Mips_Assembler);

	if (func_form) {
		symbolS        *symp;
		symbolS        *no_type_tag;

		if (DWARF2_VERSION > 2)
			no_type_tag = symbol_make(".Ldebug_no_type_tag");
		else
			no_type_tag = NULL;

		for (symp = symbol_rootP; symp; symp = symbol_next(symp)) {
			const char     *name;
			size_t		len;
			expressionS	size = {.X_op = O_constant};

			/* Skip warning constructs (see above).  */
			if (symbol_get_bfdsym(symp)->flags & BSF_WARNING) {
				symp = symbol_next(symp);
				if (!symp)
					break;
				continue;
			}
			if (!S_IS_DEFINED(symp) || !S_IS_FUNCTION(symp))
				continue;

#if defined (OBJ_ELF)		/* || defined (OBJ_MAYBE_ELF) */
			size.X_add_number = S_GET_SIZE(symp);
			if (size.X_add_number == 0 && IS_ELF
			    && symbol_get_obj(symp)->size != NULL) {
				size.X_op = O_add;
				size.X_op_symbol = make_expr_symbol(symbol_get_obj(symp)->size);
			}
#endif
			if (size.X_op == O_constant && size.X_add_number == 0)
				continue;

			subseg_set(str_seg,0);
			name_sym = symbol_temp_new_now_octets();
			name = S_GET_NAME(symp);
			len = strlen(name) + 1;
			memcpy(frag_more(len),name,len);

			subseg_set(info_seg,0);

			/* DW_TAG_subprogram DIE abbrev */
			out_uleb128(GAS_ABBREV_SUBPROG);

			/* DW_AT_name */
			TC_DWARF2_EMIT_OFFSET(name_sym,sizeof_offset);

			/* DW_AT_external.  */
			if (func_form == DW_FORM_flag)
				out_byte(S_IS_EXTERNAL(symp));

			/* PR 29517: Let consumers know that we do not have
			 * return type information for this function.  */
			if (DWARF2_VERSION > 2) {
				exp.X_op = O_symbol;
				exp.X_add_symbol = no_type_tag;
				exp.X_add_number = 0;
				emit_leb128_expr(&exp,0);
			}
			/* DW_AT_low_pc */
			exp.X_op = O_symbol;
			exp.X_add_symbol = symp;
			exp.X_add_number = 0;
			emit_expr(&exp,sizeof_address);

			/* DW_AT_high_pc */
			if (DWARF2_VERSION < 4) {
				if (size.X_op == O_constant)
					size.X_op = O_symbol;
				size.X_add_symbol = symp;
				emit_expr(&size,sizeof_address);
			} else
				if (size.X_op == O_constant)
					out_uleb128(size.X_add_number);
				else
					emit_leb128_expr(symbol_get_value_expression(size.X_op_symbol),0);
		}

		if (DWARF2_VERSION > 2) {
			/* PR 29517: Generate a DIE for the unspecified type
			 * abbrev. We do it here because it cannot be part of
			 * the top level DIE.  */
			subseg_set(info_seg,0);
			symbol_set_value_now(no_type_tag);
			out_uleb128(GAS_ABBREV_NO_TYPE);
		}
		/* End of children.  */
		out_leb128(0);
	}
	symbol_set_value_now(info_end);
}

/* Emit the three debug strings needed in .debug_str and setup symbols to them
 * for use in out_debug_info.  */
static void	out_debug_str(segT str_seg,symbolS ** name_sym,symbolS ** comp_dir_sym,
			  		symbolS **	producer_sym)
{
	char		producer  [128];
	char           *p;
	int		len;
	int		first_file = DWARF2_LINE_VERSION > 4 ? 0 : 1;

	subseg_set(str_seg,0);

	/* DW_AT_name.  We don't have the actual file name that was present on
	 * the command line,so assume files[first_file] is the main input
	 * file. We're not supposed to get called unless at least one line
	 * number entry was emitted,so this should always be defined.  */
	*name_sym = symbol_temp_new_now_octets();
	if (files_in_use == 0)
		abort();
	if (files[first_file].dir) {
		char           *dirname = remap_debug_filename(dirs[files[first_file].dir]);
		len = strlen(dirname);
		p = frag_more(len + 1);
		memcpy(p,dirname,len);
		p[len] = '/';
		free(dirname);
	}
	len = strlen(files[first_file].filename) + 1;
	p = frag_more(len);
	memcpy(p,files[first_file].filename,len);

	/* DW_AT_comp_dir */
	*comp_dir_sym = symbol_temp_new_now_octets();
	char           *comp_dir = remap_debug_filename(getpwd());
	len = strlen(comp_dir) + 1;
	p = frag_more(len);
	memcpy(p,comp_dir,len);
	free(comp_dir);

	/* DW_AT_producer */
	*producer_sym = symbol_temp_new_now_octets();
	sprintf(producer,"GNU AS %s",VERSION);
	len = strlen(producer) + 1;
	p = frag_more(len);
	memcpy(p,producer,len);
}

static void	dwarf2_init(void)
{
	all_segs = NULL;
	last_seg_ptr = &all_segs;
	files = NULL;
	files_in_use = 0;
	files_allocated = 0;
	dirs = NULL;
	dirs_in_use = 0;
	dirs_allocated = 0;
	dwarf2_loc_directive_seen = false;
	dwarf2_any_loc_directive_seen = false;
	dwarf2_loc_mark_labels = false;
	current.filenum = 1;
	current.line = 1;
	current.column = 0;
	current.isa = 0;
	current.flags = DWARF2_LINE_DEFAULT_IS_STMT ? DWARF2_FLAG_IS_STMT : 0;
	current.discriminator = 0;
	current.u.view = NULL;
	force_reset_view = NULL;
	view_assert_failed = NULL;
	dw2_line = -1;
	dw2_filename = NULL;
	label_num = 0;
	last_used = -1;

	/* Select the default CIE version to produce here.  The global starts
	 * with a value of -1 and will be modified to a valid value either by
	 * the user providing a command line option,or some targets will
	 * select their own default in md_after_parse_args.  If we get here and
	 * the global still contains -1 then it is up to us to pick a sane
	 * default.  The default we choose is 1,this is the CIE version gas
	 * has produced for a long time,and there seems no reason to change it
	 * yet.  */
	if (flag_dwarf_cie_version == -1)
		flag_dwarf_cie_version = 1;
}

static void	dwarf2_cleanup(void)
{
	purge_generated_debug(true);
	free(files);
	for (unsigned int i = 0; i < dirs_in_use; i++)
		free(dirs[i]);
	free(dirs);
}

/* Finish the dwarf2 debug sections.  We emit .debug.line if there were any
 * .file/.loc directives,or --gdwarf2 was given,and if the file has a
 * non-empty .debug_info section and an empty .debug_line section.  If we emit
 * .debug_line,and the .debug_info section is empty,we also emit .debug_info,
 * .debug_aranges and .debug_abbrev. ALL_SEGS will be non-null if there were
 * any .file/.loc directives,or --gdwarf2 was given and there were any located
 * instructions emitted.  */
static void	dwarf2_finish(void)
{
	segT		line_seg;
	struct line_seg *s;
	segT		info_seg;
	int		emit_other_sections = 0;
	int		empty_debug_line = 0;

	info_seg = bfd_get_section_by_name(stdoutput,".debug_info");
	emit_other_sections = info_seg == NULL || !seg_not_empty_p(info_seg);

	line_seg = bfd_get_section_by_name(stdoutput,".debug_line");
	empty_debug_line = line_seg == NULL || !seg_not_empty_p(line_seg);

	/* We can't construct a new debug_line section if we already have one.
	 * Give an error if we have seen any .loc,otherwise trust the user
	 * knows what they are doing and want to generate the .debug_line (and
	 * all other debug sections) themselves.  */
	if (all_segs && !empty_debug_line && dwarf2_any_loc_directive_seen)
		as_fatal("duplicate .debug_line sections");

	if ((!all_segs && emit_other_sections)
	    || (!emit_other_sections && !empty_debug_line))
		/* If there is no line information and no non-empty .debug_info
		 * section,or if there is both a non-empty .debug_info and a
		 * non-empty .debug_line,then we do nothing.  */
	{
		dwarf2_cleanup();
		return;
	}
	/* Calculate the size of an address for the target machine.  */
	sizeof_address = 8; //64 / 8 = 8:DWARF2_ADDR_SIZE(stdoutput)

	/* Create and switch to the line number section.  */
	if (empty_debug_line) {
		line_seg = subseg_new(".debug_line",0);
		line_seg->flags = SEC_READONLY|SEC_DEBUGGING|SEC_OCTETS;
	}
	for (s = all_segs; s; s = s->next) {
		struct line_subseg *lss;

		for (lss = s->head; lss; lss = lss->next)
			if (lss->head)
				do_allocate_filenum(lss->head);
	}

	/* For each subsection,chain the debug entries together.  */
	for (s = all_segs; s; s = s->next) {
		struct line_subseg *lss = s->head;
		struct line_entry **ptail = lss->ptail;

		/* Reset the initial view of the first subsection of the
		 * section.  */
		if (lss->head && lss->head->loc.u.view)
			set_or_check_view(lss->head,NULL,NULL);

		while ((lss = lss->next) != NULL) {
			/* Link the first view of subsequent subsections to the
			 * previous view.  */
			if (lss->head && lss->head->loc.u.view)
				set_or_check_view(lss->head,
				 !s->head ? NULL : (struct line_entry *)ptail,
					      s->head ? s->head->head : NULL);
			*ptail = lss->head;
			lss->head = NULL;
			ptail = lss->ptail;
		}
	}

	if (empty_debug_line)
		out_debug_line(line_seg);

	/* If this is assembler generated line info,and there is no debug_info
	 * already,we need .debug_info,.debug_abbrev and .debug_str sections
	 * as well.  */
	if (emit_other_sections) {
		segT		abbrev_seg;
		segT		aranges_seg;
		segT		str_seg;
		symbolS        *name_sym,*comp_dir_sym,*producer_sym,*ranges_sym;
		unsigned char	func_form = 0;

		gas_assert(all_segs);

		info_seg = subseg_new(".debug_info",0);
		abbrev_seg = subseg_new(".debug_abbrev",0);
		aranges_seg = subseg_new(".debug_aranges",0);
		str_seg = subseg_new(".debug_str",0);

		info_seg->flags = SEC_READONLY|SEC_DEBUGGING|SEC_OCTETS;
		abbrev_seg->flags = SEC_READONLY|SEC_DEBUGGING|SEC_OCTETS;
		aranges_seg->flags = SEC_READONLY|SEC_DEBUGGING|SEC_OCTETS;
		str_seg->flags = SEC_READONLY|SEC_DEBUGGING|SEC_OCTETS
			| SEC_MERGE|SEC_STRINGS;
		str_seg->entsize = 1;

		record_alignment(aranges_seg,ffs(2 * sizeof_address) - 1);

		if (all_segs->next == NULL)
			ranges_sym = NULL;
		else {
			if (DWARF2_VERSION < 5) {
				segT		ranges_seg = subseg_new(".debug_ranges",0);
				ranges_seg->flags = (SEC_READONLY|SEC_DEBUGGING|SEC_OCTETS);
				record_alignment(ranges_seg,ffs(2 * sizeof_address) - 1);
				out_debug_ranges(ranges_seg,&ranges_sym);
			} else {
				segT		rnglists_seg = subseg_new(".debug_rnglists",0);
				rnglists_seg->flags = (SEC_READONLY|SEC_DEBUGGING|SEC_OCTETS);
				out_debug_rnglists(rnglists_seg,&ranges_sym);
			}
		}

		out_debug_aranges(aranges_seg,info_seg);
		out_debug_abbrev(abbrev_seg,info_seg,line_seg,&func_form);
		out_debug_str(str_seg,&name_sym,&comp_dir_sym,&producer_sym);
		out_debug_info(info_seg,abbrev_seg,line_seg,str_seg,
			     ranges_sym,name_sym,comp_dir_sym,producer_sym,
			       func_form);
	}
	dwarf2_cleanup();
}

/* Perform any deferred checks pertaining to debug information.  */
static void	dwarf2dbg_final_check(void)
{
	/* Perform reset-view checks.  Don't evaluate view_assert_failed
	 * recursively: it could be very deep.  It's a chain of adds,with each
	 * chain element pointing to the next in X_add_symbol,and holding the
	 * check value in X_op_symbol.  */
	while (view_assert_failed) {
		expressionS    *exp;
		symbolS        *sym;
		offsetT		failed;

		gas_assert(!symbol_resolved_p(view_assert_failed));

		exp = symbol_get_value_expression(view_assert_failed);
		sym = view_assert_failed;

		/* If view_assert_failed looks like a compound check in the
		 * chain,break it up.  */
		if (exp->X_op == O_add && exp->X_add_number == 0 && exp->X_unsigned) {
			view_assert_failed = exp->X_add_symbol;
			sym = exp->X_op_symbol;
		} else
			view_assert_failed = NULL;

		failed = resolve_symbol_value(sym);
		if (!symbol_resolved_p(sym) || failed) {
			as_bad(("view number mismatch"));
			break;
		}
	}
}
/* ============================================================* ehopt.c */
/*
 * ehopt.c--optimize gcc exception frame information. We include this ELF file,
 * even though we may not be assembling for ELF,since the exception frame
 * information is always in a format derived from DWARF.
 */

/*
 * Try to optimize gcc 2.8 exception frame information. Exception frame
 * information is emitted for every function in the .eh_frame or .debug_frame
 * sections.  Simple information for a function with no exceptions looks like
 * this:
__FRAME_BEGIN__:
	.4byte	.LLCIE1	/ Length of Common Information Entry
.LSCIE1:
#if .eh_frame
	.4byte	0x0	/ CIE Identifier Tag
#elif .debug_frame
	.4byte	0xffffffff / CIE Identifier Tag
#endif
	.byte	0x1	/ CIE Version
	.byte	0x0	/ CIE Augmentation (none)
	.byte	0x1	/ ULEB128 0x1 (CIE Code Alignment Factor)
	.byte	0x7c	/ SLEB128 -4 (CIE Data Alignment Factor)
	.byte	0x8	/ CIE RA Column
	.byte	0xc	/ DW_CFA_def_cfa
	.byte	0x4	/ ULEB128 0x4
	.byte	0x4	/ ULEB128 0x4
	.byte	0x88	/ DW_CFA_offset, column 0x8
	.byte	0x1	/ ULEB128 0x1
	.align 4
.LECIE1:
	.set	.LLCIE1,.LECIE1-.LSCIE1	/ CIE Length Symbol
	.4byte	.LLFDE1	/ FDE Length
.LSFDE1:
	.4byte	.LSFDE1-__FRAME_BEGIN__	/ FDE CIE offset
	.4byte	.LFB1	/ FDE initial location
	.4byte	.LFE1-.LFB1	/ FDE address range
	.byte	0x4	/ DW_CFA_advance_loc4
	.4byte	.LCFI0-.LFB1
	.byte	0xe	/ DW_CFA_def_cfa_offset
	.byte	0x8	/ ULEB128 0x8
	.byte	0x85	/ DW_CFA_offset, column 0x5
	.byte	0x2	/ ULEB128 0x2
	.byte	0x4	/ DW_CFA_advance_loc4
	.4byte	.LCFI1-.LCFI0
	.byte	0xd	/ DW_CFA_def_cfa_register
	.byte	0x5	/ ULEB128 0x5
	.byte	0x4	/ DW_CFA_advance_loc4
	.4byte	.LCFI2-.LCFI1
	.byte	0x2e	/ DW_CFA_GNU_args_size
	.byte	0x4	/ ULEB128 0x4
	.byte	0x4	/ DW_CFA_advance_loc4
	.4byte	.LCFI3-.LCFI2
	.byte	0x2e	/ DW_CFA_GNU_args_size
	.byte	0x0	/ ULEB128 0x0
	.align 4
.LEFDE1:
	.set	.LLFDE1,.LEFDE1-.LSFDE1	/ FDE Length Symbol
 * The immediate issue we can address in the assembler is the DW_CFA_advance_loc4
 * followed by a four byte value.  The value is the difference of two addresses
 * in the function.  Since gcc does not know this value,it always uses four
 * bytes.  We will know the value at the end of assembly,so we can do better.  */
struct cie_info {
	unsigned	code_alignment;
	int		z_augmentation;
};

/* Extract information from the CIE.  */
static int	get_cie_info(struct cie_info *info)
{
	fragS          *f;
	fixS           *fix;
	unsigned int	offset;
	char		CIE_id;
	char		augmentation[10];
	int		iaug;
	int		code_alignment = 0;

	/* We should find the CIE at the start of the section.  */

	f = seg_info(now_seg)->frchainP->frch_root;
	fix = seg_info(now_seg)->frchainP->fix_root;

	/* Look through the frags of the section to find the code alignment.  */

	/* First make sure that the CIE Identifier Tag is 0/-1.  */

	if (startswith(segment_name(now_seg),".debug_frame"))
		CIE_id = (char)0xff;
	else
		CIE_id = 0;

	offset = 4;
	while (f != NULL && offset >= f->fr_fix) {
		offset -= f->fr_fix;
		f = f->fr_next;
	}
	if (f == NULL
	    || f->fr_fix - offset < 4
	    || f->fr_literal[offset] != CIE_id
	    || f->fr_literal[offset + 1] != CIE_id
	    || f->fr_literal[offset + 2] != CIE_id
	    || f->fr_literal[offset + 3] != CIE_id)
		return 0;

	/* Next make sure the CIE version number is 1.  */

	offset += 4;
	while (f != NULL && offset >= f->fr_fix) {
		offset -= f->fr_fix;
		f = f->fr_next;
	}
	if (f == NULL
	    || f->fr_fix - offset < 1
	    || f->fr_literal[offset] != 1)
		return 0;

	/* Skip the augmentation (a null terminated string).  */

	iaug = 0;
	++offset;
	while (1) {
		while (f != NULL && offset >= f->fr_fix) {
			offset -= f->fr_fix;
			f = f->fr_next;
		}
		if (f == NULL)
			return 0;

		while (offset < f->fr_fix && f->fr_literal[offset] != '\0') {
			if ((size_t) iaug < (sizeof augmentation) - 1) {
				augmentation[iaug] = f->fr_literal[offset];
				++iaug;
			}
			++offset;
		}
		if (offset < f->fr_fix)
			break;
	}
	++offset;
	while (f != NULL && offset >= f->fr_fix) {
		offset -= f->fr_fix;
		f = f->fr_next;
	}
	if (f == NULL)
		return 0;

	augmentation[iaug] = '\0';
	if (augmentation[0] == '\0') {
		/* No augmentation.  */
	} else
		if (strcmp(augmentation,"eh") == 0) {
			/*
			 * We have to skip a pointer.  Unfortunately,we don't
			 * know how large it is.  We find out by looking for a
			 * matching fixup.
			 */
			while (fix != NULL
			    && (fix->fx_frag != f || fix->fx_where != offset))
				fix = fix->fx_next;
			if (fix == NULL)
				offset += 4;
			else
				offset += fix->fx_size;
			while (f != NULL && offset >= f->fr_fix) {
				offset -= f->fr_fix;
				f = f->fr_next;
			}
			if (f == NULL)
				return 0;
		} else
			if (augmentation[0] != 'z')
				return 0;

	/* We're now at the code alignment factor,which is a ULEB128.  If it
	 * isn't a single byte,forget it.  */
	code_alignment = f->fr_literal[offset] & 0xff;
	if ((code_alignment & 0x80) != 0)
		code_alignment = 0;

	info->code_alignment = code_alignment;
	info->z_augmentation = (augmentation[0] == 'z');

	return 1;
}

enum frame_state {
	state_idle,state_saw_size,state_saw_cie_offset,state_saw_pc_begin,
	state_seeing_aug_size,state_skipping_aug,state_wait_loc4,
	state_saw_loc4,state_error,
};

struct frame_data {
	enum frame_state state;

	int		cie_info_ok;
	struct cie_info	cie_info;

	symbolS        *size_end_sym;
	fragS          *loc4_frag;
	int		loc4_fix;

	int		aug_size;
	int		aug_shift;
};

static struct eh_state {
	struct frame_data eh_data;
	struct frame_data debug_data;
}		frame;

/* This function is called from emit_expr.  It looks for cases which we can
 * optimize.
 * 
 * Rather than try to parse all this information as we read it,we look for a
 * single byte DW_CFA_advance_loc4 followed by a 4 byte difference.  We turn
 * that into a rs_cfa_advance frag,and handle those frags at the end of the
 * assembly.  If the gcc output changes somewhat,this optimization may stop
 * working.
 * 
 * This function returns non-zero if it handled the expression and emit_expr
 * should not do anything,or zero otherwise.  It can also change *EXP and
 * *PNBYTES.
 */
static int	check_eh_frame(expressionS * exp,unsigned int *pnbytes)
{
	struct frame_data *d;

	/* Don't optimize.  */
	if (flag_traditional_format)
		return 0;

#ifdef md_allow_eh_opt
	if (!md_allow_eh_opt)
		return 0;
#endif

	/* Select the proper section data.  */
	if (startswith(segment_name(now_seg),".eh_frame")
	    && segment_name(now_seg)[9] != '_')
		d = &frame.eh_data;
	else
		if (startswith(segment_name(now_seg),".debug_frame"))
			d = &frame.debug_data;
		else
			return 0;

	if (d->state >= state_saw_size && S_IS_DEFINED(d->size_end_sym)) {
		/*
		 * We have come to the end of the CIE or FDE.  See below where
		 * we set saw_size.  We must check this first because we may
		 * now be looking at the next size.
		 */
		d->state = state_idle;
	}
	switch (d->state) {
	case state_idle:
		if (*pnbytes == 4) {
			/* This might be the size of the CIE or FDE.  We want
			 * to know the size so that we don't accidentally
			 * optimize across an FDE boundary.  We recognize the
			 * size in one of two forms: a symbol which will later
			 * be defined as a difference,or a subtraction of two
			 * symbols.  Either way,we can tell when we are at the
			 * end of the FDE because the symbol becomes defined
			 * (in the case of a subtraction,the end symbol,from
			 * which the start symbol is being subtracted).  Other
			 * ways of describing the size will not be optimized.  */
			if ((exp->X_op == O_symbol || exp->X_op == O_subtract)
			    && !S_IS_DEFINED(exp->X_add_symbol)) {
				d->state = state_saw_size;
				d->size_end_sym = exp->X_add_symbol;
			}
		}
		break;

	case state_saw_size:
	case state_saw_cie_offset:
		/* Assume whatever form it appears in,it appears atomically.  */
		d->state = (enum frame_state)(d->state + 1);
		break;

	case state_saw_pc_begin:
		/* Decide whether we should see an augmentation.  */
		if (!d->cie_info_ok
		    && !(d->cie_info_ok = get_cie_info(&d->cie_info)))
			d->state = state_error;
		else
			if (d->cie_info.z_augmentation) {
				d->state = state_seeing_aug_size;
				d->aug_size = 0;
				d->aug_shift = 0;
			} else
				d->state = state_wait_loc4;
		break;

	case state_seeing_aug_size:
		/* Bytes == -1 means this comes from an leb128 directive.  */
		if ((int)*pnbytes == -1 && exp->X_op == O_constant) {
			d->aug_size = exp->X_add_number;
			d->state = state_skipping_aug;
		} else
			if (*pnbytes == 1 && exp->X_op == O_constant) {
				unsigned char	byte = exp->X_add_number;
				d->aug_size |= (byte & 0x7f) << d->aug_shift;
				d->aug_shift += 7;
				if ((byte & 0x80) == 0)
					d->state = state_skipping_aug;
			} else
				d->state = state_error;
		if (d->state == state_skipping_aug && d->aug_size == 0)
			d->state = state_wait_loc4;
		break;

	case state_skipping_aug:
		if ((int)*pnbytes < 0)
			d->state = state_error;
		else {
			int		left = (d->aug_size -= *pnbytes);
			if (left == 0)
				d->state = state_wait_loc4;
			else
				if (left < 0)
					d->state = state_error;
		}
		break;

	case state_wait_loc4:
		if (*pnbytes == 1
		    && exp->X_op == O_constant
		    && exp->X_add_number == DW_CFA_advance_loc4) {
			/* This might be a DW_CFA_advance_loc4.  Record the
			 * frag and the position within the frag,so that we
			 * can change it later.  */
			frag_grow(1);
			d->state = state_saw_loc4;
			d->loc4_frag = frag_now;
			d->loc4_fix = frag_now_fix();
		}
		break;

	case state_saw_loc4:
		d->state = state_wait_loc4;
		if (*pnbytes != 4)
			break;
		if (exp->X_op == O_constant) {
			/* This is a case which we can optimize.  The two
			 * symbols being subtracted were in the same frag and
			 * the expression was reduced to a constant.  We can do
			 * the optimization entirely in this function.  */
			if (exp->X_add_number < 0x40) {
				d->loc4_frag->fr_literal[d->loc4_fix]
					= DW_CFA_advance_loc|exp->X_add_number;
				/* No more bytes needed.  */
				return 1;
			} else
				if (exp->X_add_number < 0x100) {
					d->loc4_frag->fr_literal[d->loc4_fix] = DW_CFA_advance_loc1;
					*pnbytes = 1;
				} else
					if (exp->X_add_number < 0x10000) {
						d->loc4_frag->fr_literal[d->loc4_fix] = DW_CFA_advance_loc2;
						*pnbytes = 2;
					}
		} else
			if (exp->X_op == O_subtract && d->cie_info.code_alignment == 1) {
				/* This is a case we can optimize.  The
				 * expression was not reduced,so we can not
				 * finish the optimization until the end of the
				 * assembly.  We set up a variant frag which we
				 * handle later.  */
				frag_var(rs_cfa,4,0,1 << 3,make_expr_symbol(exp),
					 d->loc4_fix,(char *)d->loc4_frag);
				return 1;
			} else
				if ((exp->X_op == O_divide
				     || exp->X_op == O_right_shift)
				    && d->cie_info.code_alignment > 1) {
					if (symbol_symbolS(exp->X_add_symbol)
					&& symbol_constant_p(exp->X_op_symbol)
					    && S_GET_SEGMENT(exp->X_op_symbol) == absolute_section
					    && ((exp->X_op == O_divide
						 ? *symbol_X_add_number(exp->X_op_symbol)
						 : (offsetT) 1 << *symbol_X_add_number(exp->X_op_symbol))
						== (offsetT) d->cie_info.code_alignment)) {
						expressionS    *symval;

						symval = symbol_get_value_expression(exp->X_add_symbol);
						if (symval->X_op == O_subtract) {
							/* This is a case we can optimize as well. The
							 * expression was not reduced,so we can not finish 
							 * the optimization until the end of the
							 * assembly. We set up * a variant frag which
							 * we handle later.  */
							frag_var(rs_cfa,4,0,d->cie_info.code_alignment << 3,
								 make_expr_symbol(symval),
								 d->loc4_fix,(char *)d->loc4_frag);
							return 1;
						}
					}
				}
		break;

	case state_error:
		/* Just skipping everything.  */
		break;
	}

	return 0;
}

/* The function estimates the size of a rs_cfa variant frag based on the
 * current values of the symbols.  It is called before the relaxation loop.  We
 * set fr_subtype{0:2} to the expected length.  */
static int	eh_frame_estimate_size_before_relax(fragS * frag)
{
	offsetT		diff;
	int		ca = frag->fr_subtype >> 3;
	int		ret;

	diff = resolve_symbol_value(frag->fr_symbol);

	gas_assert(ca > 0);
	diff /= ca;
	if (diff == 0)
		ret = -1;
	else
		if (diff < 0x40)
			ret = 0;
		else
			if (diff < 0x100)
				ret = 1;
			else
				if (diff < 0x10000)
					ret = 2;
				else
					ret = 4;

	frag->fr_subtype = (frag->fr_subtype & ~7)|(ret & 7);

	return ret;
}

/* This function relaxes a rs_cfa variant frag based on the current values of
 * the symbols.  fr_subtype{0:2} is the current length of the frag.  This
 * returns the change in frag length.  */
static int	eh_frame_relax_frag(fragS * frag)
{
	int		oldsize   ,newsize;

	oldsize = frag->fr_subtype & 7;
	if (oldsize == 7)
		oldsize = -1;
	newsize = eh_frame_estimate_size_before_relax(frag);
	return newsize - oldsize;
}

/* This function converts a rs_cfa variant frag into a normal fill frag.  This
 * is called after all relaxation has been done. fr_subtype{0:2} will be the
 * desired length of the frag.  */
static void	eh_frame_convert_frag(fragS * frag)
{
	offsetT		diff;
	fragS          *loc4_frag;
	int		loc4_fix  ,ca;

	loc4_frag = (fragS *) frag->fr_opcode;
	loc4_fix = (int)frag->fr_offset;

	diff = resolve_symbol_value(frag->fr_symbol);

	ca = frag->fr_subtype >> 3;
	gas_assert(ca > 0);
	diff /= ca;
	switch (frag->fr_subtype & 7) {
	case 0:
		gas_assert(diff < 0x40);
		loc4_frag->fr_literal[loc4_fix] = DW_CFA_advance_loc|diff;
		break;

	case 1:
		gas_assert(diff < 0x100);
		loc4_frag->fr_literal[loc4_fix] = DW_CFA_advance_loc1;
		frag->fr_literal[frag->fr_fix] = diff;
		break;

	case 2:
		gas_assert(diff < 0x10000);
		loc4_frag->fr_literal[loc4_fix] = DW_CFA_advance_loc2;
		md_number_to_chars(frag->fr_literal + frag->fr_fix,diff,2);
		break;

	case 4:
		md_number_to_chars(frag->fr_literal + frag->fr_fix,diff,4);
		break;

	case 7:
		gas_assert(diff == 0);
		frag->fr_fix -= 8;
		break;

	default:
		abort();
	}

	frag->fr_fix += frag->fr_subtype & 7;
	frag->fr_type = rs_fill;
	frag->fr_subtype = 0;
	frag->fr_offset = 0;
}

static void	eh_begin(void)
{
	memset(&frame,0,sizeof(frame));
}
/* ============================================================** expr.c */
/* expr.c -operands,expressions- 
 *
 * This is really a branch office of as-read.c. I split it out to clearly
 * distinguish the world of expressions from the world of statements. (It also
 * gives smaller files to re-compile.) Here,"operand"s are of expressions,not
 * instructions.  */
#define min(a,b)       ((a) < (b) ? (a) : (b))
static void	clean_up_expression(expressionS * expressionP);
/*
 * We keep a mapping of expression symbols to file positions,so that we can
 * provide better error messages.
 */
struct expr_symbol_line {
	struct expr_symbol_line *next;
	symbolS        *sym;
	const char     *file;
	unsigned int	line;
};

static struct expr_symbol_line *expr_symbol_lines;
static const expressionS exp_zero = {.X_op = O_constant};
/*
 * Build a dummy symbol to hold a complex expression.  This is how we build
 * expressions up out of other expressions.  The symbol is put into the fake
 * section expr_section.
 */
static symbolS *make_expr_symbol(const expressionS * expressionP)
{
	symbolS        *symbolP;
	struct expr_symbol_line *n;

	if (expressionP->X_op == O_symbol
	    && expressionP->X_add_number == 0)
		return expressionP->X_add_symbol;

	if (expressionP->X_op == O_big) {
		/*
		 * This won't work,because the actual value is stored in
		 * generic_floating_point_number or generic_bignum,and we are
		 * going to lose it if we haven't already.
		 */
		if (expressionP->X_add_number > 0)
			as_bad(("bignum invalid"));
		else
			as_bad(("floating point number invalid"));
		expressionP = &exp_zero;
	}
	/*
	 * Putting constant symbols in absolute_section rather than
	 * expr_section is convenient for the old a.out code,for which
	 * S_GET_SEGMENT does not always retrieve the value put in by
	 * S_SET_SEGMENT.
	 */
	symbolP = symbol_create(FAKE_LABEL_NAME,
				(expressionP->X_op == O_constant
				 ? absolute_section
				 : expressionP->X_op == O_register
				 ? reg_section
				 : expr_section),
				&zero_address_frag,0);
	symbol_set_value_expression(symbolP,expressionP);

	if (expressionP->X_op == O_constant)
		resolve_symbol_value(symbolP);

	n = notes_alloc(sizeof(*n));
	n->sym = symbolP;
	n->file = as_where(&n->line);
	n->next = expr_symbol_lines;
	expr_symbol_lines = n;

	return symbolP;
}

/*
 * Return the file and line number for an expr symbol.  Return non-zero if
 * something was found,0 if no information is known for the symbol.
 */
static int	expr_symbol_where(symbolS * sym,const char **pfile,unsigned int *pline)
{
	struct expr_symbol_line *l;

	for (l = expr_symbol_lines; l != NULL; l = l->next) {
		if (l->sym == sym) {
			*pfile = l->file;
			*pline = l->line;
			return 1;
		}
	}

	return 0;
}

/*
 * Look up a previously used .startof. / .sizeof. symbol,or make a fresh one.
 */
static symbolS **seen[2];
static unsigned int nr_seen[2];
static symbolS *symbol_lookup_or_make(const char *name,bool start)
{
	char           *buf = concat(start ? ".startof." : ".sizeof.",name,NULL);
	symbolS        *symbolP;
	unsigned int	i;

	for (i = 0; i < nr_seen[start]; ++i) {
		symbolP = seen[start][i];

		if (!symbolP)
			break;

		name = S_GET_NAME(symbolP);
		if ((symbols_case_sensitive
		     ? strcmp(buf,name)
		     : strcasecmp(buf,name)) == 0) {
			free(buf);
			return symbolP;
		}
	}

	symbolP = symbol_make(buf);
	free(buf);

	if (i >= nr_seen[start]) {
		unsigned int	nr = (i + 1) * 2;

		seen[start] = XRESIZEVEC(symbolS *,seen[start],nr);
		nr_seen[start] = nr;
		memset(&seen[start][i + 1],0,(nr - i - 1) * sizeof(seen[0][0]));
	}
	seen[start][i] = symbolP;

	return symbolP;
}

/*
 * Utilities for building expressions. Since complex expressions are recorded
 * as symbols for use in other expressions these return a symbolS * and not an
 * expressionS *. These explicitly do not take an "add_number" argument.
 */
/*
 * ??? For completeness' sake one might want expr_build_symbol. It would just
 * return its argument.
 */

/*
 * Build any floating-point literal here. Also build any bignum literal here.
 */

/*
 * Seems atof_machine can backscan through generic_bignum and hit whatever
 * happens to be loaded before it in memory.  And its way too complicated for
 * me to fix right.  Thus a hack.  JF:  Just make generic_bignum bigger,and
 * never write into the early words,thus they'll always be zero. I hate Dean's
 * floating-point code.  Bleh.
 */
static LITTLENUM_TYPE generic_bignum[SIZE_OF_LARGE_NUMBER + 6];
static FLONUM_TYPE generic_floating_point_number = {
	&generic_bignum[6],	/* low.  (JF: Was 0)  */
	&generic_bignum[SIZE_OF_LARGE_NUMBER + 6 - 1],	/* high.  JF: (added +6)  */
	0,			/* leader.  */
	0,			/* exponent.  */
	0			/* sign.  */
};


static void	floating_constant(expressionS * expressionP)
{
	/* input_line_pointer -> floating-point constant.  */
	int		error_code;

	error_code = atof_generic(&input_line_pointer,".",EXP_CHARS,
				  &generic_floating_point_number);

	if (error_code) {
		if (error_code == ERROR_EXPONENT_OVERFLOW) {
			as_bad(("bad floating-point constant: exponent overflow"));
		} else {
			as_bad(("bad floating-point constant: unknown error code=%d"),
			       error_code);
		}
	}
	expressionP->X_op = O_big;
	/*
	 * input_line_pointer -> just after constant,which may point to
	 * whitespace.
	 */
	expressionP->X_add_number = -1;
}

static uint32_t	generic_bignum_to_int32(void)
{
	return ((((uint32_t) generic_bignum[1] & LITTLENUM_MASK)
		 << LITTLENUM_NUMBER_OF_BITS)
		| ((uint32_t) generic_bignum[0] & LITTLENUM_MASK));
}

static void	integer_constant(int radix,expressionS * expressionP)
{
	char           *start;	/* Start of number.  */
	char		c;
	valueT		number;	/* Offset or (absolute) value.  */
	short int	digit;	/* Value of next digit in current radix.  */
	short int	maxdig = 0;	/* Highest permitted digit value.  */
	int		too_many_digits = 0;	/* If we see >= this number of.  */
	int		small;	/* True if fits in 32 bits.  */

	/* May be bignum,or may fit in 32 bits.  */
	/*
	 * Most numbers fit into 32 bits,and we want this case to be fast. so
	 * we pretend it will fit into 32 bits.  If,after making up a 32 bit
	 * number,we realise that we have scanned more digits than comfortably
	 * fit into 32 bits,we re-scan the digits coding them into a bignum.
	 * For decimal and octal numbers we are conservative: Some numbers may
	 * be assumed bignums when in fact they do fit into 32 bits.  Numbers
	 * of any radix can have excess leading zeros: We strive to recognise
	 * this and cast them back into 32 bits.  We must check that the bignum
	 * really is more than 32 bits,and change it back to a 32-bit number
	 * if it fits.  The number we are looking for is expected to be
	 * positive,but if it fits into 32 bits as an unsigned number,we let
	 * it be a 32-bit number.  The cavalier approach is for speed in
	 * ordinary cases.
	 */
	/*
	 * This has been extended for 64 bits.  We blindly assume that if
	 * you're compiling in 64-bit mode,the target is a 64-bit machine.
	 * This should be cleaned up.
	 */

#ifdef BFD64
#define valuesize 64
#else				/* includes non-bfd case,mostly */
#define valuesize 32
#endif

	if (is_end_of_line[(unsigned char)*input_line_pointer]) {
		expressionP->X_op = O_absent;
		return;
	}
	switch (radix) {
	case 2:
		maxdig = 2;
		too_many_digits = valuesize + 1;
		break;
	case 8:
		maxdig = radix = 8;
		too_many_digits = (valuesize + 2) / 3 + 1;
		break;
	case 16:
		maxdig = radix = 16;
		too_many_digits = (valuesize + 3) / 4 + 1;
		break;
	case 10:
		maxdig = radix = 10;
		too_many_digits = (valuesize + 11) / 4;	/* Very rough.  */
	}
#undef valuesize
	start = input_line_pointer;
	c = *input_line_pointer++;
	for (number = 0;
	     (digit = hex_value(c)) < maxdig;
	     c = *input_line_pointer++) {
		number = number * radix + digit;
	}
	/* c contains character after number.  */
	/* input_line_pointer->char after c.  */
	small = (input_line_pointer - start - 1) < too_many_digits;

	if (radix == 16 && c == '_') {
		/*
		 * This is literal of the form 0x333_0_12345678_1. This example
		 * is equivalent to 0x00000333000000001234567800000001.
		 */

		int		num_little_digits = 0;
		int		i;
		input_line_pointer = start;	/* -> 1st digit.  */

		know(LITTLENUM_NUMBER_OF_BITS == 16);

		for (c = '_'; c == '_'; num_little_digits += 2) {

			/* Convert one 64-bit word.  */
			int		ndigit = 0;
			number = 0;
			for (c = *input_line_pointer++;
			     (digit = hex_value(c)) < maxdig;
			     c = *(input_line_pointer++)) {
				number = number * radix + digit;
				ndigit++;
			}

			/* Check for 8 digit per word max.  */
			if (ndigit > 8)
				as_bad(("a bignum with underscores may not have more than 8 hex digits in any word"));

			/* Add this chunk to the bignum. Shift things down 2
			 * little digits.  */
			know(LITTLENUM_NUMBER_OF_BITS == 16);
			for (i = min(num_little_digits + 1,SIZE_OF_LARGE_NUMBER - 1);
			     i >= 2;
			     i--)
				generic_bignum[i] = generic_bignum[i - 2];

			/*
			 * Add the new digits as the least significant new
			 * ones.
			 */
			generic_bignum[0] = number & 0xffffffff;
			generic_bignum[1] = number >> 16;
		}

		/* Again,c is char after number,input_line_pointer->after c.  */

		if (num_little_digits > SIZE_OF_LARGE_NUMBER - 1)
			num_little_digits = SIZE_OF_LARGE_NUMBER - 1;

		gas_assert(num_little_digits >= 4);

		if (num_little_digits != 8)
			as_bad(("a bignum with underscores must have exactly 4 words"));

		/*
		 * We might have some leading zeros.  These can be trimmed to
		 * give us a change to fit this constant into a small number.
		 */
		while (generic_bignum[num_little_digits - 1] == 0
		       && num_little_digits > 1)
			num_little_digits--;

		if (num_little_digits <= 2) {
			/* will fit into 32 bits.  */
			number = generic_bignum_to_int32();
			small = 1;
		}
#ifdef BFD64
		else
			if (num_little_digits <= 4) {
				/* Will fit into 64 bits.  */
				number = generic_bignum_to_int64();
				small = 1;
			}
#endif
			else {
				small = 0;

				/* Number of littlenums in the bignum.  */
				number = num_little_digits;
			}
	} else
		if (!small) {
			/*
			 * We saw a lot of digits. manufacture a bignum the
			 * hard way.
			 */
			LITTLENUM_TYPE *leader;	/* -> high order littlenum of
						 * the bignum.  */
			LITTLENUM_TYPE *pointer;	/* -> littlenum we are
							 * frobbing now.  */
			long		carry;

			leader = generic_bignum;
			generic_bignum[0] = 0;
			generic_bignum[1] = 0;
			generic_bignum[2] = 0;
			generic_bignum[3] = 0;
			input_line_pointer = start;	/* -> 1st digit.  */
			c = *input_line_pointer++;
			for (; (carry = hex_value(c)) < maxdig; c = *input_line_pointer++) {
				for (pointer = generic_bignum; pointer <= leader; pointer++) {
					long		work;

					work = carry + radix * *pointer;
					*pointer = work & LITTLENUM_MASK;
					carry = work >> LITTLENUM_NUMBER_OF_BITS;
				}
				if (carry) {
					if (leader < generic_bignum + SIZE_OF_LARGE_NUMBER - 1) {
						/*
						 * Room to grow a longer
						 * bignum.
						 */
						*++leader = carry;
					}
				}
			}
			/* Again,c is char after number.  */
			/* input_line_pointer -> after c.  */
			know(LITTLENUM_NUMBER_OF_BITS == 16);
			if (leader < generic_bignum + 2) {
				/* Will fit into 32 bits.  */
				number = generic_bignum_to_int32();
				small = 1;
			}
#ifdef BFD64
			else
				if (leader < generic_bignum + 4) {
					/* Will fit into 64 bits.  */
					number = generic_bignum_to_int64();
					small = 1;
				}
#endif
				else {
					/* Number of littlenums in the bignum.  */
					number = leader - generic_bignum + 1;
				}
		}
#ifndef tc_allow_U_suffix
#define tc_allow_U_suffix 1
#endif
	/* PR 19910: Look for,and ignore,a U suffix to the number.  */
	if (tc_allow_U_suffix && (c == 'U' || c == 'u'))
		c = *input_line_pointer++;

#ifndef tc_allow_L_suffix
#define tc_allow_L_suffix 1
#endif
	/* PR 20732: Look for,and ignore,a L or LL suffix to the number.  */
	if (tc_allow_L_suffix)
		while (c == 'L' || c == 'l')
			c = *input_line_pointer++;

	if (small) {
		/*
		 * Here with number,in correct radix. c is the next char. Note
		 * that unlike un*x,we allow "011f" "0x9f" to both mean the
		 * same as the (conventional) "9f". This is simply easier than
		 * checking for strict canonical form.  Syntax sux!
		 */

		 /* case 'f' */ 
		expressionP->X_op = O_constant;
		expressionP->X_add_number = number;
		input_line_pointer--;	/* Restore following character.  */
	} else {
		/* Not a small number.  */
		expressionP->X_op = O_big;
		expressionP->X_add_number = number;	/* Number of littlenums.  */
		input_line_pointer--;	/* -> char following number.  */
	}
}

/*
 * Return an expression representing the current location.  This handles the
 * magic symbol `.'.
 */
static void	current_location(expressionS * expressionp)
{
	if (now_seg == absolute_section) {
		expressionp->X_op = O_constant;
		expressionp->X_add_number = abs_section_offset;
	} else {
		expressionp->X_op = O_symbol;
		expressionp->X_add_symbol = &dot_symbol;
		expressionp->X_add_number = 0;
	}
}

#ifndef md_register_arithmetic
#define md_register_arithmetic 1
#endif

/*
 * In:	Input_line_pointer points to 1st char of operand,which may be a space.
 * 
 * Out:	An expressionS. The operand may have been empty: in this case X_op ==
 * O_absent. Input_line_pointer->(next non-blank) char after operand.
 */

static segT	operand(expressionS * expressionP,enum expr_mode mode)
{
	char		c;
	symbolS        *symbolP;/* Points to symbol.  */
	char           *name;	/* Points to name of symbol.  */
	segT		segment;
	operatorT	op = O_absent;	/* For unary operators.  */

	/*
	 * All integers are regarded as unsigned unless they are negated. This
	 * is because the only thing which cares whether a number is unsigned
	 * is the code in emit_expr which extends constants into bignums.  It
	 * should only sign extend negative numbers,so that something like
	 * ``.quad 0x80000000'' is not sign extended even though it appears
	 * negative if valueT is 32 bits.
	 */
	expressionP->X_unsigned = 1;
	expressionP->X_extrabit = 0;

	/* Digits,assume it is a bignum.  */

	SKIP_WHITESPACE();	/* Leading whitespace is part of operand.  */
	c = *input_line_pointer++;	/* input_line_pointer -> past char in
					 * c.  */

	if (is_end_of_line[(unsigned char)c])
		goto eol;

	switch (c) {
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
		input_line_pointer--;

		integer_constant(10, expressionP);
		break;

#ifdef LITERAL_PREFIXPERCENT_BIN
kkk
	case '%':
		integer_constant(2,expressionP);
		break;
#endif

	case '0':
		/* Non-decimal radix.  */

		c = *input_line_pointer;
		switch (c) {
		case 'o': case 'O': case 'q': case 'Q': case '8': case '9':
			/* Fall through.  */
		default:
	default_case:
			if (c && strchr(FLT_CHARS,c)) {
				input_line_pointer++;
				floating_constant(expressionP);
				expressionP->X_add_number = -TOLOWER(c);
			} else {
				/* The string was only zero.  */
				expressionP->X_op = O_constant;
				expressionP->X_add_number = 0;
			}

			break;

		case 'x': case 'X':
			input_line_pointer++;
			integer_constant(16,expressionP);
			break;

		case 'b': case 'B':
			if (input_line_pointer[1] == '0'
			    || input_line_pointer[1] == '1') {
				input_line_pointer++;
				integer_constant(2,expressionP);
				break;
			}
			goto default_case;

		case '0': case '1': case '2': case '3': case '4': case '5':
		case '6': case '7':
			integer_constant(8, expressionP);
			break;

		case 'f': case 'd': case 'D': case 'F': case 'r': case 'e':
		case 'E': case 'g': case 'G':
			input_line_pointer++;
			floating_constant(expressionP);
			expressionP->X_add_number = -TOLOWER(c);
			break;

		}

		break;

#ifndef NEED_INDEX_OPERATOR
	case '[':
#ifdef md_need_index_operator
		if (md_need_index_operator())
			goto de_fault;
#endif
#endif
		/* Fall through.  */
	case '(':
		/* Didn't begin with digit & not a name.  */
		segment = expr(0,expressionP,mode);
		/* expression () will pass trailing whitespace.  */
		if ((c == '(' && *input_line_pointer != ')')
		    || (c == '[' && *input_line_pointer != ']')) {
			if (*input_line_pointer)
				as_bad(("found '%c',expected: '%c'"),
				   *input_line_pointer,c == '(' ? ')' : ']');
			else
				as_bad(("missing '%c'"),c == '(' ? ')' : ']');
		} else
			input_line_pointer++;
		SKIP_ALL_WHITESPACE();
		/* Here with input_line_pointer -> char after "(...)".  */
		return segment;

	case '\'':
		/*
		 * Warning: to conform to other people's assemblers NO
		 * ESCAPEMENT is permitted for a single quote.  The next
		 * character,parity errors and all,is taken as the value of
		 * the operand.  VERY KINKY.
		 */
		expressionP->X_op = O_constant;
		expressionP->X_add_number = *input_line_pointer++;
		break;

	case '~':
		/* '~' is permitted to start a label on the Delta.  */
		if (is_name_beginner(c))
			goto isname;
		op = O_bit_not;
		goto unary;

	case '!':
		op = O_logical_not;
		goto unary;

	case '-':
		op = O_uminus;
		/* Fall through.  */
	case '+':
		{
	unary:
			operand(expressionP,mode);

#ifdef md_optimize_expr
			if (md_optimize_expr(NULL,op,expressionP)) {
				/* Skip.  */
				;
			} else
#endif
				if (expressionP->X_op == O_constant) {
					/*
					 * input_line_pointer -> char after
					 * operand.
					 */
					if (op == O_uminus) {
						expressionP->X_add_number
							= -(addressT) expressionP->X_add_number;
						/*
						 * Notice: '-' may overflow: no
						 * warning is given. This is
						 * compatible with other
						 * people's assemblers.  Sigh.
						 */
						expressionP->X_unsigned = 0;
						if (expressionP->X_add_number)
							expressionP->X_extrabit ^= 1;
					} else
						if (op == O_bit_not) {
							expressionP->X_add_number = ~expressionP->X_add_number;
							expressionP->X_extrabit ^= 1;
							expressionP->X_unsigned = 0;
						} else
							if (op == O_logical_not) {
								expressionP->X_add_number = !expressionP->X_add_number;
								expressionP->X_unsigned = 1;
								expressionP->X_extrabit = 0;
							}
				} else
					if (expressionP->X_op == O_big
					    && expressionP->X_add_number <= 0
					    && op == O_uminus
					    && (generic_floating_point_number.sign == '+'
						|| generic_floating_point_number.sign == 'P')) {
						/*
						 * Negative flonum (eg,
						 * -1.000e0).
						 */
						if (generic_floating_point_number.sign == '+')
							generic_floating_point_number.sign = '-';
						else
							generic_floating_point_number.sign = 'N';
					} else
						if (expressionP->X_op == O_big
						    && expressionP->X_add_number > 0) {
							int		i;

							if (op == O_uminus || op == O_bit_not) {
								for (i = 0; i < expressionP->X_add_number; ++i)
									generic_bignum[i] = ~generic_bignum[i];

								/*
								 * Extend the
								 * bignum to at
								 * least the
								 * size of
								 * .octa.
								 */
								if (expressionP->X_add_number < SIZE_OF_LARGE_NUMBER) {
									expressionP->X_add_number = SIZE_OF_LARGE_NUMBER;
									for (; i < expressionP->X_add_number; ++i)
										generic_bignum[i] = ~(LITTLENUM_TYPE) 0;
								}
								if (op == O_uminus)
									for (i = 0; i < expressionP->X_add_number; ++i) {
										generic_bignum[i] += 1;
										if (generic_bignum[i])
											break;
									}
							} else
								if (op == O_logical_not) {
									for (i = 0; i < expressionP->X_add_number; ++i)
										if (generic_bignum[i] != 0)
											break;
									expressionP->X_add_number = i >= expressionP->X_add_number;
									expressionP->X_op = O_constant;
									expressionP->X_unsigned = 1;
									expressionP->X_extrabit = 0;
								}
						} else
							if (expressionP->X_op != O_illegal
							    && expressionP->X_op != O_absent) {
								if (op != O_absent) {
									expressionP->X_add_symbol = make_expr_symbol(expressionP);
									expressionP->X_op = op;
									expressionP->X_add_number = 0;
								} else
									if (!md_register_arithmetic && expressionP->X_op == O_register) {
										/* Convert to binary  '+ ' . */
										expressionP->X_op_symbol = make_expr_symbol(expressionP);
										expressionP->X_add_symbol = make_expr_symbol(&exp_zero);
										expressionP->X_add_number = 0;
										expressionP->X_op = O_add;
									}
							} else
								as_warn(("Unary operator %c ignored because bad operand follows"),
									c);
		}
		break;
	/* The dollar case goes into the default case since "literal_prefix_dollar_hex"
		is false and never changed  */

	case '.':
		if (!is_part_of_name(*input_line_pointer)) {
			current_location(expressionP);
			break;
		} else
			if ((strncasecmp(input_line_pointer,"startof.",8) == 0
			     && !is_part_of_name(input_line_pointer[8]))
			|| (strncasecmp(input_line_pointer,"sizeof.",7) == 0
			    && !is_part_of_name(input_line_pointer[7]))) {
				int		start;

				start = (input_line_pointer[1] == 't'
					 || input_line_pointer[1] == 'T');
				input_line_pointer += start ? 8 : 7;
				SKIP_WHITESPACE();

				/* Cover for the as_bad () invocations below.  */
				expressionP->X_op = O_absent;

				if (*input_line_pointer != '(')
					as_bad(("syntax error in .startof. or .sizeof."));
				else {
					++input_line_pointer;
					SKIP_WHITESPACE();
					c = get_symbol_name(&name);
					if (!*name) {
						as_bad(("expected symbol name"));
						(void)restore_line_pointer(c);
						if (c == ')')
							++input_line_pointer;
						break;
					}
					expressionP->X_op = O_symbol;
					expressionP->X_add_symbol = symbol_lookup_or_make(name,start);
					expressionP->X_add_number = 0;

					*input_line_pointer = c;
					SKIP_WHITESPACE_AFTER_NAME();
					if (*input_line_pointer != ')')
						as_bad(("syntax error in .startof. or .sizeof."));
					else
						++input_line_pointer;
				}
				break;
			} else {
				goto isname;
			}

	case ',':
eol:
		/* Can't imagine any other kind of operand.  */
		expressionP->X_op = O_absent;
		input_line_pointer--;
		break;


	default:
		if (is_name_beginner(c) || c == '"') {	/* Here if did not begin
							 * with a digit.  */
			/* Identifier begins here. This is kludged for speed,
			 * so code is repeated.  */
	isname:
			--input_line_pointer;
			c = get_symbol_name(&name);

			/* This is a hook for the backend to parse certain
			 * names specially in certain contexts.  If a name
			 * always has a specific value,it can often be handled
			 * by simply entering it in the symbol table.  */
			if (riscv_parse_name(name,expressionP,mode)) {
				restore_line_pointer(c);
				break;
			}
			symbolP = symbol_find_or_make(name);

			/* If we have an absolute symbol or a reg,then we know
			 * its value now.  */
			segment = S_GET_SEGMENT(symbolP);
			if (mode != expr_defer
			    && segment == absolute_section
			    && !S_FORCE_RELOC(symbolP,0)) {
				expressionP->X_op = O_constant;
				expressionP->X_add_number = S_GET_VALUE(symbolP);
			} else
				if (mode != expr_defer && segment == reg_section) {
					expressionP->X_op = O_register;
					expressionP->X_add_number = S_GET_VALUE(symbolP);
				} else {
					expressionP->X_op = O_symbol;
					expressionP->X_add_symbol = symbolP;
					expressionP->X_add_number = 0;
				}

			restore_line_pointer(c);
		} else {
			/* Let the target try to parse it.  Success is
			 * indicated by changing the X_op field to something
			 * other than O_absent and pointing input_line_pointer
			 * past the expression.  If it can't parse the
			 * expression,X_op and input_line_pointer should be
			 * unchanged.  */
			expressionP->X_op = O_absent;
			--input_line_pointer;
			md_operand(expressionP);
			if (expressionP->X_op == O_absent) {
				++input_line_pointer;
				as_bad(("bad expression"));
				expressionP->X_op = O_constant;
				expressionP->X_add_number = 0;
			}
		}
		break;
	}

	/* It is more 'efficient' to clean up the expressionS when they are
	 * created.  Doing it here saves lines of code.  */
	clean_up_expression(expressionP);
	SKIP_ALL_WHITESPACE();	/* -> 1st char after operand.  */
	know(*input_line_pointer != ' ');

	/* The PA port needs this information.  */
	if (expressionP->X_add_symbol)
		symbol_mark_used(expressionP->X_add_symbol);

	if (mode != expr_defer) {
		expressionP->X_add_symbol
			= symbol_clone_if_forward_ref(expressionP->X_add_symbol);
		expressionP->X_op_symbol
			= symbol_clone_if_forward_ref(expressionP->X_op_symbol);
	}
	switch (expressionP->X_op) {
	default:
		return absolute_section;
	case O_symbol:
		return S_GET_SEGMENT(expressionP->X_add_symbol);
	case O_register:
		return reg_section;
	}
}

/* Internal.  Simplify a struct expression for use by expr ().  */

/* In:	address of an expressionS. The X_op field of the expressionS may only
 * take certain values. Elsewise we waste time special-case testing. Sigh.
 * Ditto SEG_ABSENT.
 * 
 * Out:	expressionS may have been modified: Unused fields zeroed to help expr
 * ().  */
static void	clean_up_expression(expressionS * expressionP)
{
	switch (expressionP->X_op) {
	case O_illegal:
	case O_absent:
		expressionP->X_add_number = 0;
		/* Fall through.  */
	case O_big:
	case O_constant:
	case O_register:
		expressionP->X_add_symbol = NULL;
		/* Fall through.  */
	case O_symbol:
	case O_uminus:
	case O_bit_not:
		expressionP->X_op_symbol = NULL;
		break;
	default:
		break;
	}
}

/* Expression parser.  */

/*
 * We allow an empty expression,and just assume (absolute,0) silently. Unary
 * operators and parenthetical expressions are treated as operands. As usual,
 * Q==quantity==operand,O==operator,X==expression mnemonics.
 * 
 * We used to do an aho/ullman shift-reduce parser,but the logic got so warped
 * that I flushed it and wrote a recursive-descent parser instead. Now things
 * are stable,would anybody like to write a fast parser? Most expressions are
 * either register (which does not even reach here) or 1 symbol. Then
 * "symbol+constant" and "symbol-symbol" are common. So I guess it doesn't
 * really matter how inefficient more complex expressions are parsed.
 * 
 * After expr(RANK,resultP) input_line_pointer->operator of rank <= RANK. Also,we
 * have consumed any leading or trailing spaces (operand does that) and done
 * all intervening operators.
 * 
 * This returns the segment of the result,which will be absolute_section or the
 * segment of a symbol.
 */

#undef __
#define __ O_illegal
#ifndef O_SINGLE_EQ
#define O_SINGLE_EQ O_illegal
#endif

/* Maps ASCII -> operators.  */
static const operatorT op_encoding[256] = {
	__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,
	__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,

	__,O_bit_or_not,__,__,__,O_modulus,O_bit_and,__,
	__,__,O_multiply,O_add,__,O_subtract,__,O_divide,
	__,__,__,__,__,__,__,__,
	__,__,__,__,O_lt,O_SINGLE_EQ,O_gt,__,
	__,__,__,__,__,__,__,__,
	__,__,__,__,__,__,__,__,
	__,__,__,__,__,__,__,__,
	__,__,__,
#ifdef NEED_INDEX_OPERATOR
	O_index,
#else
	__,
#endif
	__,__,O_bit_exclusive_or,__,
	__,__,__,__,__,__,__,__,
	__,__,__,__,__,__,__,__,
	__,__,__,__,__,__,__,__,
	__,__,__,__,O_bit_inclusive_or,__,__,__,

	__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,
	__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,
	__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,
	__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,
	__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,
	__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,
	__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,
	__,__,__,__,__,__,__,__,__,__,__,__,__,__,__,__
};

/*
 * Rank	Examples 0	operand,(expression) 1	|| 2	&& 3	== <> < <= >= >
 * 4	+ - 5	used for * / % in MRI mode 6	& ^ !|7	* / % << >> 8
 * unary - unary ~
 */
static operator_rankT op_rank[O_max] = {
	0,			/* O_illegal */
	0,			/* O_absent */
	0,			/* O_constant */
	0,			/* O_symbol */
	0,			/* O_symbol_rva */
	0,			/* O_secidx */
	0,			/* O_register */
	0,			/* O_big */
	9,			/* O_uminus */
	9,			/* O_bit_not */
	9,			/* O_logical_not */
	8,			/* O_multiply */
	8,			/* O_divide */
	8,			/* O_modulus */
	8,			/* O_left_shift */
	8,			/* O_right_shift */
	7,			/* O_bit_inclusive_or */
	7,			/* O_bit_or_not */
	7,			/* O_bit_exclusive_or */
	7,			/* O_bit_and */
	5,			/* O_add */
	5,			/* O_subtract */
	4,			/* O_eq */
	4,			/* O_ne */
	4,			/* O_lt */
	4,			/* O_le */
	4,			/* O_ge */
	4,			/* O_gt */
	3,			/* O_logical_and */
	2,			/* O_logical_or */
	1,			/* O_index */
};

static void	expr_set_precedence(void)
{
	op_rank[O_multiply] = 8;
	op_rank[O_divide] = 8;
	op_rank[O_modulus] = 8;
}

/* Initialize the expression parser.  */
static void	expr_begin(void)
{
	expr_set_precedence();

	memset(seen,0,sizeof seen);
	memset(nr_seen,0,sizeof nr_seen);
	expr_symbol_lines = NULL;
}

static void	expr_end(void)
{
	for (size_t i = 0; i < ARRAY_SIZE(seen); i++)
		free(seen[i]);
}

/* Return the encoding for the operator at INPUT_LINE_POINTER,and sets
 * NUM_CHARS to the number of characters in the operator. Does not advance
 * INPUT_LINE_POINTER.  */
static inline operatorT operatorf(int *num_chars)
{
	int		c;
	operatorT	ret;

	c = *input_line_pointer & 0xff;
	*num_chars = 1;

	if (is_end_of_line[c])
		return O_illegal;

#ifdef md_operator
	if (is_name_beginner(c)) {
		char           *name;
		char		ec = get_symbol_name(&name);

		ret = md_operator(name,2,&ec);
		switch (ret) {
		case O_absent:
			*input_line_pointer = ec;
			input_line_pointer = name;
			break;
		case O_uminus:
		case O_bit_not:
		case O_logical_not:
			as_bad(("invalid use of operator \"%s\""),name);
			ret = O_illegal;
			/* FALLTHROUGH */
		default:
			*input_line_pointer = ec;
			*num_chars = input_line_pointer - name;
			input_line_pointer = name;
			return ret;
		}
	}
#endif

	switch (c) {
	default:
		ret = op_encoding[c];
#ifdef md_operator
		if (ret == O_illegal) {
			char           *start = input_line_pointer;

			ret = md_operator(NULL,2,NULL);
			if (ret != O_illegal)
				*num_chars = input_line_pointer - start;
			input_line_pointer = start;
		}
#endif
		return ret;

	case '+':
	case '-':
		return op_encoding[c];

	case '<':
		switch (input_line_pointer[1]) {
		default:
			return op_encoding[c];
		case '<':
			ret = O_left_shift;
			break;
		case '>':
			ret = O_ne;
			break;
		case '=':
			ret = O_le;
			break;
		}
		*num_chars = 2;
		return ret;

	case '=':
		if (input_line_pointer[1] != '=')
			return op_encoding[c];

		*num_chars = 2;
		return O_eq;

	case '>':
		switch (input_line_pointer[1]) {
		default:
			return op_encoding[c];
		case '>':
			ret = O_right_shift;
			break;
		case '=':
			ret = O_ge;
			break;
		}
		*num_chars = 2;
		return ret;

	case '!':
		switch (input_line_pointer[1]) {
		case '!':
			/*
			 * We accept !! as equivalent to ^ for MRI
			 * compatibility.
			 */
			*num_chars = 2;
			return O_bit_exclusive_or;
		case '=':
			/* We accept != as equivalent to <>.  */
			*num_chars = 2;
			return O_ne;
		default:
			return op_encoding[c];
		}

	case '|':
		if (input_line_pointer[1] != '|')
			return op_encoding[c];

		*num_chars = 2;
		return O_logical_or;

	case '&':
		if (input_line_pointer[1] != '&')
			return op_encoding[c];

		*num_chars = 2;
		return O_logical_and;
	}
	/* NOTREACHED  */
}

/* Implement "word-size + 1 bit" addition for
 * {resultP->X_extrabit:resultP->X_add_number} + {rhs_highbit:amount}.  This is
 * used so that the full range of unsigned word values and the full range of
 * signed word values can be represented in an O_constant expression,which is
 * useful e.g. for .sleb128 directives.  */
static void	add_to_result(expressionS * resultP,offsetT amount,int rhs_highbit)
{
	valueT		ures = resultP->X_add_number;
	valueT		uamount = amount;

	resultP->X_add_number += uamount;

	resultP->X_extrabit ^= rhs_highbit;

	if (ures + uamount < ures)
		resultP->X_extrabit ^= 1;
}

/* Similarly,for subtraction.  */
static void	subtract_from_result(expressionS * resultP,offsetT amount,int rhs_highbit)
{
	valueT		ures = resultP->X_add_number;
	valueT		uamount = amount;

	resultP->X_add_number -= uamount;

	resultP->X_extrabit ^= rhs_highbit;

	if (ures < uamount)
		resultP->X_extrabit ^= 1;
}

/* Parse an expression.  */
static segT	expr(int rankarg,	/* Larger # is higher rank.  */
		 		expressionS *	resultP,	/* Deliver result here.  */
     		enum		expr_mode mode /* Controls behavior.  */ )
{
	operator_rankT	rank = (operator_rankT) rankarg;
	segT		retval;
	expressionS	right;
	operatorT	op_left;
	operatorT	op_right;
	int		op_chars;

	know(rankarg >= 0);

	/* Save the value of dot for the fixup code.  */
	if (rank == 0) {
		dot_value = frag_now_fix();
		dot_frag = frag_now;
	}
	retval = operand(resultP,mode);

	/* operand () gobbles spaces.  */
	know(*input_line_pointer != ' ');

	op_left = operatorf(&op_chars);
	while (op_left != O_illegal && op_rank[(int)op_left] > rank) {
		segT		rightseg;
		bool		is_unsigned;
		offsetT		frag_off;

		input_line_pointer += op_chars;	/* -> after operator.  */

		right.X_md = 0;
		rightseg = expr(op_rank[(int)op_left],&right,mode);
		if (right.X_op == O_absent) {
			as_warn(("missing operand; zero assumed"));
			right.X_op = O_constant;
			right.X_add_number = 0;
			right.X_add_symbol = NULL;
			right.X_op_symbol = NULL;
		}
		know(*input_line_pointer != ' ');

		if (op_left == O_index) {
			if (*input_line_pointer != ']')
				as_bad("missing right bracket");
			else {
				++input_line_pointer;
				SKIP_WHITESPACE();
			}
		}
		op_right = operatorf(&op_chars);

		know(op_right == O_illegal || op_left == O_index
		     || op_rank[(int)op_right] <= op_rank[(int)op_left]);
		know((int)op_left >= (int)O_multiply);
#ifndef md_operator
		know((int)op_left <= (int)O_index);
#else
		know((int)op_left < (int)O_max);
#endif

		/* input_line_pointer->after right-hand quantity.  */
		/* left-hand quantity in resultP.  */
		/* right-hand quantity in right.  */
		/* operator in op_left.  */

		if (resultP->X_op == O_big) {
			if (resultP->X_add_number > 0)
				as_warn(("left operand is a bignum; integer 0 assumed"));
			else
				as_warn(("left operand is a float; integer 0 assumed"));
			resultP->X_op = O_constant;
			resultP->X_add_number = 0;
			resultP->X_add_symbol = NULL;
			resultP->X_op_symbol = NULL;
		}
		if (right.X_op == O_big) {
			if (right.X_add_number > 0)
				as_warn(("right operand is a bignum; integer 0 assumed"));
			else
				as_warn(("right operand is a float; integer 0 assumed"));
			right.X_op = O_constant;
			right.X_add_number = 0;
			right.X_add_symbol = NULL;
			right.X_op_symbol = NULL;
		}
		is_unsigned = resultP->X_unsigned && right.X_unsigned;

		if (mode == expr_defer
		    && ((resultP->X_add_symbol != NULL
			 && S_IS_FORWARD_REF(resultP->X_add_symbol))
			|| (right.X_add_symbol != NULL
			    && S_IS_FORWARD_REF(right.X_add_symbol))))
			goto general;

		/* Optimize common cases.  */
#ifdef md_optimize_expr
		if (md_optimize_expr(resultP,op_left,&right)) {
			/* Skip.  */
			is_unsigned = resultP->X_unsigned;
		} else
#endif
			if (op_left == O_add && right.X_op == O_constant
			    && (md_register_arithmetic || resultP->X_op != O_register)) {
				/* X + constant.  */
				add_to_result(resultP,right.X_add_number,right.X_extrabit);
			}
		/* This case comes up in PIC code.  */
			else
				if (op_left == O_subtract
				    && right.X_op == O_symbol
				    && resultP->X_op == O_symbol
				    && retval == rightseg
#ifdef md_allow_local_subtract
				    && md_allow_local_subtract(resultP,&right,rightseg)
#endif
				    && ((SEG_NORMAL(rightseg)
				   && !S_FORCE_RELOC(resultP->X_add_symbol,0)
				     && !S_FORCE_RELOC(right.X_add_symbol,0))
				|| right.X_add_symbol == resultP->X_add_symbol)
				    && frag_offset_fixed_p(symbol_get_frag(resultP->X_add_symbol),
					  symbol_get_frag(right.X_add_symbol),
							   &frag_off)) {
					offsetT		symval_diff = S_GET_VALUE(resultP->X_add_symbol)
					- S_GET_VALUE(right.X_add_symbol);
					subtract_from_result(resultP,right.X_add_number,right.X_extrabit);
					subtract_from_result(resultP,frag_off / OCTETS_PER_BYTE,0);
					add_to_result(resultP,symval_diff,symval_diff < 0);
					resultP->X_op = O_constant;
					resultP->X_add_symbol = 0;
					is_unsigned = false;
				} else
					if (op_left == O_subtract && right.X_op == O_constant
					    && (md_register_arithmetic || resultP->X_op != O_register)) {
						/* X - constant.  */
						subtract_from_result(resultP,right.X_add_number,right.X_extrabit);
						is_unsigned = false;
					} else
						if (op_left == O_add && resultP->X_op == O_constant
						    && (md_register_arithmetic || right.X_op != O_register)) {
							/* Constant + X.  */
							resultP->X_op = right.X_op;
							resultP->X_add_symbol = right.X_add_symbol;
							resultP->X_op_symbol = right.X_op_symbol;
							add_to_result(resultP,right.X_add_number,right.X_extrabit);
							retval = rightseg;
						} else
							if (resultP->X_op == O_constant && right.X_op == O_constant) {
								/*
								 * Constant OP
								 * constant.
								 */
								offsetT		v = right.X_add_number;
								if (v == 0 && (op_left == O_divide || op_left == O_modulus)) {
									as_warn(("division by zero"));
									v = 1;
								}
								switch (op_left) {
								default:
									goto general;
								case O_multiply:
								/*
								Do the multiply as unsig ned to silence ubsan.
								The result is of* course the same when we throw
								away high bits of the result.  */
									resultP->X_add_number *= (valueT) v;
									break;
								case O_divide:
									resultP->X_add_number /= v;
									break;
								case O_modulus:
									resultP->X_add_number %= v;
									break;
								case O_left_shift:
								case O_right_shift:
					          /* We always use unsigned shifts.  According to the ISO
         						C standard, left shift of a signed type having a
         						negative value is undefined behaviour, and right
         						shift of a signed type having negative value is
         						implementation defined.  Left shift of a signed type
         						when the result overflows is also undefined
         						behaviour.  So don't trigger ubsan warnings or rely
         						on characteristics of the compiler.  */
									if ((valueT) v >= sizeof(valueT) * CHAR_BIT) {
										as_warn_value_out_of_range(("shift count"),v,0,
													   sizeof(valueT) * CHAR_BIT - 1,
													   NULL,0);
										resultP->X_add_number = 0;
									} else
										if (op_left == O_left_shift)
											resultP->X_add_number
												= (valueT) resultP->X_add_number << (valueT) v;
										else
											resultP->X_add_number
												= (valueT) resultP->X_add_number >> (valueT) v;
									is_unsigned = resultP->X_unsigned;
									break;
								case O_bit_inclusive_or:
									resultP->X_add_number |= v;
									break;
								case O_bit_or_not:
									resultP->X_add_number |= ~v;
									break;
								case O_bit_exclusive_or:
									resultP->X_add_number ^= v;
									break;
								case O_bit_and:
									resultP->X_add_number &= v;
									break;
					          /* Constant + constant (O_add) is handled by the
   							      previous if statement for constant + X, so is omitted 
								  here.  */
								case O_subtract:
									subtract_from_result(resultP,v,0);
									is_unsigned = false;
									break;
								case O_eq:
									resultP->X_add_number =
										resultP->X_add_number == v ? ~(offsetT) 0 : 0;
									is_unsigned = false;
									break;
								case O_ne:
									resultP->X_add_number =
										resultP->X_add_number != v ? ~(offsetT) 0 : 0;
									is_unsigned = false;
									break;
								case O_lt:
									resultP->X_add_number =
										resultP->X_add_number < v ? ~(offsetT) 0 : 0;
									is_unsigned = false;
									break;
								case O_le:
									resultP->X_add_number =
										resultP->X_add_number <= v ? ~(offsetT) 0 : 0;
									is_unsigned = false;
									break;
								case O_ge:
									resultP->X_add_number =
										resultP->X_add_number >= v ? ~(offsetT) 0 : 0;
									is_unsigned = false;
									break;
								case O_gt:
									resultP->X_add_number =
										resultP->X_add_number > v ? ~(offsetT) 0 : 0;
									is_unsigned = false;
									break;
								case O_logical_and:
									resultP->X_add_number = resultP->X_add_number && v;
									is_unsigned = true;
									break;
								case O_logical_or:
									resultP->X_add_number = resultP->X_add_number || v;
									is_unsigned = true;
									break;
								}
							} else
								if (resultP->X_op == O_symbol
								    && right.X_op == O_symbol
								    && (op_left == O_add
									|| op_left == O_subtract
									|| (resultP->X_add_number == 0
									    && right.X_add_number == 0))) {
									/* Symbol OP symbol.  */
									resultP->X_op = op_left;
									resultP->X_op_symbol = right.X_add_symbol;
									if (op_left == O_add)
										add_to_result(resultP,right.X_add_number,right.X_extrabit);
									else
										if (op_left == O_subtract) {
											subtract_from_result(resultP,right.X_add_number,
													     right.X_extrabit);
											if (retval == rightseg
											    && SEG_NORMAL(retval)
											    && !S_FORCE_RELOC(resultP->X_add_symbol,0)
											    && !S_FORCE_RELOC(right.X_add_symbol,0)) {
												retval = absolute_section;
												rightseg = absolute_section;
											}
										}
								} else {
							general:
									/* The general case. */
									resultP->X_add_symbol = make_expr_symbol(resultP);
									resultP->X_op_symbol = make_expr_symbol(&right);
									resultP->X_op = op_left;
									resultP->X_add_number = 0;
									resultP->X_extrabit = 0;
								}

		resultP->X_unsigned = is_unsigned;

		if (retval != rightseg) {
			if (retval == undefined_section);
			else
				if (rightseg == undefined_section)
					retval = rightseg;
				else
					if (retval == expr_section);
					else
						if (rightseg == expr_section)
							retval = rightseg;
						else
							if (retval == reg_section);
							else
								if (rightseg == reg_section)
									retval = rightseg;
								else
									if (rightseg == absolute_section);
									else
										if (retval == absolute_section)
											retval = rightseg;
#ifdef DIFF_EXPR_OK
										else
											if (op_left == O_subtract);
#endif
											else
												as_bad(("operation combines symbols in different segments"));
		}
		op_left = op_right;
	}			/* While next operator is >= this rank.  */

	/* The PA port needs this information.  */
	if (resultP->X_add_symbol)
		symbol_mark_used(resultP->X_add_symbol);

	if (rank == 0 && mode == expr_evaluate)
		resolve_expression(resultP);

	return resultP->X_op == O_constant ? absolute_section : retval;
}

/* Resolve an expression without changing any symbols/sub-expressions used.  */
static int	resolve_expression(expressionS * expressionP)
{
	/* Help out with CSE.  */
	valueT		final_val = expressionP->X_add_number;
	symbolS        *add_symbol = expressionP->X_add_symbol;
	symbolS        *orig_add_symbol = add_symbol;
	symbolS        *op_symbol = expressionP->X_op_symbol;
	operatorT	op = expressionP->X_op;
	valueT		left   ,right;
	segT		seg_left ,seg_right;
	fragS          *frag_left,*frag_right;
	offsetT		frag_off;

	switch (op) {
	default:
		return 0;

	case O_constant:
	case O_register:
		left = 0;
		break;

	case O_symbol:
	case O_symbol_rva:
		if (!snapshot_symbol(&add_symbol,&left,&seg_left,&frag_left))
			return 0;

		break;

	case O_uminus:
	case O_bit_not:
	case O_logical_not:
		if (!snapshot_symbol(&add_symbol,&left,&seg_left,&frag_left))
			return 0;

		if (seg_left != absolute_section)
			return 0;

		if (op == O_logical_not)
			left = !left;
		else
			if (op == O_uminus)
				left = -left;
			else
				left = ~left;
		op = O_constant;
		break;

	case O_multiply:
	case O_divide:
	case O_modulus:
	case O_left_shift:
	case O_right_shift:
	case O_bit_inclusive_or:
	case O_bit_or_not:
	case O_bit_exclusive_or:
	case O_bit_and:
	case O_add:
	case O_subtract:
	case O_eq:
	case O_ne:
	case O_lt:
	case O_le:
	case O_ge:
	case O_gt:
	case O_logical_and:
	case O_logical_or:
		if (!snapshot_symbol(&add_symbol,&left,&seg_left,&frag_left)
		    || !snapshot_symbol(&op_symbol,&right,&seg_right,&frag_right))
			return 0;

		/*
		 * Simplify addition or subtraction of a constant by folding
		 * the constant into X_add_number.
		 */
		if (op == O_add) {
			if (seg_right == absolute_section) {
				final_val += right;
				op = O_symbol;
				break;
			} else
				if (seg_left == absolute_section) {
					final_val += left;
					left = right;
					seg_left = seg_right;
					add_symbol = op_symbol;
					orig_add_symbol = expressionP->X_op_symbol;
					op = O_symbol;
					break;
				}
		} else
			if (op == O_subtract) {
				if (seg_right == absolute_section) {
					final_val -= right;
					op = O_symbol;
					break;
				}
			}
		/*
		 * Equality and non-equality tests are permitted on anything.
		 * Subtraction,and other comparison operators are permitted if
		 * both operands are in the same section. Shifts by constant
		 * zero are permitted on anything. Multiplies,bit-ors,and
		 * bit-ands with constant zero are permitted on anything.
		 * Multiplies and divides by constant one are permitted on
		 * anything. Binary operations with both operands being the
		 * same register or undefined symbol are permitted if the
		 * result doesn't depend on the input value. Otherwise,both
		 * operands must be absolute.  We already handled the case of
		 * addition or subtraction of a constant above.
		 */
		frag_off = 0;
		if (!(seg_left == absolute_section
		      && seg_right == absolute_section)
		    && !(op == O_eq || op == O_ne)
		    && !((op == O_subtract
		      || op == O_lt || op == O_le || op == O_ge || op == O_gt)
			 && seg_left == seg_right
			 && (finalize_syms
		      || frag_offset_fixed_p(frag_left,frag_right,&frag_off)
			     || (op == O_gt
				 && frag_gtoffset_p(left,frag_left,
					       right,frag_right,&frag_off)))
			 && (seg_left != reg_section || left == right)
			 && (seg_left != undefined_section || add_symbol == op_symbol))) {
			if ((seg_left == absolute_section && left == 0)
			    || (seg_right == absolute_section && right == 0)) {
				if (op == O_bit_exclusive_or || op == O_bit_inclusive_or) {
					if (!(seg_right == absolute_section && right == 0)) {
						seg_left = seg_right;
						left = right;
						add_symbol = op_symbol;
						orig_add_symbol = expressionP->X_op_symbol;
					}
					op = O_symbol;
					break;
				} else
					if (op == O_left_shift || op == O_right_shift) {
						if (!(seg_left == absolute_section && left == 0)) {
							op = O_symbol;
							break;
						}
					} else
						if (op != O_multiply
						    && op != O_bit_or_not && op != O_bit_and)
							return 0;
			} else
				if (op == O_multiply
				&& seg_left == absolute_section && left == 1) {
					seg_left = seg_right;
					left = right;
					add_symbol = op_symbol;
					orig_add_symbol = expressionP->X_op_symbol;
					op = O_symbol;
					break;
				} else
					if ((op == O_multiply || op == O_divide)
					    && seg_right == absolute_section && right == 1) {
						op = O_symbol;
						break;
					} else
						if (!(left == right
						      && ((seg_left == reg_section && seg_right == reg_section)
							  || (seg_left == undefined_section
							      && seg_right == undefined_section
						&& add_symbol == op_symbol))))
							return 0;
						else
							if (op == O_bit_and || op == O_bit_inclusive_or) {
								op = O_symbol;
								break;
							} else
								if (op != O_bit_exclusive_or && op != O_bit_or_not)
									return 0;
		}
		right += frag_off / OCTETS_PER_BYTE;
		switch (op) {
		case O_add:
			left += right;
			break;
		case O_subtract:
			left -= right;
			break;
		case O_multiply:
			left *= right;
			break;
		case O_divide:
			if (right == 0)
				return 0;
			left = (offsetT) left / (offsetT) right;
			break;
		case O_modulus:
			if (right == 0)
				return 0;
			left = (offsetT) left % (offsetT) right;
			break;
		case O_left_shift:
			if (right >= sizeof(left) * CHAR_BIT)
				left = 0;
			else
				left <<= right;
			break;
		case O_right_shift:
			if (right >= sizeof(left) * CHAR_BIT)
				left = 0;
			else
				left >>= right;
			break;
		case O_bit_inclusive_or:
			left |= right;
			break;
		case O_bit_or_not:
			left |= ~right;
			break;
		case O_bit_exclusive_or:
			left ^= right;
			break;
		case O_bit_and:
			left &= right;
			break;
		case O_eq:
		case O_ne:
			left = (left == right
				&& seg_left == seg_right
				&& (finalize_syms || frag_left == frag_right)
				&& (seg_left != undefined_section
				    || add_symbol == op_symbol)
				? ~(valueT) 0 : 0);
			if (op == O_ne)
				left = ~left;
			break;
		case O_lt:
			left = (offsetT) left < (offsetT) right ? ~(valueT) 0 : 0;
			break;
		case O_le:
			left = (offsetT) left <= (offsetT) right ? ~(valueT) 0 : 0;
			break;
		case O_ge:
			left = (offsetT) left >= (offsetT) right ? ~(valueT) 0 : 0;
			break;
		case O_gt:
			left = (offsetT) left > (offsetT) right ? ~(valueT) 0 : 0;
			break;
		case O_logical_and:
			left = left && right;
			break;
		case O_logical_or:
			left = left || right;
			break;
		default:
			abort();
		}

		op = O_constant;
		break;
	}

	if (op == O_symbol) {
		if (seg_left == absolute_section)
			op = O_constant;
		else
			if (seg_left == reg_section && final_val == 0)
				op = O_register;
			else
				if (!symbol_same_p(add_symbol,orig_add_symbol))
					final_val += left;
		expressionP->X_add_symbol = add_symbol;
	}
	expressionP->X_op = op;

	if (op == O_constant || op == O_register)
		final_val += left;
	expressionP->X_add_number = final_val;

	return 1;
}

/* This lives here because it belongs equally in expr.c & read.c. expr.c is
 * just a branch office read.c anyway,and putting it here lessens the crowd at
 * read.c.
 * 
 * Assume input_line_pointer is at start of symbol name,or the start of a double
 * quote enclosed symbol name.  Advance input_line_pointer past symbol name.
 * Turn that character into a '\0',returning its former value,which may be
 * the closing double quote.
 * 
 * This allows a string compare (RMS wants symbol names to be strings) of the
 * symbol name.
 * 
 * NOTE: The input buffer is further altered when adjacent strings are
 * concatenated by the function.  Callers caring about the original buffer
 * contents will need to make a copy before calling here.
 * 
 * There will always be a char following symbol name,because all good lines end
 * in end-of-line.  */
static char	get_symbol_name(char **ilp_return)
{
	char		c;

	*ilp_return = input_line_pointer;
	/*
	 * We accept FAKE_LABEL_CHAR in a name in case this is being called
	 * with a constructed string.
	 */
	if (is_name_beginner(c = *input_line_pointer++)
	    || (input_from_string && c == FAKE_LABEL_CHAR)) {
		while (is_part_of_name(c = *input_line_pointer++)
		       || (input_from_string && c == FAKE_LABEL_CHAR))
				;
		if (is_name_ender(c))
			c = *input_line_pointer++;
	} else
		if (c == '"') {
			char           *dst = input_line_pointer;

			*ilp_return = input_line_pointer;
			for (;;) {
				c = *input_line_pointer++;

				if (c == 0) {
					as_warn(("missing closing '\"'"));
					break;
				}
				if (c == '"') {
					char           *ilp_save = input_line_pointer;

					SKIP_WHITESPACE();
					if (*input_line_pointer == '"') {
						++input_line_pointer;
						continue;
					}
					input_line_pointer = ilp_save;
					break;
				}
				if (c == '\\')
					switch (*input_line_pointer) {
					case '"':
					case '\\':
						c = *input_line_pointer++;
						break;

					default:
						if (c != 0)
							as_warn(("'\\%c' in quoted symbol name; "
								 "behavior may change in the future"),
							 *input_line_pointer);
						break;
					}

				*dst++ = c;
			}
			*dst = 0;
		}
	*--input_line_pointer = 0;
	return c;
}

/* Replace the NUL character pointed to by input_line_pointer with C.  If C is
 * \" then advance past it.  Return the character now pointed to by
 * input_line_pointer.  */
static char	restore_line_pointer(char c)
{
	*input_line_pointer = c;
	if (c == '"')
		c = *++input_line_pointer;
	return c;
}

static unsigned int get_single_number(void)
{
	expressionS	exp;
	operand(&exp,expr_normal);
	return exp.X_add_number;
}
/* ======================================================= flonum-copy.c */
/* flonum_copy.c - copy a flonum  */
static void	flonum_copy(FLONUM_TYPE * in,FLONUM_TYPE * out)
{
	unsigned int	in_length;	/* 0 origin */
	unsigned int	out_length;	/* 0 origin */

	out->sign = in->sign;
	in_length = in->leader - in->low;

	if (in->leader < in->low) {
		out->leader = out->low - 1;	/* 0.0 case */
	} else {
		out_length = out->high - out->low;
		/* Assume no GAPS in packing of littlenums. I.e. sizeof(array)
		 * == sizeof(element) * number_of_elements.  */
		if (in_length <= out_length) {
			/* For defensive programming,zero any
			 * high-order littlenums we don't need.  This
			 * is destroying evidence and wasting time,so
			 * why bother???  */
			if (in_length < out_length) {
				memset((char *)(out->low + in_length + 1),'\0',
				       out_length - in_length);
			}
			memcpy((void *)(out->low),(void *)(in->low),
			       ((in_length + 1) * sizeof(LITTLENUM_TYPE)));
			out->exponent = in->exponent;
			out->leader = in->leader - in->low + out->low;
		} else {
			int		shorten;	/* 1-origin. Number of
							 * littlenums we drop.  */

			shorten = in_length - out_length;
			/* Assume out_length >= 0 ! */
			memcpy((void *)(out->low),(void *)(in->low + shorten),
			       ((out_length + 1) * sizeof(LITTLENUM_TYPE)));
			out->leader = out->high;
			out->exponent = in->exponent + shorten;
		}
	}			/* if any significant bits */
}
/* ==================================================**** flonum-konst.c */
/*
 * flonum_const.c - Useful Flonum constants JF:  I added the last entry to this
 * table,and I'm not sure if its right or not.  Could go either way.  I wish I
 * really understood this stuff.
 */
static const int table_size_of_flonum_powers_of_ten = 13;
static const LITTLENUM_TYPE zero[] = {1};
/* ====================================================================== 
 * 
 * Warning: the low order bits may be WRONG here.			* I took this
 * from a suspect bc(1) script.			* "minus("[] is supposed to be
 * 10^(2^-X) expressed in base 2^16.	* The radix point is just AFTER the
 * highest element of the []	* *
 * 
 * Because bc rounds DOWN for printing (I think),the lowest	* significance
 * littlenums should probably have 1 added to them.	* *
 * 
 * \======================================================================
 */

/* JF:  If this equals 6553/(2^16)+39321/(2^32)+...  it approaches .1 */
static const LITTLENUM_TYPE minus_1[] = {
	39322,39321,39321,39321,39321,39321,39321,39321,39321,39321,
	39321,39321,39321,39321,39321,39321,39321,39321,39321,6553
};

static const LITTLENUM_TYPE plus_1[] = {10};

/* JF:  If this equals 655/(2^16) + 23592/(2^32) + ... it approaches .01 */
static const LITTLENUM_TYPE minus_2[] = {
	10486,36700,62914,23592,49807,10485,36700,62914,23592,49807,
	10485,36700,62914,23592,49807,10485,36700,62914,23592,655
};

static const LITTLENUM_TYPE plus_2[] = {100};

/* This approaches .0001 */
static const LITTLENUM_TYPE minus_3[] = {
	52534,20027,37329,65116,64067,60397,14784,18979,33659,19503,
	2726,9542,629,2202,40475,10590,4299,47815,36280,6
};

static const LITTLENUM_TYPE plus_3[] = {10000};

/* JF: this approaches 1e-8 */
static const LITTLENUM_TYPE minus_4[] = {
	22517,49501,54293,19424,60699,6716,24348,22618,23904,21327,
	3919,44703,19149,28803,48959,6259,50273,62237,42
};

/* This equals 1525 * 2^16 + 57600 */
static const LITTLENUM_TYPE plus_4[] = {57600,1525};

/* This approaches 1e-16 */
static const LITTLENUM_TYPE minus_5[] = {
	22199,45957,17005,26266,10526,16260,55017,35680,40443,19789,
	17356,30195,55905,28426,63010,44197,1844
};

static const LITTLENUM_TYPE plus_5[] = {
	28609,34546,35
};

static const LITTLENUM_TYPE minus_6[] = {
	30926,26518,13110,43018,54982,48258,24658,15209,63366,11929,
	20069,43857,60487,51
};

static const LITTLENUM_TYPE plus_6[] = {
	61313,34220,16731,11629,1262
};

static const LITTLENUM_TYPE minus_7[] = {
	29819,14733,21490,40602,31315,65186,2695
};

static const LITTLENUM_TYPE plus_7[] = {
	7937,49002,60772,28216,38893,55975,63988,59711,20227,24
};

static const LITTLENUM_TYPE minus_8[] = {
	27579,64807,12543,794,13907,61297,12013,64360,15961,20566,
	24178,15922,59427,110
};

static const LITTLENUM_TYPE plus_8[] = {
	15873,11925,39177,991,14589,3861,58415,9076,62956,54223,
	56328,50180,45274,48333,32537,42547,9731,59679,590
};

static const LITTLENUM_TYPE minus_9[] = {
	11042,8464,58971,63429,6022,63485,5500,53464,47545,50068,
	56988,22819,49708,54493,9920,47667,40409,35764,10383,54466,
	32702,17493,32420,34382,22750,20681,12300
};

static const LITTLENUM_TYPE plus_9[] = {
	20678,27614,28272,53066,55311,54677,29038,9906,26288,44486,
	13860,7445,54106,15426,21518,25599,29632,52309,61207,26105,
	10482,21948,51191,32988,60892,62574,61390,24540,21495,5
};

static const LITTLENUM_TYPE minus_10[] = {
	6214,48771,23471,30163,31763,38013,57001,11770,18263,36366,
	20742,45086,56969,53231,37856,55814,38057,15692,46761,8713,
	6102,20083,8269,11839,11571,50963,15649,11698,40675,2308
};

static const LITTLENUM_TYPE plus_10[] = {
	63839,36576,45712,44516,37803,29482,4966,30556,37961,23310,
	27070,44972,29507,48257,45209,7494,17831,38728,41577,29443,
	36016,7955,35339,35479,36011,14553,49618,5588,25396,28
};

static const LITTLENUM_TYPE minus_11[] = {
	16663,56882,61983,7804,36555,32060,34502,1000,14356,21681,
	6605,34767,51411,59048,53614,39850,30079,6496,6846,26841,
	40778,19578,59899,44085,54016,24259,11232,21229,21313,81
};

static const LITTLENUM_TYPE plus_11[] = {
	92,9054,62707,17993,7821,56838,13992,21321,29637,48426,
	42982,38668,49574,28820,18200,18927,53979,16219,37484,2516,
	44642,14665,11587,41926,13556,23956,54320,6661,55766,805
};

static const LITTLENUM_TYPE minus_12[] = {
	33202,45969,58804,56734,16482,26007,44984,49334,31007,32944,
	44517,63329,47131,15291,59465,2264,23218,11829,59771,38798,
	31051,28748,23129,40541,41562,35108,50620,59014,51817,6613
};

static const LITTLENUM_TYPE plus_12[] = {
	10098,37922,58070,7432,10470,63465,23718,62190,47420,7009,
	38443,4587,45596,38472,52129,52779,29012,13559,48688,31678,
	41753,58662,10668,36067,29906,56906,21461,46556,59571,9
};

static const LITTLENUM_TYPE minus_13[] = {
	45309,27592,37144,34637,34328,41671,34620,24135,53401,22112,
	21576,45147,39310,44051,48572,3676,46544,59768,33350,2323,
	49524,61568,3903,36487,36356,30903,14975,9035,29715,667
};

static const LITTLENUM_TYPE plus_13[] = {
	18788,16960,6318,45685,55400,46230,35794,25588,7253,55541,
	49716,59760,63592,8191,63765,58530,44667,13294,10001,55586,
	47887,18738,9509,40896,42506,52580,4171,325,12329,98
};

/*
 * Shut up complaints about differing pointer types.  They only differ in the
 * const attribute,but there isn't any easy way to do this
 */
#define X (LITTLENUM_TYPE *)

static const FLONUM_TYPE flonum_negative_powers_of_ten[] = {
	{X zero,X zero,X zero,0,'+'},
	{X minus_1,X minus_1 + 19,X minus_1 + 19,-20,'+'},
	{X minus_2,X minus_2 + 19,X minus_2 + 19,-20,'+'},
	{X minus_3,X minus_3 + 19,X minus_3 + 19,-20,'+'},
	{X minus_4,X minus_4 + 18,X minus_4 + 18,-20,'+'},
	{X minus_5,X minus_5 + 16,X minus_5 + 16,-20,'+'},
	{X minus_6,X minus_6 + 13,X minus_6 + 13,-20,'+'},
	{X minus_7,X minus_7 + 6,X minus_7 + 6,-20,'+'},
	{X minus_8,X minus_8 + 13,X minus_8 + 13,-40,'+'},
	{X minus_9,X minus_9 + 26,X minus_9 + 26,-80,'+'},
	{X minus_10,X minus_10 + 29,X minus_10 + 29,-136,'+'},
	{X minus_11,X minus_11 + 29,X minus_11 + 29,-242,'+'},
	{X minus_12,X minus_12 + 29,X minus_12 + 29,-455,'+'},
	{X minus_13,X minus_13 + 29,X minus_13 + 29,-880,'+'},
};

static const FLONUM_TYPE flonum_positive_powers_of_ten[] = {
	{X zero,X zero,X zero,0,'+'},
	{X plus_1,X plus_1 + 0,X plus_1 + 0,0,'+'},
	{X plus_2,X plus_2 + 0,X plus_2 + 0,0,'+'},
	{X plus_3,X plus_3 + 0,X plus_3 + 0,0,'+'},
	{X plus_4,X plus_4 + 1,X plus_4 + 1,0,'+'},
	{X plus_5,X plus_5 + 2,X plus_5 + 2,1,'+'},
	{X plus_6,X plus_6 + 4,X plus_6 + 4,2,'+'},
	{X plus_7,X plus_7 + 9,X plus_7 + 9,4,'+'},
	{X plus_8,X plus_8 + 18,X plus_8 + 18,8,'+'},
	{X plus_9,X plus_9 + 29,X plus_9 + 29,24,'+'},
	{X plus_10,X plus_10 + 29,X plus_10 + 29,77,'+'},
	{X plus_11,X plus_11 + 29,X plus_11 + 29,183,'+'},
	{X plus_12,X plus_12 + 29,X plus_12 + 29,396,'+'},
	{X plus_13,X plus_13 + 29,X plus_13 + 29,821,'+'},
};

/* ======================================================= flonum-mult.c */
/*
 * flonum_mult.c - multiply two flonums Copyright (C) 1987-2023 Free Software
 * Foundation,Inc.
 * 
 * This file is part of GAS,the GNU Assembler.
 * 
 * GAS is free software; you can redistribute it and/or modify it under the terms
 * of the GNU General Public License as published by the Free Software
 * Foundation; either version 3,or (at your option) any later version.
 * 
 * GAS is distributed in the hope that it will be useful,but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * GAS; see the file COPYING.  If not,write to the Free Software Foundation,
 * 51 Franklin Street - Fifth Floor,Boston,MA 02110-1301,USA.
 */


/*
 * plan for a . b => p(roduct)
 * 
 *  +-------+-------+-/   /-+-------+-------+
 *  | a | a |  ...  | a | a |
 *  |  A    |  A-1  |   |  1    |  0    |
 *  +-------+-------+-/   /-+-------+-------+

 *  +-------+-------+-/   /-+-------+-------+
 *  | b | b |  ...  | b | b |
 *  |  B    |  B-1  |   |  1    |  0    |
 *  +-------+-------+-/   /-+-------+-------+

 *  +-------+-------+-/   /-+-------+-/   /-+-------+-------+
 *  | p | p |  ...  | p |  ...  | p | p |
 *  |  A+B+1|  A+B  |   |  N    |   |  1    |  0    |
 *  +-------+-------+-/   /-+-------+-/   /-+-------+-------+

 *  /^\
 *  (carry) a .b       ...      |      ...   a .b    a .b
 *  A  B            |         0  1    0  0
 *  |
 *  ...     |      ...   a .b
 *  |         1  0
 *  |
 *  |      ...
 *  |
 *  |
 *  |
 *  |         ___
 *  |         \
 *  +-----  P  =   >  a .b
 *  N     /__  i  j
 *
 *  N = 0 ... A+B
 * 
 * for all i,j where i+j=N [i,j integers > 0]
 * 
 * a[],b[],p[] may not intersect. Zero length factors signify 0 significant
 * bits: treat as 0.0. 0.0 factors do the right thing. Zero length product OK.
 * 
 * I chose the ForTran accent "foo[bar]" instead of the C accent "*garply" because
 * I felt the ForTran way was more intuitive. The C way would probably yield
 * better code on most C compilers. Dean Elsner. (C style also gives deeper
 * insight [to me] ... oh well ...) */
static void	flonum_multip(const FLONUM_TYPE * a,const FLONUM_TYPE * b,
			  		FLONUM_TYPE *	product)
{
	int		size_of_a;	/* 0 origin  */
	int		size_of_b;	/* 0 origin  */
	int		size_of_product;	/* 0 origin  */
	int		size_of_sum;	/* 0 origin  */
	int		extra_product_positions;	/* 1 origin  */
	unsigned long	work;
	unsigned long	carry;
	long		exponent;
	LITTLENUM_TYPE *q;
	long		significant;	/* TRUE when we emit a non-0 littlenum  */
	/* ForTran accent follows.  */
	int		P;	/* Scan product low-order -> high.  */
	int		N;	/* As in sum above.  */
	int		A;	/* Which [] of a?  */
	int		B;	/* Which [] of b?  */

	if ((a->sign != '-' && a->sign != '+')
	    || (b->sign != '-' && b->sign != '+')) {
		/* Got to fail somehow.  Any suggestions?  */
		product->sign = 0;
		return;
	}
	product->sign = (a->sign == b->sign) ? '+' : '-';
	size_of_a = a->leader - a->low;
	size_of_b = b->leader - b->low;
	exponent = a->exponent + b->exponent;
	size_of_product = product->high - product->low;
	size_of_sum = size_of_a + size_of_b;
	extra_product_positions = size_of_product - size_of_sum;
	if (extra_product_positions < 0) {
		P = extra_product_positions;	/* P < 0  */
		exponent -= extra_product_positions;	/* Increases exponent.  */
	} else {
		P = 0;
	}
	carry = 0;
	significant = 0;
	for (N = 0; N <= size_of_sum; N++) {
		work = carry;
		carry = 0;
		for (A = 0; A <= N; A++) {
			B = N - A;
			if (A <= size_of_a && B <= size_of_b && B >= 0) {
#ifdef TRACE
				printf("a:low[%d.]=%04x b:low[%d.]=%04x work_before=%08x\n",
				       A,a->low[A],B,b->low[B],work);
#endif
				/*
				 * Watch out for sign extension!  Without the
				 * casts,on the DEC Alpha,the multiplication
				 * result is *signed* int,which gets
				 * sign-extended to convert to the unsigned
				 * long!
				 */
				work += (unsigned long)a->low[A] * (unsigned long)b->low[B];
				carry += work >> LITTLENUM_NUMBER_OF_BITS;
				work &= LITTLENUM_MASK;
#ifdef TRACE
				printf("work=%08x carry=%04x\n",work,carry);
#endif
			}
		}
		significant |= work;
		if (significant || P < 0) {
			if (P >= 0) {
				product->low[P] = work;
#ifdef TRACE
				printf("P=%d. work[p]:=%04x\n",P,work);
#endif
			}
			P++;
		} else {
			extra_product_positions++;
			exponent++;
		}
	}
	/*
	 * [P]-> position # size_of_sum + 1. This is where 'carry' should go.
	 */
#ifdef TRACE
	printf("final carry =%04x\n",carry);
#endif
	if (carry) {
		if (extra_product_positions > 0)
			product->low[P] = carry;
		else {
			/* No room at high order for carry littlenum.  */
			/*
			 * Shift right 1 to make room for most significant
			 * littlenum.
			 */
			exponent++;
			P--;
			for (q = product->low + P; q >= product->low; q--) {
				work = *q;
				*q = carry;
				carry = work;
			}
		}
	} else
		P--;
	product->leader = product->low + P;
	product->exponent = exponent;
}
/* ============================================================* frags.c */
/* frags.c - manage frags - */
static fragS	zero_address_frag;
static fragS	predefined_address_frag;

static int	totalfrags;
/* Initialization for frag routines.  */

static void	frag_init(void)
{
	zero_address_frag.fr_type = rs_fill;
	predefined_address_frag.fr_type = rs_fill;
}

/* Check that we're not trying to assemble into a section that can't allocate
 * frags (currently,this is only possible in the absolute section),or into an
 * mri common.  */
static void	frag_alloc_check(const struct obstack *ob)
{
	if (ob->chunk_size == 0) {
		as_bad(("attempt to allocate data in absolute section"));
		subseg_set(text_section,0);
	}
}

/* Allocate a frag on the specified obstack. Call this routine from everywhere
 * else,so that all the weird alignment hackery can be done in just one place.  */
static fragS   *frag_alloc(struct obstack *ob)
{
	fragS          *ptr;
	int		oalign;

	(void)obstack_alloc(ob,0);
	oalign = obstack_alignment_mask(ob);
	obstack_alignment_mask(ob) = 0;
	ptr = (fragS *) obstack_alloc(ob,SIZEOF_STRUCT_FRAG);
	obstack_alignment_mask(ob) = oalign;
	memset(ptr,0,SIZEOF_STRUCT_FRAG);
	totalfrags++;
	return ptr;
}

/* Try to augment current frag by nchars chars. If there is no room,close off
 * the current frag with a ".fill 0" and begin a new frag.  Then loop until the
 * new frag has at least nchars chars available.  Does not set up any fields in
 * frag_now.  */
static void	frag_grow(size_t nchars)
{
	if (obstack_room(&frchain_now->frch_obstack) < nchars) {
		size_t		oldc;
		size_t		newc;

		/*
		 * Try to allocate a bit more than needed right now.  But don't
		 * do this if we would waste too much memory.  Especially
		 * necessary for extremely big (like 2GB initialized) frags.
		 */
		if (nchars < 0x10000)
			newc = 2 * nchars;
		else
			newc = nchars + 0x10000;
		newc += SIZEOF_STRUCT_FRAG;

		/* Check for possible overflow.  */
		if (newc < nchars)
			as_fatal(ngettext("can't extend frag %lu char",
					  "can't extend frag %lu chars",
					  (unsigned long)nchars),
				 (unsigned long)nchars);

		/*
		 * Force to allocate at least NEWC bytes,but not less than the
		 * default.
		 */
		oldc = obstack_chunk_size(&frchain_now->frch_obstack);
		if (newc > oldc)
			obstack_chunk_size(&frchain_now->frch_obstack) = newc;

		while (obstack_room(&frchain_now->frch_obstack) < nchars) {
			/*
			 * Not enough room in this frag.  Close it and start a
			 * new one. This must be done in a loop because the
			 * created frag may not be big enough if the current
			 * obstack chunk is used.
			 */
			frag_wane(frag_now);
			frag_new(0);
		}

		/* Restore the old chunk size.  */
		obstack_chunk_size(&frchain_now->frch_obstack) = oldc;
	}
}

/* Call this to close off a completed frag,and start up a new (empty) frag,in
 * the same subsegment as the old frag. [frchain_now remains the same but
 * frag_now is updated.] Because this calculates the correct value of fr_fix by
 * looking at the obstack 'frags',it needs to know how many characters at the
 * end of the old frag belong to the maximal variable part;  The rest must
 * belong to fr_fix. It doesn't actually set up the old frag's fr_var.  You may
 * have set fr_var == 1,but allocated 10 chars to the end of the frag; In this
 * case you pass old_frags_var_max_size == 10. In fact,you may use fr_var for
 * something totally unrelated to the size of the variable part of the frag;
 * None of the generic frag handling code makes use of fr_var.
 * 
 * Make a new frag,initialising some components. Link new frag at end of
 * frchain_now.  */
static void	frag_new(size_t old_frags_var_max_size)
/* Number of chars (already allocated on obstack frags) in variable_length part of frag. */ 
{
	fragS          *former_last_fragP;
	frchainS       *frchP;

	gas_assert(frchain_now->frch_last == frag_now);

	/* Fix up old frag's fr_fix.  */
	frag_now->fr_fix = frag_now_fix_octets();
	gas_assert(frag_now->fr_fix >= old_frags_var_max_size
		   || now_seg == absolute_section);
	frag_now->fr_fix -= old_frags_var_max_size;
	/* Make sure its type is valid.  */
	gas_assert(frag_now->fr_type != 0);

	/* This will align the obstack so the next struct we allocate on it
	 * will begin at a correct boundary.  */
	obstack_finish(&frchain_now->frch_obstack);
	frchP = frchain_now;
	know(frchP);
	former_last_fragP = frchP->frch_last;
	gas_assert(former_last_fragP != 0);
	gas_assert(former_last_fragP == frag_now);
	frag_now = frag_alloc(&frchP->frch_obstack);

	frag_now->fr_file = as_where(&frag_now->fr_line);

	/* Generally,frag_now->points to an address rounded up to next
	 * alignment.  However,characters will add to obstack frags
	 * IMMEDIATELY after the struct frag,even if they are not starting at
	 * an alignment address.  */
	former_last_fragP->fr_next = frag_now;
	frchP->frch_last = frag_now;

	gas_assert(frchain_now->frch_last == frag_now);

	frag_now->fr_next = NULL;
}

/* Start a new frag unless we have n more chars of room in the current frag.
 * Close off the old frag with a .fill 0.
 * 
 * Return the address of the 1st char to write into. Advance frag_now_growth past
 * the new chars.  */
static char    *frag_more(size_t nchars)
{
	char           *retval;

	frag_alloc_check(&frchain_now->frch_obstack);
	frag_grow(nchars);
	retval = obstack_next_free(&frchain_now->frch_obstack);
	obstack_blank_fast(&frchain_now->frch_obstack,nchars);
	return retval;
}

/* Close the current frag,setting its fields for a relaxable frag.  Start a
 * new frag.  */
static void	frag_var_init(relax_stateT type,size_t max_chars,size_t var,
      		relax_substateT subtype,symbolS * symbol,offsetT offset,
			  		char         *opcode)
{
	frag_now->fr_var = var;
	frag_now->fr_type = type;
	frag_now->fr_subtype = subtype;
	frag_now->fr_symbol = symbol;
	frag_now->fr_offset = offset;
	frag_now->fr_opcode = opcode;
#ifdef TC_FRAG_INIT
	TC_FRAG_INIT(frag_now,max_chars);
#endif
	frag_now->fr_file = as_where(&frag_now->fr_line);

	frag_new(max_chars);
}

/* Start a new frag unless we have max_chars more chars of room in the current
 * frag.  Close off the old frag with a .fill 0.
 * 
 * Set up a machine_dependent relaxable frag,then start a new frag. Return the
 * address of the 1st char of the var part of the old frag to write into.  */

static char    *frag_var(relax_stateT type,size_t max_chars,size_t var,
     		relax_substateT subtype,symbolS * symbol,offsetT offset,
			 		char         *opcode)
{
	char           *retval;

	frag_grow(max_chars);
	retval = obstack_next_free(&frchain_now->frch_obstack);
	obstack_blank_fast(&frchain_now->frch_obstack,max_chars);
	frag_var_init(type,max_chars,var,subtype,symbol,offset,opcode);
	return retval;
}

/* Reduce the variable end of a frag to a harmless state.  */
static void	frag_wane(fragS * fragP)
{
	fragP->fr_type = rs_fill;
	fragP->fr_offset = 0;
	fragP->fr_var = 0;
}

/* Make an alignment frag.  The size of this frag will be adjusted to force the
 * next frag to have the appropriate alignment.  ALIGNMENT is the power of two
 * to which to align.  FILL_CHARACTER is the character to use to fill in any
 * bytes which are skipped.  MAX is the maximum number of characters to skip
 * when doing the alignment,or 0 if there is no maximum.  */
static void	frag_align(int alignment,int fill_character,int max)
{
	if (now_seg == absolute_section) {
		addressT	new_off;
		addressT	mask;

		mask = (~(addressT) 0) << alignment;
		new_off = (abs_section_offset + ~mask) & mask;
		if (max == 0 || new_off - abs_section_offset <= (addressT) max)
			abs_section_offset = new_off;
	} else {
		char           *p;

		p = frag_var(rs_align,1,1,(relax_substateT) max,
			     (symbolS *) 0,(offsetT) alignment,(char *)0);
		*p = fill_character;
	}
}

/* Make an alignment frag like frag_align,but fill with a repeating pattern
 * rather than a single byte.  ALIGNMENT is the power of two to which to align.
 * FILL_PATTERN is the fill pattern to repeat in the bytes which are skipped.
 * N_FILL is the number of bytes in FILL_PATTERN.  MAX is the maximum number of
 * characters to skip when doing the alignment,or 0 if there is no maximum.  */
static void	frag_align_pattern(int alignment,const char *fill_pattern,
			       		size_t	n_fill,int max)
{
	char           *p;

	p = frag_var(rs_align,n_fill,n_fill,(relax_substateT) max,
		     (symbolS *) 0,(offsetT) alignment,(char *)0);
	memcpy(p,fill_pattern,n_fill);
}

/*
 * The NOP_OPCODE is for the alignment fill value.  Fill it with a nop
 * instruction so that the disassembler does not choke on it.
 */
#ifndef NOP_OPCODE
#define NOP_OPCODE 0x00
#endif

/*
 * Use this to restrict the amount of memory allocated for representing the
 * alignment code.  Needs to be large enough to hold any fixed sized prologue
 * plus the replicating portion.
 */
#ifndef MAX_MEM_FOR_RS_ALIGN_CODE
/*
 * Assume that if HANDLE_ALIGN is not defined then no special action is
 * required to code fill,which means that we get just repeat the one
 * NOP_OPCODE byte.
 */
#ifndef HANDLE_ALIGN
#define MAX_MEM_FOR_RS_ALIGN_CODE  1
#else
#define MAX_MEM_FOR_RS_ALIGN_CODE  (((size_t) 1 << alignment) - 1)
#endif
#endif
static void	frag_align_code(int alignment,int max)
{
	char           *p;

	p = frag_var(rs_align_code,MAX_MEM_FOR_RS_ALIGN_CODE,1,
		     (relax_substateT) max,(symbolS *) 0,
		     (offsetT) alignment,(char *)0);
	*p = NOP_OPCODE;
}

static addressT	frag_now_fix_octets(void)
{
	if (now_seg == absolute_section)
		return abs_section_offset;

	return ((char *)obstack_next_free(&frchain_now->frch_obstack)
		- frag_now->fr_literal);
}

static addressT	frag_now_fix(void)
{
	/* Symbols whose section has SEC_ELF_OCTETS set,resolve to octets
	 * instead of target bytes.  */
	if (now_seg->flags & SEC_OCTETS)
		return frag_now_fix_octets();
	else
		return frag_now_fix_octets() / OCTETS_PER_BYTE;
}

static void	frag_append_1_char(int datum)
{
	frag_alloc_check(&frchain_now->frch_obstack);
	if (obstack_room(&frchain_now->frch_obstack) <= 1) {
		frag_wane(frag_now);
		frag_new(0);
	}
	obstack_1grow(&frchain_now->frch_obstack,datum);
}

/* Return TRUE if FRAG1 and FRAG2 have a fixed relationship between their start
 * addresses.  Set OFFSET to the difference in address not already accounted
 * for in the frag FR_ADDRESS.  */
static bool	frag_offset_fixed_p(const fragS * frag1,const fragS * frag2,offsetT * offset)
{
	const fragS    *frag;
	offsetT		off;

	/* Start with offset initialised to difference between the two frags.
	 * Prior to assigning frag addresses this will be zero.  */
	off = frag1->fr_address - frag2->fr_address;
	if (frag1 == frag2) {
		*offset = off;
		return true;
	}
	/* Maybe frag2 is after frag1.  */
	frag = frag1;
	while (frag->fr_type == rs_fill) {
		off += frag->fr_fix + frag->fr_offset * frag->fr_var;
		frag = frag->fr_next;
		if (frag == NULL)
			break;
		if (frag == frag2) {
			*offset = off;
			return true;
		}
	}

	/* Maybe frag1 is after frag2.  */
	off = frag1->fr_address - frag2->fr_address;
	frag = frag2;
	while (frag->fr_type == rs_fill) {
		off -= frag->fr_fix + frag->fr_offset * frag->fr_var;
		frag = frag->fr_next;
		if (frag == NULL)
			break;
		if (frag == frag1) {
			*offset = off;
			return true;
		}
	}

	return false;
}

/*
 * Return TRUE if FRAG2 follows FRAG1 with a fixed relationship between the two
 * assuming alignment frags do nothing.  Set OFFSET to the difference in
 * address not already accounted for in the frag FR_ADDRESS.
 */

static bool	frag_offset_ignore_align_p(const fragS * frag1,const fragS * frag2,
				       		offsetT *	offset)
{
	const fragS    *frag;
	offsetT		off;

	/*
	 * Start with offset initialised to difference between the two frags.
	 * Prior to assigning frag addresses this will be zero.
	 */
	off = frag1->fr_address - frag2->fr_address;
	if (frag1 == frag2) {
		*offset = off;
		return true;
	}
	frag = frag1;
	while (frag->fr_type == rs_fill
	       || frag->fr_type == rs_align
	       || frag->fr_type == rs_align_code
	       || frag->fr_type == rs_align_test) {
		if (frag->fr_type == rs_fill)
			off += frag->fr_fix + frag->fr_offset * frag->fr_var;
		frag = frag->fr_next;
		if (frag == NULL)
			break;
		if (frag == frag2) {
			*offset = off;
			return true;
		}
	}

	return false;
}

/* Return TRUE if we can determine whether FRAG2 OFF2 appears after (strict >,
 * not >=) FRAG1 OFF1,assuming it is not before.  Set OFFSET so that
 * resolve_expression will resolve an O_gt operation between them to false (0)
 * if they are guaranteed to be at the same location,or to true (-1) if they
 * are guaranteed to be at different locations.  Return FALSE conservatively,
 * e.g. if neither result can be guaranteed (yet).
 * 
 * They are known to be in the same segment,and not the same frag (this is a
 * fallback for frag_offset_fixed_p,that always takes care of this case),and
 * it is expected (from the uses this is designed to simplify,namely location
 * view increments) that frag2 is reachable from frag1 following the fr_next
 * links,rather than the other way round.  */
static bool	frag_gtoffset_p(valueT off2,const fragS * frag2,
	    		valueT	off1  ,const fragS * frag1,offsetT * offset)
{
	/* Insanity check.  */
	if (frag2 == frag1 || off1 > frag1->fr_fix)
		return false;

	/* If the first symbol offset is at the end of the first frag and the
	 * second symbol offset at the beginning of the second frag then it is
	 * possible they are at the same address.  Go looking for a non-zero
	 * fr_fix in any frag between these frags.  If found then we can say
	 * the O_gt result will be true.  If no such frag is found we assume
	 * that frag1 or any of the following frags might have a variable tail
	 * and thus the answer is unknown.  This isn't strictly true; some
	 * frags don't have a variable tail,but it doesn't seem worth
	 * optimizing for those cases.  */
	const fragS    *frag = frag1;
	offsetT		delta = off2 - off1;
	for (;;) {
		delta += frag->fr_fix;
		frag = frag->fr_next;
		if (frag == frag2) {
			if (delta == 0)
				return false;
			break;
		}
		/* If we run off the end of the frag chain then we have a case
		 * where frag2 is not after frag1,ie. an O_gt expression not
		 * created for .loc view.  */
		if (frag == NULL)
			return false;
	}

	*offset = (off2 - off1 - delta) * OCTETS_PER_BYTE;
	return true;
}

static void	output_sframe(segT sframe_seg ATTRIBUTE_UNUSED)
{
}

/* ============================================================** hash.c */
/* Hash function for a string_tuple.  */

static hashval_t hash_string_tuple(const void *e)
{
	string_tuple_t *tuple = (string_tuple_t *) e;
	return htab_hash_string(tuple->key);
}

/* Equality function for a string_tuple.  */
static int	eq_string_tuple(const void *a,const void *b)
{
	const string_tuple_t *ea = (const string_tuple_t *)a;
	const string_tuple_t *eb = (const string_tuple_t *)b;

	return strcmp(ea->key,eb->key) == 0;
}

/* Insert ELEMENT into HTAB.  If REPLACE is non-zero existing elements are
 * overwritten.  If ELEMENT already exists,a pointer to the slot is returned.
 * Otherwise NULL is returned.  */
static void ** htab_insert(htab_t htab,void *element,int replace)
{
	void          **slot = htab_find_slot(htab,element,INSERT);
	if (*slot != NULL) {
		if (replace) {
			if (htab->del_f)
				(*htab->del_f) (*slot);
			*slot = element;
		}
		return slot;
	}
	*slot = element;
	return NULL;
}

/* =======================================================* input-file.c */
/* input_file.c - Deal with Input Files - */
/*
 * This code opens a file,then delivers BUFFER_SIZE character chunks of the
 * file on demand. BUFFER_SIZE is supposed to be a number chosen for speed. The
 * caller only asks once what BUFFER_SIZE is,and asks before the nature of the
 * input files (if any) is known.
 */

#define BUFFER_SIZE (32 * 1024)

/* We use static data: the data area is not sharable.  */

static FILE    *f_in;
static const char *file_name;

/* Struct for saving the state of this module for file includes.  */
struct saved_file {
	FILE           *f_in;
	const char     *file_name;
	char           *app_save;
};

/* These hooks accommodate most operating systems.  */

static char    *input_file_give_next_buffer(char *where);
static void	input_file_close(void);
static void	input_file_open(const char *filename,int pre);
static void	input_file_pop(char *arg);

static void	input_file_pop(char *arg ATTRIBUTE_UNUSED)
{
}

/* Open the specified file,"" means stdin.  Filename must not be null.  */
static void	input_file_open(const char *filename, int pre ATTRIBUTE_UNUSED)
{
	int		c;


	if (filename == NULL) {
		fprintf(stderr,"Must provide input file name\n");
		exit(1);
	}
	if (filename[0]) {
		f_in = fopen(filename,"r");
		file_name = filename;
	}
	if (f_in == NULL) {
		as_bad(("can't open %s for reading: %s"),
		       file_name,xstrerror(errno));
		return;
	}
	c = getc(f_in);

	if (ferror(f_in)) {
		as_bad(("can't read from %s: %s"),
		       file_name,xstrerror(errno));

		fclose(f_in);
		f_in = NULL;
		return;
	}
	/* Check for an empty input file.  */
	if (feof(f_in)) {
		fclose(f_in);
		f_in = NULL;
		return;
	}
	gas_assert(c != EOF);

	ungetc(c,f_in);
}

/* Close input file.  */
void		input_file_close(void)
{
	/* Don't close a null file pointer.  */
	if (f_in != NULL)
		fclose(f_in);

	f_in = 0;
}

/* This function is passed to do_scrub_chars.  */
static		size_t input_file_get(char *buf,size_t buflen)
{
	size_t		size;

	if (feof(f_in))
		return 0;

	size = fread(buf,sizeof(char),buflen,f_in);
	if (ferror(f_in))
		as_bad(("can't read from %s: %s"),file_name,xstrerror(errno));
	return size;
}

/* Read a buffer from the input file.  */
static char    *
		input_file_give_next_buffer(char *where	/* Where to place 1st
							 * character of new
			          buffer.  */ )
{
	char           *return_value;	/* -> Last char of what we read,+ 1.  */
	size_t		size;

	if (f_in == (FILE *) 0)
		return 0;
	/*
	 * fflush (stdin); could be done here if you want to synchronise stdin
	 * and stdout,for the case where our input file is stdin. Since the
	 * assembler shouldn't do any output to stdout,we don't bother to
	 * synch output and input.
	 */
	size = input_file_get(where,BUFFER_SIZE);

	if (size)
		return_value = where + size;
	else {
		if (fclose(f_in))
			as_warn(("can't close %s: %s"),file_name,xstrerror(errno));

		f_in = (FILE *) 0;
		return_value = 0;
	}

	return return_value;
}
/* ======================================================= input-scrub.c */
/* input_scrub.c - Break up input buffers into whole numbers of lines. */
/*
 * O/S independent module to supply buffers of sanitised source code to rest of
 * assembler.  We get sanitised input data of arbitrary length. We break these
 * buffers on line boundaries,recombine pieces that were broken across
 * buffers,and return a buffer of full lines to the caller. The last partial
 * line begins the next buffer we build and return to caller. The buffer
 * returned to caller is preceded by BEFORE_STRING and followed by
 * AFTER_STRING,as sentinels. The last character before AFTER_STRING is a
 * newline. Also looks after line numbers,for e.g. error messages.
 */

/*
 * We don't care how filthy our buffers are,but our callers assume that the
 * following sanitation has already been done.
 * 
 * No comments,reduce a comment to a space. Reduce a tab to a space unless it is
 * 1st char of line. All multiple tabs and spaces collapsed into 1 char. Tab
 * only legal if 1st char of line. # line file statements converted to .line
 * x;.file y; statements. Escaped newlines at end of line: remove them but add
 * as many newlines to end of statement as you removed in the middle,to synch
 * line numbers.
 */

#define BEFORE_STRING ("\n")
#define AFTER_STRING ("\0")	/* memcpy of 0 chars might choke.  */
#define BEFORE_SIZE (1)
#define AFTER_SIZE  (1)

static char    *buffer_start;	/*->1st char of full buffer area.  */
static char    *partial_where;	/*->after last full line in buffer.  */
static size_t	partial_size;	/* >=0. Number of chars in partial line in
				 * buffer.  */

/*
 * Because we need AFTER_STRING just after last full line,it clobbers 1st part
 * of partial line. So we preserve 1st part of partial line here.
 */
static char	save_source[AFTER_SIZE];

/*
 * The size of the input buffer we concatenate input_file_give_next_buffer
 * chunks into.  Excludes the BEFORE and AFTER counts.
 */
static size_t	buffer_length;

/* The index into an sb structure we are reading from.  -1 if none.  */
static size_t	sb_index = -1;

/* If we are reading from an sb structure,this is it.  */
static sb	from_sb;

/* Should we do a conditional check on from_sb? */
static enum expansion from_sb_expansion = expanding_none;

/* The number of nested sb structures we have included.  */
int		macro_nest;

/*
 * We can have more than one source file open at once,though the info for all
 * but the latest one are saved off in a struct input_save.  These files remain
 * open,so we are limited by the number of open files allowed by the
 * underlying OS. We may also sequentially read more than one source file in an
 * assembly.
 */

/*
 * We must track the physical file and line number for error messages. We also
 * track a "logical" file and line number corresponding to (C?)  compiler
 * source line numbers.  Whenever we open a file we must fill in
 * physical_input_file. So if it is NULL we have not opened any files yet.
 */

static const char *physical_input_file;
static const char *logical_input_file;

/* 1-origin line number in a source file.  */
/* A line ends in '\n' or eof.  */
static unsigned int physical_input_line;
static unsigned int logical_input_line;

/* Indicator whether the origin of an update was a .linefile directive. */
static bool	is_linefile;

/* Struct used to save the state of the input handler during include files */
struct input_save {
	char           *buffer_start;
	char           *partial_where;
	size_t		partial_size;
	char		save_source[AFTER_SIZE];
	size_t		buffer_length;
	const char     *physical_input_file;
	const char     *logical_input_file;
	unsigned int	physical_input_line;
	unsigned int	logical_input_line;
	bool		is_linefile;
	size_t		sb_index;
	sb		from_sb;
	enum expansion	from_sb_expansion;	/* Should we do a conditional
						 * check?  */
	struct input_save *next_saved_file;	/* Chain of input_saves.  */
	char           *input_file_save;	/* Saved state of input
						 * routines.  */
	char           *saved_position;	/* Caller's saved position in buf.  */
};

static char    *input_scrub_pop(struct input_save *arg);

/*
 * Saved information about the file that .include'd this one.  When we hit EOF,
 * we automatically pop to that file.
 */
static struct input_save *next_saved_file;

/* Initialize input buffering.  */

static void	input_scrub_reinit(void)
{
	f_in = 0;	/* Reinitialize! */
	logical_input_line = -1u;
	logical_input_file = NULL;
	sb_index = -1;

	buffer_length = BUFFER_SIZE * 2;
	buffer_start = XNEWVEC(char,BEFORE_SIZE + AFTER_SIZE + 1 + buffer_length);
	memcpy(buffer_start,BEFORE_STRING,(int)BEFORE_SIZE);
}

static char    *input_scrub_pop(struct input_save *saved)
{
	char           *saved_position;

	input_scrub_end();	/* Finish off old buffer */

	input_file_pop(saved->input_file_save);
	saved_position = saved->saved_position;
	buffer_start = saved->buffer_start;
	buffer_length = saved->buffer_length;
	physical_input_file = saved->physical_input_file;
	logical_input_file = saved->logical_input_file;
	physical_input_line = saved->physical_input_line;
	logical_input_line = saved->logical_input_line;
	is_linefile = saved->is_linefile;
	sb_index = saved->sb_index;
	from_sb = saved->from_sb;
	from_sb_expansion = saved->from_sb_expansion;
	partial_where = saved->partial_where;
	partial_size = saved->partial_size;
	next_saved_file = saved->next_saved_file;
	memcpy(save_source,saved->save_source,sizeof(save_source));

	free(saved);
	return saved_position;
}

static void	input_scrub_begin(void)
{
	know(strlen(BEFORE_STRING) == BEFORE_SIZE);
	know(strlen(AFTER_STRING) == AFTER_SIZE
	     || (AFTER_STRING[0] == '\0' && AFTER_SIZE == 1));

	physical_input_file = NULL;	/* No file read yet.  */
	next_saved_file = NULL;	/* At EOF,don't pop to any other file */
	macro_nest = 0;
	input_scrub_reinit();
}

static void	input_scrub_end(void)
{
	if (buffer_start) {
		free(buffer_start);
		buffer_start = 0;
	}
}

/* Start reading input from a new file. Return start of caller's part of
 * buffer.  */
static char    *input_scrub_new_file(const char *filename)
{
	input_file_open(filename,!flag_no_comments);
	physical_input_file = filename[0] ? filename : ("{standard input}");
	physical_input_line = 0;

	partial_size = 0;
	return (buffer_start + BEFORE_SIZE);
}

static void	input_scrub_close(void)
{
	input_file_close();
	physical_input_line = 0;
	logical_input_line = -1u;
}

static char    *input_scrub_next_buffer(char **bufp)
{
	char           *limit;	/*->just after last char of buffer.  */

	if (sb_index != (size_t) - 1) {
		if (sb_index >= from_sb.len) {
			free(from_sb.ptr);
			--macro_nest;
			partial_where = NULL;
			partial_size = 0;
			if (next_saved_file != NULL)
				*bufp = input_scrub_pop(next_saved_file);
			return partial_where;
		}
		partial_where = from_sb.ptr + from_sb.len;
		partial_size = 0;
		*bufp = from_sb.ptr + sb_index;
		sb_index = from_sb.len;
		return partial_where;
	}
	if (partial_size) {
		memmove(buffer_start + BEFORE_SIZE,partial_where,partial_size);
		memcpy(buffer_start + BEFORE_SIZE,save_source,AFTER_SIZE);
	}
	while (1) {
		char           *p;
		char           *start = buffer_start + BEFORE_SIZE + partial_size;

		*bufp = buffer_start + BEFORE_SIZE;
		limit = input_file_give_next_buffer(start);
		if (!limit) {
			if (!partial_size)
				/* End of this file.  */
				break;

			as_warn(("end of file not at end of a line; newline inserted"));
			p = buffer_start + BEFORE_SIZE + partial_size;
			*p++ = '\n';
			limit = p;
		} else {
			/* Terminate the buffer to avoid confusing  TC_EOL_IN_INSN.  */
			*limit = '\0';

			/* Find last newline.  */
			for (p = limit - 1; *p != '\n' ; --p)
				if (p < start)
					goto read_more;
			++p;
		}

		if (multibyte_handling == multibyte_warn)
			(void)scan_for_multibyte_characters((const unsigned char *)p,
						 (const unsigned char *)limit,
					       true /* Generate warnings */ );

		/* We found a newline in the newly read chars.  */
		partial_where = p;
		partial_size = limit - p;

		/* Save the fragment after that last newline.  */
		memcpy(save_source,partial_where,(int)AFTER_SIZE);
		memcpy(partial_where,AFTER_STRING,(int)AFTER_SIZE);
		return partial_where;

read_more:
		/* Didn't find a newline.  Read more text.  */
		partial_size = limit - (buffer_start + BEFORE_SIZE);
		if (buffer_length - BUFFER_SIZE < partial_size) {
			/*
			 * Increase the buffer when it doesn't have room for
			 * the next block of input.
			 */
			buffer_length *= 2;
			buffer_start = XRESIZEVEC(char,buffer_start,
						  (buffer_length
					     + BEFORE_SIZE + AFTER_SIZE + 1));
		}
	}

	/* If we should pop to another file at EOF,do it.  */
	partial_where = NULL;
	if (next_saved_file)
		*bufp = input_scrub_pop(next_saved_file);

	return partial_where;
}

/* The remaining part of this file deals with line numbers,error messages and
 * so on.  Return TRUE if we opened any file.  */
static int	seen_at_least_1_file(void)
{
	return (physical_input_file != NULL);
}

static void	bump_line_counters(void)
{
	if (sb_index == (size_t) - 1)
		++physical_input_line;

	if (logical_input_line != -1u)
		++logical_input_line;
}

/* Tells us what the new logical line number and file are. If the line_number
 * is -1,we don't change the current logical line number. If fname is NULL,we
 * don't change the current logical file name,unless bit 3 of flags is set.
 * Returns nonzero if the filename actually changes.  */
static void	new_logical_line_flags(const char *fname,	/* DON'T destroy it!  We
								 * point to it!  */
				   		int		line_number,
				   		int		flags)
{
	switch (flags) {
	case 0:
		break;
	case 1:
		if (line_number != -1)
			abort();
		break;
	case 1 << 1:
	case 1 << 2:
		/* FIXME: we could check that include nesting is correct.  */
		break;
	case 1 << 3:
		if (line_number < 0 || fname != NULL)
			abort();
		if (next_saved_file == NULL)
			fname = physical_input_file;
		else
			if (next_saved_file->logical_input_file)
				fname = next_saved_file->logical_input_file;
			else
				fname = next_saved_file->physical_input_file;
		break;
	default:
		abort();
	}

	is_linefile = flags != 1 && (flags != 0 || fname);

	if (line_number >= 0)
		logical_input_line = line_number;
	else
		if (line_number == -1 && fname && !*fname && (flags & (1 << 2))) {
			logical_input_file = physical_input_file;
			logical_input_line = physical_input_line;
			fname = NULL;
		}
	if (fname
	    && (logical_input_file == NULL
		|| filename_cmp(logical_input_file,fname)))
		logical_input_file = fname;
}

static void	new_logical_line(const char *fname,int line_number)
{
	new_logical_line_flags(fname,line_number,0);
}

static void	as_report_context(void)
{
	const struct input_save *saved = next_saved_file;
	enum expansion	expansion = from_sb_expansion;
	int		indent = 1;

	if (!macro_nest)
		return;

	do {
		if (expansion != expanding_macro)
			 /* Nothing.  */ ;
		else
			if (saved->logical_input_file != NULL
			    && saved->logical_input_line != -1u)
				as_info_where(saved->logical_input_file,saved->logical_input_line,
					 indent,("macro invoked from here"));
			else
				as_info_where(saved->physical_input_file,saved->physical_input_line,
					 indent,("macro invoked from here"));

		expansion = saved->from_sb_expansion;
		++indent;
	}
	while ((saved = saved->next_saved_file) != NULL);
}

/* Return the current physical input file name and line number,if known  */
static const char *as_where_physical(unsigned int *linep)
{
	if (physical_input_file != NULL) {
		if (linep != NULL)
			*linep = physical_input_line;
		return physical_input_file;
	}
	if (linep != NULL)
		*linep = 0;
	return NULL;
}

/* Return the file name and line number at the top most macro invocation,
 * unless .file / .line were used inside a macro.  */
static const char *as_where(unsigned int *linep)
{
	const char     *file = as_where_top(linep);

	if (macro_nest && is_linefile) {
		const struct input_save *saved = next_saved_file;
		enum expansion	expansion = from_sb_expansion;

		do {
			if (expansion != expanding_macro)
				 /* Nothing.  */ ;
			else
				if (saved->logical_input_file != NULL
				    && (linep == NULL || saved->logical_input_line != -1u)) {
					if (linep != NULL)
						*linep = saved->logical_input_line;
					file = saved->logical_input_file;
				} else
					if (saved->physical_input_file != NULL) {
						if (linep != NULL)
							*linep = saved->physical_input_line;
						file = saved->physical_input_file;
					}
			expansion = saved->from_sb_expansion;
		}
		while ((saved = saved->next_saved_file) != NULL);
	}
	return file;
}

/* Return the current file name and line number.  */
static const char *as_where_top(unsigned int *linep)
{
	if (logical_input_file != NULL
	    && (linep == NULL || logical_input_line != -1u)) {
		if (linep != NULL)
			*linep = logical_input_line;
		return logical_input_file;
	}
	return as_where_physical(linep);
}
/* =======================================================**** literal.c */
/*
 * literal.c - GAS literal pool management. This isn't a requirement,just a
 * guideline that can help keep .o file size down.
 */
/* =======================================================*** messages.c */
/* messages.c - error reporter - */

/*
 * If the system doesn't provide strsignal,we get it defined in libiberty but
 * no declaration is supplied.  Because,reasons.
 */

static void	identify(const char *);
static void	as_show_where(void);
static void	as_warn_internal(const char *,unsigned int,char *);
static void	as_bad_internal(const char *,unsigned int,char *);
static void	signal_crash(int)ATTRIBUTE_NORETURN;

/* Despite the rest of the comments in this file,(FIXME-SOON),here is the
 * current scheme for error messages etc:
 * 
 * as_fatal() is used when gas is quite confused and continuing the assembly is
 * pointless.  In this case we exit immediately with error status.
 * 
 * as_bad() is used to mark errors that result in what we presume to be a useless
 * object file.  Say,we ignored something that might have been vital.  If we
 * see any of these,assembly will continue to the end of the source,no object
 * file will be produced,and we will terminate with error status.  The new
 * option,-Z,tells us to produce an object file anyway but we still exit with
 * error status.  The assumption here is that you don't want this object file
 * but we could be wrong.
 * 
 * as_warn() is used when we have an error from which we have a plausible error
 * recovery.  eg,masking the top bits of a constant that is longer than will
 * fit in the destination.  In this case we will continue to assemble the
 * source,although we may have made a bad assumption,and we will produce an
 * object file and return normal exit status (ie,no error).  The new option -X
 * tells us to treat all as_warn() errors as as_bad() errors.  That is,no
 * object file will be produced and we will exit with error status.  The idea
 * here is that we don't kill an entire make because of an error that we knew
 * how to correct.  On the other hand,sometimes you might want to stop the
 * make at these points.
 * 
 * as_tsktsk() is used when we see a minor error for which our error recovery
 * action is almost certainly correct. In this case,we print a message and
 * then assembly continues as though no error occurred.
 * 
 * as_abort () is used for logic failure (assert or abort,signal).  */
static void	identify(const char *file)
{
	static int	identified;

	if (identified)
		return;
	identified++;

	if (!file) {
		unsigned int	x;
		file = as_where(&x);
	}
	if (file)
		fprintf(stderr,"%s: ",file);
	fprintf(stderr,"Assembler messages:\n");
}

/* The number of warnings issued.  */
static int	warning_count;

int		had_warnings(void)
{
	return warning_count;
}

/*
 * Nonzero if we've hit a 'bad error',and should not write an obj file,and
 * exit with a nonzero error code.
 */
static int	error_count;
static int	had_errors(void)
{
	return error_count;
}

/* Print the current location to stderr.  */
static void	as_show_where(void)
{
	const char     *file;
	unsigned int	line;

	file = as_where_top(&line);
	identify(file);
	if (file) {
		if (line != 0)
			fprintf(stderr,"%s:%u: ",file,line);
		else
			fprintf(stderr,"%s: ",file);
	}
}

/*
 * Send to stderr a string as information,with location data passed in. Note
 * that for now this is not intended for general use.
 */
static void	as_info_where(const char *file,unsigned int line,unsigned int indent,
			  		const		char  *format,...)
{
	va_list		args;
	char		Buffer    [2000];

	va_start(args,format);
	vsnprintf(Buffer,sizeof(Buffer),format,args);
	va_end(args);
	fprintf(stderr,"%s:%u: %*s%s%s\n",
		file,line,(int)indent,"","Info: ",Buffer);
}

/* The common portion of as_warn and as_warn_where.  */
static void	as_warn_internal(const char *file,unsigned int line,char *Buffer)
{
	bool		context = false;

	++warning_count;

	if (file == NULL) {
		file = as_where_top(&line);
		context = true;
	}
	identify(file);
	if (file) {
		if (line != 0)
			fprintf(stderr,"%s:%u: %s%s\n",file,line,"Warning: ",Buffer);
		else
			fprintf(stderr,"%s: %s%s\n",file,"Warning: ",Buffer);
	} else
		fprintf(stderr,"%s%s\n","Warning: ",Buffer);

	if (context)
		as_report_context();

}

/*
 * Send to stderr a string as a warning,and locate warning in input file(s).
 * Please only use this for when we have some recovery action. Please explain
 * in string (which may have '\n's) what recovery was done.
 */

static void	as_warn(const char *format,...)
{
	va_list		args;
	char		Buffer    [2000];

	if (!flag_no_warnings) {
		va_start(args,format);
		vsnprintf(Buffer,sizeof(Buffer),format,args);
		va_end(args);
		as_warn_internal((char *)NULL,0,Buffer);
	}
}

/*
 * Like as_warn but the file name and line number are passed in. Unfortunately,
 * we have to repeat the function in order to handle the varargs correctly and
 * portably.
 */
static void	as_warn_where(const char *file,unsigned int line,const char *format,...)
{
	va_list		args;
	char		Buffer    [2000];

	if (!flag_no_warnings) {
		va_start(args,format);
		vsnprintf(Buffer,sizeof(Buffer),format,args);
		va_end(args);
		as_warn_internal(file,line,Buffer);
	}
}

/* The common portion of as_bad and as_bad_where.  */
static void	as_bad_internal(const char *file,unsigned int line,char *Buffer)
{
	bool		context = false;

	++error_count;

	if (file == NULL) {
		file = as_where_top(&line);
		context = true;
	}
	identify(file);
	if (file) {
		if (line != 0)
			fprintf(stderr,"%s:%u: %s%s\n",file,line,"Error: ",Buffer);
		else
			fprintf(stderr,"%s: %s%s\n",file,"Error: ",Buffer);
	} else
		fprintf(stderr,"%s%s\n","Error: ",Buffer);

	if (context)
		as_report_context();

}

/* Send to stderr a string as a warning,and locate warning in input file(s).
 * Please use when there is no recovery,but we want to continue processing but
 * not produce an object file. Please explain in string (which may have '\n's)
 * what recovery was done.  */
static void	as_bad(const char *format,...)
{
	va_list		args;
	char		Buffer    [2000];

	va_start(args,format);
	vsnprintf(Buffer,sizeof(Buffer),format,args);
	va_end(args);

	as_bad_internal((char *)NULL,0,Buffer);
}

/* Like as_bad but the file name and line number are passed in. Unfortunately,
 * we have to repeat the function in order to handle the varargs correctly and
 * portably.  */
static void	as_bad_where(const char *file,unsigned int line,const char *format,...)
{
	va_list		args;
	char		Buffer    [2000];

	va_start(args,format);
	vsnprintf(Buffer,sizeof(Buffer),format,args);
	va_end(args);

	as_bad_internal(file,line,Buffer);
}

/* Send to stderr a string as a fatal message,and print location of error in
 * input file(s). Please only use this for when we DON'T have some recovery
 * action. It xexit()s with a warning status. */
static void	as_fatal(const char *format,...)
{
	va_list		args;

	as_show_where();
	va_start(args,format);
	fprintf(stderr,"Fatal error: ");
	vfprintf(stderr,format,args);
	(void)putc('\n',stderr);
	va_end(args);
	as_report_context();
	/* Delete the output file,if it exists.  This will prevent make from
	 * thinking that a file was created and hence does not need rebuilding.  */
	if (out_file_name != NULL)
		unlink(out_file_name);
	xexit(EXIT_FAILURE);
}

/* Indicate internal constency error. Arguments: Filename,line number,
 * optional function name. FILENAME may be NULL,which we use for
 * crash-via-signal.  */
static void	as_abort(const char *file,int line,const char *fn)
{
	as_show_where();

	if (!file)
		fprintf(stderr,"Internal error (%s).\n",fn ? fn : "unknown");
	else
		if (fn)
			fprintf(stderr,"Internal error in %s at %s:%d.\n",fn,file,line);
		else
			fprintf(stderr,"Internal error at %s:%d.\n",file,line);
	as_report_context();
	fprintf(stderr,"Please report this bug.\n");
	xexit(EXIT_FAILURE);
}

/* Handler for fatal signals,such as SIGSEGV. */
static void	signal_crash(int signo)
{
	/* Reset,to prevent unbounded recursion.  */
	signal(signo,SIG_DFL);

	as_abort(NULL,0,strsignal(signo));
}

/* Register signal handlers,for less abrubt crashes.  */

static void	signal_init(void)
{
	signal(SIGSEGV,signal_crash);
	signal(SIGILL,signal_crash);
	signal(SIGBUS,signal_crash);
#ifdef SIGABRT
	signal(SIGABRT,signal_crash);
#endif
#if defined SIGIOT && (!defined SIGABRT || SIGABRT != SIGIOT)
	signal(SIGIOT,signal_crash);
#endif
	signal(SIGFPE,signal_crash);
}

/* Support routines.  */

#define HEX_MAX_THRESHOLD	1024
#define HEX_MIN_THRESHOLD	-(HEX_MAX_THRESHOLD)
static void	as_internal_value_out_of_range(const char *prefix,
					   		offsetT	val  ,
					   		offsetT	min  ,
					   		offsetT	max  ,
				     		const		char  *file,
					   		unsigned	line,
					   		bool		bad)
{
	const char     *err;

	if (prefix == NULL)
		prefix = "";

	if (val >= min && val <= max) {
		addressT	right = max & -max;

		if (max <= 1)
			abort();

		/* xgettext:c-format  */
		err = "%s out of domain (%" PRId64
			" is not a multiple of %" PRId64 ")";

		if (bad)
			as_bad_where(file,line,err,prefix,(int64_t) val,(int64_t) right);
		else
			as_warn_where(file,line,err,prefix,(int64_t) val,(int64_t) right);
	} else
		if (val < HEX_MAX_THRESHOLD
		    && min < HEX_MAX_THRESHOLD
		    && max < HEX_MAX_THRESHOLD
		    && val > HEX_MIN_THRESHOLD
		    && min > HEX_MIN_THRESHOLD
		    && max > HEX_MIN_THRESHOLD) {
			/* xgettext:c-format.  */
			err = "%s out of range (%" PRId64
				" is not between %" PRId64 " and %" PRId64 ")";

			if (bad)
				as_bad_where(file,line,err,prefix,
				 (int64_t) val,(int64_t) min,(int64_t) max);
			else
				as_warn_where(file,line,err,prefix,
				 (int64_t) val,(int64_t) min,(int64_t) max);
		} else {
			/* xgettext:c-format.  */
			err = "%s out of range (0x%" PRIx64
				" is not between 0x%" PRIx64 " and 0x%" PRIx64 ")";

			if (bad)
				as_bad_where(file,line,err,prefix,
				 (int64_t) val,(int64_t) min,(int64_t) max);
			else
				as_warn_where(file,line,err,prefix,
				 (int64_t) val,(int64_t) min,(int64_t) max);
		}
}

static void	as_warn_value_out_of_range(const char *prefix,
				       		offsetT	value,
				       		offsetT	min  ,
				       		offsetT	max  ,
				       		const		char  *file,
				       		unsigned	line)
{
	as_internal_value_out_of_range(prefix,value,min,max,file,line,false);
}

/* ======================================================= output-file.c */
/* output-file.c -  Deal with the output file  */
static struct bfd_hash_entry *bfd_hash_newfunc(struct bfd_hash_entry *entry,
				       		struct	bfd_hash_table *table,
		      		const		char  *string ATTRIBUTE_UNUSED)
{
	if (entry == NULL)
		entry = (struct bfd_hash_entry *)bfd_hash_allocate(table,
							      sizeof(*entry));
	return entry;
}
static void    *bfd_hash_allocate(struct bfd_hash_table *table,unsigned int size)
{
	void           *ret;

	ret = objalloc_alloc((struct objalloc *)table->memory,size);
	if (ret == NULL && size != 0)
		bfd_set_error(bfd_error_no_memory);
	return ret;
}
/* Initialize an entry in the section hash table.  */
static struct bfd_hash_entry *bfd_section_hash_newfunc(struct bfd_hash_entry *entry,
		   		struct	bfd_hash_table *table,const char *string)
{
	/*
	 * Allocate the structure if it has not already been allocated by a
	 * subclass.
	 */
	if (entry == NULL) {
		entry = (struct bfd_hash_entry *)
		bfd_hash_allocate(table,sizeof(struct section_hash_entry));
		if (entry == NULL)
			return entry;
	}
	/* Call the allocation method of the superclass.  */
	entry = bfd_hash_newfunc(entry,table,string);
	if (entry != NULL)
		memset(&((struct section_hash_entry *)entry)->section,0,
		       sizeof(asection));

	return entry;
}
static bfd     *new_bfd(void)
{
	bfd            *nbfd;

	nbfd = stdoutput;
	nbfd->memory = objalloc_create();
	if (nbfd->memory == NULL) {
		bfd_set_error(bfd_error_no_memory);
		return NULL;
	}
	//nbfd->arch_info = &bfd_default_arch_struct;

	if (!bfd_hash_table_init_n(&nbfd->section_htab,bfd_section_hash_newfunc,
				   sizeof(struct section_hash_entry),13)) {
		objalloc_free((struct objalloc *)nbfd->memory);
		return NULL;
	}
	nbfd->archive_plugin_fd = -1;
	return nbfd;
}

static bfd     *openw(const char *filename,const char *target ATTRIBUTE_UNUSED)
{
	bfd            *nbfd;
	char           *ptr;

	/*
	 * nbfd has to point to head of malloc'ed block so that bfd_close may
	 * reclaim it correctly.
	 */
	nbfd = new_bfd();
	if (nbfd == NULL)
		return NULL;

	/*
	 * PR 11983: Do not cache the original filename,but rather make a copy
	 * - the original might go away.
	 */
	ptr = bfd_alloc(nbfd,1 + strlen(filename));
	if (!ptr) {
		return NULL;
	}
	strcpy(ptr,filename);
	nbfd->filename = ptr;
	nbfd->direction = write_direction;

	nbfd->iostream = fopen(filename,"wb");
	if (nbfd->iostream == NULL) {
		/* File not writeable,etc.  */
		bfd_set_error(bfd_error_system_call);
		return NULL;
	}
	return nbfd;
}

#ifndef TARGET_MACH
#define TARGET_MACH 0
#endif
/*
 * Create a tdata field OBJECT_SIZE bytes in length,zeroed out and with the
 * object_id field of an elf_obj_tdata field set to OBJECT_ID.
 */
static bool	bfd_elf_allocate_object(bfd * abfd,
				    		size_t	object_size,
			  		enum		elf_target_id object_id)
{
	gas_assert(object_size >= sizeof(struct elf_obj_tdata));
	abfd->tdata.any = bfd_zalloc(abfd,object_size);
	if (abfd->tdata.any == NULL)
		return false;

	elf_object_id(abfd) = object_id;
	if (abfd->direction != read_direction) {
		struct output_elf_obj_tdata *o = bfd_zalloc(abfd,sizeof *o);
		if (o == NULL)
			return false;
		elf_tdata(abfd)->o = o;
		elf_program_header_size(abfd) = (size_t) - 1;
	}
	return true;
}
static bool	elf64_riscv_mkobject(bfd * abfd)
{
	return bfd_elf_allocate_object(abfd,
			      3440,//sizeof(struct _bfd_riscv_elf_obj_tdata),
				       RISCV_ELF_DATA);
}
static bool	bfd_set_format(bfd * abfd,bfd_format format)
{
	if (abfd->format != bfd_unknown)
		return abfd->format == format;

	/* Presume the answer is yes.  */
	abfd->format = format;

	if (!elf64_riscv_mkobject(abfd)) {
		abfd->format = bfd_unknown;
		return false;
	}
	return true;
}
static void	output_file_create(const char *name)
{
	if (name[0] == '-' && name[1] == '\0')
		as_fatal("can't open a bfd on stdout %s",name);

	else
		if (!(openw(name,TARGET_FORMAT))) {
			fprintf(stderr,"Can't create %s\n",name);
			exit(1);
		}
	bfd_set_format(stdoutput,bfd_object);
	bfd_default_set_arch_mach(stdoutput,TARGET_ARCH,TARGET_MACH);
	if (flag_traditional_format)
		stdoutput->flags |= BFD_TRADITIONAL_FORMAT;
}

static void	stash_frchain_obs(asection * sec)
{
	segment_info_type *info = seg_info(sec);
	if (info) {
		struct frchain *frchp;
		for (frchp = info->frchainP; frchp; frchp = frchp->frch_next)
			obstack_ptr_grow(&notes,&frchp->frch_obstack);
		info->frchainP = NULL;
	}
}
static bool	bfd_close(bfd * abfd)
{
	bool		ret = elf_write_object_contents(abfd);

	return close_all_done(abfd) && ret;
}

static void	output_file_close(void)
{
	bool		res;
	bfd            *obfd = stdoutput;
	struct obstack **obs;
	asection       *sec;
	const char     *filename;

	if (obfd == NULL)
		return;

	/*
	 * Prevent an infinite loop - if the close failed we will call as_fatal
	 * which will call xexit() which may call this function again...
	 */
	//stdoutput = NULL;

	/*
	 * We can't free obstacks attached to the output bfd sections before
	 * closing the output bfd since data in those obstacks may need to be
	 * accessed,but we can't access anything in the output bfd after it is
	 * closed..
	 */
	for (sec = obfd->sections; sec; sec = sec->next)
		stash_frchain_obs(sec);
	stash_frchain_obs(reg_section);
	stash_frchain_obs(expr_section);
	stash_frchain_obs(bfd_abs_section_ptr);
	stash_frchain_obs(bfd_und_section_ptr);
	obstack_ptr_grow(&notes,NULL);
	obs = obstack_finish(&notes);

	/* Close the bfd.  */
	if (!flag_always_generate_output && had_errors())
		res = close_all_done(obfd);
	else
		res = bfd_close(obfd);
	now_seg = NULL;
	now_subseg = 0;

	filename = out_file_name;
	out_file_name = NULL;
	if (!keep_it && filename)
		unlink(filename);

	elf_end();
	expr_end();
	read_end();
	htab_delete(sy_hash);
	subsegs_end(obs);

	if (!res)
		as_fatal("%s: %s",filename,bfd_errmsg(bfd_get_error()));
}
/* ============================================================** read.c */
/* read.c - read a source file - */

/*
 * If your chars aren't 8 bits,you will change this a bit (eg. to 0xFF). But
 * then,GNU isn't supposed to run on your machine anyway. (RMS is so
 * shortsighted sometimes.)
 */
#define MASK_CHAR ((int)(unsigned char) -1)

/*
 * This is the largest known floating point format (for now). It will grow when
 * we do 4361 style flonums.
 */
#define MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT (16)

/*
 * Routines that read assembler source text to build spaghetti in memory.
 * Another group of these functions is in the expr.c module.
 */

#ifndef TC_START_LABEL
#define TC_START_LABEL(STR,NUL_CHAR,NEXT_CHAR) (NEXT_CHAR == ':')
#endif

/* Set by the object-format or the target.  */
#ifndef TC_IMPLICIT_LCOMM_ALIGNMENT
#define TC_IMPLICIT_LCOMM_ALIGNMENT(SIZE,P2VAR)		\
  do								\
    {								\
      if ((SIZE) >= 8)						\
	(P2VAR) = 3;						\
      else if ((SIZE) >= 4)					\
	(P2VAR) = 2;						\
      else if ((SIZE) >= 2)					\
	(P2VAR) = 1;						\
      else							\
	(P2VAR) = 0;						\
    }								\
  while (0)
#endif

#if BITS_PER_CHAR != 8
/*
 * The following table is indexed by[(char)] and will break if a char does not
 * have exactly 256 states (hopefully 0:255!)!
 */
die		horribly;
#endif

#ifndef LEX_AT
#define LEX_AT 0
#endif

#ifndef LEX_BR
/* The RS/6000 assembler uses {,},[,] as parts of symbol names.  */
#define LEX_BR 0
#endif

#ifndef LEX_PCT
/* The Delta 68k assembler permits % inside label names.  */
#define LEX_PCT 0
#endif

#ifndef LEX_QM
/* The PowerPC Windows NT assemblers permits ? inside label names.  */
#define LEX_QM 0
#endif

#ifndef LEX_HASH
/*
 * The IA-64 assembler uses # as a suffix designating a symbol.  We include it
 * in the symbol and strip it out in tc_canonicalize_symbol_name.
 */
#define LEX_HASH 0
#endif

#ifndef LEX_DOLLAR
#define LEX_DOLLAR 3
#endif

#ifndef LEX_TILDE
/* The Delta 68k assembler permits ~ at start of label names.  */
#define LEX_TILDE 0
#endif

/* Used by is_... macros. our ctype[].  */
static char	lex_type[256] = {
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,	/* @ABCDEFGHIJKLMNO */
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,	/* PQRSTUVWXYZ[\]^_ */
	0,0,0,LEX_HASH,LEX_DOLLAR,LEX_PCT,0,0,0,0,0,0,0,0,3,0,	/* ("#$%&'()*+,-./ */
	1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,LEX_QM,	/* 0123456789:;<=>? */
	LEX_AT,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,	/* @ABCDEFGHIJKLMNO */
	3,3,3,3,3,3,3,3,3,3,3,LEX_BR,0,LEX_BR,0,3,	/* PQRSTUVWXYZ[\]^_ */
	0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,	/* `abcdefghijklmno */
	3,3,3,3,3,3,3,3,3,3,3,LEX_BR,0,LEX_BR,LEX_TILDE,0,	/* pqrstuvwxyz{|}~.  */
	3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
	3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
	3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
	3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
	3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
	3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
	3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
	3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3
};

/*
 * In: a character. Out: 1 if this character ends a line. 2 if this character
 * is a line separator.
 */
static char	is_end_of_line[256] = {
#ifdef CR_EOL
	1,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,	/* @abcdefghijklmno */
#else
	1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,	/* @abcdefghijklmno */
#endif
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,	/* */
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,	/* ("#$%&'()*+,-./ */
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,	/* 0123456789:;<=>? */
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,	/* */
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,	/* */
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,	/* */
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,	/* */
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,	/* */
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,	/* */
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,	/* */
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,	/* */
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,	/* */
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,	/* */
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,	/* */
	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0	/* */
};

static void	do_s_func(int end_p,const char *default_prefix);
static void	s_align(int,int);
static void	s_reloc(int);
static int	hex_float(int,char *);
static segT	get_known_segmented_expression(expressionS * expP);
static void	pobegin(void);
static void	poend(void);
static void	generate_file_debug(void);
static char *_find_end_of_line(char *);

static void	read_begin(void)
{
	const char     *p;

	pobegin();
	obj_read_begin_hook();


#ifndef tc_line_separator_chars
#define tc_line_separator_chars line_separator_chars
#endif
	/* Use machine dependent syntax.  */
	for (p = tc_line_separator_chars; *p; p++)
		is_end_of_line[(unsigned char)*p] = 2;
	/* Use more.  FIXME-SOMEDAY.  */

	stabs_begin();

	abs_section_offset = 0;

	current_name = NULL;
	current_label = NULL;

	dwarf_file = 0;
	dwarf_line = -1;
	dwarf_file_string = 0;
}

static void	read_end(void)
{
	stabs_end();
	poend();
}

#ifndef TC_ADDRESS_BYTES
#define TC_ADDRESS_BYTES address_bytes

static inline int address_bytes(void)
{
	/*
	 * Choose smallest of 1,2,4,8 bytes that is large enough to contain
	 * an address.
	 */
	int		n = (stdoutput->arch_info->bits_per_address - 1) / 8;
	n |= n >> 1;
	n |= n >> 2;
	n += 1;
	return n;
}
#endif

/* Set up pseudo-op tables.  */

static htab_t	po_hash;

static const pseudo_typeS potable[] = {
	{"align",s_align_ptwo,0},
	{"ascii",stringer,8 + 0},
	{"asciz",stringer,8 + 1},
	{"balign",s_align_bytes,0},
	{"balignw",s_align_bytes,-2},
	{"balignl",s_align_bytes,-4},
	/* block  */
	{"byte",cons,1},
	{"comm",s_comm,0},
	{"data",s_data,0},
	{"dc",cons,2},
	{"dc.a",cons,0},
	{"dc.b",cons,1},
	{"dc.d",float_cons,'d'},
	{"dc.l",cons,4},
	{"dc.s",float_cons,'f'},
	{"dc.w",cons,2},
	{"dc.x",float_cons,'x'},
	{"dcb",s_space,2},
	{"dcb.b",s_space,1},
	{"ds",s_space,2},
	{"ds.b",s_space,1},
	{"ds.d",s_space,8},
	{"ds.l",s_space,4},
	{"ds.p",s_space,'p'},
	{"ds.s",s_space,4},
	{"ds.w",s_space,2},
	{"ds.x",s_space,'x'},
	{"debug",s_ignore,0},
	/* dim  */
	{"double",float_cons,'d'},
	/* dsect  */
	{"endfunc",s_func,1},
	/* endef  */
	{"equ",s_set,0},
	{"equiv",s_set,1},
	{"eqv",s_set,-1},
	/* extend  */
	{"extern",s_ignore,0},/* We treat all undef as ext.  */
	{"file",s_file,0},
	{"fill",s_fill,0},
	{"float",float_cons,'f'},
	{"format",s_ignore,0},
	{"func",s_func,0},
	{"global",s_globl,0},
	{"globl",s_globl,0},
	{"hword",cons,2},
	{"incbin",s_incbin,0},
	{"int",cons,4},
	{"lcomm",s_lcomm,0},
	{"lflags",s_ignore,0},/* Listing flags.  */
	{"linefile",s_linefile,0},
	{"linkonce",s_linkonce,0},
	{"long",cons,4},
	{"lsym",s_lsym,0},
	//{"macro",s_macro,0},
	{"name",s_ignore,0},
	{"noformat",s_ignore,0},
	{"nop",s_nop,0},
	{"nops",s_nops,0},
	{"octa",cons,16},
	{"offset",s_struct,0},
	{"org",s_org,0},
	{"p2align",s_align_ptwo,0},
	{"p2alignw",s_align_ptwo,-2},
	{"p2alignl",s_align_ptwo,-4},
	{"quad",cons,8},
	{"reloc",s_reloc,0},
	{"rva",s_rva,4},
	/* scl  */
	/* sect  */
	{"set",s_set,0},
	{"short",cons,2},
	{"single",float_cons,'f'},
	/* size  */
	{"space",s_space,0},
	{"skip",s_space,0},
	{"sleb128",s_leb128,1},
	{"spc",s_ignore,0},
	{"stabd",s_stab,'d'},
	{"stabn",s_stab,'n'},
	{"stabs",s_stab,'s'},
	{"string",stringer,8 + 1},
	{"string8",stringer,8 + 1},
	{"string16",stringer,16 + 1},
	{"string32",stringer,32 + 1},
	{"string64",stringer,64 + 1},
	{"struct",s_struct,0},
	/* tag  */
	{"text",s_text,0},

	/* type  */
	{"uleb128",s_leb128,0},
	/* use  */
	/* val  */
	{"xcom",s_comm,0},
	{"xdef",s_globl,0},
	{"xref",s_ignore,0},
	{"xstabs",s_xstab,'s'},
	{"weakref",s_weakref,0},
	{"word",cons,2},
	{"zero",s_space,0},
	{"2byte",cons,2},
	{"4byte",cons,4},
	{"8byte",cons,8},
	{NULL,NULL,0}		/* End sentinel.  */
};

static		offsetT
		get_absolute_expr(expressionS * exp)
{
	expression_and_evaluate(exp);

	if (exp->X_op != O_constant) {
		if (exp->X_op != O_absent)
			as_bad("bad or irreducible absolute expression");
		exp->X_add_number = 0;
	}
	return exp->X_add_number;
}

static offsetT	get_absolute_expression(void)
{
	expressionS	exp;

	return get_absolute_expr(&exp);
}

static int	pop_override_ok;
static const char *pop_table_name;

static void	pop_insert(const pseudo_typeS * table)
{
	const pseudo_typeS *pop;
	for (pop = table; pop->poc_name; pop++) {
		if (str_hash_insert(po_hash,pop->poc_name,pop,0) != NULL) {
			if (!pop_override_ok)
				as_fatal("error constructing %s pseudo-op table",
					 pop_table_name);
		}
		//else printf("%s\n",pop->poc_name);
	}
}

static void	obj_elf_attach_to_group(int);
static void	obj_elf_lcomm(int);
static void	obj_elf_local(int);
static void	obj_elf_ident(int);
static void	obj_elf_line(int);
static void	obj_elf_size(int);
static void	obj_elf_type(int);
static void	obj_elf_weak(int);
static void	obj_elf_visibility(int);
static void	obj_elf_symver(int);
static void	obj_elf_subsection(int);
static void	obj_elf_popsection(int);
static void	obj_elf_gnu_attribute(int);
static void	obj_elf_tls_common(int);
static void	obj_elf_struct(int);
static const pseudo_typeS elf_pseudo_table[] = {
	{"attach_to_group",obj_elf_attach_to_group,0},
	{"comm",obj_elf_common,0},
	{"common",obj_elf_common,1},
	{"ident",obj_elf_ident,0},
	{"lcomm",obj_elf_lcomm,0},
	{"local",obj_elf_local,0},
	{"previous",obj_elf_previous,0},
	{"section",obj_elf_section,0},
	{"section.s",obj_elf_section,0},
	{"sect",obj_elf_section,0},
	{"sect.s",obj_elf_section,0},
	{"pushsection",obj_elf_section,1},
	{"popsection",obj_elf_popsection,0},
	{"size",obj_elf_size,0},
	{"type",obj_elf_type,0},
	{"version",obj_elf_version,0},
	{"weak",obj_elf_weak,0},

	/* These define symbol visibility.  */
	{"internal",obj_elf_visibility,STV_INTERNAL},
	{"hidden",obj_elf_visibility,STV_HIDDEN},
	{"protected",obj_elf_visibility,STV_PROTECTED},

	/* These are used for stabs-in-elf configurations.  */
	{"line",obj_elf_line,0},

	/* This is a GNU extension to handle symbol versions.  */
	{"symver",obj_elf_symver,0},

	/* A GNU extension to change subsection only.  */
	{"subsection",obj_elf_subsection,0},

	/* These are GNU extensions to aid in garbage collecting C++ vtables.  */
	{"vtable_inherit",obj_elf_vtable_inherit,0},
	{"vtable_entry",obj_elf_vtable_entry,0},

	/* A GNU extension for object attributes.  */
	{"gnu_attribute",obj_elf_gnu_attribute,0},

	/* These are used for dwarf2.  */
	{"file",dwarf2_directive_file,0},
	{"loc",dwarf2_directive_loc,0},
	{"loc_mark_labels",dwarf2_directive_loc_mark_labels,0},

	/* We need to trap the section changing calls to handle .previous.  */
	{"data",obj_elf_data,0},
	{"offset",obj_elf_struct,0},
	{"struct",obj_elf_struct,0},
	{"text",obj_elf_text,0},
	{"bss",obj_elf_bss,0},

	{"tls_common",obj_elf_tls_common,0},

	/* End sentinel.  */
	{NULL,NULL,0},
};
static void	s_riscv_option(int x ATTRIBUTE_UNUSED);
static void	s_dtprel(int bytes);
static void	s_bss(int ignore ATTRIBUTE_UNUSED);
static void	s_riscv_leb128(int sign);
static void	s_riscv_insn(int x ATTRIBUTE_UNUSED);
static void	s_riscv_attribute(int ignored ATTRIBUTE_UNUSED);
static void	s_variant_cc(int ignored ATTRIBUTE_UNUSED);
static const pseudo_typeS riscv_pseudo_table[] =
{
	{"option",s_riscv_option,0},
	{"half",cons,2},
	{"word",cons,4},
	{"dword",cons,8},
	{"dtprelword",s_dtprel,4},
	{"dtpreldword",s_dtprel,8},
	{"bss",s_bss,0},
	{"uleb128",s_riscv_leb128,0},
	{"sleb128",s_riscv_leb128,1},
	{"insn",s_riscv_insn,0},
	{"attribute",s_riscv_attribute,0},
	{"variant_cc",s_variant_cc,0},
	{"float16",float_cons,'h'},

	{NULL,NULL,0},
};
static void	pobegin(void)
{
	po_hash = str_htab_create();

	/* Do the target-specific pseudo ops.  */
	pop_table_name = "md";
	pop_override_ok = 0;
	pop_insert(riscv_pseudo_table);

	/* Now object specific.  Skip any that were in the target table.  */
	pop_table_name = "obj";
	pop_override_ok = 1;
	pop_insert(elf_pseudo_table);

	/* Now portable ones.  Skip any that we've seen already.  */
	pop_table_name = "standard";
	pop_insert(potable);

	/* Now CFI ones.  */
	pop_table_name = "cfi";
	pop_insert(cfi_pseudo_table);
}

static void	poend(void)
{
	htab_delete(po_hash);
}

#define assemble_one(line) md_assemble(line)
static bool	in_bss(void)
{
	uint32_t	flags = now_seg->flags;

	return (flags & SEC_ALLOC) && !(flags & (SEC_LOAD|SEC_HAS_CONTENTS));
}

/* Guts of .align directive: N is the power of two to which to align.  A value
 * of zero is accepted but ignored: the default alignment of the section will
 * be at least this. FILL may be NULL,or it may point to the bytes of the fill
 * pattern. LEN is the length of whatever FILL points to,if anything.  If LEN
 * is zero but FILL is not NULL then LEN is treated as if it were one. MAX is
 * the maximum number of characters to skip when doing the alignment,or 0 if
 * there is no maximum.  */
static void	do_align(unsigned int n,char *fill,unsigned int len,unsigned int max)
{
	if (now_seg == absolute_section || in_bss()) {
		if (fill != NULL)
			while (len-- > 0)
				if (*fill++ != '\0') {
					if (now_seg == absolute_section)
						as_warn("ignoring fill value in absolute section");
					else
						as_warn("ignoring fill value in section `%s'",
							segment_name(now_seg));
					break;
				}
		fill = NULL;
		len = 0;
	}

#ifdef md_do_align
	md_do_align(n,fill,len,max,just_record_alignment);
#endif

	/* Only make a frag if we HAVE to...  */
	if ((n > OCTETS_PER_BYTE_POWER) && !need_pass_2) {
		if (fill == NULL) {
			if (subseg_text_p(now_seg))
				frag_align_code(n,max);
			else
				frag_align(n,0,max);
		} else
			if (len <= 1)
				frag_align(n,*fill,max);
			else
				frag_align_pattern(n,fill,len,max);
	}
#ifdef md_do_align
just_record_alignment:ATTRIBUTE_UNUSED_LABEL
#endif

		if (n > OCTETS_PER_BYTE_POWER)
		record_alignment(now_seg,n - OCTETS_PER_BYTE_POWER);
}

/*
 * We read the file,putting things into a web that represents what we have
 * been reading.
 */
static void	read_a_source_file(const char *name)
{
	char		nul_char;
	char		next_char;
	char           *s;	/* String of symbol,'\0' appended.  */
	const pseudo_typeS *pop;


	buffer = input_scrub_new_file(name);
	/* Generate debugging information before we've read anything in to
	 * denote this file as the "main" source file and not a subordinate one
	 * (e.g. N_SO vs N_SOL in stabs).  */
	generate_file_debug();

	while ((buffer_limit = input_scrub_next_buffer(&input_line_pointer)) != 0) {	
		/* We have another line to parse.  */
		while (input_line_pointer < buffer_limit) {
			bool		was_new_line;
			/* We have more of this buffer to parse.  */

			/* We now have input_line_pointer->1st char of next
			 * line. If input_line_pointer [-1] == '\n' then we
			 * just scanned another line: so bump line counters.  */
			was_new_line = is_end_of_line[(unsigned char)input_line_pointer[-1]];
			if (was_new_line) {
				symbol_set_value_now(&dot_symbol);
				if (input_line_pointer[-1] == '\n')
					bump_line_counters();
			}
			/* We are at the beginning of a line,or similar place.
			 * We expect a well-formed assembler statement. A
			 * "symbol-name:" is a statement.
			 * 
			 * Depending on what compiler is used,the order of these
			 * tests may vary to catch most common case 1st. Each
			 * test is independent of all other tests at the (top)
			 * level.  */
			do
				nul_char = next_char = *input_line_pointer++;
			while (next_char == '\t' || next_char == ' ' || next_char == '\f');

			/* C is the 1st significant character.
			 * Input_line_pointer points after that character.  */
			if (is_name_beginner(next_char) || next_char == '"') {
				char           *rest;

				--input_line_pointer;
				nul_char = get_symbol_name(&s);	/* name's delimiter.  */
				next_char = (nul_char == '"' ? input_line_pointer[1] : nul_char);
				rest = input_line_pointer + (nul_char == '"' ? 2 : 1);

				/* NEXT_CHAR is character after symbol. The end
				 * of symbol in the input line is now '\0'. S
				 * points to the beginning of the symbol. [In
				 * case of pseudo-op,s->'.'.]
				 * Input_line_pointer->'\0' where NUL_CHAR was.  */
				if (next_char == ':') {

					colon(s);	/* User-defined label.  */
					restore_line_pointer(nul_char);
					++input_line_pointer;
					/* Input_line_pointer->after ':'.  */
					SKIP_WHITESPACE();
				} else
					if ((next_char == '=' && *rest == '=')
					    || ((next_char == ' ' || next_char == '\t')
						&& rest[0] == '='
						&& rest[1] == '=')) {
						equals(s,-1);
						demand_empty_rest_of_line();
					} else
						if ((next_char == '='
						     || ((next_char == ' ' || next_char == '\t')
							 && *rest == '='))) {
							equals(s,1);
							demand_empty_rest_of_line();
						} else {
							if (*s == '.') {
							/* PSEUDO - OP. WARNING:
							 * next_char may be end-of-line. We lookup the
							 * pseudo-op table with s+1 because we already
							 * know that the pseudo-op begins with a '.'  */
								pop = str_hash_find(po_hash,s + 1);
								if (pop && !pop->poc_handler)
									pop = NULL;

								/* Print the error msg now,while we still
								 * can.  */
								if (pop == NULL) {
									char           *end = input_line_pointer;

									(void)restore_line_pointer(nul_char);
									s_ignore(0);
									nul_char = next_char = *--input_line_pointer;
									*input_line_pointer = '\0';
									*end = '\0';
									as_bad("unknown pseudo-op: `%s'",s);
									*input_line_pointer++ = nul_char;
									continue;
								}
								/* Put it back for error messages etc.  */
								next_char = restore_line_pointer(nul_char);
								/* The following skip of whitespace is compulsory.
								 * A well shaped space is sometimes all that
								 * separates keyword from operands.  */
								if (next_char == ' ' || next_char == '\t')
									input_line_pointer++;

								/* Input_line is restored. Input_line_pointer->1st
								 * non-blank char after pseudo-operation.  */
								(*pop->poc_handler) (pop->poc_val);

							} else {
								/* WARNING: next_char may be end-of-line. */
								/* Also: input_line_pointer->`\0` where
								 * nul_char was.  */
								(void)restore_line_pointer(nul_char);
								input_line_pointer = _find_end_of_line(input_line_pointer);
								next_char = nul_char = *input_line_pointer;
								*input_line_pointer = '\0';

								generate_lineno_debug();
								assemble_one(s);/* Assemble 1 * instruction.  */

								*input_line_pointer++ = nul_char;
								/* We resume loop AFTER the end-of-line from this
								 * instruction.  */
							}
						}
				continue;
			}
			/* Empty statement?  */
			if (is_end_of_line[(unsigned char)next_char])
				continue;

			input_line_pointer--;
			/* Report unknown char as error.  */
			demand_empty_rest_of_line();
		}
	}

	symbol_set_value_now(&dot_symbol);

	/* Close the input file.  */
	input_scrub_close();
}

/* Convert O_constant expression EXP into the equivalent O_big representation.
 * Take the sign of the number from SIGN rather than X_add_number.  */
static void	convert_to_bignum(expressionS * exp,int sign)
{
	valueT		value;
	unsigned int	i;

	value = exp->X_add_number;
	for (i = 0; i < sizeof(exp->X_add_number) / CHARS_PER_LITTLENUM; i++) {
		generic_bignum[i] = value & LITTLENUM_MASK;
		value >>= LITTLENUM_NUMBER_OF_BITS;
	}
	/* Add a sequence of sign bits if the top bit of X_add_number is not
	 * the sign of the original value.  */
	if ((exp->X_add_number < 0) == !sign)
		generic_bignum[i++] = sign ? LITTLENUM_MASK : 0;
	exp->X_op = O_big;
	exp->X_add_number = i;
}


/*
 * Handle the .align pseudo-op.  A positive ARG is a default alignment (in
 * bytes).  A negative ARG is the negative of the length of the fill pattern.
 * BYTES_P is non-zero if the alignment value should be interpreted as the byte
 * boundary,rather than the power of 2.
 */
#ifndef TC_ALIGN_LIMIT
#define TC_ALIGN_LIMIT (stdoutput->arch_info->bits_per_address - 1)
#endif

static void	s_align(signed int arg,int bytes_p)
{
	unsigned int	align_limit = TC_ALIGN_LIMIT;
	addressT	align;
	offsetT		fill = 0;
	unsigned int	max;
	int		fill_p;

	if (is_end_of_line[(unsigned char)*input_line_pointer]) {
		if (arg < 0)
			align = 0;
		else
			align = arg;	/* Default value from pseudo-op table.  */
	} else {
		align = get_absolute_expression();
		SKIP_WHITESPACE();

#ifdef TC_ALIGN_ZERO_IS_DEFAULT
		if (arg > 0 && align == 0)
			align = arg;
#endif
	}

	if (bytes_p) {
		/* Convert to a power of 2.  */
		if (align != 0) {
			unsigned int	i;

			for (i = 0; (align & 1) == 0; align >>= 1,++i);
			if (align != 1)
				as_bad("alignment not a power of 2");

			align = i;
		}
	}
	if (align > align_limit) {
		align = align_limit;
		as_warn("alignment too large: %u assumed",align_limit);
	}
	if (*input_line_pointer != ',') {
		fill_p = 0;
		max = 0;
	} else {
		++input_line_pointer;
		if (*input_line_pointer == ',')
			fill_p = 0;
		else {
			fill = get_absolute_expression();
			SKIP_WHITESPACE();
			fill_p = 1;
		}

		if (*input_line_pointer != ',')
			max = 0;
		else {
			++input_line_pointer;
			max = get_absolute_expression();
		}
	}

	if (!fill_p) {
		if (arg < 0)
			as_warn("expected fill pattern missing");
		do_align(align,(char *)NULL,0,max);
	} else {
		unsigned int	fill_len;

		if (arg >= 0)
			fill_len = 1;
		else
			fill_len = -arg;

		if (fill_len <= 1) {
			char		fill_char = 0;

			fill_char = fill;
			do_align(align,&fill_char,fill_len,max);
		} else {
			char		ab        [16];

			if ((size_t) fill_len > sizeof ab) {
				as_warn("fill pattern too long,truncating to %u",
					(unsigned)sizeof ab);
				fill_len = sizeof ab;
			}
			md_number_to_chars(ab,fill,fill_len);
			do_align(align,ab,fill_len,max);
		}
	}

	demand_empty_rest_of_line();

}

/*
 * Handle the .align pseudo-op on machines where ".align 4" means align to a 4
 * byte boundary.
 */

static void	s_align_bytes(int arg)
{
	s_align(arg,1);
}

/*
 * Handle the .align pseudo-op on machines where ".align 4" means align to a
 * 2**4 boundary.
 */

static void	s_align_ptwo(int arg)
{
	s_align(arg,0);
}

/*
 * Read a symbol name from input_line_pointer.
 * 
 * Stores the symbol name in a buffer and returns a pointer to this buffer. The
 * buffer is xalloc'ed.  It is the caller's responsibility to free this buffer.
 * 
 * The name is not left in the i_l_p buffer as it may need processing to handle
 * escape characters.
 * 
 * Advances i_l_p to the next non-whitespace character.
 * 
 * If a symbol name could not be read,the routine issues an error messages,skips
 * to the end of the line and returns NULL.
 */

static char    *read_symbol_name(void)
{
	char           *name;
	char           *start;
	char		c;

	c = *input_line_pointer++;

	if (c == '"') {
#define SYM_NAME_CHUNK_LEN 128
		ptrdiff_t	len = SYM_NAME_CHUNK_LEN;
		char           *name_end;
		unsigned int	C;

		start = name = XNEWVEC(char,len + 1);

		name_end = name + SYM_NAME_CHUNK_LEN;

		while (is_a_char(C = next_char_of_string())) {
			if (name >= name_end) {
				ptrdiff_t	sofar;

				sofar = name - start;
				len += SYM_NAME_CHUNK_LEN;
				start = XRESIZEVEC(char,start,len + 1);
				name_end = start + len;
				name = start + sofar;
			}
			*name++ = (char)C;
		}
		*name = 0;

		/* Since quoted symbol names can contain non-ASCII characters,
		 * check the string and warn if it cannot be recognised by the
		 * current character set.
		 *
		 * PR 29447: mbstowcs ignores the third (length) parameter when
		 * the first (destination) parameter is NULL.  For clarity sake
		 * therefore we pass 0 rather than 'len' as the third
		 * parameter.  */
		if (mbstowcs(NULL,name,0) == (size_t) - 1)
			as_warn(("symbol name not recognised in the current locale"));
	} else
		if (is_name_beginner(c) || (input_from_string && c == FAKE_LABEL_CHAR)) {
			ptrdiff_t	len;

			name = input_line_pointer - 1;

			/*
			 * We accept FAKE_LABEL_CHAR in a name in case this is
			 * being called with a constructed string.
			 */
			while (is_part_of_name(c = *input_line_pointer++)
			       || (input_from_string && c == FAKE_LABEL_CHAR));

			len = (input_line_pointer - name) - 1;
			start = XNEWVEC(char,len + 1);

			memcpy(start,name,len);
			start[len] = 0;

			/* Skip a name ender char if one is present.  */
			if (!is_name_ender(c))
				--input_line_pointer;
		} else
			name = start = NULL;

	if (name == start) {
		as_bad(("expected symbol name"));
		ignore_rest_of_line();
		free(start);
		return NULL;
	}
	SKIP_WHITESPACE();

	return start;
}


static symbolS *s_comm_internal(int param,
 		symbolS *     (*comm_parse_extra) (int,symbolS *,addressT))
{
	char           *name;
	offsetT		temp  ,size;
	symbolS        *symbolP = NULL;
	expressionS	exp;

	if ((name = read_symbol_name()) == NULL)
		goto out;

	/*
	 * Accept an optional comma after the name.  The comma used to be
	 * required,but Irix 5 cc does not generate it for .lcomm.
	 */
	if (*input_line_pointer == ',')
		input_line_pointer++;

	temp = get_absolute_expr(&exp);
	size = temp;
	size &= ((addressT) 2 << (stdoutput->arch_info->bits_per_address - 1)) - 1;
	if (exp.X_op == O_absent) {
		as_bad(("missing size expression"));
		ignore_rest_of_line();
		goto out;
	} else
		if (temp != size || !exp.X_unsigned) {
			as_warn(("size (%ld) out of range,ignored"),(long)temp);
			ignore_rest_of_line();
			goto out;
		}
	symbolP = symbol_find_or_make(name);
	if ((S_IS_DEFINED(symbolP) || symbol_equated_p(symbolP))
	    && !S_IS_COMMON(symbolP)) {
		if (!S_IS_VOLATILE(symbolP)) {
			symbolP = NULL;
			as_bad(("symbol `%s' is already defined"),name);
			ignore_rest_of_line();
			goto out;
		}
#if 1
		symbolP = symbol_clone(symbolP,1);
		S_SET_SEGMENT(symbolP,undefined_section);
		S_SET_VALUE(symbolP,0);
		symbol_set_frag(symbolP,&zero_address_frag);
		S_CLEAR_VOLATILE(symbolP);
#endif
	}
	size = S_GET_VALUE(symbolP);
	if (size == 0)
		size = temp;
	else
		if (size != temp)
			as_warn(("size of \"%s\" is already %ld; not changing to %ld"),
				name,(long)size,(long)temp);

	if (comm_parse_extra != NULL)
		symbolP = (*comm_parse_extra) (param,symbolP,size);
	else {
		S_SET_VALUE(symbolP,(valueT) size);
		S_SET_EXTERNAL(symbolP);
		S_SET_SEGMENT(symbolP,bfd_com_section_ptr);
	}

	demand_empty_rest_of_line();
out:
	free(name);
	return symbolP;
}

static void	s_comm(int ignore)
{
	s_comm_internal(ignore,NULL);
}

static void	s_data(int ignore ATTRIBUTE_UNUSED)
{
	segT		section;
	int		temp;

	temp = get_absolute_expression();
	if (flag_readonly_data_in_text) {
		section = text_section;
		temp += 1000;
	} else
		section = data_section;

	subseg_set(section,(subsegT) temp);

	demand_empty_rest_of_line();
}

/*
 * Handle the .file pseudo-op.  This default definition may be overridden by
 * the object or CPU specific pseudo-ops.
 */
static void	s_file_string(char *file)
{
#ifdef obj_app_file
	obj_app_file(file);
#endif
}

static void	s_file(int ignore ATTRIBUTE_UNUSED)
{
	char           *s;
	int		length;

	/* Some assemblers tolerate immediately following '"'.  */
	if ((s = demand_copy_string(&length)) != 0) {
		new_logical_line_flags(s,-1,1);

		demand_empty_rest_of_line();
		s_file_string(s);
	}
}

static bool	get_linefile_number(int *flag)
{
	expressionS	exp;

	SKIP_WHITESPACE();

	if (*input_line_pointer < '0' || *input_line_pointer > '9')
		return false;

	/* Don't mistakenly interpret octal numbers as line numbers.  */
	if (*input_line_pointer == '0') {
		*flag = 0;
		++input_line_pointer;
		return true;
	}
	expression_and_evaluate(&exp);
	if (exp.X_op != O_constant)
		return false;

#if defined (BFD64) || LONG_MAX > INT_MAX
	if (exp.X_add_number < INT_MIN || exp.X_add_number > INT_MAX)
		return false;
#endif

	*flag = exp.X_add_number;

	return true;
}

/* Handle the .linefile pseudo-op.  This is automatically generated by
 * do_scrub_chars when a preprocessor # line comment is seen.  This default
 * definition may be overridden by the object or CPU specific pseudo-ops.  */
static void	s_linefile(int ignore ATTRIBUTE_UNUSED)
{
	char           *file = NULL;
	int		linenum   ,flags = 0;

	/* The given number is that of the next line.  */
	if (!get_linefile_number(&linenum)) {
		ignore_rest_of_line();
		return;
	}
	if (linenum < 0)
		/* Some of the back ends can't deal with non-positive line
		 * numbers. Besides,it's silly.  GCC however will generate a
		 * line number of zero when it is pre-processing builtins for
		 * assembler-with-cpp files:
		 * 
		 * # 0 "<built-in>"
		 * 
		 * We do not want to barf on this,especially since such files are
		 * used in the GCC and GDB testsuites.  So we check for
		 * negative line numbers rather than non-positive line numbers.
		 */
		as_warn("line numbers must be positive; line number %d rejected",linenum);
	else {
		int		length = 0;

		SKIP_WHITESPACE();

		if (*input_line_pointer == '"')
			file = demand_copy_string(&length);
		else
			if (*input_line_pointer == '.') {
				/* buffer_and_nest() may insert this form.  */
				++input_line_pointer;
				flags = 1 << 3;
			}
		if (file) {
			int		this_flag;

			while (get_linefile_number(&this_flag))
				switch (this_flag) {
				/* From GCC's cpp documentation: 
				 * 1: start of a new file. 
				 * 2: returning to a file after having 
				 * included another file. 
				 * 3: following text comes from a
				 * system header file. 
				 * 4: following text should be treated 
				 * as extern "C".
				 * 
				 * 4 is nonsensical for the assembler; 3,
				 * we don't care about,so we ignore it
				 * just in case a system header file is
				 * included while preprocessing
				 * assembly.  So 1 and 2 are all we
				 * care about,and they are mutually
				 * incompatible.
				 * new_logical_line_flags() demands * this.  */
				case 1:
				case 2:
					if (flags && flags != (1 << this_flag))
						as_warn(("incompatible flag %i in line directive"),
							this_flag);
					else
						flags |= 1 << this_flag;
					break;

				case 3:
				case 4:
					/* We ignore these.  */
					break;

				default:
					as_warn(("unsupported flag %i in line directive"),
						this_flag);
					break;
				}

			if (!is_end_of_line[(unsigned char)*input_line_pointer])
				file = NULL;
		}
		if (file || flags) {
			demand_empty_rest_of_line();

			/*
			 * read_a_source_file() will bump the line number only
			 * if the line is terminated by '\n'.
			 */
			if (input_line_pointer[-1] == '\n')
				linenum--;

			new_logical_line_flags(file,linenum,flags);
			return;
		}
	}
	ignore_rest_of_line();
}

static void	s_fill(int ignore ATTRIBUTE_UNUSED)
{
	expressionS	rep_exp;
	long		size = 1;
	long		fill = 0;
	char           *p;

	riscv_mapping_state (MAP_DATA, 0, 0);
	expression(&rep_exp);
	if (*input_line_pointer == ',') {
		input_line_pointer++;
		size = get_absolute_expression();
		if (*input_line_pointer == ',') {
			input_line_pointer++;
			fill = get_absolute_expression();
		}
	}
	/* This is to be compatible with BSD 4.2 AS,not for any rational
	 * reason.  */
#define BSD_FILL_SIZE_CROCK_8 (8)
	if (size > BSD_FILL_SIZE_CROCK_8) {
		as_warn((".fill size clamped to %d"),BSD_FILL_SIZE_CROCK_8);
		size = BSD_FILL_SIZE_CROCK_8;
	}
	if (size < 0) {
		as_warn(("size negative; .fill ignored"));
		size = 0;
	} else
		if (rep_exp.X_op == O_constant && rep_exp.X_add_number <= 0) {
			if (rep_exp.X_add_number < 0)
				as_warn(("repeat < 0; .fill ignored"));
			size = 0;
		} else
			if (size && !need_pass_2) {
				if (now_seg == absolute_section && rep_exp.X_op != O_constant) {
					as_bad(("non-constant fill count for absolute section"));
					size = 0;
				} else
					if (now_seg == absolute_section && fill && rep_exp.X_add_number != 0) {
						as_bad(("attempt to fill absolute section with non-zero value"));
						size = 0;
					} else
						if (fill
						    && (rep_exp.X_op != O_constant || rep_exp.X_add_number != 0)
						    && in_bss()) {
							as_bad(("attempt to fill section `%s' with non-zero value"),
							segment_name(now_seg));
							size = 0;
						}
			}
	if (size && !need_pass_2) {
		if (now_seg == absolute_section)
			abs_section_offset += rep_exp.X_add_number * size;

		if (rep_exp.X_op == O_constant) {
			p = frag_var(rs_fill,(int)size,(int)size,
				     (relax_substateT) 0,(symbolS *) 0,
				     (offsetT) rep_exp.X_add_number,
				     (char *)0);
		} else {
			/* We don't have a constant repeat count,so we can't
			 * use rs_fill.  We can get the same results out of
			 * rs_space,but its argument is in bytes,so we must
			 * multiply the repeat count by size.  */
			symbolS        *rep_sym;
			rep_sym = make_expr_symbol(&rep_exp);
			if (size != 1) {
				expressionS	size_exp;
				size_exp.X_op = O_constant;
				size_exp.X_add_number = size;

				rep_exp.X_op = O_multiply;
				rep_exp.X_add_symbol = rep_sym;
				rep_exp.X_op_symbol = make_expr_symbol(&size_exp);
				rep_exp.X_add_number = 0;
				rep_sym = make_expr_symbol(&rep_exp);
			}
			p = frag_var(rs_space,(int)size,(int)size,
			(relax_substateT) 0,rep_sym,(offsetT) 0,(char *)0);
		}

		memset(p,0,(unsigned int)size);

		/* The magic number BSD_FILL_SIZE_CROCK_4 is from BSD 4.2 VAX
		 * flavoured AS.  The following bizarre behaviour is to be
		 * compatible with above.  I guess they tried to take up to 8
		 * bytes from a 4-byte expression and they forgot to sign
		 * extend.  */
#define BSD_FILL_SIZE_CROCK_4 (4)
		/* So, we are still in 2023 keeping compatibility with an
		   assembler for a machine that ceased production in 2000.
		   jacob */
		md_number_to_chars(p,(valueT) fill,
				   (size > BSD_FILL_SIZE_CROCK_4
				    ? BSD_FILL_SIZE_CROCK_4
				    : (int)size));
		/* Note: .fill (),0 emits no frag (since we are asked to .fill
		 * 0 bytes) but emits no error message because it seems a legal
		 * thing to do. It is a degenerate case of .fill but could be
		 * emitted by a compiler.  */
	}
	demand_empty_rest_of_line();
}

static void	s_globl(int ignore ATTRIBUTE_UNUSED)
{
	char           *name;
	int		c;
	symbolS        *symbolP;

	do {
		if ((name = read_symbol_name()) == NULL)
			return;

		symbolP = symbol_find_or_make(name);
		S_SET_EXTERNAL(symbolP);

		SKIP_WHITESPACE();
		c = *input_line_pointer;
		if (c == ',') {
			input_line_pointer++;
			SKIP_WHITESPACE();
			if (is_end_of_line[(unsigned char)*input_line_pointer])
				c = '\n';
		}
		free(name);
	}
	while (c == ',');

	demand_empty_rest_of_line();

}


/* Handle the .linkonce pseudo-op.  This tells the assembler to mark the
 * section to only be linked once.  However,this is not supported by most
 * object file formats.  This takes an optional argument,which is what to do
 * about duplicates.  */
static void	s_linkonce(int ignore ATTRIBUTE_UNUSED)
{
	enum linkonce_type type;

	SKIP_WHITESPACE();

	type = LINKONCE_DISCARD;

	if (!is_end_of_line[(unsigned char)*input_line_pointer]) {
		char           *s;
		char		c;

		c = get_symbol_name(&s);
		if (strcasecmp(s,"discard") == 0)
			type = LINKONCE_DISCARD;
		else
			if (strcasecmp(s,"one_only") == 0)
				type = LINKONCE_ONE_ONLY;
			else
				if (strcasecmp(s,"same_size") == 0)
					type = LINKONCE_SAME_SIZE;
				else
					if (strcasecmp(s,"same_contents") == 0)
						type = LINKONCE_SAME_CONTENTS;
					else
						as_warn(("unrecognized .linkonce type `%s'"),s);

		(void)restore_line_pointer(c);
	}
#ifdef obj_handle_link_once
	obj_handle_link_once(type);
#else				/* ! defined (obj_handle_link_once) */
	{
		uint32_t	flags;

		if ((bfd_applicable_section_flags(stdoutput) & SEC_LINK_ONCE) == 0)
			as_warn((".linkonce is not supported for this object file format"));

		flags = now_seg->flags;
		flags |= SEC_LINK_ONCE;
		switch (type) {
		default:
			abort();
		case LINKONCE_DISCARD:
			flags |= SEC_LINK_DUPLICATES_DISCARD;
			break;
		case LINKONCE_ONE_ONLY:
			flags |= SEC_LINK_DUPLICATES_ONE_ONLY;
			break;
		case LINKONCE_SAME_SIZE:
			flags |= SEC_LINK_DUPLICATES_SAME_SIZE;
			break;
		case LINKONCE_SAME_CONTENTS:
			flags |= SEC_LINK_DUPLICATES_SAME_CONTENTS;
			break;
		}
		now_seg->flags = flags;
	}
#endif				/* ! defined (obj_handle_link_once) */

	demand_empty_rest_of_line();
}

static void	bss_alloc(symbolS * symbolP,addressT size,unsigned int align)
{
	char           *pfrag;
	segT		current_seg = now_seg;
	subsegT		current_subseg = now_subseg;
	segT		bss_seg = bss_section;

	subseg_set(bss_seg,1);

	if (align > OCTETS_PER_BYTE_POWER) {
		record_alignment(bss_seg,align);
		frag_align(align,0,0);
	}
	/* Detach from old frag.  */
	if (S_GET_SEGMENT(symbolP) == bss_seg)
		symbol_get_frag(symbolP)->fr_symbol = NULL;

	symbol_set_frag(symbolP,frag_now);
	pfrag = frag_var(rs_org,1,1,0,symbolP,size * OCTETS_PER_BYTE,NULL);
	*pfrag = 0;

	S_SET_SIZE(symbolP,size);
	S_SET_SEGMENT(symbolP,bss_seg);

	subseg_set(current_seg,current_subseg);
}

static offsetT	parse_align(int align_bytes)
{
	expressionS	exp;
	addressT	align;

	SKIP_WHITESPACE();
	if (*input_line_pointer != ',') {
no_align:
		as_bad(("expected alignment after size"));
		ignore_rest_of_line();
		return -1;
	}
	input_line_pointer++;
	SKIP_WHITESPACE();

	align = get_absolute_expr(&exp);
	if (exp.X_op == O_absent)
		goto no_align;

	if (!exp.X_unsigned) {
		as_warn(("alignment negative; 0 assumed"));
		align = 0;
	}
	if (align_bytes && align != 0) {
		/* convert to a power of 2 alignment */
		unsigned int	alignp2 = 0;
		while ((align & 1) == 0)
			align >>= 1,++alignp2;
		if (align != 1) {
			as_bad(("alignment not a power of 2"));
			ignore_rest_of_line();
			return -1;
		}
		align = alignp2;
	}
	return align;
}

/*
 * Called from s_comm_internal after symbol name and size have been parsed.
 * NEEDS_ALIGN is 0 if it was an ".lcomm" (2 args only),1 if this was a ".bss"
 * directive which has a 3rd argument (alignment as a power of 2),or 2 if this
 * was a ".bss" directive with alignment in bytes.
 */
static symbolS *s_lcomm_internal(int needs_align,symbolS * symbolP,addressT size)
{
	addressT	align = 0;

	if (needs_align) {
		align = parse_align(needs_align - 1);
		if (align == (addressT) - 1)
			return NULL;
	} else
		/* Assume some objects may require alignment on some systems.  */
		TC_IMPLICIT_LCOMM_ALIGNMENT(size,align);

	bss_alloc(symbolP,size,align);
	return symbolP;
}

static void	s_lcomm(int needs_align)
{
	s_comm_internal(needs_align,s_lcomm_internal);
}

static void	s_lsym(int ignore ATTRIBUTE_UNUSED)
{
	char           *name;
	expressionS	exp;
	symbolS        *symbolP;

	/* We permit ANY defined expression: BSD4.2 demands constants.  */
	if ((name = read_symbol_name()) == NULL)
		return;

	if (*input_line_pointer != ',') {
		as_bad(("expected comma after \"%s\""),name);
		goto err_out;
	}
	input_line_pointer++;
	expression_and_evaluate(&exp);

	if (exp.X_op != O_constant
	    && exp.X_op != O_register) {
		as_bad(("bad expression"));
		goto err_out;
	}
	symbolP = symbol_find_or_make(name);

	if (S_GET_SEGMENT(symbolP) == undefined_section) {
		/*
		 * The name might be an undefined .global symbol; be sure to
		 * keep the "external" bit.
		 */
		S_SET_SEGMENT(symbolP,
			      (exp.X_op == O_constant
			       ? absolute_section
			       : reg_section));
		S_SET_VALUE(symbolP,(valueT) exp.X_add_number);
	} else {
		as_bad(("symbol `%s' is already defined"),name);
	}

	demand_empty_rest_of_line();
	free(name);
	return;

err_out:
	ignore_rest_of_line();
	free(name);
	return;
}

/* Handle changing the location counter.  */
static void	do_org(segT segment,expressionS * exp,int fill)
{
	if (segment != now_seg
	    && segment != absolute_section
	    && segment != expr_section)
		as_bad(("invalid segment \"%s\""),segment_name(segment));

	if (now_seg == absolute_section) {
		if (fill != 0)
			as_warn(("ignoring fill value in absolute section"));
		if (exp->X_op != O_constant) {
			as_bad(("only constant offsets supported in absolute section"));
			exp->X_add_number = 0;
		}
		abs_section_offset = exp->X_add_number;
	} else {
		char           *p;
		symbolS        *sym = exp->X_add_symbol;
		offsetT		off = exp->X_add_number * OCTETS_PER_BYTE;

		if (fill && in_bss())
			as_warn(("ignoring fill value in section `%s'"),
				segment_name(now_seg));

		if (exp->X_op != O_constant && exp->X_op != O_symbol) {
			/* Handle complex expressions.  */
			sym = make_expr_symbol(exp);
			off = 0;
		}
		p = frag_var(rs_org,1,1,(relax_substateT) 0,sym,off,(char *)0);
		*p = fill;
	}
}

static void	s_org(int ignore ATTRIBUTE_UNUSED)
{
	segT		segment;
	expressionS	exp;
	long		temp_fill;

	/*
	 * Don't believe the documentation of BSD 4.2 AS.  There is no such
	 * thing as a sub-segment-relative origin.  Any absolute origin is
	 * given a warning,then assumed to be segment-relative.  Any segmented
	 * origin expression ("foo+42") had better be in the right segment or
	 * the .org is ignored.
	 * 
	 * BSD 4.2 AS warns if you try to .org backwards. We cannot because we
	 * never know sub-segment sizes when we are reading code.  BSD will
	 * crash trying to emit negative numbers of filler bytes in certain
	 * .orgs. We don't crash,but see as-write for that code.
	 * 
	 * Don't make frag if need_pass_2==1.
	 */
	segment = get_known_segmented_expression(&exp);
	if (*input_line_pointer == ',') {
		input_line_pointer++;
		temp_fill = get_absolute_expression();
	} else
		temp_fill = 0;

	if (!need_pass_2)
		do_org(segment,&exp,temp_fill);

	demand_empty_rest_of_line();
}

static void	assign_symbol(char *name,int mode)
{
	symbolS        *symbolP;

	if (name[0] == '.' && name[1] == '\0') {
		/* Turn '. = mumble' into a .org mumble.  */
		segT		segment;
		expressionS	exp;

		segment = get_known_segmented_expression(&exp);

		if (!need_pass_2)
			do_org(segment,&exp,0);

		return;
	}
	if ((symbolP = symbol_find(name)) == NULL
	    && (symbolP = md_undefined_symbol(name)) == NULL) {
		symbolP = symbol_find_or_make(name);
#if defined (OBJ_COFF) && !defined (TE_PE)
		/* "set" symbols are local unless otherwise specified.  */
		SF_SET_LOCAL(symbolP);
#endif
	}
	if (S_IS_DEFINED(symbolP) || symbol_equated_p(symbolP)) {
		if ((mode != 0 || !S_IS_VOLATILE(symbolP))
		    && !S_CAN_BE_REDEFINED(symbolP)) {
			as_bad(("symbol `%s' is already defined"),name);
			ignore_rest_of_line();
			input_line_pointer--;
			return;
		}
		/* If the symbol is volatile,copy the symbol and replace the
		 * original with the copy,so that previous uses of the symbol
		 * will retain the value of the symbol at the point of use.  */
		else
			if (S_IS_VOLATILE(symbolP))
				symbolP = symbol_clone(symbolP,1);
	}
	if (mode == 0)
		S_SET_VOLATILE(symbolP);
	else
		if (mode < 0)
			S_SET_FORWARD_REF(symbolP);

	pseudo_set(symbolP);
}

/* Handle the .equ,.equiv,.eqv,and .set directives.  If EQUIV is 1,then
 * this is .equiv,and it is an error if the symbol is already defined.  If
 * EQUIV is -1,the symbol additionally is a forward reference.  */
static void	s_set(int equiv)
{
	char           *name;

	/* Especial apologies for the random logic: this just grew,and could
	 * be parsed much more simply! Dean in haste.  */
	if ((name = read_symbol_name()) == NULL)
		return;

	if (*input_line_pointer != ',') {
		as_bad(("expected comma after \"%s\""),name);
		ignore_rest_of_line();
		free(name);
		return;
	}
	input_line_pointer++;
	assign_symbol(name,equiv);
	demand_empty_rest_of_line();
	free(name);
}

static void	s_space(int mult)
{
	expressionS	exp;
	expressionS	val;
	char           *p = 0;

	switch (mult) {
	case 'x':
#ifdef X_PRECISION
#ifndef P_PRECISION
#define P_PRECISION     X_PRECISION
#define P_PRECISION_PAD X_PRECISION_PAD
#endif
		mult = (X_PRECISION + X_PRECISION_PAD) * sizeof(LITTLENUM_TYPE);
		if (!mult)
#endif
			mult = 12;
		break;

	case 'p':
#ifdef P_PRECISION
		mult = (P_PRECISION + P_PRECISION_PAD) * sizeof(LITTLENUM_TYPE);
		if (!mult)
#endif
			mult = 12;
		break;
	}

	riscv_mapping_state(MAP_DATA,0,0);
	expression(&exp);

	SKIP_WHITESPACE();
	if (*input_line_pointer == ',') {
		++input_line_pointer;
		expression(&val);
	} else {
		val.X_op = O_constant;
		val.X_add_number = 0;
	}

	if ((val.X_op != O_constant
	     || val.X_add_number < -0x80
	     || val.X_add_number > 0xff
	     || (mult != 0 && mult != 1 && val.X_add_number != 0))
	    && (now_seg != absolute_section && !in_bss())) {
		resolve_expression(&exp);
		if (exp.X_op != O_constant)
			as_bad(("unsupported variable size or fill value"));
		else {
			offsetT		i;

			/*
			 * PR 20901: Check for excessive values. FIXME: 1<<10
			 * is an arbitrary limit.  Maybe use maxpagesize
			 * instead ?
			 */
			if (exp.X_add_number < 0 || exp.X_add_number > (1 << 10))
				as_bad(("size value for space directive too large: %lx"),
				       (long)exp.X_add_number);
			else {
				if (mult == 0)
					mult = 1;

				for (i = 0; i < exp.X_add_number; i++)
					emit_expr(&val,mult);
			}
		}
	} else {
		if (now_seg == absolute_section)
			resolve_expression(&exp);

		if (exp.X_op == O_constant) {
			addressT	repeat = exp.X_add_number;
			addressT	total;

			if ((offsetT) repeat < 0) {
				as_warn((".space repeat count is negative,ignored"));
				goto getout;
			}
			if (repeat == 0) {
				goto getout;
			}
			if ((unsigned int)mult <= 1)
				total = repeat;
			else
				if (gas_mul_overflow(repeat,mult,&total)
				    || (offsetT) total < 0) {
					as_warn((".space repeat count overflow,ignored"));
					goto getout;
				}
			/*
			 * If we are in the absolute section,just bump the
			 * offset.
			 */
			if (now_seg == absolute_section) {
				if (val.X_op != O_constant || val.X_add_number != 0)
					as_warn(("ignoring fill value in absolute section"));
				abs_section_offset += total;
				goto getout;
			}
			/*
			 * If we are secretly in an MRI common section,then
			 * creating space just increases the size of the common
			 * symbol.
			 */

			if (!need_pass_2)
				p = frag_var(rs_fill,1,1,(relax_substateT) 0,(symbolS *) 0,
					     (offsetT) total,(char *)0);
		} else {
			if (now_seg == absolute_section) {
				as_bad(("space allocation too complex in absolute section"));
				subseg_set(text_section,0);
			}
			if (!need_pass_2)
				p = frag_var(rs_space,1,1,(relax_substateT) 0,
					     make_expr_symbol(&exp),(offsetT) 0,(char *)0);
		}

		if ((val.X_op != O_constant || val.X_add_number != 0) && in_bss())
			as_warn(("ignoring fill value in section `%s'"),
				segment_name(now_seg));
		else
			if (p)
				*p = val.X_add_number;
	}

getout:

	demand_empty_rest_of_line();

}

static void	s_nop(int ignore ATTRIBUTE_UNUSED)
{
	expressionS	exp;
	fragS          *start;
	addressT	start_off;
	offsetT		frag_off;

	riscv_mapping_state(MAP_DATA, 0, 0);

	SKIP_WHITESPACE();
	expression(&exp);
	demand_empty_rest_of_line();

	start = frag_now;
	start_off = frag_now_fix();
	do {
#ifdef md_emit_single_noop
		md_emit_single_noop;
#else
		char           *nop;

#ifndef md_single_noop_insn
#define md_single_noop_insn "nop"
#endif
		/*
		 * md_assemble might modify its argument,so we must pass it a
		 * string that is writable.
		 */
		if (asprintf(&nop,"%s",md_single_noop_insn) < 0)
			as_fatal("%s",xstrerror(errno));

		/*
		 * Some targets assume that they can update input_line_pointer
		 * inside md_assemble,and,worse,that they can leave it
		 * assigned to the string pointer that was provided as an
		 * argument.  So preserve ilp here.
		 */
		char           *saved_ilp = input_line_pointer;
		md_assemble(nop);
		input_line_pointer = saved_ilp;
		free(nop);
#endif
	} while (exp.X_op == O_constant
		 && exp.X_add_number > 0
		 && frag_offset_ignore_align_p(start,frag_now,&frag_off)
		 && frag_off + frag_now_fix() < start_off + exp.X_add_number);
}

static void	s_nops(int ignore ATTRIBUTE_UNUSED)
{
	expressionS	exp;
	expressionS	val;

	riscv_mapping_state (MAP_DATA, 0, 0);

	SKIP_WHITESPACE();
	expression(&exp);
	/*
	 * Note - this expression is tested for an absolute value in
	 * write.c:relax_segment().
	 */

	SKIP_WHITESPACE();
	if (*input_line_pointer == ',') {
		++input_line_pointer;
		expression(&val);
	} else {
		val.X_op = O_constant;
		val.X_add_number = 0;
	}

	if (val.X_op != O_constant) {
		as_bad(("unsupported variable nop control in .nops directive"));
		val.X_op = O_constant;
		val.X_add_number = 0;
	} else
		if (val.X_add_number < 0) {
			as_warn(("negative nop control byte,ignored"));
			val.X_add_number = 0;
		}
	demand_empty_rest_of_line();

	if (need_pass_2)
		/*
		 * Ignore this directive if we are going to perform a second
		 * pass.
		 */
		return;

	/* Store the no-op instruction control byte in the first byte of frag.  */
	char           *p;
	symbolS        *sym = make_expr_symbol(&exp);
	p = frag_var(rs_space_nop,1,1,(relax_substateT) 0,
		     sym,(offsetT) 0,(char *)0);
	*p = val.X_add_number;
}

/* Obtain the size of a floating point number,given a type.  */
static int	float_length(int float_type,int *pad_p)
{
	int		length    ,pad = 0;

	switch (float_type) {
	case 'b':
	case 'B':
	case 'h':
	case 'H':
		length = 2;
		break;

	case 'f':
	case 'F':
	case 's':
	case 'S':
		length = 4;
		break;

	case 'd':
	case 'D':
	case 'r':
	case 'R':
		length = 8;
		break;

	case 'x':
	case 'X':
#ifdef X_PRECISION
		length = X_PRECISION * sizeof(LITTLENUM_TYPE);
		pad = X_PRECISION_PAD * sizeof(LITTLENUM_TYPE);
		if (!length)
#endif
			length = 12;
		break;

	case 'p':
	case 'P':
#ifdef P_PRECISION
		length = P_PRECISION * sizeof(LITTLENUM_TYPE);
		pad = P_PRECISION_PAD * sizeof(LITTLENUM_TYPE);
		if (!length)
#endif
			length = 12;
		break;

	default:
		as_bad(("unknown floating type '%c'"),float_type);
		length = -1;
		break;
	}

	if (pad_p)
		*pad_p = pad;

	return length;
}

static int	parse_one_float(int float_type,char temp[MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT])
{
	int		length;

	SKIP_WHITESPACE();

	/* Skip any 0{letter} that may be present.  Don't even check if the
	 * letter is legal.  Someone may invent a "z" format and this routine
	 * has no use for such information. Lusers beware: you get diagnostics
	 * if your input is ill-conditioned.  */
	if (input_line_pointer[0] == '0' && ISALPHA(input_line_pointer[1]))
		input_line_pointer += 2;

	/* Accept :xxxx,where the x's are hex digits,for a floating point
	 * with the exact digits specified.  */
	if (input_line_pointer[0] == ':') {
		++input_line_pointer;
		length = hex_float(float_type,temp);
		if (length < 0) {
			ignore_rest_of_line();
			return length;
		}
	} else {
		const char     *err;

		err = ieee_md_atof(float_type,temp,&length,TARGET_BYTES_BIG_ENDIAN);
		know(length <= MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT);
		know(err != NULL || length > 0);
		if (err) {
			as_bad(("bad floating literal: %s"),err);
			ignore_rest_of_line();
			return -1;
		}
	}
	return length;
}
static void	s_struct(int ignore ATTRIBUTE_UNUSED)
{
	abs_section_offset = get_absolute_expression();
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
	/*
	 * The ELF backend needs to know that we are changing sections,so that
	 * .previous works correctly.
	 */
	if (IS_ELF)
		obj_elf_section_change_hook();
#endif
	subseg_set(absolute_section,0);
	demand_empty_rest_of_line();
}

static void	s_text(int ignore ATTRIBUTE_UNUSED)
{
	int		temp;

	temp = get_absolute_expression();
	subseg_set(text_section,(subsegT) temp);
	demand_empty_rest_of_line();
}

/*
 * .weakref x,y sets x as an alias to y that,as long as y is not referenced
 * directly,will cause y to become a weak symbol.
 */
static void	s_weakref(int ignore ATTRIBUTE_UNUSED)
{
	char           *name;
	symbolS        *symbolP;
	symbolS        *symbolP2;
	expressionS	exp;

	if ((name = read_symbol_name()) == NULL)
		return;

	symbolP = symbol_find_or_make(name);

	if (S_IS_DEFINED(symbolP) || symbol_equated_p(symbolP)) {
		//if (!S_IS_VOLATILE(symbolP)) {
			as_bad(("symbol `%s' is already defined"),name);
			goto err_out;
		//}
#if 0
		symbolP = symbol_clone(symbolP,1);
		S_CLEAR_VOLATILE(symbolP);
#endif
	}
	SKIP_WHITESPACE();

	if (*input_line_pointer != ',') {
		as_bad(("expected comma after \"%s\""),name);
		goto err_out;
	}
	input_line_pointer++;

	SKIP_WHITESPACE();
	free(name);

	if ((name = read_symbol_name()) == NULL)
		return;

	if ((symbolP2 = symbol_find_noref(name,1)) == NULL
	    && (symbolP2 = md_undefined_symbol(name)) == NULL) {
		symbolP2 = symbol_find_or_make(name);
		S_SET_WEAKREFD(symbolP2);
	} else {
		symbolS        *symp = symbolP2;

		while (S_IS_WEAKREFR(symp) && symp != symbolP) {
			expressionS    *expP = symbol_get_value_expression(symp);

			gas_assert(expP->X_op == O_symbol
				   && expP->X_add_number == 0);
			symp = expP->X_add_symbol;
		}
		if (symp == symbolP) {
			char           *loop;

			loop = concat(S_GET_NAME(symbolP),
			    " => ",S_GET_NAME(symbolP2),(const char *)NULL);

			symp = symbolP2;
			while (symp != symbolP) {
				char           *old_loop = loop;

				symp = symbol_get_value_expression(symp)->X_add_symbol;
				loop = concat(loop," => ",S_GET_NAME(symp),
					      (const char *)NULL);
				free(old_loop);
			}

			as_bad(("%s: would close weakref loop: %s"),
			       S_GET_NAME(symbolP),loop);

			free(loop);
			free(name);
			ignore_rest_of_line();
			return;
		}
		/*
		 * Short-circuiting instead of just checking here might speed
		 * things up a tiny little bit,but loop error messages would
		 * miss intermediate links.
		 */
		/* symbolP2 = symp; */
	}

	memset(&exp,0,sizeof(exp));
	exp.X_op = O_symbol;
	exp.X_add_symbol = symbolP2;

	S_SET_SEGMENT(symbolP,undefined_section);
	symbol_set_value_expression(symbolP,&exp);
	symbol_set_frag(symbolP,&zero_address_frag);
	S_SET_WEAKREFR(symbolP);

	demand_empty_rest_of_line();
	free(name);
	return;

err_out:
	ignore_rest_of_line();
	free(name);
	return;
}


/* Verify that we are at the end of a line.  If not,issue an error and skip to
 * EOL.  This function may leave input_line_pointer one past buffer_limit,so
 * should not be called from places that may dereference input_line_pointer
 * unconditionally.  Note that when the gas parser is switched to handling a
 * string (where buffer_limit should be the size of the string excluding the
 * NUL terminator) this will be one past the NUL; is_end_of_line(0) returns
 * true.  */
static void	demand_empty_rest_of_line(void)
{
	SKIP_WHITESPACE();
	if (input_line_pointer > buffer_limit)
		return;
	if (is_end_of_line[(unsigned char)*input_line_pointer])
		input_line_pointer++;
	else {
		if (ISPRINT(*input_line_pointer))
			as_bad("junk at end of line,first unrecognized character is `%c'",
			       *input_line_pointer);
		else
			as_bad("junk at end of line,first unrecognized character valued 0x%x",
			       *input_line_pointer);
		ignore_rest_of_line();
	}
	/* Return pointing just after end-of-line.  */
}

/* Silently advance to the end of line.  Use this after already having issued
 * an error about something bad.  Like demand_empty_rest_of_line,this function
 * may leave input_line_pointer one after buffer_limit; Don't call it from
 * within expression parsing code in an attempt to silence further errors.  */
static void	ignore_rest_of_line(void)
{
	while (input_line_pointer <= buffer_limit)
		if (is_end_of_line[(unsigned char)*input_line_pointer++])
			break;
	/* Return pointing just after end-of-line.  */
}

/* Sets frag for given symbol to zero_address_frag,except when the symbol frag
 * is already set to a dummy listing frag.  */
static void	set_zero_frag(symbolS * symbolP)
{
	if (symbol_get_frag(symbolP)->fr_type != rs_dummy)
		symbol_set_frag(symbolP,&zero_address_frag);
}

/* In:	Pointer to a symbol. Input_line_pointer->expression.
 * 
 * Out:	Input_line_pointer->just after any whitespace after expression. Tried
 * to set symbol to value of expression. Will change symbols type,value,and
 * frag; */
static void	pseudo_set(symbolS * symbolP)
{
	expressionS	exp;
	segT		seg;

	know(symbolP);		/* NULL pointer is logic error.  */

	if (!S_IS_FORWARD_REF(symbolP))
		(void)expression(&exp);
	else
		(void)deferred_expression(&exp);

	if (exp.X_op == O_illegal)
		as_bad(("illegal expression"));
	else
		if (exp.X_op == O_absent)
			as_bad(("missing expression"));
		else
			if (exp.X_op == O_big) {
				if (exp.X_add_number > 0)
					as_bad(("bignum invalid"));
				else
					as_bad(("floating point number invalid"));
			} else
				if (exp.X_op == O_subtract
				    && !S_IS_FORWARD_REF(symbolP)
				&& SEG_NORMAL(S_GET_SEGMENT(exp.X_add_symbol))
				    && (symbol_get_frag(exp.X_add_symbol)
					== symbol_get_frag(exp.X_op_symbol))) {
					exp.X_op = O_constant;
					exp.X_add_number = (S_GET_VALUE(exp.X_add_symbol)
					      - S_GET_VALUE(exp.X_op_symbol));
				}
	if (symbol_section_p(symbolP)) {
		as_bad("attempt to set value of section symbol");
		return;
	}
	switch (exp.X_op) {
	case O_illegal:
	case O_absent:
	case O_big:
		exp.X_add_number = 0;
		/* Fall through.  */
	case O_constant:
		S_SET_SEGMENT(symbolP,absolute_section);
		S_SET_VALUE(symbolP,(valueT) exp.X_add_number);
		set_zero_frag(symbolP);
		break;

	case O_register:
#ifndef TC_GLOBAL_REGISTER_SYMBOL_OK
		if (S_IS_EXTERNAL(symbolP)) {
			as_bad("can't equate global symbol `%s' with register name",
			       S_GET_NAME(symbolP));
			return;
		}
#endif
		/*
		 * Make sure symbol_equated_p() recognizes the symbol as an
		 * equate.
		 */
		exp.X_add_symbol = make_expr_symbol(&exp);
		exp.X_add_number = 0;
		exp.X_op = O_symbol;
		symbol_set_value_expression(symbolP,&exp);
		S_SET_SEGMENT(symbolP,reg_section);
		set_zero_frag(symbolP);
		break;

	case O_symbol:
		seg = S_GET_SEGMENT(exp.X_add_symbol);
		/*
		 * For x=undef+const,create an expression symbol. For
		 * x=x+const,just update x except when x is an undefined
		 * symbol For x=defined+const,evaluate x.
		 */
		if (symbolP == exp.X_add_symbol
		    && (seg != undefined_section
			|| !symbol_constant_p(symbolP))) {
			*symbol_X_add_number(symbolP) += exp.X_add_number;
			break;
		} else
			if (!S_IS_FORWARD_REF(symbolP) && seg != undefined_section) {
				symbolS        *s = exp.X_add_symbol;

				if (S_IS_COMMON(s))
					as_bad(("`%s' can't be equated to common symbol `%s'"),
					  S_GET_NAME(symbolP),S_GET_NAME(s));

				S_SET_SEGMENT(symbolP,seg);
				S_SET_VALUE(symbolP,exp.X_add_number + S_GET_VALUE(s));
				symbol_set_frag(symbolP,symbol_get_frag(s));
				copy_symbol_attributes(symbolP,s);
				break;
			}
		S_SET_SEGMENT(symbolP,undefined_section);
		symbol_set_value_expression(symbolP,&exp);
		copy_symbol_attributes(symbolP,exp.X_add_symbol);
		set_zero_frag(symbolP);
		break;

	default:
		/* The value is some complex expression.  */
		S_SET_SEGMENT(symbolP,expr_section);
		symbol_set_value_expression(symbolP,&exp);
		set_zero_frag(symbolP);
		break;
	}
}

/*
 * cons() CONStruct more frag of .bytes,or .words etc. Should need_pass_2 be 1
 * then emit no frag(s). This understands EXPRESSIONS.
 * 
 * Bug (?)
 * 
 * This has a split personality. We use expression() to read the value. We can
 * detect if the value won't fit in a byte or word. But we can't detect if
 * expression() discarded significant digits in the case of a long. Not worth
 * the crocks required to fix it.
 */

/* Select a parser for cons expressions.  */

/*
 * Some targets need to parse the expression in various fancy ways. You can
 * define TC_PARSE_CONS_EXPRESSION to do whatever you like (for example,the
 * HPPA does this).  Otherwise,you can define REPEAT_CONS_EXPRESSIONS to
 * permit repeat counts.  If none of these are defined,which is the normal
 * case,then only simple expressions are permitted.
 */

#ifndef TC_PARSE_CONS_EXPRESSION
#ifdef REPEAT_CONS_EXPRESSIONS
#define TC_PARSE_CONS_EXPRESSION(EXP,NBYTES) \
  (parse_repeat_cons (EXP,NBYTES),TC_PARSE_CONS_RETURN_NONE)
static void
		parse_repeat_cons(expressionS * exp,unsigned int nbytes);
#endif

/* If we haven't gotten one yet,just call expression.  */
#ifndef TC_PARSE_CONS_EXPRESSION
#define TC_PARSE_CONS_EXPRESSION(EXP,NBYTES) \
  (expression (EXP),TC_PARSE_CONS_RETURN_NONE)
#endif
#endif

void		do_parse_cons_expression(expressionS * exp,
			    		int		nbytes	ATTRIBUTE_UNUSED)
{
	(void)TC_PARSE_CONS_EXPRESSION(exp,nbytes);
}


/* Worker to do .byte etc statements. Clobbers input_line_pointer and checks
 * end-of-line.  */
static void	cons_worker(int nbytes,	/* 1=.byte,2=.word,4=.long.  */
					int		rva)
{
	int		c;
	expressionS	exp;

	if (is_it_end_of_statement()) {
		demand_empty_rest_of_line();
		return;
	}
	if (nbytes == 0)
		nbytes = TC_ADDRESS_BYTES();

	riscv_mapping_state (MAP_DATA, 0, 0);
	c = 0;
	do {
		TC_PARSE_CONS_RETURN_TYPE ret = TC_PARSE_CONS_RETURN_NONE;
		ret = TC_PARSE_CONS_EXPRESSION(&exp,(unsigned int)nbytes);

		if (rva) {
			if (exp.X_op == O_symbol)
				exp.X_op = O_symbol_rva;
			else
				as_fatal(("rva without symbol"));
		}
		emit_expr_with_reloc(&exp,(unsigned int)nbytes,ret);
		++c;
	}
	while (*input_line_pointer++ == ',');

	input_line_pointer--;	/* Put terminator back into stream.  */

	demand_empty_rest_of_line();

}

static void	cons(int size)
{
	cons_worker(size,0);
}

static void	s_rva(int size)
{
	cons_worker(size,1);
}

/* .reloc offset,reloc_name,symbol+addend.  */
static void	s_reloc(int ignore ATTRIBUTE_UNUSED)
{
	expressionS	exp;
	char           *r_name;
	int		c;
	struct reloc_list *reloc;
	struct _bfd_rel {
		const char     *name;
		bfd_reloc_code_real_type code;
	};
	static const struct _bfd_rel bfd_relocs[] =
	{
		{"NONE",BFD_RELOC_NONE},
		{"8",BFD_RELOC_8},
		{"16",BFD_RELOC_16},
		{"32",BFD_RELOC_32},
		{"64",BFD_RELOC_64}
	};

	reloc = XNEW(struct reloc_list);

	expression(&exp);
	switch (exp.X_op) {
	case O_illegal:
	case O_absent:
	case O_big:
	case O_register:
		as_bad(("missing or bad offset expression"));
		goto err_out;
	case O_constant:
		exp.X_add_symbol = section_symbol(now_seg);
		/*
		 * Mark the section symbol used in relocation so that it will
		 * be included in the symbol table.
		 */
		symbol_mark_used_in_reloc(exp.X_add_symbol);
		exp.X_op = O_symbol;
		/* Fallthru */
	case O_symbol:
		if (exp.X_add_number == 0) {
			reloc->u.a.offset_sym = exp.X_add_symbol;
			break;
		}
		/* Fallthru */
	default:
		reloc->u.a.offset_sym = make_expr_symbol(&exp);
		break;
	}

	SKIP_WHITESPACE();
	if (*input_line_pointer != ',') {
		as_bad(("missing reloc type"));
		goto err_out;
	}
	++input_line_pointer;
	SKIP_WHITESPACE();
	c = get_symbol_name(&r_name);
	if (strncasecmp(r_name,"BFD_RELOC_",10) == 0) {
		unsigned int	i;

		for (reloc->u.a.howto = NULL,i = 0; i < ARRAY_SIZE(bfd_relocs); i++)
			if (strcasecmp(r_name + 10,bfd_relocs[i].name) == 0) {
				reloc->u.a.howto = riscv_reloc_type_lookup(stdoutput,
							  bfd_relocs[i].code);
				break;
			}
	} else
		reloc->u.a.howto = riscv_reloc_name_lookup(stdoutput,r_name);
	*input_line_pointer = c;
	if (reloc->u.a.howto == NULL) {
		as_bad(("unrecognized reloc type"));
		goto err_out;
	}
	exp.X_op = O_absent;
	SKIP_WHITESPACE_AFTER_NAME();
	if (*input_line_pointer == ',') {
		++input_line_pointer;
		expression(&exp);
	}
	switch (exp.X_op) {
	case O_illegal: case O_big: case O_register:
		as_bad(("bad reloc expression"));
err_out:
		ignore_rest_of_line();
		free(reloc);
		return;
	case O_absent:
		reloc->u.a.sym = NULL;
		reloc->u.a.addend = 0;
		break;
	case O_constant:
		reloc->u.a.sym = NULL;
		reloc->u.a.addend = exp.X_add_number;
		break;
	case O_symbol:
		reloc->u.a.sym = exp.X_add_symbol;
		reloc->u.a.addend = exp.X_add_number;
		break;
	default:
		reloc->u.a.sym = make_expr_symbol(&exp);
		reloc->u.a.addend = 0;
		break;
	}

	reloc->file = as_where(&reloc->line);
	reloc->next = reloc_list;
	reloc_list = reloc;

	demand_empty_rest_of_line();
}

/* Put the contents of expression EXP into the object file using NBYTES bytes.
 * If need_pass_2 is 1,this does nothing.  */
static void	emit_expr(expressionS * exp,unsigned int nbytes)
{
	emit_expr_with_reloc(exp,nbytes,TC_PARSE_CONS_RETURN_NONE);
}

static void	emit_expr_with_reloc(expressionS * exp,
				 		unsigned	int	nbytes,
			       		TC_PARSE_CONS_RETURN_TYPE reloc)
{
	operatorT	op;
	char           *p;
	valueT		extra_digit = 0;

	/* Don't do anything if we are going to make another pass.  */
	if (need_pass_2)
		return;

	frag_grow(nbytes);
	dot_value = frag_now_fix();
	dot_frag = frag_now;


	if (check_eh_frame(exp,&nbytes))
		return;

	op = exp->X_op;

	/* Handle a negative bignum.  */
	if (op == O_uminus
	    && exp->X_add_number == 0
	    && symbol_get_value_expression(exp->X_add_symbol)->X_op == O_big
	&& symbol_get_value_expression(exp->X_add_symbol)->X_add_number > 0) {
		int		i;
		unsigned long	carry;

		exp = symbol_get_value_expression(exp->X_add_symbol);

		/* Negate the bignum: one's complement each digit and add 1.  */
		carry = 1;
		for (i = 0; i < exp->X_add_number; i++) {
			unsigned long	next;

			next = (((~(generic_bignum[i] & LITTLENUM_MASK))
				 & LITTLENUM_MASK)
				+ carry);
			generic_bignum[i] = next & LITTLENUM_MASK;
			carry = next >> LITTLENUM_NUMBER_OF_BITS;
		}

		/*
		 * We can ignore any carry out,because it will be handled by
		 * extra_digit if it is needed.
		 */

		extra_digit = (valueT) - 1;
		op = O_big;
	}
	if (op == O_absent || op == O_illegal) {
		as_warn(("zero assumed for missing expression"));
		exp->X_add_number = 0;
		op = O_constant;
	} else
		if (op == O_big && exp->X_add_number <= 0) {
			as_bad(("floating point number invalid"));
			exp->X_add_number = 0;
			op = O_constant;
		} else
			if (op == O_register) {
				as_warn(("register value used as expression"));
				op = O_constant;
			}
	/* Allow `.word 0' in the absolute section.  */
	if (now_seg == absolute_section) {
		if (op != O_constant || exp->X_add_number != 0)
			as_bad(("attempt to store value in absolute section"));
		abs_section_offset += nbytes;
		return;
	}
	/* Allow `.word 0' in BSS style sections.  */
	if ((op != O_constant || exp->X_add_number != 0) && in_bss())
		as_bad(("attempt to store non-zero value in section `%s'"),
		       segment_name(now_seg));

	p = frag_more((int)nbytes);

	if (reloc != TC_PARSE_CONS_RETURN_NONE) {
		emit_expr_fix(exp,nbytes,frag_now,p,reloc);
		return;
	}
	/*
	 * If we have an integer,but the number of bytes is too large to pass
	 * to md_number_to_chars,handle it as a bignum.
	 */
	if (op == O_constant && nbytes > sizeof(valueT)) {
		extra_digit = exp->X_unsigned ? 0 : -1;
		convert_to_bignum(exp,!exp->X_unsigned);
		op = O_big;
	}
	if (op == O_constant) {
		valueT		get;
		valueT		use;
		valueT		mask;
		valueT		unmask;

		/*
		 * JF << of >= number of bits in the object is undefined.  In
		 * particular SPARC (Sun 4) has problems.
		 */
		if (nbytes >= sizeof(valueT)) {
			know(nbytes == sizeof(valueT));
			mask = 0;
		} else {
			/* Don't store these bits.  */
			mask = ~(valueT) 0 << (BITS_PER_CHAR * nbytes);
		}

		unmask = ~mask;	/* Do store these bits.  */

		get = exp->X_add_number;
		use = get & unmask;
		if ((get & mask) != 0 && (-get & mask) != 0) {
			/* Leading bits contain both 0s & 1s.  */
			as_warn(("value 0x%" PRIx64 " truncated to 0x%" PRIx64),
				(uint64_t) get,(uint64_t) use);
		}
		/* Put bytes in right order.  */
		md_number_to_chars(p,use,(int)nbytes);
	} else
		if (op == O_big) {
			unsigned int	size;
			LITTLENUM_TYPE *nums;

			size = exp->X_add_number * CHARS_PER_LITTLENUM;
			if (nbytes < size) {
				int		i = nbytes / CHARS_PER_LITTLENUM;

				if (i != 0) {
					LITTLENUM_TYPE	sign = 0;
					if ((generic_bignum[--i]
					     & (1 << (LITTLENUM_NUMBER_OF_BITS - 1))) != 0)
						sign = ~(LITTLENUM_TYPE) 0;

					while (++i < exp->X_add_number)
						if (generic_bignum[i] != sign)
							break;
				} else
					if (nbytes == 1) {
						/*
						 * We have nbytes == 1 and
						 * CHARS_PER_LITTLENUM == 2
						 * (probably). Check that bits
						 * 8.. of generic_bignum[0]
						 * match bit 7 and that they
						 * match all of
						 * generic_bignum[1..exp->X_add_
						 * number].
						 */
						LITTLENUM_TYPE	sign = (generic_bignum[0] & (1 << 7)) ? -1 : 0;
						LITTLENUM_TYPE	himask = LITTLENUM_MASK & ~0xFF;

						if ((generic_bignum[0] & himask) == (sign & himask)) {
							while (++i < exp->X_add_number)
								if (generic_bignum[i] != sign)
									break;
						}
					}
				if (i < exp->X_add_number)
					as_warn(ngettext("bignum truncated to %d byte",
					       "bignum truncated to %d bytes",
							 nbytes),
						nbytes);
				size = nbytes;
			}
			if (nbytes == 1) {
				md_number_to_chars(p,(valueT) generic_bignum[0],1);
				return;
			}
			know(nbytes % CHARS_PER_LITTLENUM == 0);

			if (target_big_endian) {
				while (nbytes > size) {
					md_number_to_chars(p,extra_digit,CHARS_PER_LITTLENUM);
					nbytes -= CHARS_PER_LITTLENUM;
					p += CHARS_PER_LITTLENUM;
				}

				nums = generic_bignum + size / CHARS_PER_LITTLENUM;
				while (size >= CHARS_PER_LITTLENUM) {
					--nums;
					md_number_to_chars(p,(valueT) * nums,CHARS_PER_LITTLENUM);
					size -= CHARS_PER_LITTLENUM;
					p += CHARS_PER_LITTLENUM;
				}
			} else {
				nums = generic_bignum;
				while (size >= CHARS_PER_LITTLENUM) {
					md_number_to_chars(p,(valueT) * nums,CHARS_PER_LITTLENUM);
					++nums;
					size -= CHARS_PER_LITTLENUM;
					p += CHARS_PER_LITTLENUM;
					nbytes -= CHARS_PER_LITTLENUM;
				}

				while (nbytes >= CHARS_PER_LITTLENUM) {
					md_number_to_chars(p,extra_digit,CHARS_PER_LITTLENUM);
					nbytes -= CHARS_PER_LITTLENUM;
					p += CHARS_PER_LITTLENUM;
				}
			}
		} else
			emit_expr_fix(exp,nbytes,frag_now,p,TC_PARSE_CONS_RETURN_NONE);
}

static void	emit_expr_fix(expressionS * exp,unsigned int nbytes,fragS * frag,char *p,
		   		TC_PARSE_CONS_RETURN_TYPE r ATTRIBUTE_UNUSED)
{
	int		offset = 0;
	unsigned int	size = nbytes;

	memset(p,0,size);

	/* Generate a fixS to record the symbol value.  */

#ifdef TC_CONS_FIX_NEW
	TC_CONS_FIX_NEW(frag,p - frag->fr_literal + offset,size,exp,r);
#else
	if (r != TC_PARSE_CONS_RETURN_NONE) {
		reloc_howto_type *reloc_howto;

		reloc_howto = riscv_reloc_type_lookup(stdoutput,r);
		size = bfd_get_reloc_size(reloc_howto);

		if (size > nbytes) {
			as_bad(ngettext("%s relocations do not fit in %u byte",
				      "%s relocations do not fit in %u bytes",
					nbytes),
			       reloc_howto->name,nbytes);
			return;
		} else
			if (target_big_endian)
				offset = nbytes - size;
	} else
		switch (size) {
		case 1:
			r = BFD_RELOC_8;
			break;
		case 2:
			r = BFD_RELOC_16;
			break;
		case 3:
			r = BFD_RELOC_24;
			break;
		case 4:
			r = BFD_RELOC_32;
			break;
		case 8:
			r = BFD_RELOC_64;
			break;
		default:
			as_bad(("unsupported BFD relocation size %u"),size);
			return;
		}
	fix_new_exp(frag,p - frag->fr_literal + offset,size,
		    exp,0,r);
#endif
}

/*
 * Parse a floating point number represented as a hex constant.  This permits
 * users to specify the exact bits they want in the floating point number.
 */
static int	hex_float(int float_type,char *bytes)
{
	int		pad       ,length = float_length(float_type,&pad);
	int		i;

	if (length < 0)
		return length;

	/* It would be nice if we could go through expression to parse the hex
	 * constant,but if we get a bignum it's a pain to sort it into the
	 * buffer correctly.  */
	i = 0;
	while (hex_p(*input_line_pointer) || *input_line_pointer == '_') {
		int		d;

		/* The MRI assembler accepts arbitrary underscores strewn about
		 * through the hex constant,so we ignore them as well.  */
		if (*input_line_pointer == '_') {
			++input_line_pointer;
			continue;
		}
		if (i >= length) {
			as_warn(("floating point constant too large"));
			return -1;
		}
		d = hex_value(*input_line_pointer) << 4;
		++input_line_pointer;
		while (*input_line_pointer == '_')
			++input_line_pointer;
		if (hex_p(*input_line_pointer)) {
			d += hex_value(*input_line_pointer);
			++input_line_pointer;
		}
		if (target_big_endian)
			bytes[i] = d;
		else
			bytes[length - i - 1] = d;
		++i;
	}

	if (i < length) {
		if (target_big_endian)
			memset(bytes + i,0,length - i);
		else
			memset(bytes,0,length - i);
	}
	memset(bytes + length,0,pad);

	return length + pad;
}

/* CONStruct some more frag chars of .floats .ffloats etc. Makes 0
 * or more new frags. If need_pass_2 == 1,no frags are emitted. This
 * understands only floating literals,not expressions. Sorry.
 * Defined in gas/read.c:4907
 * A floating constant is defined by atof_generic(),except it is preceded by 0d
 * 0f 0g or 0h. After observing the STRANGE way my BSD AS does its reading,I
 * decided to be incompatible. This always tries to give you rounded bits to
 * the precision of the pseudo-op. Former AS did premature truncation,restored
 * noisy bits instead of trailing 0s AND gave you a choice of 2 flavours of
 * noise according to which of 2 floating-point scanners you directed AS to
 * use.
 * 
 * In:	input_line_pointer->whitespace before,or '0' of flonum.  */
static void	float_cons(	/* Clobbers input_line-pointer,checks
				 * end-of-line.  */
		       		int		float_type	/* 'f':.ffloat ...
		           'F':.float ...  */ )
{
	char           *p;
	int		length;	/* Number of chars in an object.  */
	char		temp      [MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT];

	if (is_it_end_of_statement()) {
		demand_empty_rest_of_line();
		return;
	}
	if (now_seg == absolute_section) {
		as_bad("attempt to store float in absolute section");
		ignore_rest_of_line();
		return;
	}
	if (in_bss()) {
		as_bad(("attempt to store float in section `%s'"),
		       segment_name(now_seg));
		ignore_rest_of_line();
		return;
	}
	riscv_mapping_state (MAP_DATA, 0, 0);

	do {
		length = parse_one_float(float_type,temp);
		if (length < 0)
			return;

		if (!need_pass_2) {
			int		count;

			count = 1;

			if (*input_line_pointer == ':') {
				expressionS	count_exp;

				++input_line_pointer;
				expression(&count_exp);

				if (count_exp.X_op != O_constant
				    || count_exp.X_add_number <= 0)
					as_warn(("unresolvable or nonpositive repeat count; using 1"));
				else
					count = count_exp.X_add_number;
			}
			while (--count >= 0) {
				p = frag_more(length);
				memcpy(p,temp,(unsigned int)length);
			}
		}
		SKIP_WHITESPACE();
	} while (*input_line_pointer++ == ',');

	/* Put terminator back into stream.  */
	--input_line_pointer;
	demand_empty_rest_of_line();
}

/* LEB128 Encoding.
 * 
 * Note - we are using the DWARF standard's definition of LEB128 encoding where
 * each 7-bit value is a stored in a byte,*not* an octet.  This means that on
 * targets where a byte contains multiple octets there is a *huge waste of
 * space*.  (This also means that we do not have to have special versions of
 * these functions for when OCTETS_PER_BYTE_POWER is non-zero).
 * Defined in gas/read.c:5005
 * If the 7-bit values were to be packed into N-bit bytes (where N > 8) we would
 * then have to consider whether multiple,successive LEB128 values should be
 * packed into the bytes without padding (bad idea) or whether each LEB128
 * number is padded out to a whole number of bytes. Plus you have to decide on
 * the endianness of packing octets into a byte.  */
/* Return the size of a LEB128 value in bytes.  */
static unsigned int sizeof_sleb128(offsetT value)
{
	int		size = 0;
	unsigned	byte;

	do {
		byte = (value & 0x7f);
		/*
		 * Sadly,we cannot rely on typical arithmetic right shift
		 * behaviour. Fortunately,we can structure things so that the
		 * extra work reduces to a noop on systems that do things
		 * "properly".
		 */
		value = (value >> 7)|~(-(offsetT) 1 >> 7);
		size += 1;
	}
	while (!(((value == 0) && ((byte & 0x40) == 0))
		 || ((value == -1) && ((byte & 0x40) != 0))));

	return size;
}

static inline unsigned int sizeof_uleb128(valueT value)
{
	int		size = 0;

	do {
		value >>= 7;
		size += 1;
	}
	while (value != 0);

	return size;
}

static unsigned int sizeof_leb128(valueT value,int sign)
{
	if (sign)
		return sizeof_sleb128((offsetT) value);
	else
		return sizeof_uleb128(value);
}

/* Output a LEB128 value.  Returns the number of bytes used. gas/read.c:5051 */
static inline unsigned int output_sleb128(char *p,offsetT value)
{
	char           *orig = p;
	int		more;

	do {
		unsigned	byte = (value & 0x7f);

		/* Sadly,we cannot rely on typical arithmetic right shift
		 * behaviour. Fortunately,we can structure things so that the
		 * extra work reduces to a noop on systems that do things
		 * "properly".  */
		value = (value >> 7)|~(-(offsetT) 1 >> 7);

		more = !((((value == 0) && ((byte & 0x40) == 0))
			  || ((value == -1) && ((byte & 0x40) != 0))));
		if (more)
			byte |= 0x80;

		*p++ = byte;
	}
	while (more);

	return p - orig;
}

static inline unsigned int output_uleb128(char *p,valueT value)
{
	char           *orig = p;

	do {
		unsigned	byte = (value & 0x7f);

		value >>= 7;
		if (value != 0)
			/* More bytes to follow.  */
			byte |= 0x80;

		*p++ = byte;
	}
	while (value != 0);

	return p - orig;
}

static unsigned int output_leb128(char *p,valueT value,int sign)
{
	if (sign)
		return output_sleb128(p,(offsetT) value);
	else
		return output_uleb128(p,value);
}

/* Do the same for bignums.  We combine sizeof with output here in that we
 * don't output for NULL values of P.  It isn't really as critical as for
 * "normal" values that this be streamlined. Returns the number of bytes used. */
static unsigned	output_big_sleb128(char *p,LITTLENUM_TYPE * bignum,unsigned size)
{
	char           *orig = p;
	valueT		val = 0;
	int		loaded = 0;
	unsigned	byte;

	/* Strip leading sign extensions off the bignum.  */
	while (size > 1
	       && bignum[size - 1] == LITTLENUM_MASK
	       && bignum[size - 2] > LITTLENUM_MASK / 2)
		size--;

	do {
		/* OR in the next part of the littlenum.  */
		val |= (*bignum << loaded);
		loaded += LITTLENUM_NUMBER_OF_BITS;
		size--;
		bignum++;

		/*
		 * Add bytes until there are less than 7 bits left in VAL or
		 * until every non-sign bit has been written.
		 */
		do {
			byte = val & 0x7f;
			loaded -= 7;
			val >>= 7;
			if (size > 0
			    || val != ((byte & 0x40) == 0 ? 0 : ((valueT) 1 << loaded) - 1))
				byte |= 0x80;

			if (orig)
				*p = byte;
			p++;
		}
		while ((byte & 0x80) != 0 && loaded >= 7);
	}
	while (size > 0);

	/* Mop up any left-over bits (of which there will be less than 7).  */
	if ((byte & 0x80) != 0) {
		/* Sign-extend VAL.  */
		if (val & (1 << (loaded - 1)))
			val |= ~0U << loaded;
		if (orig)
			*p = val & 0x7f;
		p++;
	}
	return p - orig;
}

static unsigned	output_big_uleb128(char *p,LITTLENUM_TYPE * bignum,unsigned size)
{
	char           *orig = p;
	valueT		val = 0;
	int		loaded = 0;
	unsigned	byte;

	/* Strip leading zeros off the bignum.  */
	/* XXX: Is this needed?  */
	while (size > 0 && bignum[size - 1] == 0)
		size--;

	do {
		if (loaded < 7 && size > 0) {
			val |= (*bignum << loaded);
			loaded += 8 * CHARS_PER_LITTLENUM;
			size--;
			bignum++;
		}
		byte = val & 0x7f;
		loaded -= 7;
		val >>= 7;

		if (size > 0 || val)
			byte |= 0x80;

		if (orig)
			*p = byte;
		p++;
	}
	while (byte & 0x80);

	return p - orig;
}

static unsigned	output_big_leb128(char *p,LITTLENUM_TYPE * bignum,unsigned size,int sign)
{
	if (sign)
		return output_big_sleb128(p,bignum,size);
	else
		return output_big_uleb128(p,bignum,size);
}

/* Generate the appropriate fragments for a given expression to emit a leb128
 * value.  SIGN is 1 for sleb,0 for uleb. gas/read.c:5220  */
static void	emit_leb128_expr(expressionS * exp,int sign)
{
	operatorT	op = exp->X_op;
	unsigned int	nbytes;

	if (op == O_absent || op == O_illegal) {
		as_warn(("zero assumed for missing expression"));
		exp->X_add_number = 0;
		op = O_constant;
	} else
		if (op == O_big && exp->X_add_number <= 0) {
			as_bad(("floating point number invalid"));
			exp->X_add_number = 0;
			op = O_constant;
		} else
			if (op == O_register) {
				as_warn(("register value used as expression"));
				op = O_constant;
			} else
				if (op == O_constant
				    && sign
				    && (exp->X_add_number < 0) == !exp->X_extrabit) {
					/* * We're outputting a signed leb128 and the sign of 
					 * X_add_number doesn't reflect the sign of the original 
					 * value. Convert EXP to a correctly-extended bignum 
					 * instead. */
					convert_to_bignum(exp,exp->X_extrabit);
					op = O_big;
				}
	if (now_seg == absolute_section) {
		if (op != O_constant || exp->X_add_number != 0)
			as_bad("attempt to store value in absolute section");
		abs_section_offset++;
		return;
	}
	if ((op != O_constant || exp->X_add_number != 0) && in_bss())
		as_bad("attempt to store non-zero value in section `%s'",
		       segment_name(now_seg));

	/* Let check_eh_frame know that data is being emitted.  nbytes == -1 is
	 * a signal that this is leb128 data.  It shouldn't optimize this away. */
	nbytes = (unsigned int)-1;
	if (check_eh_frame(exp,&nbytes))
		abort();

	/* Let the backend know that subsequent data may be byte aligned.  */
	riscv_mapping_state (MAP_DATA, 0, 0);

	if (op == O_constant) {
		/* If we've got a constant,emit the thing directly right now.  */

		valueT		value = exp->X_add_number;
		unsigned int	size;
		char           *p;

		size = sizeof_leb128(value,sign);
		p = frag_more(size);
		if (output_leb128(p,value,sign) > size)
			abort();
	} else
		if (op == O_big) {
			/* O_big is a different sort of constant.  */
			int		nbr_digits = exp->X_add_number;
			unsigned int	size;
			char           *p;

			/* If the leading littenum is 0xffff,prepend a 0 to
			 * avoid confusion with a signed number.  Unary
			 * operators like - or ~ always extend the bignum to
			 * its largest size.  */
			if (exp->X_unsigned
			    && nbr_digits < SIZE_OF_LARGE_NUMBER
			  && generic_bignum[nbr_digits - 1] == LITTLENUM_MASK)
				generic_bignum[nbr_digits++] = 0;

			size = output_big_leb128(NULL,generic_bignum,nbr_digits,sign);
			p = frag_more(size);
			if (output_big_leb128(p,generic_bignum,nbr_digits,sign) > size)
				abort();
		} else {
			/* Otherwise,we have to create a variable sized
			 * fragment and resolve things later. */

			frag_var(rs_leb128,sizeof_uleb128(~(valueT) 0),0,sign,
				 make_expr_symbol(exp),0,(char *)NULL);
		}
}

/* Parse the .sleb128 and .uleb128 pseudos. gas/read.c:5321  */
static void	s_leb128(int sign)
{
	expressionS	exp;

	do {
		expression(&exp);
		emit_leb128_expr(&exp,sign);
	}
	while (*input_line_pointer++ == ',');

	input_line_pointer--;
	demand_empty_rest_of_line();
}

static void	stringer_append_char(int c,int bitsize)
{
	if (c && in_bss())
		as_bad(("attempt to store non-empty string in section `%s'"),
		       segment_name(now_seg));

	if (!target_big_endian)
		FRAG_APPEND_1_CHAR(c);

	switch (bitsize) {
	case 64:
		FRAG_APPEND_1_CHAR(0);
		FRAG_APPEND_1_CHAR(0);
		FRAG_APPEND_1_CHAR(0);
		FRAG_APPEND_1_CHAR(0);
		/* Fall through.  */
	case 32:
		FRAG_APPEND_1_CHAR(0);
		FRAG_APPEND_1_CHAR(0);
		/* Fall through.  */
	case 16:
		FRAG_APPEND_1_CHAR(0);
		/* Fall through.  */
	case 8:
		break;
	default:
		/* Called with invalid bitsize argument.  */
		abort();
		break;
	}
	if (target_big_endian)
		FRAG_APPEND_1_CHAR(c);
}

/* Worker to do .ascii etc statements. Reads 0 or more ',' separated,
 * double-quoted strings. Caller should have checked need_pass_2 is FALSE
 * because we don't check it. Checks for end-of-line. BITS_APPENDZERO says how
 * many bits are in a target char. The bottom bit is set if a NUL char should
 * be appended to the strings.
 */
static void	stringer(int bits_appendzero)
{
	const int	bitsize = bits_appendzero & ~7;
	const int	append_zero = bits_appendzero & 1;
	unsigned int	c;

	riscv_mapping_state (MAP_DATA, 0, 0);
	/* If we have been switched into the abs_section then we will not have
	 * an obstack onto which we can hang strings.  */
	if (now_seg == absolute_section) {
		as_bad(("strings must be placed into a section"));
		ignore_rest_of_line();
		return;
	}
	/* The following awkward logic is to parse ZERO or more strings,comma
	 * separated. Recall a string expression includes spaces before the
	 * opening '\"' and spaces after the closing '\"'. We fake a leading
	 * ',' if there is (supposed to be) a 1st,expression. We keep
	 * demanding expressions for each ','.  */
	if (is_it_end_of_statement()) {
		c = 0;		/* Skip loop.  */
		++input_line_pointer;	/* Compensate for end of loop.  */
	} else {
		c = ',';	/* Do loop.  */
	}

	while (c == ',' || c == '<' || c == '"') {
		SKIP_WHITESPACE();
		switch (*input_line_pointer) {
		case '\"':
			++input_line_pointer;	/*->1st char of string.  */

			while (is_a_char(c = next_char_of_string()))
				stringer_append_char(c,bitsize);

			/*
			 * Treat "a" "b" as "ab".  Even if we are appending
			 * zeros.
			 */
			SKIP_ALL_WHITESPACE();
			if (*input_line_pointer == '"')
				break;

			if (append_zero)
				stringer_append_char(0,bitsize);

			break;
		case '<':
			input_line_pointer++;
			c = get_single_number();
			stringer_append_char(c,bitsize);
			if (*input_line_pointer != '>') {
				as_bad(("expected <nn>"));
				ignore_rest_of_line();
				return;
			}
			input_line_pointer++;
			break;
		case ',':
			input_line_pointer++;
			break;
		}
		SKIP_WHITESPACE();
		c = *input_line_pointer;
	}

	demand_empty_rest_of_line();
}

/* FIXME-SOMEDAY: I had trouble here on characters with the high bits set.
 * We'll probably also have trouble with multibyte chars,wide chars,etc.
 * Also be careful about returning values bigger than 1 byte.  xoxorich.  */
static unsigned int next_char_of_string(void)
{
	unsigned int	c;

	c = *input_line_pointer++ & CHAR_MASK;
	switch (c) {
	case 0:
		/* PR 20902: Do not advance past the end of the buffer.  */
		--input_line_pointer;
		c = NOT_A_CHAR;
		break;

	case '\"':
		c = NOT_A_CHAR;
		break;

	case '\n':
		as_warn(("unterminated string; newline inserted"));
		bump_line_counters();
		break;

	case '\\':
		switch (c = *input_line_pointer++ & CHAR_MASK) {
		case 'b': c = '\b'; break;
		case 'f': c = '\f'; break;
		case 'n': c = '\n'; break;
		case 'r': c = '\r'; break;
		case 't': c = '\t'; break;
		case 'v': c = '\013'; break;
		case '\\': case '"': break;	/* As itself.  */
		case '0': case '1': case '2': case '3': case '4': case '5':
		case '6': case '7': case '8': case '9':
			{
				unsigned	number = 0;
				int		i = 0;

				for (; ISDIGIT(c) && i < 3;
				     c = *input_line_pointer++,i++) {
					number = number * 8 + c - '0';
				}

				c = number & CHAR_MASK;
			}
			--input_line_pointer;
			break;
		case 'x': case 'X':
			{
				unsigned	number = 0;

				c = *input_line_pointer++;
				while (ISXDIGIT(c)) {
					if (ISDIGIT(c))
						number = number * 16 + c - '0';
					else
						if (ISUPPER(c))
							number = number * 16 + c - 'A' + 10;
						else
							number = number * 16 + c - 'a' + 10;
					c = *input_line_pointer++;
				}
				c = number & CHAR_MASK;
				--input_line_pointer;
			}
			break;

		case '\n':
			/* To be compatible with BSD 4.2 as: give the luser a
			 * linefeed!!  */
			as_warn("unterminated string; newline inserted");
			c = '\n';
			bump_line_counters();
			break;

		case 0:
			/* Do not advance past the end of the buffer.  */
			--input_line_pointer;
			c = NOT_A_CHAR;
			break;

		default:
			as_bad(("bad escaped character in string"));
			c = '?';
			break;
		}
		break;

	default:
		break;
	}
	return (c);
}

static segT	get_segmented_expression(expressionS * expP)
{
	segT		retval;

	retval = expression(expP);
	if (expP->X_op == O_illegal
	    || expP->X_op == O_absent
	    || expP->X_op == O_big) {
		as_bad(("expected address expression"));
		expP->X_op = O_constant;
		expP->X_add_number = 0;
		retval = absolute_section;
	}
	return retval;
}

static segT	get_known_segmented_expression(expressionS * expP)
{
	segT		retval = get_segmented_expression(expP);

	if (retval == undefined_section) {
		/*
		 * There is no easy way to extract the undefined symbol from
		 * the expression.
		 */
		if (expP->X_add_symbol != NULL
		    && S_GET_SEGMENT(expP->X_add_symbol) != expr_section)
			as_warn(("symbol \"%s\" undefined; zero assumed"),
				S_GET_NAME(expP->X_add_symbol));
		else
			as_warn(("some symbol undefined; zero assumed"));
		retval = absolute_section;
		expP->X_op = O_constant;
		expP->X_add_number = 0;
	}
	return retval;
}

/* Return terminator.  */
static char	get_absolute_expression_and_terminator(long *val_pointer)
/* Return value of expression.  */
{
	/* FIXME: val_pointer should probably be offsetT *.  */
	*val_pointer = (long)get_absolute_expression();
	return (*input_line_pointer++);
}

/* Like demand_copy_string,but return NULL if the string contains any '\0's.
 * Give a warning if that happens. */
static char    *demand_copy_C_string(int *len_pointer)
{
	char           *s;

	if ((s = demand_copy_string(len_pointer)) != 0) {
		int		len;

		for (len = *len_pointer; len > 0; len--) {
			if (s[len - 1] == 0) {
				s = 0;
				*len_pointer = 0;
				as_bad(("this string may not contain \'\\0\'"));
				break;
			}
		}
	}
	return s;
}

/* Demand string,but return a safe (=private) copy of the string. Return NULL
 * if we can't read a string here. gas/read.c:5708 */
static char    *demand_copy_string(int *lenP)
{
	unsigned int	c;
	int		len;
	char           *retval;

	len = 0;
	SKIP_WHITESPACE();
	if (*input_line_pointer == '\"') {
		input_line_pointer++;	/* Skip opening quote.  */

		while (is_a_char(c = next_char_of_string())) {
			obstack_1grow(&notes,c);
			len++;
		}
		/* JF this next line is so demand_copy_C_string will return a
		 * null terminated string.  */
		obstack_1grow(&notes,'\0');
		retval = (char *)obstack_finish(&notes);
	} else {
		as_bad(("missing string"));
		retval = NULL;
		ignore_rest_of_line();
	}
	*lenP = len;
	return (retval);
}

/* In:	Input_line_pointer->next character.
 * Do:	Skip input_line_pointer over all whitespace.
 * Out:	1 if input_line_pointer->end-of-line. */
static int	is_it_end_of_statement(void)
{
	SKIP_WHITESPACE();
	return (is_end_of_line[(unsigned char)*input_line_pointer]);
}

static void	equals(char *sym_name,int reassign)
{
	input_line_pointer++;
	if (*input_line_pointer == '=')
		input_line_pointer++;
	if (reassign < 0 && *input_line_pointer == '=')
		input_line_pointer++;

	while (*input_line_pointer == ' ' || *input_line_pointer == '\t')
		input_line_pointer++;

	assign_symbol(sym_name,reassign >= 0 ? !reassign : reassign);
}

/* Open FILENAME,first trying the unadorned file name,then if that fails and
 * the file name is not an absolute path,attempt to open the file in current
 * -I include paths.  PATH is a preallocated buffer which will be set to the
 * file opened,or FILENAME if no file is found. */
static FILE    *search_and_open(const char *filename,char *path)
{
	FILE           *f = fopen(filename,"rb");
	strcpy(path,filename);
	return f;
}

/* .incbin -- include a file verbatim at the current location.  */
static void	s_incbin(int x ATTRIBUTE_UNUSED)
{
	FILE           *binfile;
	char           *path;
	char           *filename;
	char           *binfrag;
	long		skip = 0;
	long		count = 0;
	long		bytes;
	int		len;

	riscv_mapping_state (MAP_DATA, 0, 0);

	SKIP_WHITESPACE();
	filename = demand_copy_string(&len);
	if (filename == NULL)
		return;

	SKIP_WHITESPACE();

	/* Look for optional skip and count.  */
	if (*input_line_pointer == ',') {
		++input_line_pointer;
		skip = get_absolute_expression();

		SKIP_WHITESPACE();

		if (*input_line_pointer == ',') {
			++input_line_pointer;

			count = get_absolute_expression();
			if (count == 0)
				as_warn((".incbin count zero,ignoring `%s'"),filename);

			SKIP_WHITESPACE();
		}
	}
	demand_empty_rest_of_line();

	path = XNEWVEC(char,len + include_dir_maxlen + 2);
	binfile = search_and_open(filename,path);

	if (binfile == NULL)
		as_bad(("file not found: %s"),filename);
	else {
		long		file_len;
		struct stat	filestat;

		if (fstat(fileno(binfile),&filestat) != 0
		    || !S_ISREG(filestat.st_mode)
		    || S_ISDIR(filestat.st_mode)) {
			as_bad(("unable to include `%s'"),path);
			goto done;
		}
		/* Compute the length of the file.  */
		if (fseek(binfile,0,SEEK_END) != 0) {
			as_bad(("seek to end of .incbin file failed `%s'"),path);
			goto done;
		}
		file_len = ftell(binfile);

		/* If a count was not specified use the remainder of the file.  */
		if (count == 0)
			count = file_len - skip;

		if (skip < 0 || count < 0 || file_len < 0 || skip + count > file_len) {
			as_bad(("skip (%ld) or count (%ld) invalid for file size (%ld)"),
			       skip,count,file_len);
			goto done;
		}
		if (fseek(binfile,skip,SEEK_SET) != 0) {
			as_bad(("could not skip to %ld in file `%s'"),skip,path);
			goto done;
		}
		/* Allocate frag space and store file contents in it.  */
		binfrag = frag_more(count);

		bytes = fread(binfrag,1,count,binfile);
		if (bytes < count)
			as_warn(("truncated file `%s',%ld of %ld bytes read"),
				path,bytes,count);
	}
done:
	if (binfile != NULL)
		fclose(binfile);
	free(path);
}

/* Output debugging information to denote the source file.  */
static void	generate_file_debug(void)
{
	if (debug_type == DEBUG_STABS)
		stabs_generate_asm_file();
}

/* Output line number debugging information for the current source line.  */
static void	generate_lineno_debug(void)
{
	switch (debug_type) {
	case DEBUG_UNSPECIFIED: case DEBUG_NONE: case DEBUG_DWARF:
		break;
	case DEBUG_STABS:
		stabs_generate_asm_lineno();
		break;
	case DEBUG_ECOFF: break;
	case DEBUG_DWARF2:
		/* ??? We could here indicate to dwarf2dbg.c that something has
		 * changed.  However,since there is additional backend support
		 * that is required (calling dwarf2_emit_insn),we let
		 * dwarf2dbg.c call as_where on its own.  */
		break;
	}
}

/* Output debugging information to mark a function entry point or end point.
 * END_P is zero for .func,and non-zero for .endfunc.  */
static void	s_func(int end_p)
{
	do_s_func(end_p,NULL);
}

/* Subroutine of s_func so targets can choose a different default prefix. If
 * DEFAULT_PREFIX is NULL,use the target's "leading char".  */
static void	do_s_func(int end_p,const char *default_prefix)
{
	if (end_p) {
		if (current_name == NULL) {
			as_bad(("missing .func"));
			ignore_rest_of_line();
			return;
		}
		if (debug_type == DEBUG_STABS)
			stabs_generate_asm_endfunc(current_name,current_label);

		current_name = current_label = NULL;
	} else {		/* ! end_p */
		char           *name,*label;
		char		delim1   ,delim2;

		if (current_name != NULL) {
			as_bad((".endfunc missing for previous .func"));
			ignore_rest_of_line();
			return;
		}
		delim1 = get_symbol_name(&name);
		name = strdup(name);
		*input_line_pointer = delim1;
		SKIP_WHITESPACE_AFTER_NAME();
		if (*input_line_pointer != ',') {
			if (default_prefix) {
				if (asprintf(&label,"%s%s",default_prefix,name) == -1)
					as_fatal("%s",xstrerror(errno));
			} else {
				char		leading_char = bfd_get_symbol_leading_char(stdoutput);
				/*
				 * Missing entry point,use function's name
				 * with the leading char prepended.
				 */
				if (leading_char) {
					if (asprintf(&label,"%c%s",leading_char,name) == -1)
						as_fatal("%s",xstrerror(errno));
				} else
					label = name;
			}
		} else {
			++input_line_pointer;
			SKIP_WHITESPACE();
			delim2 = get_symbol_name(&label);
			label = strdup(label);
			restore_line_pointer(delim2);
		}

		if (debug_type == DEBUG_STABS)
			stabs_generate_asm_func(name,label);

		current_name = name;
		current_label = label;
	}

	demand_empty_rest_of_line();
}


static void	s_ignore(int arg ATTRIBUTE_UNUSED)
{
	ignore_rest_of_line();
}

/* Find the end of a line,considering quotation and escaping of quotes.  */
#if !defined(TC_SINGLE_QUOTE_STRINGS) && defined(SINGLE_QUOTE_STRINGS)
#define TC_SINGLE_QUOTE_STRINGS 1
#endif
/* interface trimmed for the single call to this function.
 * _find_end_of_line(input_line_pointer,0,1,0); */
static char * _find_end_of_line(char *s)
{
	char		inquote = '\0';
	int		inescape = 0;

	while (!is_end_of_line[(unsigned char)*s]
	       || (inquote && !ISCNTRL(*s))) {
		if (inescape)
			inescape = 0;
		else
			if (*s == '\\')
				inescape = 1;
			else
				if (!inquote
				    ? *s == '"'
#ifdef TC_SINGLE_QUOTE_STRINGS
				    || (TC_SINGLE_QUOTE_STRINGS && *s == '\'')
#endif
				    : *s == inquote)
					inquote ^= *s;
		++s;
	}
	if (inquote)
		as_warn(("missing closing `%c'"),inquote);
	if (inescape)
		as_warn(("stray `\\'"));
	return s;
}

static char    *saved_ilp;
static char    *saved_limit;

/* Use BUF as a temporary input pointer for calling other functions in this
 * file.  BUF must be a C string,so that its end can be found by strlen. Also
 * sets the buffer_limit variable (local to this file) so that buffer overruns
 * should not occur.  Saves the current input line pointer so that it can be
 * restored by calling restore_ilp().
 * 
 * Does not support recursion.
 */
static void	temp_ilp(char *buf)
{
	gas_assert(saved_ilp == NULL);
	gas_assert(buf != NULL);

	saved_ilp = input_line_pointer;
	saved_limit = buffer_limit;
	/*
	 * Prevent the assert in restore_ilp from triggering if the
	 * input_line_pointer has not yet been initialised.
	 */
	if (saved_ilp == NULL)
		saved_limit = saved_ilp = (char *)"";

	input_line_pointer = buf;
	buffer_limit = buf + strlen(buf);
	input_from_string = true;
}

/* Restore a saved input line pointer.  */
static void	restore_ilp(void)
{
	gas_assert(saved_ilp != NULL);

	input_line_pointer = saved_ilp;
	buffer_limit = saved_limit;
	input_from_string = false;

	saved_ilp = NULL;
}
/* ============================================================* remap.c */
/* Remap file names for debug info for GNU assembler. */


/*
 * Structure recording the mapping from source file and directory names at
 * compile time to those to be embedded in debug information.
 */
typedef struct debug_prefix_map {
	const char     *old_prefix;
	const char     *new_prefix;
	size_t		old_len;
	size_t		new_len;
	struct debug_prefix_map *next;
}		debug_prefix_map;

/* Linked list of such structures.  */
static debug_prefix_map *debug_prefix_maps;


/*
 * Record a debug file prefix mapping.  ARG is the argument to
 * -fdebug-prefix-map and must be of the form OLD=NEW.
 */

static void	add_debug_prefix_map(const char *arg)
{
	debug_prefix_map *map;
	const char     *p;
	char           *o;

	p = strchr(arg,'=');
	if (!p) {
		as_fatal(("invalid argument '%s' to -fdebug-prefix-map"),arg);
		return;
	}
	map = XNEW(debug_prefix_map);
	o = strdup(arg);
	map->old_prefix = o;
	map->old_len = p - arg;
	o[map->old_len] = 0;
	p++;
	map->new_prefix = strdup(p);
	map->new_len = strlen(p);
	map->next = debug_prefix_maps;
	debug_prefix_maps = map;
}

/*
 * Perform user-specified mapping of debug filename prefixes.  Returns a newly
 * allocated buffer containing the name corresponding to FILENAME. It is the
 * caller's responsibility to free the buffer.
 */
static char    *remap_debug_filename(const char *filename)
{
	debug_prefix_map *map;

	for (map = debug_prefix_maps; map; map = map->next)
		if (filename_ncmp(filename,map->old_prefix,map->old_len) == 0) {
			const char     *name = filename + map->old_len;
			return concat(map->new_prefix,name,NULL);
		}
	return strdup(filename);
}
/* ============================================================* stabs.c */
/* Generic stabs parsing for gas.  */

/*
 * We need this,despite the apparent object format dependency,since it
 * defines stab types,which all object formats can use now.
 */

/*
 * Holds whether the assembler is generating stabs line debugging information
 * or not.  Potentially used by md_cleanup function.
 */
//static int	outputting_stabs_line_debug = 0;

static void	generate_asm_file(int,const char *);

/* Allow backends to override the names used for the stab sections.  */
#ifndef STAB_SECTION_NAME
#define STAB_SECTION_NAME ".stab"
#endif

#ifndef STAB_STRING_SECTION_NAME
#define STAB_STRING_SECTION_NAME ".stabstr"
#endif

/*
 * Label at start of current function if we're in the middle of a .func
 * function,in which case stabs_generate_asm_lineno emits function relative
 * line number stabs.  Otherwise it emits line number stabs with absolute
 * addresses.  Note that both cases only apply to assembler code assembled with
 * -gstabs.
 */
static const char *current_function_label;

/* Current stab section when SEPARATE_STAB_SECTIONS.  */
static segT	cached_sec;

/* State used by generate_asm_file.  */
static char    *last_asm_file;
static int	file_label_count;

/* State used by stabs_generate_asm_lineno.  */
static int	line_label_count;
static unsigned int prev_lineno;
static char    *prev_line_file;

/* State used by stabs_generate_asm_func.  */
static bool	void_emitted_p;

/* State used by stabs_generate_asm_endfunc.  */
static int	endfunc_label_count;

/*
 * Handle .stabX directives,which used to be open-coded. So much creeping
 * featurism overloaded the semantics that we decided to put all .stabX
 * thinking in one place. Here.
 * 
 * We try to make any .stabX directive legal. Other people's AS will often do
 * assembly-time consistency checks: eg assigning meaning to n_type bits and
 * "protecting" you from setting them to certain values. (They also zero
 * certain bits before emitting symbols. Tut tut.)
 * 
 * If an expression is not absolute we either gripe or use the relocation
 * information. Other people's assemblers silently forget information they
 * don't need and invent information they need that you didn't supply.
 */

/*
 * Build a string dictionary entry for a .stabX symbol. The symbol is added to
 * the .<secname>str section.
 */

#ifndef SEPARATE_STAB_SECTIONS
#define SEPARATE_STAB_SECTIONS 0
#endif

static unsigned int get_stab_string_offset(const char *string,
					   		const		char  *stabstr_secname,bool free_stabstr_secname)
{
	unsigned int	length;
	unsigned int	retval;
	segT		save_seg;
	subsegT		save_subseg;
	segT		seg;
	char           *p;

	if (!SEPARATE_STAB_SECTIONS)
		abort();

	length = strlen(string);

	save_seg = now_seg;
	save_subseg = now_subseg;

	/* Create the stab string section,if it doesn't already exist.  */
	seg = subseg_new(stabstr_secname,0);
	if (free_stabstr_secname && seg->name != stabstr_secname)
		free((char *)stabstr_secname);

	retval = seg_info(seg)->stabu.stab_string_size;
	if (retval <= 0) {
		/* Make sure the first string is empty.  */
		p = frag_more(1);
		*p = 0;
		retval = seg_info(seg)->stabu.stab_string_size = 1;
		seg->flags = SEC_READONLY|SEC_DEBUGGING;
	}
	if (length > 0) {	/* Ordinary case.  */
		p = frag_more(length + 1);
		strcpy(p,string);

		seg_info(seg)->stabu.stab_string_size += length + 1;
	} else
		retval = 0;

	subseg_set(save_seg,save_subseg);

	return retval;
}

/*
 * This can handle different kinds of stabs (s,n,d) and different kinds of stab
 * sections.  If STAB_SECNAME_OBSTACK_END is non-NULL,then STAB_SECNAME and
 * STABSTR_SECNAME will be freed if possible before this function returns (the
 * former by obstack_free).
 */

static void	s_stab_generic(int what,
			   		const		char  *stab_secname,
			   		const		char  *stabstr_secname,
		 		const		char  *stab_secname_obstack_end)
{
	long		longint;
	const char     *string;
	char           *saved_string_obstack_end;
	int		type;
	int		other;
	int		desc;

	/*
	 * The general format is: .stabs "STRING",TYPE,OTHER,DESC,VALUE .stabn
	 * TYPE,OTHER,DESC,VALUE .stabd TYPE,OTHER,DESC At this point
	 * input_line_pointer points after the pseudo-op and any trailing
	 * whitespace.  The argument what is one of 's','n' or 'd' indicating
	 * which type of .stab this is.
	 */

	if (what != 's') {
		string = "";
		saved_string_obstack_end = 0;
	} else {
		int		length;

		string = demand_copy_C_string(&length);
		if (string == NULL) {
			as_warn((".stab%c: missing string"),what);
			ignore_rest_of_line();
			return;
		}
		/*
		 * FIXME: We should probably find some other temporary storage
		 * for string,rather than leaking memory if someone else
		 * happens to use the notes obstack.
		 */
		saved_string_obstack_end = obstack_next_free(&notes);
		SKIP_WHITESPACE();
		if (*input_line_pointer == ',')
			input_line_pointer++;
		else {
			as_warn((".stab%c: missing comma"),what);
			ignore_rest_of_line();
			return;
		}
	}

	if (get_absolute_expression_and_terminator(&longint) != ',') {
		as_warn((".stab%c: missing comma"),what);
		ignore_rest_of_line();
		return;
	}
	type = longint;

	if (get_absolute_expression_and_terminator(&longint) != ',') {
		as_warn((".stab%c: missing comma"),what);
		ignore_rest_of_line();
		return;
	}
	other = longint;

	desc = get_absolute_expression();

	if ((desc > 0xffff) || (desc < -0x8000))
		/*
		 * This could happen for example with a source file with a huge
		 * number of lines.  The only cure is to use a different debug
		 * format,probably DWARF.
		 */
		as_warn((".stab%c: description field '%x' too big,try a different debug format"),
			what,desc);

	if (what == 's' || what == 'n') {
		if (*input_line_pointer != ',') {
			as_warn((".stab%c: missing comma"),what);
			ignore_rest_of_line();
			return;
		}
		input_line_pointer++;
		SKIP_WHITESPACE();
	}
	/*
	 * We have now gathered the type,other,and desc information.  For
	 * .stabs or .stabn,input_line_pointer is now pointing at the value.
	 */

	if (SEPARATE_STAB_SECTIONS)
		/*
		 * Output the stab information in a separate section.  This is
		 * used at least for COFF and ELF.
		 */
	{
		segT		saved_seg = now_seg;
		subsegT		saved_subseg = now_subseg;
		fragS          *saved_frag = frag_now;
		valueT		dot;
		segT		seg;
		unsigned int	stroff;
		char           *p;

		dot = frag_now_fix();

		if (cached_sec && strcmp(cached_sec->name,stab_secname) == 0) {
			seg = cached_sec;
			subseg_set(seg,0);
		} else {
			seg = subseg_new(stab_secname,0);
			cached_sec = seg;
		}

		if (!seg_info(seg)->hadone) {
			seg->flags = SEC_READONLY|SEC_RELOC|SEC_DEBUGGING;
#ifdef INIT_STAB_SECTION
			INIT_STAB_SECTION(seg);
#endif
			seg_info(seg)->hadone = 1;
		}
		stroff = get_stab_string_offset(string,stabstr_secname,
					    stab_secname_obstack_end != NULL);

		/* Release the string,if nobody else has used the obstack.  */
		if (saved_string_obstack_end != NULL
		    && saved_string_obstack_end == obstack_next_free(&notes))
			obstack_free(&notes,string);
		/*
		 * Similarly for the section name.  This must be done before
		 * creating symbols below,which uses the notes obstack.
		 */
		if (seg->name != stab_secname
		    && stab_secname_obstack_end != NULL
		    && stab_secname_obstack_end == obstack_next_free(&notes))
			obstack_free(&notes,stab_secname);

		/*
		 * At least for now,stabs in a special stab section are always
		 * output as 12 byte blocks of information.
		 */
		p = frag_more(8);
		md_number_to_chars(p,(valueT) stroff,4);
		md_number_to_chars(p + 4,(valueT) type,1);
		md_number_to_chars(p + 5,(valueT) other,1);
		md_number_to_chars(p + 6,(valueT) desc,2);

		if (what == 's' || what == 'n') {
			/* Pick up the value from the input line.  */
			cons(4);
			input_line_pointer--;
		} else {
			symbolS        *symbol;
			expressionS	exp;

			/*
			 * Arrange for a value representing the current
			 * location.
			 */
			symbol = symbol_temp_new(saved_seg,saved_frag,dot);

			exp.X_op = O_symbol;
			exp.X_add_symbol = symbol;
			exp.X_add_number = 0;

			emit_expr(&exp,4);
		}

#ifdef OBJ_PROCESS_STAB
		OBJ_PROCESS_STAB(seg,what,string,type,other,desc);
#endif

		subseg_set(saved_seg,saved_subseg);
	} else {
		if (stab_secname_obstack_end != NULL) {
			free((char *)stabstr_secname);
			if (stab_secname_obstack_end == obstack_next_free(&notes))
				obstack_free(&notes,stab_secname);
		}
#ifdef OBJ_PROCESS_STAB
		OBJ_PROCESS_STAB(0,what,string,type,other,desc);
#else
		abort();
#endif
	}

	demand_empty_rest_of_line();
}

/* Regular stab directive.  */
static void	s_stab(int what)
{
	s_stab_generic(what,STAB_SECTION_NAME,STAB_STRING_SECTION_NAME,NULL);
}

/* "Extended stabs",used in Solaris only now.  */
static void	s_xstab(int what)
{
	int		length;
	char           *stab_secname,*stabstr_secname,*stab_secname_obstack_end;

	stab_secname = demand_copy_C_string(&length);
	stab_secname_obstack_end = obstack_next_free(&notes);
	SKIP_WHITESPACE();
	if (*input_line_pointer == ',')
		input_line_pointer++;
	else {
		as_bad(("comma missing in .xstabs"));
		ignore_rest_of_line();
		return;
	}

	/*
	 * To get the name of the stab string section,simply add "str" to the
	 * stab section name.
	 */
	stabstr_secname = concat(stab_secname,"str",(char *)NULL);
	s_stab_generic(what,stab_secname,stabstr_secname,
		       stab_secname_obstack_end);
}

/* Generate stabs debugging information to denote the main source file.  */
static void	stabs_generate_asm_file(void)
{
	const char     *file;
	unsigned int	lineno;

	file = as_where(&lineno);
	if (use_gnu_debug_info_extensions) {
		char           *dir;
		char           *dir2;

		dir = remap_debug_filename(getpwd());
		dir2 = concat(dir,"/",NULL);
		generate_asm_file(N_SO,dir2);
		free(dir2);
		free(dir);
	}
	generate_asm_file(N_SO,file);
}

/*
 * Generate stabs debugging information to denote the source file. TYPE is one
 * of N_SO,N_SOL.
 */
static void	generate_asm_file(int type,const char *file)
{
	char		sym       [30];
	char           *buf;
	const char     *tmp = file;
	const char     *file_endp = file + strlen(file);
	char           *bufp;

	if (last_asm_file != NULL
	    && filename_cmp(last_asm_file,file) == 0)
		return;

	/*
	 * Rather than try to do this in some efficient fashion,we just
	 * generate a string and then parse it again.  That lets us use the
	 * existing stabs hook,which expect to see a string,rather than
	 * inventing new ones.
	 */
	sprintf(sym,"%sF%d",FAKE_LABEL_NAME,file_label_count);
	++file_label_count;

	/*
	 * Allocate enough space for the file name (possibly extended with
	 * doubled up backslashes),the symbol name,and the other characters
	 * that make up a stabs file directive.
	 */
	bufp = buf = XNEWVEC(char,2 * strlen(file) + strlen(sym) + 12);

	*bufp++ = '"';

	while (tmp < file_endp) {
		const char     *bslash = strchr(tmp,'\\');
		size_t		len = bslash != NULL ? bslash - tmp + 1 : file_endp - tmp;

		/*
		 * Double all backslashes,since demand_copy_C_string (used by
		 * s_stab to extract the part in quotes) will try to replace
		 * them as escape sequences.  backslash may appear in a
		 * filespec.
		 */
		memcpy(bufp,tmp,len);

		tmp += len;
		bufp += len;

		if (bslash != NULL)
			*bufp++ = '\\';
	}

	sprintf(bufp,"\",%d,0,0,%s\n",type,sym);

	temp_ilp(buf);
	s_stab('s');
	restore_ilp();

	colon(sym);

	free(last_asm_file);
	last_asm_file = strdup(file);

	free(buf);
}

/*
 * Generate stabs debugging information for the current line.  This is used to
 * produce debugging information for an assembler file.
 */
static void	stabs_generate_asm_lineno(void)
{
	const char     *file;
	unsigned int	lineno;
	char           *buf;
	char		sym       [30];

	/*
	 * Rather than try to do this in some efficient fashion,we just
	 * generate a string and then parse it again.  That lets us use the
	 * existing stabs hook,which expect to see a string,rather than
	 * inventing new ones.
	 */

	file = as_where(&lineno);

	/* Don't emit sequences of stabs for the same line.  */
	if (prev_line_file != NULL
	    && filename_cmp(file,prev_line_file) == 0) {
		if (lineno == prev_lineno)
			/* Same file/line as last time.  */
			return;
	} else {
		/* Remember file/line for next time.  */
		free(prev_line_file);
		prev_line_file = strdup(file);
	}

	prev_lineno = lineno;

	/*
	 * Let the world know that we are in the middle of generating a piece
	 * of stabs line debugging information.
	 */
	outputting_stabs_line_debug = 1;

	generate_asm_file(N_SOL,file);

	sprintf(sym,"%sL%d",FAKE_LABEL_NAME,line_label_count);
	++line_label_count;

	if (current_function_label) {
		buf = XNEWVEC(char,100 + strlen(current_function_label));
		sprintf(buf,"%d,0,%d,%s-%s\n",N_SLINE,lineno,
			sym,current_function_label);
	} else {
		buf = XNEWVEC(char,100);
		sprintf(buf,"%d,0,%d,%s\n",N_SLINE,lineno,sym);
	}

	temp_ilp(buf);
	s_stab('n');
	restore_ilp();

	colon(sym);

	outputting_stabs_line_debug = 0;
	free(buf);
}

/*
 * Emit a function stab. All assembler functions are assumed to have return
 * type `void'.
 */
static void	stabs_generate_asm_func(const char *funcname,const char *startlabname)
{
	char           *buf;
	unsigned int	lineno;

	if (!void_emitted_p) {
		temp_ilp((char *)"\"void:t1=1\",128,0,0,0");
		s_stab('s');
		restore_ilp();
		void_emitted_p = true;
	}
	as_where(&lineno);
	if (asprintf(&buf,"\"%s:F1\",%d,0,%d,%s",
		     funcname,N_FUN,lineno + 1,startlabname) == -1)
		as_fatal("%s",xstrerror(errno));

	temp_ilp(buf);
	s_stab('s');
	restore_ilp();
	free(buf);

	free((char *)current_function_label);
	current_function_label = strdup(startlabname);
}

/* Emit a stab to record the end of a function.  */

static void	stabs_generate_asm_endfunc(const char *funcname ATTRIBUTE_UNUSED,
				 		const		char  *startlabname)
{
	char           *buf;
	char		sym       [30];

	sprintf(sym,"%sendfunc%d",FAKE_LABEL_NAME,endfunc_label_count);
	++endfunc_label_count;
	colon(sym);

	if (asprintf(&buf,"\"\",%d,0,0,%s-%s",N_FUN,sym,startlabname) == -1)
		as_fatal("%s",xstrerror(errno));

	temp_ilp(buf);
	s_stab('s');
	restore_ilp();
	free(buf);

	free((char *)current_function_label);
	current_function_label = NULL;
}

static void	stabs_begin(void)
{
	current_function_label = NULL;
	cached_sec = NULL;
	last_asm_file = NULL;
	file_label_count = 0;
	line_label_count = 0;
	prev_lineno = -1u;
	prev_line_file = NULL;
	void_emitted_p = false;
	endfunc_label_count = 0;
}

static void	stabs_end(void)
{
	free((char *)current_function_label);
	free(last_asm_file);
	free(prev_line_file);
}
/* =======================================================**** subsegs.c */
/* subsegs.c - subsegments - */
static frchainS *frchain_now;
static struct obstack frchains;
static fragS	dummy_frag;
static void	subsegs_begin(void)
{
	obstack_begin(&frchains,chunksize);
#if __GNUC__ >= 2
	obstack_alignment_mask(&frchains) = __alignof__(frchainS) - 1;
#endif

	frchain_now = NULL;	/* Warn new_subseg() that we are booting.  */
	frag_now = &dummy_frag;
}

static void	subsegs_end(struct obstack **obs)
{
	for (; *obs; obs++)
		_obstack_free(*obs,NULL);
	_obstack_free(&frchains,NULL);
	(bfd_abs_section_ptr)->userdata = NULL;
	(bfd_und_section_ptr)->userdata = NULL;
}

static void	alloc_seginfo(segT seg)
{
	segment_info_type *seginfo;

	seginfo = obstack_alloc(&notes,sizeof(*seginfo));
	memset(seginfo,0,sizeof(*seginfo));
	seginfo->bfd_section = seg;
	seg->userdata = seginfo;
}
/*
 * subseg_change()
 * 
 * Change the subsegment we are in,BUT DO NOT MAKE A NEW FRAG for the subsegment.
 * If we are already in the correct subsegment,change nothing. This is used eg
 * as a worker for subseg_set [which does make a new frag_now] and for changing
 * segments after we have read the source. We construct eg fixSs even after the
 * source file is read,so we do have to keep the segment context correct.
 */
static void	subseg_change(segT seg,int subseg)
{
	now_seg = seg;
	now_subseg = subseg;

	if (!seg_info(seg))
		alloc_seginfo(seg);
}

static void	subseg_set_rest(segT seg,subsegT subseg)
{
	frchainS       *frcP;	/* crawl frchain chain */
	frchainS      **lastPP;	/* address of last pointer */
	frchainS       *newP;	/* address of new frchain */
	segment_info_type *seginfo;


	if (frag_now && frchain_now)
		frchain_now->frch_frag_now = frag_now;

	gas_assert(frchain_now == 0
		   || frchain_now->frch_last == frag_now);

	subseg_change(seg,(int)subseg);

	seginfo = seg_info(seg);

	/* Should the section symbol be kept?  */
	//if (bfd_keep_unused_section_symbols(stdoutput))
		seg->symbol->flags |= BSF_SECTION_SYM_USED;

	/*
	 * Attempt to find or make a frchain for that subsection. We keep the
	 * list sorted by subsection number.
	 */
	for (frcP = *(lastPP = &seginfo->frchainP);
	     frcP != NULL;
	     frcP = *(lastPP = &frcP->frch_next))
		if (frcP->frch_subseg >= subseg)
			break;

	if (frcP == NULL || frcP->frch_subseg != subseg) {
		/* This should be the only code that creates a frchainS.  */

		newP = (frchainS *) obstack_alloc(&frchains,sizeof(frchainS));
		newP->frch_subseg = subseg;
		newP->fix_root = NULL;
		newP->fix_tail = NULL;
		obstack_begin(&newP->frch_obstack,chunksize);
#if __GNUC__ >= 2
		obstack_alignment_mask(&newP->frch_obstack) = __alignof__(fragS) - 1;
#endif
		newP->frch_frag_now = frag_alloc(&newP->frch_obstack);
		newP->frch_frag_now->fr_type = rs_fill;
		newP->frch_cfi_data = NULL;

		newP->frch_root = newP->frch_last = newP->frch_frag_now;

		*lastPP = newP;
		newP->frch_next = frcP;
		frcP = newP;
	}
	frchain_now = frcP;
	frag_now = frcP->frch_frag_now;

	gas_assert(frchain_now->frch_last == frag_now);
}

/*
 * subseg_set(segT,subsegT)
 * 
 * If you attempt to change to the current subsegment,nothing happens.
 * 
 * In:	segT,subsegT code for new subsegment. frag_now -> incomplete frag for
 * current subsegment. If frag_now==NULL,then there is no old,incomplete
 * frag,so the old frag is not closed off.
 * 
 * Out:	now_subseg,now_seg updated. Frchain_now points to the (possibly new)
 * struct frchain for this sub-segment.
 */

static segT	subseg_get(const char *segname,int force_new)
{
	segT		secptr;
	const char     *now_seg_name = now_seg ? bfd_section_name(now_seg) : 0;

	if (!force_new
	    && now_seg_name
	    && (now_seg_name == segname
		|| !strcmp(now_seg_name,segname)))
		return now_seg;

	if (!force_new)
		secptr = make_section_old_way(stdoutput,segname);
	else
		secptr = make_section_anyway(stdoutput,segname);

	if (!seg_info(secptr)) {
		secptr->output_section = secptr;
		alloc_seginfo(secptr);
	}
	return secptr;
}

static segT	subseg_new(const char *segname,subsegT subseg)
{
	segT		secptr;

	secptr = subseg_get(segname,0);
	subseg_set_rest(secptr,subseg);
	return secptr;
}

/*
 * Like subseg_new,except a new section is always created,even if a section
 * with that name already exists.
 */
static segT	subseg_force_new(const char *segname,subsegT subseg)
{
	segT		secptr;

	secptr = subseg_get(segname,1);
	subseg_set_rest(secptr,subseg);
	return secptr;
}

static void	subseg_set(segT secptr,subsegT subseg)
{
	if (!(secptr == now_seg && subseg == now_subseg))
		subseg_set_rest(secptr,subseg);
}

#ifndef obj_sec_sym_ok_for_reloc
#define obj_sec_sym_ok_for_reloc(SEC)	0
#endif
static symbolS *section_symbol(segT sec)
{
	segment_info_type *seginfo = seg_info(sec);
	symbolS        *s;

	if (seginfo == 0)
		abort();
	if (seginfo->sym)
		return seginfo->sym;

#ifndef EMIT_SECTION_SYMBOLS
#define EMIT_SECTION_SYMBOLS 1
#endif

	if (!EMIT_SECTION_SYMBOLS || symbol_table_frozen) {
		/* Here we know it won't be going into the symbol table.  */
		s = symbol_create(sec->symbol->name,sec,&zero_address_frag,0);
	} else {
		segT		seg;
		s = symbol_find(sec->symbol->name);
		/*
		 * We have to make sure it is the right symbol when we have
		 * multiple sections with the same section name.
		 */
		if (s == NULL
		    || ((seg = S_GET_SEGMENT(s)) != sec
			&& seg != undefined_section))
			s = symbol_new(sec->symbol->name,sec,&zero_address_frag,0);
		else
			if (seg == undefined_section) {
				S_SET_SEGMENT(s,sec);
				symbol_set_frag(s,&zero_address_frag);
			}
	}

	S_CLEAR_EXTERNAL(s);

	/* Use the BFD section symbol,if possible.  */
	if (obj_sec_sym_ok_for_reloc(sec))
		symbol_set_bfdsym(s,sec->symbol);
	else
		symbol_get_bfdsym(s)->flags |= BSF_SECTION_SYM;

	seginfo->sym = s;
	return s;
}

/* Return whether the specified segment is thought to hold text.  */
static int	subseg_text_p(segT sec)
{
	return (sec->flags & SEC_CODE) != 0;
}

/*
 * Return non zero if SEC has at least one byte of data.  It is possible that
 * we'll return zero even on a non-empty section because we don't know all the
 * fragment types,and it is possible that an fr_fix == 0 one still contributes
 * data.  Think of this as seg_definitely_not_empty_p.
 */
static int	seg_not_empty_p(segT sec ATTRIBUTE_UNUSED)
{
	segment_info_type *seginfo = seg_info(sec);
	frchainS       *chain;
	fragS          *frag;

	if (!seginfo)
		return 0;

	for (chain = seginfo->frchainP; chain; chain = chain->frch_next) {
		for (frag = chain->frch_root; frag; frag = frag->fr_next)
			if (frag->fr_fix)
				return 1;
		if (obstack_next_free(&chain->frch_obstack)
		    != chain->frch_last->fr_literal)
			return 1;
	}
	return 0;
}

/* end of subsegs.c */
/* =======================================================**** symbols.c */
typedef struct symbol symbolS;
/* Extra fields to make up a full symbol.  */

struct xsymbol {
	/* The value of the symbol.  */
	expressionS	value;

	/* Forwards and backwards chain pointers.  */
	struct symbol  *next;
	struct symbol  *previous;

#ifdef OBJ_SYMFIELD_TYPE
	OBJ_SYMFIELD_TYPE obj;
#endif

#ifdef TC_SYMFIELD_TYPE
	TC_SYMFIELD_TYPE tc;
#endif
};

typedef union symbol_entry {
	struct local_symbol lsy;
	struct symbol	sy;
}		symbol_entry_t;

/* Hash function for a symbol_entry.  */

static hashval_t hash_symbol_entry(const void *e)
{
	symbol_entry_t *entry = (symbol_entry_t *) e;
	if (entry->sy.hash == 0)
		entry->sy.hash = htab_hash_string(entry->sy.name);

	return entry->sy.hash;
}

/* Equality function for a symbol_entry.  */

static int	eq_symbol_entry(const void *a,const void *b)
{
	const symbol_entry_t *ea = (const symbol_entry_t *)a;
	const symbol_entry_t *eb = (const symbol_entry_t *)b;

	return (ea->sy.hash == eb->sy.hash
		&& strcmp(ea->sy.name,eb->sy.name) == 0);
}

static void    *symbol_entry_find(htab_t table,const char *name)
{
	hashval_t	hash = htab_hash_string(name);
	symbol_entry_t	needle = {{{0,0,0,0,0,0,0,0,0,0,0,0,0},
	hash,name,0,0,0}};
	return htab_find_with_hash(table,&needle,hash);
}


/*
 * This is non-zero if symbols are case sensitive,which is the default.
 */
/* Below are commented in "symbols.h".  */
static symbolS *symbol_rootP;
static symbolS *symbol_lastP;
static symbolS	abs_symbol;
struct xsymbol	abs_symbol_x;
static symbolS	dot_symbol;
struct xsymbol	dot_symbol_x;

#ifdef DEBUG_SYMS
#define debug_verify_symchain verify_symbol_chain
#else
#define debug_verify_symchain(root,last) ((void) 0)
#endif

#define DOLLAR_LABEL_CHAR	'\001'
#define LOCAL_LABEL_CHAR	'\002'

#ifndef TC_LABEL_IS_LOCAL
#define TC_LABEL_IS_LOCAL(name)	0
#endif


/* Utility functions to allocate and duplicate memory on the notes obstack,
 * each like the corresponding function without "notes_" prefix.  All of these
 * exit on an allocation failure.  */
static void    *notes_alloc(size_t size)
{
	return obstack_alloc(&notes,size);
}

static void    *notes_calloc(size_t n,size_t size)
{
	size_t		amt;
	void           *ret;
	if (gas_mul_overflow(n,size,&amt)) {
		obstack_alloc_failed_handler();
		abort();
	}
	ret = notes_alloc(amt);
	memset(ret,0,amt);
	return ret;
}

static void    *notes_memdup(const void *src,size_t copy_size,size_t alloc_size)
{
	void           *ret = obstack_alloc(&notes,alloc_size);
	memcpy(ret,src,copy_size);
	if (alloc_size > copy_size)
		memset((char *)ret + copy_size,0,alloc_size - copy_size);
	return ret;
}

static char    *notes_strdup(const char *str)
{
	size_t		len = strlen(str) + 1;
	return notes_memdup(str,len,len);
}

static char    *notes_concat(const char *first,...)
{
	va_list		args;
	const char     *str;

	va_start(args,first);
	for (str = first; str; str = va_arg(args,const char *)) {
		size_t		size = strlen(str);
		obstack_grow(&notes,str,size);
	}
	va_end(args);
	obstack_1grow(&notes,0);
	return obstack_finish(&notes);
}

/* Use with caution!  Frees PTR and all more recently allocated memory on the
 * notes obstack.  */
static void	notes_free(void *ptr)
{
	obstack_free(&notes,ptr);
}

/* Return a pointer to a new symbol.  Die if we can't make a new symbol.  Fill
 * in the symbol's values.  Add symbol to end of symbol chain.
 * 
 * This function should be called in the general case of creating a symbol.
 * However,if the output file symbol table has already been set,and you are
 * certain that this symbol won't be wanted in the output file,you can call
 * symbol_create.  */
static symbolS *symbol_new(const char *name,segT segment,fragS * frag,valueT valu)
{
	symbolS        *symbolP = symbol_create(name,segment,frag,valu);

	/* Link to end of symbol chain.  */
	symbol_append(symbolP,symbol_lastP,&symbol_rootP,&symbol_lastP);

	return symbolP;
}

/* Save a symbol name on a permanent obstack,and convert it according to the
 * object file format.  */
static const char *save_symbol_name(const char *name)
{
	char           *ret;

	gas_assert(name != NULL);
	ret = notes_strdup(name);

#ifdef tc_canonicalize_symbol_name
	ret = tc_canonicalize_symbol_name(ret);
#endif

	if (!symbols_case_sensitive) {
		char           *s;

		for (s = ret; *s != '\0'; s++)
			*s = TOUPPER(*s);
	}
	return ret;
}
static asymbol *elf_make_empty_symbol(bfd * abfd)
{
	elf_symbol_type *newsym;

	newsym = (elf_symbol_type *) bfd_zalloc(abfd,sizeof(*newsym));
	if (!newsym)
		return NULL;
	newsym->symbol.the_bfd = abfd;
	return &newsym->symbol;
}

static void	symbol_init(symbolS * symbolP,const char *name,asection * sec,
					fragS *	frag ,valueT valu)
{
	symbolP->frag = frag;
	symbolP->bsym = elf_make_empty_symbol(stdoutput);
	if (symbolP->bsym == NULL)
		as_fatal("elf_make_empty_symbol: %s",bfd_errmsg(bfd_get_error()));
	symbolP->bsym->name = name;
	symbolP->bsym->section = sec;

	if (multibyte_handling == multibyte_warn_syms
	    && !symbolP->flags.local_symbol
	    && sec != undefined_section
	    && !symbolP->flags.multibyte_warned
	    && scan_for_multibyte_characters((const unsigned char *)name,
				   (const unsigned char *)name + strlen(name),
					     false /* Do not warn.  */ )) {
		as_warn(("symbol '%s' contains multibyte characters"),name);
		symbolP->flags.multibyte_warned = 1;
	}
	S_SET_VALUE(symbolP,valu);
	if (sec == reg_section)
		symbolP->x->value.X_op = O_register;

	symbol_clear_list_pointers(symbolP);

	obj_symbol_new_hook(symbolP);

#ifdef tc_symbol_new_hook
	tc_symbol_new_hook(symbolP);
#endif
}

/* Create a symbol.  NAME is copied,the caller can destroy/modify.  */
static symbolS *symbol_create(const char *name,segT segment,fragS * frag,valueT valu)
{
	const char     *preserved_copy_of_name;
	symbolS        *symbolP;
	size_t		size;

	preserved_copy_of_name = save_symbol_name(name);

	size = sizeof(symbolS) + sizeof(struct xsymbol);
	symbolP = notes_alloc(size);

	/* symbol must be born in some fixed state.  This seems as good as any.  */
	memset(symbolP,0,size);
	symbolP->name = preserved_copy_of_name;
	symbolP->x = (struct xsymbol *)(symbolP + 1);

	symbol_init(symbolP,preserved_copy_of_name,segment,frag,valu);

	return symbolP;
}


/* Local symbol support.  If we can get away with it,we keep only a small
 * amount of information for local symbols.  */
/* Used for statistics.  */
static unsigned long local_symbol_count;
static unsigned long local_symbol_conversion_count;

/* Create a local symbol and insert it into the local hash table.  */
static struct local_symbol *local_symbol_make(const char *name,
		  		segT		section,fragS * frag,valueT val)
{
	const char     *name_copy;
	struct local_symbol *ret;
	struct symbol_flags flags = {.local_symbol = 1,.resolved = 0};

	++local_symbol_count;
	name_copy = save_symbol_name(name);
	ret = notes_alloc(sizeof *ret);
	ret->flags = flags;
	ret->hash = 0;
	ret->name = name_copy;
	ret->frag = frag;
	ret->section = section;
	ret->value = val;
	htab_insert(sy_hash,ret,1);
	return ret;
}

/* Convert a local symbol into a real symbol.  */
static symbolS * local_symbol_convert(void *sym)
{
	symbol_entry_t *ent = (symbol_entry_t *) sym;
	struct xsymbol *xtra;
	valueT		val;

	gas_assert(ent->lsy.flags.local_symbol);

	++local_symbol_conversion_count;

	xtra = notes_alloc(sizeof(*xtra));
	memset(xtra,0,sizeof(*xtra));
	val = ent->lsy.value;
	ent->sy.x = xtra;

	/* Local symbols are always either defined or used.  */
	ent->sy.flags.used = 1;
	ent->sy.flags.local_symbol = 0;

	symbol_init(&ent->sy,ent->lsy.name,ent->lsy.section,ent->lsy.frag,val);
	symbol_append(&ent->sy,symbol_lastP,&symbol_rootP,&symbol_lastP);

	return &ent->sy;
}

static void	define_sym_at_dot(symbolS * symbolP)
{
	symbolP->frag = frag_now;
	S_SET_VALUE(symbolP,(valueT) frag_now_fix());
	S_SET_SEGMENT(symbolP,now_seg);
}

/* We have just seen "<name>:". Creates a struct symbol unless it already
 * exists. Gripes if we are redefining a symbol incompatibly (and ignores it).  */
static symbolS *colon(		/* Just seen "x:" - rattle symbols & frags.  */
		      		const		char  *sym_name	/* Symbol name,as a
								 * canonical string.  */
		       /* We copy this string: OK to alter later.  */ )
{
	symbolS        *symbolP;/* Symbol we are working with.  */

	if ((symbolP = symbol_find(sym_name)) != 0) {
		S_CLEAR_WEAKREFR(symbolP);
		/* Now check for undefined symbols.  */
		if (symbolP->flags.local_symbol) {
			struct local_symbol *locsym = (struct local_symbol *)symbolP;

			if (locsym->section != undefined_section
			    && (locsym->frag != frag_now
				|| locsym->section != now_seg
				|| locsym->value != frag_now_fix())) {
				as_bad(("symbol `%s' is already defined"),sym_name);
				return symbolP;
			}
			locsym->section = now_seg;
			locsym->frag = frag_now;
			locsym->value = frag_now_fix();
		} else
			if (!(S_IS_DEFINED(symbolP) || symbol_equated_p(symbolP))
			    || S_IS_COMMON(symbolP)
			    || S_IS_VOLATILE(symbolP)) {
				if (S_IS_VOLATILE(symbolP)) {
					symbolP = symbol_clone(symbolP,1);
					S_SET_VALUE(symbolP,0);
					S_CLEAR_VOLATILE(symbolP);
				}
				if (S_GET_VALUE(symbolP) == 0) {
					define_sym_at_dot(symbolP);
#ifdef N_UNDF
					know(N_UNDF == 0);
#endif				/* if we have one,it better be zero.  */

				} else {
				/* There are still several cases to * check:
				 * 
				 * A .comm/.lcomm symbol being redefined * as 
				 * initialized data is OK
				 * A .comm/.lcomm symbol being redefined with a 
				 * larger size is also OK
				 * This only used to be allowed on VMS gas,but 
				 * Sun cc on the sparc also depends on it.  */
					if (((!S_IS_DEBUG(symbolP)
					      && (!S_IS_DEFINED(symbolP) || S_IS_COMMON(symbolP))
					      && S_IS_EXTERNAL(symbolP))
					     || S_GET_SEGMENT(symbolP) == bss_section)
					    && (now_seg == data_section
						|| now_seg == bss_section
						|| now_seg == S_GET_SEGMENT(symbolP))) {
						/* Select which of the 2 cases * this is.  */
						if (now_seg != data_section) {
						/* New .comm for prev .comm symbol.
						 * If the new size is larger we just
						 * change its value. If the new size is
						 * smaller,we ignore this symbol.  */
							if (S_GET_VALUE(symbolP)
							    < ((unsigned)frag_now_fix())) {
								S_SET_VALUE(symbolP,(valueT) frag_now_fix());
							}
						} else {
							/* It is a .comm/.lcomm being converted to
						 	 * initialized data.  */
							define_sym_at_dot(symbolP);
						}
					} else {
						static const char *od_buf = "";
						as_bad(("symbol `%s' is already defined as \"%s\"/%s%ld"),
						       sym_name,
						       segment_name(S_GET_SEGMENT(symbolP)),
						       od_buf,
						  (long)S_GET_VALUE(symbolP));
					}
				}	/* if the undefined symbol has no value  */
			} else {
				/* Don't blow up if the definition is the same.  */
				if (!(frag_now == symbolP->frag
				      && S_GET_VALUE(symbolP) == frag_now_fix()
				      && S_GET_SEGMENT(symbolP) == now_seg)) {
					as_bad(("symbol `%s' is already defined"),sym_name);
					symbolP = symbol_clone(symbolP,0);
					define_sym_at_dot(symbolP);
				}
			}

	} else
		if (!flag_keep_locals && is_local_label_name(sym_name)) {
			symbolP = (symbolS *) local_symbol_make(sym_name,now_seg,frag_now,
							      frag_now_fix());
		} else {
			symbolP = symbol_new(sym_name,now_seg,frag_now,frag_now_fix());

			symbol_table_insert(symbolP);
		}
	dwarf2_emit_label(symbolP);
	return symbolP;
}

/* Die if we can't insert the symbol.  */
static void	symbol_table_insert(symbolS * symbolP)
{
	know(symbolP);
	htab_insert(sy_hash,symbolP,1);
}

/* If a symbol name does not exist,create it as undefined,and insert it into
 * the symbol table.  Return a pointer to it.  */
static symbolS *symbol_find_or_make(const char *name)
{
	symbolS        *symbolP;

	symbolP = symbol_find(name);

	if (symbolP == NULL) {
		if (!flag_keep_locals && is_local_label_name(name)) {
			symbolP = md_undefined_symbol((char *)name);
			if (symbolP != NULL)
				return symbolP;

			symbolP = (symbolS *) local_symbol_make(name,undefined_section,
						       &zero_address_frag,0);
			return symbolP;
		}
		symbolP = symbol_make(name);
		symbol_table_insert(symbolP);
	}			/* if symbol wasn't found */
	return (symbolP);
}

static symbolS *symbol_make(const char *name)
{
	symbolS        *symbolP;

	/* Let the machine description default it,e.g. for register names.  */
	symbolP = md_undefined_symbol((char *)name);

	if (!symbolP)
		symbolP = symbol_new(name,undefined_section,&zero_address_frag,0);

	return (symbolP);
}

static asymbol *make_empty_symbol(void)
{
	elf_symbol_type *newsym = xcalloc(1,sizeof *newsym);
	return &newsym->symbol;
}
static symbolS *symbol_clone(symbolS * orgsymP,int replace)
{
	symbolS        *newsymP;
	asymbol        *bsymorg,*bsymnew;

	/* Make sure we never clone the dot special symbol.  */
	gas_assert(orgsymP != &dot_symbol);

	/* When cloning a local symbol it isn't absolutely necessary to convert
	 * the original,but converting makes the code much simpler to cover
	 * this unexpected case.  As of 2020-08-21 symbol_clone won't be called
	 * on a local symbol.  */
	if (orgsymP->flags.local_symbol)
		orgsymP = local_symbol_convert(orgsymP);
	bsymorg = orgsymP->bsym;

	newsymP = notes_alloc(sizeof(symbolS) + sizeof(struct xsymbol));
	*newsymP = *orgsymP;
	newsymP->x = (struct xsymbol *)(newsymP + 1);
	*newsymP->x = *orgsymP->x;
	bsymnew = make_empty_symbol();
	if (bsymnew == NULL)
		as_fatal("bfd_make_empty_symbol: %s",bfd_errmsg(bfd_get_error()));
	newsymP->bsym = bsymnew;
	bsymnew->name = bsymorg->name;
	bsymnew->flags = bsymorg->flags & ~BSF_SECTION_SYM;
	bsymnew->section = bsymorg->section;
	//bfd_copy_private_symbol_data(bfd_asymbol_bfd(bsymorg),bsymorg,
				       //bfd_asymbol_bfd(bsymnew),bsymnew);

	elf_obj_symbol_clone_hook(newsymP,orgsymP);

	if (replace) {
		if (symbol_rootP == orgsymP)
			symbol_rootP = newsymP;
		else
			if (orgsymP->x->previous) {
				orgsymP->x->previous->x->next = newsymP;
				orgsymP->x->previous = NULL;
			}
		if (symbol_lastP == orgsymP)
			symbol_lastP = newsymP;
		else
			if (orgsymP->x->next)
				orgsymP->x->next->x->previous = newsymP;

		/* Symbols that won't be output can't be external.  */
		S_CLEAR_EXTERNAL(orgsymP);
		orgsymP->x->previous = orgsymP->x->next = orgsymP;
		debug_verify_symchain(symbol_rootP,symbol_lastP);

		symbol_table_insert(newsymP);
	} else {
		/* Symbols that won't be output can't be external.  */
		S_CLEAR_EXTERNAL(newsymP);
		newsymP->x->previous = newsymP->x->next = newsymP;
	}

	return newsymP;
}

/* Referenced symbols,if they are forward references,need to be cloned
 * (without replacing the original) so that the value of the referenced symbols
 * at the point of use is saved by the clone.  */
#undef symbol_clone_if_forward_ref
static symbolS *symbol_clone_if_forward_ref(symbolS * symbolP,int is_forward)
{
	if (symbolP
	    && !symbolP->flags.local_symbol
	    && !symbolP->flags.forward_resolved) {
		symbolS        *orig_add_symbol = symbolP->x->value.X_add_symbol;
		symbolS        *orig_op_symbol = symbolP->x->value.X_op_symbol;
		symbolS        *add_symbol = orig_add_symbol;
		symbolS        *op_symbol = orig_op_symbol;

		if (symbolP->flags.forward_ref)
			is_forward = 1;

		if (is_forward) {
			/* assign_symbol() clones volatile symbols;
			 * pre-existing expressions hold references to the
			 * original instance,but want the current value.  Just
			 * repeat the lookup.  */
			if (add_symbol && S_IS_VOLATILE(add_symbol))
				add_symbol = symbol_find_exact(S_GET_NAME(add_symbol));
			if (op_symbol && S_IS_VOLATILE(op_symbol))
				op_symbol = symbol_find_exact(S_GET_NAME(op_symbol));
		}
		/* Re-using resolving here,as this routine cannot get called
		 * from symbol resolution code.  */
		if ((symbolP->bsym->section == expr_section
		     || symbolP->flags.forward_ref)
		    && !symbolP->flags.resolving) {
			symbolP->flags.resolving = 1;
			add_symbol = symbol_clone_if_forward_ref(add_symbol,is_forward);
			op_symbol = symbol_clone_if_forward_ref(op_symbol,is_forward);
			symbolP->flags.resolving = 0;
		}
		if (symbolP->flags.forward_ref
		    || add_symbol != orig_add_symbol
		    || op_symbol != orig_op_symbol) {
			if (symbolP != &dot_symbol) {
				symbolP = symbol_clone(symbolP,0);
				symbolP->flags.resolving = 0;
			} else {
				symbolP = symbol_temp_new_now();
			}
		}
		symbolP->x->value.X_add_symbol = add_symbol;
		symbolP->x->value.X_op_symbol = op_symbol;
		symbolP->flags.forward_resolved = 1;
	}
	return symbolP;
}

static symbolS *symbol_temp_new(segT seg,fragS * frag,valueT ofs)
{
	return symbol_new(FAKE_LABEL_NAME,seg,frag,ofs);
}

static symbolS *symbol_temp_new_now(void)
{
	return symbol_temp_new(now_seg,frag_now,frag_now_fix());
}

static symbolS *symbol_temp_new_now_octets(void)
{
	return symbol_temp_new(now_seg,frag_now,frag_now_fix_octets());
}

static symbolS *symbol_temp_make(void)
{
	return symbol_make(FAKE_LABEL_NAME);
}

/* Implement symbol table lookup. In:	A symbol's name as a string: '\0' can't
 * be part of a symbol name. Out:	NULL if the name was not in the symbol
 * table,else the address of a struct symbol associated with that name.  */
static symbolS *symbol_find_exact(const char *name)
{
	return symbol_find_exact_noref(name,0);
}

static symbolS *symbol_find_exact_noref(const char *name,int noref)
{
	symbolS        *sym = symbol_entry_find(sy_hash,name);

	/* Any references to the symbol,except for the reference in .weakref,
	 * must clear this flag,such that the symbol does not turn into a weak
	 * symbol.  Note that we don't have to handle the local_symbol case,
	 * since a weakrefd is always promoted out of the local_symbol table
	 * when it is turned into a weak symbol.  */
	if (sym && !noref)
		S_CLEAR_WEAKREFD(sym);

	return sym;
}

static symbolS *symbol_find(const char *name)
{
	return symbol_find_noref(name,0);
}

/* from symbols.c:980 */
static symbolS *symbol_find_noref(const char *name,int noref)
{
	symbolS        *result;
	char           *copy = NULL;

	if (!symbols_case_sensitive) {
		const char     *orig;
		char           *copy2 = NULL;
		unsigned char	c;

		orig = name;
		if (copy != NULL)
			copy2 = copy;
		name = copy = XNEWVEC(char,strlen(name) + 1);

		while ((c = *orig++) != '\0')
			*copy++ = TOUPPER(c);
		*copy = '\0';

		free(copy2);
		copy = (char *)name;
	}
	result = symbol_find_exact_noref(name,noref);
	free(copy);
	return result;
}

/* Once upon a time,symbols were kept in a singly linked list.  At least coff
 * needs to be able to rearrange them from time to time,for which a doubly
 * linked list is much more convenient.  Loic did these as macros which seemed
 * dangerous to me so they're now functions. xoxorich.  */
/* Link symbol ADDME after symbol TARGET in chain. gas/symbols.c:1017 */
static void	symbol_append(symbolS * addme,symbolS * target,
		      		symbolS **	rootPP,symbolS ** lastPP)
{
	if (symbol_table_frozen)
		abort();
	if (addme->flags.local_symbol)
		abort();
	if (target != NULL && target->flags.local_symbol)
		abort();

	if (target == NULL) {
		know(*rootPP == NULL);
		know(*lastPP == NULL);
		addme->x->next = NULL;
		addme->x->previous = NULL;
		*rootPP = addme;
		*lastPP = addme;
		return;
	}			/* if the list is empty  */
	if (target->x->next != NULL) {
		target->x->next->x->previous = addme;
	} else {
		know(*lastPP == target);
		*lastPP = addme;
	}			/* if we have a next  */

	addme->x->next = target->x->next;
	target->x->next = addme;
	addme->x->previous = target;

	debug_verify_symchain(symbol_rootP,symbol_lastP);
}

/* Set the chain pointers of SYMBOL to null.  */
/* this is inlined in the original. jacob */
static void	symbol_clear_list_pointers(symbolS * symbolP)
{
	if (symbolP->flags.local_symbol)
		abort();
	symbolP->x->next = NULL;
	symbolP->x->previous = NULL;
}

/* Remove SYMBOLP from the list.  from symbols.c:1068 */
static void	symbol_remove(symbolS * symbolP,symbolS ** rootPP,symbolS ** lastPP)
{
	if (symbolP->flags.local_symbol)
		abort();

	if (symbolP == *rootPP) {
		*rootPP = symbolP->x->next;
	}			/* if it was the root  */
	if (symbolP == *lastPP) {
		*lastPP = symbolP->x->previous;
	}			/* if it was the tail  */
	if (symbolP->x->next != NULL) {
		symbolP->x->next->x->previous = symbolP->x->previous;
	}			/* if not last  */
	if (symbolP->x->previous != NULL) {
		symbolP->x->previous->x->next = symbolP->x->next;
	}			/* if not first  */
	debug_verify_symchain(*rootPP,*lastPP);
}

/* Link symbol ADDME before symbol TARGET in the chain. symbols.c:1101 */
static void	symbol_insert(symbolS * addme,symbolS * target,
     		symbolS **	rootPP,symbolS ** lastPP ATTRIBUTE_UNUSED)
{
	if (symbol_table_frozen)
		abort();
	if (addme->flags.local_symbol)
		abort();
	if (target->flags.local_symbol)
		abort();
	if (target->x->previous != NULL) {
		target->x->previous->x->next = addme;
	} else {
		know(*rootPP == target);
		*rootPP = addme;
	}			/* if not first  */
	addme->x->previous = target->x->previous;
	target->x->previous = addme;
	addme->x->next = target;
	debug_verify_symchain(*rootPP,*lastPP);
}

#ifdef DEBUG
static void	verify_symbol_chain(symbolS * rootP,symbolS * lastP)
{
	symbolS        *symbolP = rootP;

	if (symbolP == NULL)
		return;

	for (; symbol_next(symbolP) != NULL; symbolP = symbol_next(symbolP)) {
		gas_assert(symbolP->bsym != NULL);
		gas_assert(symbolP->flags.local_symbol == 0);
		gas_assert(symbolP->x->next->x->previous == symbolP);
	}

	gas_assert(lastP == symbolP);
}
#endif

static int	symbol_on_chain(symbolS * s,symbolS * rootPP,symbolS * lastPP)
{
	return (!s->flags.local_symbol
		&& ((s->x->next != s
		     && s->x->next != NULL
		     && s->x->next->x->previous == s)
		    || s == lastPP)
		&& ((s->x->previous != s
		     && s->x->previous != NULL
		     && s->x->previous->x->next == s)
		    || s == rootPP));
}

static void	report_op_error(symbolS * symp,
	      		symbolS *	left,operatorT op,symbolS * right)
{
	const char     *file;
	unsigned int	line;
	segT		seg_left = left ? S_GET_SEGMENT(left) : 0;
	segT		seg_right = S_GET_SEGMENT(right);
	const char     *opname;

	switch (op) {
	default: abort(); return;

	case O_uminus: opname = "-"; break;
	case O_bit_not: opname = "~"; break;
	case O_logical_not: opname = "!"; break;
	case O_multiply: opname = "*"; break;
	case O_divide: opname = "/"; break;
	case O_modulus: opname = "%"; break;
	case O_left_shift: opname = "<<"; break;
	case O_right_shift: opname = ">>"; break;
	case O_bit_inclusive_or: opname = "|"; break;
	case O_bit_or_not: opname = "|~"; break;
	case O_bit_exclusive_or: opname = "^"; break;
	case O_bit_and: opname = "&"; break;
	case O_add: opname = "+"; break;
	case O_subtract: opname = "-"; break;
	case O_eq: opname = "=="; break;
	case O_ne: opname = "!="; break;
	case O_lt: opname = "<"; break;
	case O_le: opname = "<="; break;
	case O_ge: opname = ">="; break;
	case O_gt: opname = ">"; break;
	case O_logical_and: opname = "&&"; break;
	case O_logical_or: opname = "||"; break;
	}

	if (expr_symbol_where(symp,&file,&line)) {
		if (left)
			as_bad_where(file,line,
			   "invalid operands (%s and %s sections) for `%s'",
				     seg_left->name,seg_right->name,opname);
		else
			as_bad_where(file,line,
				     "invalid operand (%s section) for `%s'",
				     seg_right->name,opname);
	} else {
		const char     *sname = S_GET_NAME(symp);

		if (left)
			as_bad("invalid operands (%s and %s sections) for `%s' when setting `%s'",
			       seg_left->name,seg_right->name,opname,sname);
		else
			as_bad("invalid operand (%s section) for `%s' when setting `%s'",
			       seg_right->name,opname,sname);
	}
}

/* Resolve the value of a symbol.  This is called during the final pass over
 * the symbol table to resolve any symbols with complex values.
 * gas/symbols.c:1285 */
static valueT	resolve_symbol_value(symbolS * symp)
{
	int		resolved;
	valueT		final_val;
	segT		final_seg;

	if (symp->flags.local_symbol) {
		struct local_symbol *locsym = (struct local_symbol *)symp;

		final_val = locsym->value;
		if (locsym->flags.resolved)
			return final_val;

		/* Symbols whose section has SEC_ELF_OCTETS set,resolve to
		 * octets instead of target bytes.  */
		if (locsym->section->flags & SEC_OCTETS)
			final_val += locsym->frag->fr_address;
		else
			final_val += locsym->frag->fr_address / OCTETS_PER_BYTE;

		if (finalize_syms) {
			locsym->value = final_val;
			locsym->flags.resolved = 1;
		}
		return final_val;
	}
	if (symp->flags.resolved) {
		final_val = 0;
		while (symp->x->value.X_op == O_symbol) {
			final_val += symp->x->value.X_add_number;
			symp = symp->x->value.X_add_symbol;
			if (symp->flags.local_symbol) {
				struct local_symbol *locsym = (struct local_symbol *)symp;
				final_val += locsym->value;
				return final_val;
			}
			if (!symp->flags.resolved)
				return 0;
		}
		if (symp->x->value.X_op == O_constant)
			final_val += symp->x->value.X_add_number;
		else
			final_val = 0;
		return final_val;
	}
	resolved = 0;
	final_seg = S_GET_SEGMENT(symp);

	if (symp->flags.resolving) {
		if (finalize_syms)
			as_bad("symbol definition loop encountered at `%s'",
			       S_GET_NAME(symp));
		final_val = 0;
		resolved = 1;
	}
	else {
		symbolS        *add_symbol,*op_symbol;
		offsetT		left  ,right;
		segT		seg_left ,seg_right;
		operatorT	op;
		int		move_seg_ok;

		symp->flags.resolving = 1;

		/* Help out with CSE.  */
		add_symbol = symp->x->value.X_add_symbol;
		op_symbol = symp->x->value.X_op_symbol;
		final_val = symp->x->value.X_add_number;
		op = symp->x->value.X_op;

		switch (op) {
		default: BAD_CASE(op); break;

		case O_md1: case O_md2: case O_md3: case O_md4: case O_md5:
		case O_md6: case O_md7: case O_md8: case O_md9: case O_md10:
		case O_md11: case O_md12: case O_md13: case O_md14: case O_md15:
		case O_md16: case O_md17: case O_md18: case O_md19: case O_md20:
		case O_md21: case O_md22: case O_md23: case O_md24: case O_md25:
		case O_md26: case O_md27: case O_md28: case O_md29: case O_md30:
		case O_md31: case O_md32:
				goto exit_dont_set_value;

			case O_absent:
				final_val = 0;
				/* Fall through.  */
			case O_constant:
				/* * Symbols whose section has SEC_ELF_OCTETS
				 * set,resolve to octets instead of target
				 * bytes.  */
				if (symp->bsym->section->flags & SEC_OCTETS)
					final_val += symp->frag->fr_address;
				else
					final_val += symp->frag->fr_address / OCTETS_PER_BYTE;
				if (final_seg == expr_section)
					final_seg = absolute_section;
				/* Fall through.  */
			case O_register:
				resolved = 1;
				break;

			case O_symbol: case O_symbol_rva: case O_secidx:
				left = resolve_symbol_value(add_symbol);
				seg_left = S_GET_SEGMENT(add_symbol);
				if (finalize_syms)
					symp->x->value.X_op_symbol = NULL;

		do_symbol:
				if (S_IS_WEAKREFR(symp)) {
					gas_assert(final_val == 0);
					if (S_IS_WEAKREFR(add_symbol)) {
						gas_assert(add_symbol->x->value.X_op == O_symbol
							   && add_symbol->x->value.X_add_number == 0);
						add_symbol = add_symbol->x->value.X_add_symbol;
						gas_assert(!S_IS_WEAKREFR(add_symbol));
						symp->x->value.X_add_symbol = add_symbol;
					}
				}
				/* Don't leave symbol loops.  */
				if (finalize_syms
				    && !add_symbol->flags.local_symbol
				    && add_symbol->flags.resolving)
					break;

				if (finalize_syms && final_val == 0) {
					if (add_symbol->flags.local_symbol)
						add_symbol = local_symbol_convert(add_symbol);
					copy_symbol_attributes(symp,add_symbol);
				}
				/* If we have equated this symbol to an
				 * undefined or common symbol,keep X_op set to
				 * O_symbol,and don't change X_add_number.
				 * This permits the routine which writes out
				 * relocation to detect this case,and convert
				 * the relocation to be against the symbol to
				 * which this symbol is equated.  */
				if (seg_left == undefined_section
				    || bfd_is_com_section(seg_left)
				    || (finalize_syms
					&& ((final_seg == expr_section
					     && seg_left != expr_section
					     && seg_left != absolute_section)
					    || symbol_shadow_p(symp)))) {
					if (finalize_syms) {
						symp->x->value.X_op = O_symbol;
						symp->x->value.X_add_symbol = add_symbol;
						symp->x->value.X_add_number = final_val;
						/* Use X_op_symbol as a flag.  */
						symp->x->value.X_op_symbol = add_symbol;
					}
					final_seg = seg_left;
					final_val += symp->frag->fr_address + left;
					resolved = symbol_resolved_p(add_symbol);
					symp->flags.resolving = 0;

					if (op == O_secidx && seg_left != undefined_section) {
						final_val = 0;
						break;
					}
					goto exit_dont_set_value;
				} else {
					final_val += symp->frag->fr_address + left;
					if (final_seg == expr_section || final_seg == undefined_section)
						final_seg = seg_left;
				}

				resolved = symbol_resolved_p(add_symbol);
				if (S_IS_WEAKREFR(symp)) {
					symp->flags.resolving = 0;
					goto exit_dont_set_value;
				}
				break;

			case O_uminus: case O_bit_not: case O_logical_not:
				left = resolve_symbol_value(add_symbol);
				seg_left = S_GET_SEGMENT(add_symbol);

				/*
				 * By reducing these to the relevant dyadic
				 * operator,we get !S -> S == 0
				 * permitted on anything,-S -> 0 - S	only
				 * permitted on absolute ~S -> S ^ ~0	only
				 * permitted on absolute
				 */
				if (op != O_logical_not && seg_left != absolute_section
				    && finalize_syms)
					report_op_error(symp,NULL,op,add_symbol);

				if (final_seg == expr_section || final_seg == undefined_section)
					final_seg = absolute_section;

				if (op == O_uminus)
					left = -left;
				else
					if (op == O_logical_not)
						left = !left;
					else
						left = ~left;

				final_val += left + symp->frag->fr_address;

				resolved = symbol_resolved_p(add_symbol);
				break;

			case O_multiply: case O_divide: case O_modulus: case O_left_shift:
			case O_right_shift: case O_bit_inclusive_or: case O_bit_or_not:
			case O_bit_exclusive_or: case O_bit_and: case O_add:
			case O_subtract: case O_eq: case O_ne: case O_lt: case O_le:
			case O_ge: case O_gt: case O_logical_and: case O_logical_or:
				left = resolve_symbol_value(add_symbol);
				right = resolve_symbol_value(op_symbol);
				seg_left = S_GET_SEGMENT(add_symbol);
				seg_right = S_GET_SEGMENT(op_symbol);

				/* Simplify addition or subtraction of a
				 * constant by folding the constant into
				 * X_add_number.  */
				if (op == O_add) {
					if (seg_right == absolute_section) {
						final_val += right;
						goto do_symbol;
					} else
						if (seg_left == absolute_section) {
							final_val += left;
							add_symbol = op_symbol;
							left = right;
							seg_left = seg_right;
							goto do_symbol;
						}
				} else
					if (op == O_subtract) {
						if (seg_right == absolute_section) {
							final_val -= right;
							goto do_symbol;
						}
					}
				move_seg_ok = 1;
				/* Equality and non-equality tests are permitted on 
				 * anything. Subtraction,and other comparison operators 
				 * are permitted if both operands are in the same section.
				 * Otherwise,both operands must be absolute.
				 * We already handled the case of addition or subtraction 
				 * of a constant above.  This will probably need to be 
				 * changed for an object file format which supports arbitrary
				 * expressions.  */
				if (!(seg_left == absolute_section
				      && seg_right == absolute_section)
				    && !(op == O_eq || op == O_ne)
				    && !((op == O_subtract
					  || op == O_lt || op == O_le || op == O_ge || op == O_gt)
					 && seg_left == seg_right
					 && (seg_left != undefined_section
					     || add_symbol == op_symbol))) {
					/* Don't emit messages unless we're finalizing the symbol 
					 * value, otherwise we may get the same message multiple 
					 * times.  */
					if (finalize_syms)
						report_op_error(symp,add_symbol,op,op_symbol);
					/* However do not move the symbol into the absolute section 
					 * if it cannot currently be resolved - this would
					 * confuse other parts of the assembler into believing that 
					 * the expression had been evaluated to zero.  */
					else
						move_seg_ok = 0;
				}
				if (move_seg_ok
				    && (final_seg == expr_section || final_seg == undefined_section))
					final_seg = absolute_section;

				/* Check for division by zero.  */
				if ((op == O_divide || op == O_modulus) && right == 0) {
					/* If seg_right is not absolute_section,then we've already
					 * issued a warning about using a bad symbol.  */
					if (seg_right == absolute_section && finalize_syms) {
						const char     *file;
						unsigned int	line;

						if (expr_symbol_where(symp,&file,&line))
							as_bad_where(file,line,("division by zero"));
						else
							as_bad(("division by zero when setting `%s'"),
							    S_GET_NAME(symp));
					}
					right = 1;
				}
				if ((op == O_left_shift || op == O_right_shift)
				    && (valueT) right >= sizeof(valueT) * CHAR_BIT) {
					as_warn_value_out_of_range(("shift count"),right,0,
						sizeof(valueT) * CHAR_BIT - 1,
								   NULL,0);
					left = right = 0;
				}
				switch (symp->x->value.X_op) {
				case O_multiply: left *= right; break;
				case O_divide: left /= right; break;
				case O_modulus: left %= right; break;
				case O_left_shift: left = (valueT) left << (valueT) right; break;
				case O_right_shift: left = (valueT) left >> (valueT) right; break;
				case O_bit_inclusive_or: left |= right; break;
				case O_bit_or_not: left |= ~right; break;
				case O_bit_exclusive_or: left ^= right; break;
				case O_bit_and: left &= right; break;
				case O_add: left += right; break;
				case O_subtract: left -= right; break;
				case O_eq: case O_ne:
					left = (left == right && seg_left == seg_right
					     && (seg_left != undefined_section
						 || add_symbol == op_symbol)
						? ~(offsetT) 0 : 0);
					if (symp->x->value.X_op == O_ne)
						left = ~left;
					break;
				case O_lt: left = left < right ? ~(offsetT) 0 : 0; break;
				case O_le: left = left <= right ? ~(offsetT) 0 : 0; break;
				case O_ge: left = left >= right ? ~(offsetT) 0 : 0; break;
				case O_gt: left = left > right ? ~(offsetT) 0 : 0; break;
				case O_logical_and: left = left && right; break;
				case O_logical_or: left = left || right; break;

				case O_illegal: case O_absent: case O_constant:
					/* See PR 20895 for a reproducer.  */
					as_bad(("Invalid operation on symbol"));
					goto exit_dont_set_value;

				default:
					abort();
				}

				final_val += symp->frag->fr_address + left;
				if (final_seg == expr_section || final_seg == undefined_section) {
					if (seg_left == undefined_section
					    || seg_right == undefined_section)
						final_seg = undefined_section;
					else
						if (seg_left == absolute_section)
							final_seg = seg_right;
						else
							final_seg = seg_left;
				}
				resolved = (symbol_resolved_p(add_symbol)
					    && symbol_resolved_p(op_symbol));
				break;

			case O_big: case O_illegal:
			/* Give an error (below) if not in expr_section.  We don't 
			 * want to worry about expr_section symbols,because they are
			 * fictional (they are created as part of expression resolution),
			 * and any problems may not actually mean anything.  */
				break;
			}

			symp->flags.resolving = 0;
		}

	if (finalize_syms)
		S_SET_VALUE(symp,final_val);

exit_dont_set_value:
	/* Always set the segment,even if not finalizing the value. The
	 * segment is used to determine whether a symbol is defined.  */
	S_SET_SEGMENT(symp,final_seg);

	/* Don't worry if we can't resolve an expr_section symbol.  */
	if (finalize_syms) {
		if (resolved)
			symp->flags.resolved = 1;
		else
			if (S_GET_SEGMENT(symp) != expr_section) {
				as_bad(("can't resolve value for symbol `%s'"),
				       S_GET_NAME(symp));
				symp->flags.resolved = 1;
			}
	}
	return final_val;
}

/* A static function passed to hash_traverse.  */
static int	resolve_local_symbol(void **slot,void *arg ATTRIBUTE_UNUSED)
{
	symbol_entry_t *entry = *((symbol_entry_t **) slot);
	if (entry->sy.flags.local_symbol)
		resolve_symbol_value(&entry->sy);
	return 1;
}

/* This function scans over the entire hash table calling CALLBACK for each
 * live entry.  If CALLBACK returns false,the iteration stops.  INFO is passed
 * as CALLBACK's second argument.  */
static void	htab_traverse_noresize(htab_t htab,htab_trav callback,void *info)
{
	void          **slot;
	void          **limit;

	slot = htab->entries;
	limit = slot + htab_size(htab);

	do {
		void           *x = *slot;

		if (x != HTAB_EMPTY_ENTRY && x != HTAB_DELETED_ENTRY)
			if (!(*callback) (slot,info))
				break;
	}
	while (++slot < limit);
}
/* Resolve all local symbols.  */
static void	resolve_local_symbol_values(void)
{
	htab_traverse_noresize(sy_hash,resolve_local_symbol,NULL);
}

/* Obtain the current value of a symbol without changing any sub-expressions
 * used.  */
static int	snapshot_symbol(symbolS ** symbolPP,valueT * valueP,segT * segP,fragS ** fragPP)
{
	symbolS        *symbolP = *symbolPP;

	if (symbolP->flags.local_symbol) {
		struct local_symbol *locsym = (struct local_symbol *)symbolP;

		*valueP = locsym->value;
		*segP = locsym->section;
		*fragPP = locsym->frag;
	} else {
		expressionS	exp = symbolP->x->value;

		if (!symbolP->flags.resolved && exp.X_op != O_illegal) {
			int		resolved;

			if (symbolP->flags.resolving)
				return 0;
			symbolP->flags.resolving = 1;
			resolved = resolve_expression(&exp);
			symbolP->flags.resolving = 0;
			if (!resolved)
				return 0;

			switch (exp.X_op) {
			case O_constant:
			case O_register:
				if (!symbol_equated_p(symbolP))
					break;
				/* Fallthru.  */
			case O_symbol:
			case O_symbol_rva:
				symbolP = exp.X_add_symbol;
				break;
			default:
				return 0;
			}
		}
		*symbolPP = symbolP;

		/* A bogus input file can result in resolve_expression()
		 * generating a local symbol,so we have to check again.  */
		if (symbolP->flags.local_symbol) {
			struct local_symbol *locsym = (struct local_symbol *)symbolP;

			*valueP = locsym->value;
			*segP = locsym->section;
			*fragPP = locsym->frag;
		} else {
			*valueP = exp.X_add_number;
			*segP = symbolP->bsym->section;
			*fragPP = symbolP->frag;
		}

		if (*segP == expr_section)
			switch (exp.X_op) {
			case O_constant:
				*segP = absolute_section;
				break;
			case O_register:
				*segP = reg_section;
				break;
			default:
				break;
			}
	}

	return 1;
}

/* Somebody else's idea of local labels. They are made by "n:" where n is any
 * decimal digit. Refer to them with "nb" for previous (backward) n: or "nf"
 * for next (forward) n:.
 * 
 * We do a little better and let n be any number,not just a single digit,but
 * since the other guy's assembler only does ten,we treat the first ten
 * specially.
 * 
 * Like someone else's assembler,we have one set of local label counters for
 * entire assembly,not one set per (sub)segment like in most assemblers. This
 * implies that one can refer to a label in another segment,and indeed some
 * crufty compilers have done just that.
 * 
 * Since there could be a LOT of these things,treat them as a sparse array.  */

#define FB_LABEL_SPECIAL (10)

typedef unsigned int fb_ent;

/* This must be more than FB_LABEL_SPECIAL.  */
#define FB_LABEL_BUMP_BY (FB_LABEL_SPECIAL + 6)

/* Decode name that may have been generated by foo_label_name() above. If the
 * name wasn't generated by foo_label_name(),then return it unaltered.  This
 * is used for error messages.  */
static char    *decode_local_label_name(char *s)
{
	char           *p;
	char           *symbol_decode;
	int		label_number;
	int		instance_number;
	const char     *type;
	const char     *message_format;
	int		lindex = 0;

#ifdef LOCAL_LABEL_PREFIX
	if (s[lindex] == LOCAL_LABEL_PREFIX)
		++lindex;
#endif

	if (s[lindex] != 'L')
		return s;

	for (label_number = 0,p = s + lindex + 1; ISDIGIT(*p); ++p)
		label_number = (10 * label_number) + *p - '0';

	if (*p == DOLLAR_LABEL_CHAR)
		type = "dollar";
	else
		if (*p == LOCAL_LABEL_CHAR)
			type = "fb";
		else
			return s;

	for (instance_number = 0,p++; ISDIGIT(*p); ++p)
		instance_number = (10 * instance_number) + *p - '0';

	message_format = ("\"%d\" (instance number %d of a %s label)");
	symbol_decode = notes_alloc(strlen(message_format) + 30);
	sprintf(symbol_decode,message_format,label_number,instance_number,type);

	return symbol_decode;
}

/* Get the value of a symbol.  */

static valueT	S_GET_VALUE_WHERE(symbolS * s,const char *file,unsigned int line)
{
	if (s->flags.local_symbol)
		return resolve_symbol_value(s);

	if (!s->flags.resolved) {
		valueT		val = resolve_symbol_value(s);
		if (!finalize_syms)
			return val;
	}
	if (S_IS_WEAKREFR(s))
		return S_GET_VALUE(s->x->value.X_add_symbol);

	if (s->x->value.X_op != O_constant) {
		if (!s->flags.resolved
		    || s->x->value.X_op != O_symbol
		    || (S_IS_DEFINED(s) && !S_IS_COMMON(s))) {
			if (strcmp(S_GET_NAME(s),FAKE_LABEL_NAME) == 0)
				as_bad_where(file,line,("expression is too complex to be resolved or converted into relocations"));
			else
				if (file != NULL)
					as_bad_where(file,line,("attempt to get value of unresolved symbol `%s'"),
						     S_GET_NAME(s));
				else
					as_bad(("attempt to get value of unresolved symbol `%s'"),
					       S_GET_NAME(s));
		}
	}
	return (valueT) s->x->value.X_add_number;
}

static valueT	S_GET_VALUE(symbolS * s)
{
	return S_GET_VALUE_WHERE(s,NULL,0);
}

/* Set the value of a symbol.  */
static void	S_SET_VALUE(symbolS * s,valueT val)
{
	if (s->flags.local_symbol) {
		((struct local_symbol *)s)->value = val;
		return;
	}
	s->x->value.X_op = O_constant;
	s->x->value.X_add_number = (offsetT) val;
	s->x->value.X_unsigned = 0;
	S_CLEAR_WEAKREFR(s);
}

static void	copy_symbol_attributes(symbolS * dest,symbolS * src)
{				/* gas/symbols.c:2281 */
	if (dest->flags.local_symbol)
		dest = local_symbol_convert(dest);
	if (src->flags.local_symbol)
		src = local_symbol_convert(src);

	/*
	 * In an expression,transfer the settings of these flags. The user can
	 * override later,of course.
	 */
#define COPIED_SYMFLAGS	(BSF_FUNCTION|BSF_OBJECT \
			|BSF_GNU_INDIRECT_FUNCTION)
	dest->bsym->flags |= src->bsym->flags & COPIED_SYMFLAGS;
	OBJ_COPY_SYMBOL_ATTRIBUTES(dest,src);
}

static int	S_IS_FUNCTION(symbolS * s)
{				/* gas/symbols.c:2306 */
	return !s->flags.local_symbol &&
	(s->bsym->flags & BSF_FUNCTION) != 0;
}

static int	S_IS_EXTERNAL(symbolS * s)
{
	uint32_t	flags;

	if (s->flags.local_symbol)
		return 0;

	flags = s->bsym->flags;

	/* Sanity check.  */
	if ((flags & BSF_LOCAL) && (flags & BSF_GLOBAL))
		abort();

	return (flags & BSF_GLOBAL) != 0;
}

static int	S_IS_WEAK(symbolS * s)
{
	if (s->flags.local_symbol)
		return 0;
	/* Conceptually,a weakrefr is weak if the referenced symbol is.  We
	 * could probably handle a WEAKREFR as always weak though.  E.g.,if
	 * the referenced symbol has lost its weak status,there's no reason to
	 * keep handling the weakrefr as if it was weak.  */
	if (S_IS_WEAKREFR(s))
		return S_IS_WEAK(s->x->value.X_add_symbol);
	return (s->bsym->flags & BSF_WEAK) != 0;
}

static int	S_IS_WEAKREFR(symbolS * s)
{
	if (s->flags.local_symbol)
		return 0;
	return s->flags.weakrefr != 0;
}

static int	S_IS_WEAKREFD(symbolS * s)
{
	if (s->flags.local_symbol)
		return 0;
	return s->flags.weakrefd != 0;
}

static int	S_IS_COMMON(symbolS * s)
{
	if (s->flags.local_symbol)
		return 0;
	return bfd_is_com_section(s->bsym->section);
}

static int	S_IS_DEFINED(symbolS * s)
{
	if (s->flags.local_symbol)
		return ((struct local_symbol *)s)->section != undefined_section;
	return s->bsym->section != undefined_section;
}


#ifndef EXTERN_FORCE_RELOC
#define EXTERN_FORCE_RELOC IS_ELF
#endif

/* Return true for symbols that should not be reduced to section symbols or
 * eliminated from expressions,because they may be overridden by the linker.  */
static int	S_FORCE_RELOC(symbolS * s,int strict)
{
	segT		sec;
	if (s->flags.local_symbol)
		sec = ((struct local_symbol *)s)->section;
	else {
		if ((strict
		     && ((s->bsym->flags & BSF_WEAK) != 0
			 || (EXTERN_FORCE_RELOC
			     && (s->bsym->flags & BSF_GLOBAL) != 0)))
		    || (s->bsym->flags & BSF_GNU_INDIRECT_FUNCTION) != 0)
			return true;
		sec = s->bsym->section;
	}
	return bfd_is_und_section(sec) || bfd_is_com_section(sec);
}

static int	S_IS_DEBUG(symbolS * s)
{
	if (s->flags.local_symbol)
		return 0;
	if (s->bsym->flags & BSF_DEBUGGING)
		return 1;
	return 0;
}

static int	S_IS_LOCAL(symbolS * s)
{
	uint32_t	flags;
	const char     *name;

	if (s->flags.local_symbol)
		return 1;

	flags = s->bsym->flags;

	/* Sanity check.  */
	if ((flags & BSF_LOCAL) && (flags & BSF_GLOBAL))
		abort();

	if (bfd_asymbol_section(s->bsym) == reg_section)
		return 1;

	if (flag_strip_local_absolute
	/*
	 * Keep BSF_FILE symbols in order to allow debuggers to identify the
	 * source file even when the object file is stripped.
	 */
	    && (flags & (BSF_GLOBAL|BSF_FILE)) == 0
	    && bfd_asymbol_section(s->bsym) == absolute_section)
		return 1;

	name = S_GET_NAME(s);
	return (name != NULL
		&& !S_IS_DEBUG(s)
		&& (strchr(name,DOLLAR_LABEL_CHAR)
		    || strchr(name,LOCAL_LABEL_CHAR)
#if FAKE_LABEL_CHAR != DOLLAR_LABEL_CHAR
		    || strchr(name,FAKE_LABEL_CHAR)
#endif
		    || TC_LABEL_IS_LOCAL(name)
		    || (!flag_keep_locals
			&& (is_local_label(s->bsym)))));
}

static int	S_CAN_BE_REDEFINED(const symbolS * s)
{
	if (s->flags.local_symbol)
		return (((struct local_symbol *)s)->frag
			== &predefined_address_frag);
	/* Permit register names to be redefined.  */
	return s->x->value.X_op == O_register;
}

static int	S_IS_VOLATILE(const symbolS * s)
{
	if (s->flags.local_symbol)
		return 0;
	return s->flags.volatil;
}

static int	S_IS_FORWARD_REF(const symbolS * s)
{
	if (s->flags.local_symbol)
		return 0;
	return s->flags.forward_ref;
}

static const char *S_GET_NAME(symbolS * s)
{
	return s->name;
}

static segT	S_GET_SEGMENT(symbolS * s)
{
	if (s->flags.local_symbol)
		return ((struct local_symbol *)s)->section;
	return s->bsym->section;
}

static void	S_SET_SEGMENT(symbolS * s,segT seg)
{
	if (s->flags.local_symbol) {
		((struct local_symbol *)s)->section = seg;
		return;
	}
	/*
	 * Don't reassign section symbols.  The direct reason is to prevent seg
	 * faults assigning back to const global symbols such as *ABS*,but it
	 * shouldn't happen anyway.
	 */
	if (s->bsym->flags & BSF_SECTION_SYM) {
		if (s->bsym->section != seg)
			abort();
	} else {
		if (multibyte_handling == multibyte_warn_syms
		    && !s->flags.local_symbol
		    && seg != undefined_section
		    && !s->flags.multibyte_warned
		    && scan_for_multibyte_characters((const unsigned char *)s->name,
			     (const unsigned char *)s->name + strlen(s->name),
						     false)) {
			as_warn(("symbol '%s' contains multibyte characters"),s->name);
			s->flags.multibyte_warned = 1;
		}
		s->bsym->section = seg;
	}
}

static void	S_SET_EXTERNAL(symbolS * s)
{
	if (s->flags.local_symbol)
		s = local_symbol_convert(s);
	if ((s->bsym->flags & BSF_WEAK) != 0) {
		/* Let .weak override .global.  */
		return;
	}
	if (s->bsym->flags & BSF_SECTION_SYM) {
		/* Do not reassign section symbols.  */
		as_warn(("can't make section symbol global"));
		return;
	}
	if (S_GET_SEGMENT(s) == reg_section) {
		as_bad(("can't make register symbol global"));
		return;
	}
	s->bsym->flags |= BSF_GLOBAL;
	s->bsym->flags &= ~(BSF_LOCAL|BSF_WEAK);

}

static void	S_CLEAR_EXTERNAL(symbolS * s)
{
	if (s->flags.local_symbol)
		return;
	if ((s->bsym->flags & BSF_WEAK) != 0) {
		/* Let .weak override.  */
		return;
	}
	s->bsym->flags |= BSF_LOCAL;
	s->bsym->flags &= ~(BSF_GLOBAL|BSF_WEAK);
}

static void	S_SET_WEAK(symbolS * s)
{
	if (s->flags.local_symbol)
		s = local_symbol_convert(s);
	s->bsym->flags |= BSF_WEAK;
	s->bsym->flags &= ~(BSF_GLOBAL|BSF_LOCAL);
}

static void	S_SET_WEAKREFR(symbolS * s)
{
	if (s->flags.local_symbol)
		s = local_symbol_convert(s);
	s->flags.weakrefr = 1;
	/*
	 * If the alias was already used,make sure we mark the target as used
	 * as well,otherwise it might be dropped from the symbol table.  This
	 * may have unintended side effects if the alias is later redirected to
	 * another symbol,such as keeping the unused previous target in the
	 * symbol table.  Since it will be weak,it's not a big deal.
	 */
	if (s->flags.used)
		symbol_mark_used(s->x->value.X_add_symbol);
}

static void	S_CLEAR_WEAKREFR(symbolS * s)
{
	if (s->flags.local_symbol)
		return;
	s->flags.weakrefr = 0;
}

static void	S_SET_WEAKREFD(symbolS * s)
{
	if (s->flags.local_symbol)
		s = local_symbol_convert(s);
	s->flags.weakrefd = 1;
	S_SET_WEAK(s);
}

static void	S_CLEAR_WEAKREFD(symbolS * s)
{
	if (s->flags.local_symbol)
		return;
	if (s->flags.weakrefd) {
		s->flags.weakrefd = 0;
		/*
		 * If a weakref target symbol is weak,then it was never
		 * referenced directly before,not even in a .global directive,
		 * so decay it to local.  If it remains undefined,it will be
		 * later turned into a global,like any other undefined symbol.
		 */
		if (s->bsym->flags & BSF_WEAK) {
			s->bsym->flags &= ~BSF_WEAK;
			s->bsym->flags |= BSF_LOCAL;
		}
	}
}

static void	S_SET_THREAD_LOCAL(symbolS * s)
{
	if (s->flags.local_symbol)
		s = local_symbol_convert(s);
	if (bfd_is_com_section(s->bsym->section)
	    && (s->bsym->flags & BSF_THREAD_LOCAL) != 0)
		return;
	s->bsym->flags |= BSF_THREAD_LOCAL;
	if ((s->bsym->flags & BSF_FUNCTION) != 0)
		as_bad(("Accessing function `%s' as thread-local object"),
		       S_GET_NAME(s));
	else
		if (!bfd_is_und_section(s->bsym->section)
		    && (s->bsym->section->flags & SEC_THREAD_LOCAL) == 0)
			as_bad(("Accessing `%s' as thread-local object"),
			       S_GET_NAME(s));
}

static void	S_SET_NAME(symbolS * s,const char *name)
{
	s->name = name;
	if (s->flags.local_symbol)
		return;
	s->bsym->name = name;
}

static void	S_SET_VOLATILE(symbolS * s)
{
	if (s->flags.local_symbol)
		s = local_symbol_convert(s);
	s->flags.volatil = 1;
}

static void	S_CLEAR_VOLATILE(symbolS * s)
{
	if (!s->flags.local_symbol)
		s->flags.volatil = 0;
}

static void	S_SET_FORWARD_REF(symbolS * s)
{
	if (s->flags.local_symbol)
		s = local_symbol_convert(s);
	s->flags.forward_ref = 1;
}

/* Return the next symbol in a chain.  */
static symbolS *symbol_next(symbolS * s)
{
	if (s->flags.local_symbol)
		abort();
	return s->x->next;
}

/* Return a pointer to the value of a symbol as an expression.  */
static expressionS *symbol_get_value_expression(symbolS * s)
{
	if (s->flags.local_symbol)
		s = local_symbol_convert(s);
	return &s->x->value;
}

/* Set the value of a symbol to an expression.  */
static void	symbol_set_value_expression(symbolS * s,const expressionS * exp)
{
	if (s->flags.local_symbol)
		s = local_symbol_convert(s);
	s->x->value = *exp;
	S_CLEAR_WEAKREFR(s);
}

/* Return whether 2 symbols are the same.  */
static int	symbol_same_p(symbolS * s1,symbolS * s2)
{
	return s1 == s2;
}

/* Return a pointer to the X_add_number component of a symbol.  */
static offsetT *symbol_X_add_number(symbolS * s)
{
	if (s->flags.local_symbol)
		return (offsetT *) & ((struct local_symbol *)s)->value;

	return &s->x->value.X_add_number;
}

/* Set the value of SYM to the current position in the current segment.  */
static void	symbol_set_value_now(symbolS * sym)
{
	S_SET_SEGMENT(sym,now_seg);
	S_SET_VALUE(sym,frag_now_fix());
	symbol_set_frag(sym,frag_now);
}

/* Set the frag of a symbol.  */
static void	symbol_set_frag(symbolS * s,fragS * f)
{
	if (s->flags.local_symbol) {
		((struct local_symbol *)s)->frag = f;
		return;
	}
	s->frag = f;
	S_CLEAR_WEAKREFR(s);
}

/* Return the frag of a symbol.  */
static fragS   *symbol_get_frag(symbolS * s)
{
	if (s->flags.local_symbol)
		return ((struct local_symbol *)s)->frag;
	return s->frag;
}

/* Mark a symbol as having been used.  */
static void	symbol_mark_used(symbolS * s)
{
	if (s->flags.local_symbol)
		return;
	s->flags.used = 1;
	if (S_IS_WEAKREFR(s))
		symbol_mark_used(s->x->value.X_add_symbol);
}

/* Return whether a symbol has been used.  */
static int	symbol_used_p(symbolS * s)
{
	if (s->flags.local_symbol)
		return 1;
	return s->flags.used;
}

/* Mark a symbol as having been used in a reloc.  */
static void	symbol_mark_used_in_reloc(symbolS * s)
{
	if (s->flags.local_symbol)
		s = local_symbol_convert(s);
	s->flags.used_in_reloc = 1;
}

/* Return whether a symbol has been used in a reloc.  */
static int	symbol_used_in_reloc_p(symbolS * s)
{
	if (s->flags.local_symbol)
		return 0;
	return s->flags.used_in_reloc;
}

/* Mark a symbol as having been written.  */
static void	symbol_mark_written(symbolS * s)
{
	if (s->flags.local_symbol)
		return;
	s->flags.written = 1;
}

/* Mark a symbol as to be removed.  */
static void	symbol_mark_removed(symbolS * s)
{
	if (s->flags.local_symbol)
		return;
	s->flags.removed = 1;
}

/* Return whether a symbol has been marked to be removed.  */
static int	symbol_removed_p(symbolS * s)
{
	if (s->flags.local_symbol)
		return 0;
	return s->flags.removed;
}

/* Mark a symbol has having been resolved.  */
static void	symbol_mark_resolved(symbolS * s)
{
	s->flags.resolved = 1;
}

/* Return whether a symbol has been resolved.  */
static int	symbol_resolved_p(symbolS * s)
{
	return s->flags.resolved;
}

/* Return whether a symbol is a section symbol.  */
static int	symbol_section_p(symbolS * s)
{
	if (s->flags.local_symbol)
		return 0;
	return (s->bsym->flags & BSF_SECTION_SYM) != 0;
}

/* Return whether a symbol is equated to another symbol.  */
static int	symbol_equated_p(symbolS * s)
{
	if (s->flags.local_symbol)
		return 0;
	return s->x->value.X_op == O_symbol;
}

/* Return whether a symbol is equated to another symbol,and should be treated
 * specially when writing out relocs.  */
static int	symbol_equated_reloc_p(symbolS * s)
{
	if (s->flags.local_symbol)
		return 0;
	/*
	 * X_op_symbol,normally not used for O_symbol,is set by
	 * resolve_symbol_value to flag expression syms that have been equated.
	 */
	return (s->x->value.X_op == O_symbol
		&& ((s->flags.resolved && s->x->value.X_op_symbol != NULL)
		    || !S_IS_DEFINED(s)
		    || S_IS_COMMON(s)));
}

/* Return whether a symbol has a constant value.  */
static int	symbol_constant_p(symbolS * s)
{
	if (s->flags.local_symbol)
		return 1;
	return s->x->value.X_op == O_constant;
}

/* Return whether a symbol was cloned and thus removed from the global symbol
 * list.  */
static int	symbol_shadow_p(symbolS * s)
{
	if (s->flags.local_symbol)
		return 0;
	return s->x->next == s;
}

/* If S is a struct symbol return S,otherwise return NULL.  */
static symbolS *symbol_symbolS(symbolS * s)
{
	if (s->flags.local_symbol)
		return NULL;
	return s;
}

/* Return the BFD symbol for a symbol.  */
static asymbol *symbol_get_bfdsym(symbolS * s)
{
	if (s->flags.local_symbol)
		s = local_symbol_convert(s);
	return s->bsym;
}

/* Set the BFD symbol for a symbol.  */
static void	symbol_set_bfdsym(symbolS * s,asymbol * bsym)
{
	if (s->flags.local_symbol)
		s = local_symbol_convert(s);
	/*
	 * Usually,it is harmless to reset a symbol to a BFD section symbol.
	 * For example,obj_elf_change_section sets the BFD symbol of an old
	 * symbol with the newly created section symbol. But when we have
	 * multiple sections with the same name,the newly created section may
	 * have the same name as an old section. We check if the old symbol has
	 * been already marked as a section symbol before resetting it.
	 */
	if ((s->bsym->flags & BSF_SECTION_SYM) == 0)
		s->bsym = bsym;
	/* else XXX - What do we do now ?  */
}

/* Get a pointer to the object format information for a symbol.  */
static OBJ_SYMFIELD_TYPE *symbol_get_obj(symbolS * s)
{
	if (s->flags.local_symbol)
		s = local_symbol_convert(s);
	return &s->x->obj;
}

static void	symbol_begin(void)
{
	symbol_lastP = NULL;
	symbol_rootP = NULL;	/* In case we have 0 symbols (!!)  */
	sy_hash = htab_create_alloc(16,hash_symbol_entry,eq_symbol_entry,
				    NULL,xcalloc,free);

	abs_symbol.bsym = bfd_abs_section_ptr->symbol;
	abs_symbol.x = &abs_symbol_x;
	abs_symbol.x->value.X_op = O_constant;
	abs_symbol.frag = &zero_address_frag;

}

static void	dot_symbol_init(void)
{
	dot_symbol.name = ".";
	dot_symbol.flags.forward_ref = 1;
	dot_symbol.bsym = elf_make_empty_symbol(stdoutput);
	if (dot_symbol.bsym == NULL)
		as_fatal("elf_make_empty_symbol: %s",bfd_errmsg(bfd_get_error()));
	dot_symbol.bsym->name = ".";
	dot_symbol.x = &dot_symbol_x;
	dot_symbol.x->value.X_op = O_constant;
}

/* ============================================================* write.c */
/*
 * write.c - emit .o file This thing should be set up to do byte ordering
 * correctly.  But...  */

#define TC_FORCE_RELOCATION(FIX) (generic_force_reloc (FIX))

#ifndef TC_FORCE_RELOCATION_ABS
#define TC_FORCE_RELOCATION_ABS(FIX)		\
  (TC_FORCE_RELOCATION (FIX))
#endif

#define GENERIC_FORCE_RELOCATION_LOCAL(FIX)	\
  (!(FIX)->fx_pcrel				\
   || TC_FORCE_RELOCATION (FIX))
#ifndef TC_FORCE_RELOCATION_LOCAL
#define TC_FORCE_RELOCATION_LOCAL GENERIC_FORCE_RELOCATION_LOCAL
#endif

#define GENERIC_FORCE_RELOCATION_SUB_SAME(FIX,SEG)	\
  (!SEG_NORMAL (SEG))
#ifndef TC_FORCE_RELOCATION_SUB_SAME
#define TC_FORCE_RELOCATION_SUB_SAME GENERIC_FORCE_RELOCATION_SUB_SAME
#endif

#ifndef md_register_arithmetic
#define md_register_arithmetic 1
#endif

#ifndef TC_FORCE_RELOCATION_SUB_ABS
#define TC_FORCE_RELOCATION_SUB_ABS(FIX,SEG)	\
  (!md_register_arithmetic && (SEG) == reg_section)
#endif

#ifndef TC_FORCE_RELOCATION_SUB_LOCAL
#ifdef DIFF_EXPR_OK
#define TC_FORCE_RELOCATION_SUB_LOCAL(FIX,SEG)	\
  (!md_register_arithmetic && (SEG) == reg_section)
#else
#define TC_FORCE_RELOCATION_SUB_LOCAL(FIX,SEG)	1
#endif
#endif

#ifndef TC_VALIDATE_FIX_SUB
#define TC_VALIDATE_FIX_SUB(FIX,SEG) 0
#endif

#ifndef TC_LINKRELAX_FIXUP
#define TC_LINKRELAX_FIXUP(SEG) 1
#endif

#ifndef MD_APPLY_SYM_VALUE
#define MD_APPLY_SYM_VALUE(FIX) 1
#endif

#ifndef TC_FINALIZE_SYMS_BEFORE_SIZE_SEG
#define TC_FINALIZE_SYMS_BEFORE_SIZE_SEG 1
#endif

#ifndef	MD_PCREL_FROM_SECTION
#define MD_PCREL_FROM_SECTION(FIX,SEC) md_pcrel_from (FIX)
#endif

#ifndef TC_FAKE_LABEL
#define TC_FAKE_LABEL(NAME) (strcmp ((NAME),FAKE_LABEL_NAME) == 0)
#endif

/* Positive values of TC_FX_SIZE_SLACK allow a target to define fixups that far
 * past the end of a frag.  Having such fixups is of course most most likely a
 * bug in setting fx_size correctly. A negative value disables the fixup check
 * entirely,which is appropriate for something like the Renesas / SuperH
 * SH_COUNT reloc.  */
#ifndef TC_FX_SIZE_SLACK
#define TC_FX_SIZE_SLACK(FIX) 0
#endif

static symbolS *abs_section_sym;
/* Remember the value of dot when parsing expressions.  */
static addressT	dot_value;
/* The frag that dot_value is based from.  */
static fragS   *dot_frag;
/* Relocs generated by ".reloc" pseudo.  */
static struct reloc_list *reloc_list;

/* We generally attach relocs to frag chains.  However,after we have chained
 * these all together into a segment,any relocs we add after that must be
 * attached to a segment.  This will include relocs added in
 * md_estimate_size_before_relax,for example.  */
static bool	frags_chained = false;
static unsigned int n_fixups;

#define RELOC_ENUM enum bfd_reloc_code_real
/* Create a fixS in obstack 'notes'.  */
static fixS    *fix_new_internal(fragS * frag,	/* Which frag?  */
				 		unsigned	long	where,	/* Where in that frag?  */
				 		unsigned	long	size,	/* 1,2,or 4 usually.  */
				 		symbolS *	add_symbol,	/* X_add_symbol.  */
				 		symbolS *	sub_symbol,	/* X_op_symbol.  */
				 		offsetT	offset,	/* X_add_number.  */
				 		int		pcrel   ,	/* TRUE if PC-relative
										 * relocation.  */
	       		RELOC_ENUM	r_type /* Relocation type.  */ ,
				 		int		at_beginning)
{				/* Add to the start of the list?  */
	fixS           *fixP;

	n_fixups++;

	fixP = (fixS *) obstack_alloc(&notes,sizeof(fixS));

	fixP->fx_frag = frag;
	fixP->fx_where = where;
	fixP->fx_size = size;
	/* We've made fx_size a narrow field; check that it's wide enough.  */
	if (fixP->fx_size != size) {
		as_bad(("field fx_size too small to hold %lu"),size);
		abort();
	}
	fixP->fx_addsy = add_symbol;
	fixP->fx_subsy = sub_symbol;
	fixP->fx_offset = offset;
	fixP->fx_dot_value = dot_value;
	fixP->fx_dot_frag = dot_frag;
	fixP->fx_pcrel = pcrel;
	fixP->fx_r_type = r_type;
	fixP->fx_pcrel_adjust = 0;
	fixP->fx_addnumber = 0;
	fixP->fx_tcbit = 0;
	fixP->fx_tcbit2 = 0;
	fixP->fx_done = 0;
	fixP->fx_no_overflow = 0;
	fixP->fx_signed = 0;

	fixP->fx_file = as_where(&fixP->fx_line);
	{
		fixS          **seg_fix_rootP = (frags_chained
						 ? &seg_info(now_seg)->fix_root
						 : &frchain_now->fix_root);
		fixS          **seg_fix_tailP = (frags_chained
						 ? &seg_info(now_seg)->fix_tail
						 : &frchain_now->fix_tail);

		if (at_beginning) {
			fixP->fx_next = *seg_fix_rootP;
			*seg_fix_rootP = fixP;
			if (fixP->fx_next == NULL)
				*seg_fix_tailP = fixP;
		} else {
			fixP->fx_next = NULL;
			if (*seg_fix_tailP)
				(*seg_fix_tailP)->fx_next = fixP;
			else
				*seg_fix_rootP = fixP;
			*seg_fix_tailP = fixP;
		}
	}
	return fixP;
}

/* Create a fixup relative to a symbol (plus a constant).  */
static fixS    *fix_new(fragS * frag,	/* Which frag?  */
					unsigned	long	where,	/* Where in that frag?  */
					unsigned	long	size,	/* 1,2,or 4 usually.  */
					symbolS *	add_symbol,	/* X_add_symbol.  */
					offsetT	offset,	/* X_add_number.  */
					int		pcrel   ,	/* TRUE if PC-relative
									 * relocation.  */
	      		RELOC_ENUM	r_type /* Relocation type.  */ )
{
	return fix_new_internal(frag,where,size,add_symbol,
			      (symbolS *) NULL,offset,pcrel,r_type,false);
}

/* Create a fixup for an expression.  Currently we only support fixups for
 * difference expressions.  That is itself more than most object file formats
 * support anyhow.  */
static fixS    *fix_new_exp(fragS * frag,	/* Which frag?  */
			    		unsigned	long	where,	/* Where in that frag?  */
			    		unsigned	long	size,	/* 1,2,or 4 usually.  */
			    		expressionS *	exp,	/* Expression.  */
			    		int		pcrel   ,	/* TRUE if PC-relative
									 * relocation.  */
		  		RELOC_ENUM	r_type /* Relocation type.  */ )
{
	symbolS        *add = NULL;
	symbolS        *sub = NULL;
	offsetT		off = 0;

	switch (exp->X_op) {
	case O_absent:
		break;

	case O_register:
		as_bad(("register value used as expression"));
		break;

	case O_add:
		/* This comes up when _GLOBAL_OFFSET_TABLE_+(.-L0) is read,if
		 * the difference expression cannot immediately be reduced.  */
		{
			symbolS        *stmp = make_expr_symbol(exp);

			exp->X_op = O_symbol;
			exp->X_op_symbol = 0;
			exp->X_add_symbol = stmp;
			exp->X_add_number = 0;

			return fix_new_exp(frag,where,size,exp,pcrel,r_type);
		}

	case O_symbol_rva:
		add = exp->X_add_symbol;
		off = exp->X_add_number;
		r_type = BFD_RELOC_RVA;
		break;

	case O_uminus:
		sub = exp->X_add_symbol;
		off = exp->X_add_number;
		break;

	case O_subtract:
		sub = exp->X_op_symbol;
		/* Fall through.  */
	case O_symbol:
		add = exp->X_add_symbol;
		/* Fall through.  */
	case O_constant:
		off = exp->X_add_number;
		break;

	default:
		add = make_expr_symbol(exp);
		break;
	}

	return fix_new_internal(frag,where,size,add,sub,off,pcrel, r_type,false);
}

/* Generic function to determine whether a fixup requires a relocation.  */
static int	generic_force_reloc(fixS * fix)
{
	if (fix->fx_r_type == BFD_RELOC_VTABLE_INHERIT
	    || fix->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
		return 1;

	if (fix->fx_addsy == NULL)
		return 0;

	return S_FORCE_RELOC(fix->fx_addsy,fix->fx_subsy == NULL);
}

/* This routine records the largest alignment seen for each segment. If the
 * beginning of the segment is aligned on the worst-case boundary,all of the
 * other alignments within it will work.  At least one object format really
 * uses this info.  */
static void	record_alignment(	/* Segment to which alignment pertains.  */
			     		segT		seg    ,
/* Alignment,as a power of 2 (e.g.,1 => 2-byte boundary,2 => 4-byte
 * boundary,etc.) */
			     		unsigned	int	align)
{
	if (seg == absolute_section)
		return;

	if (align > seg->alignment_power)
		seg->alignment_power = align;
}

static int	get_recorded_alignment(segT seg)
{
	return (seg == absolute_section)? 0 : seg->alignment_power;
}

/* Reset the section indices after removing the gas created sections.  */
static void	renumber_sections(asection * sec,void *countparg)
{
	int            *countp = (int *)countparg;

	sec->index = *countp;
	++*countp;
}

static fragS   *chain_frchains_together_1(segT section,struct frchain *frchp)
{
	fragS		dummy   ,*prev_frag = &dummy;
	fixS		fix_dummy,*prev_fix = &fix_dummy;

	do {
		prev_frag->fr_next = frchp->frch_root;
		prev_frag = frchp->frch_last;
		gas_assert(prev_frag->fr_type != 0);
		if (frchp->fix_root != (fixS *) NULL) {
			if (seg_info(section)->fix_root == (fixS *) NULL)
				seg_info(section)->fix_root = frchp->fix_root;
			prev_fix->fx_next = frchp->fix_root;
			seg_info(section)->fix_tail = frchp->fix_tail;
			prev_fix = frchp->fix_tail;
		}
		frchp = frchp->frch_next;
	} while (frchp);
	gas_assert(prev_frag != &dummy
		   && prev_frag->fr_type != 0);
	prev_frag->fr_next = 0;
	return prev_frag;
}

static void	chain_frchains_together(segT section,void *xxx ATTRIBUTE_UNUSED)
{
	segment_info_type *info;

	/* BFD may have introduced its own sections without using subseg_new,
	 * so it is possible that seg_info is NULL.  */
	info = seg_info(section);
	if (info != NULL)
		info->frchainP->frch_last
			= chain_frchains_together_1(section,info->frchainP);

	/* Now that we've chained the frags together,we must add new fixups to
	 * the segment,not to the frag chain.  */
	frags_chained = true;
}

static void	cvt_frag_to_fill(segT sec ATTRIBUTE_UNUSED,fragS * fragP)
{
	switch (fragP->fr_type) {
	case rs_space_nop:
		goto skip_align;
	case rs_align: case rs_align_code: case rs_align_test:
	case rs_org: case rs_space:
		HANDLE_ALIGN(fragP);
skip_align:
		know(fragP->fr_next != NULL);
		fragP->fr_offset = (fragP->fr_next->fr_address
				    - fragP->fr_address
				    - fragP->fr_fix) / fragP->fr_var;
		if (fragP->fr_offset < 0) {
			as_bad_where(fragP->fr_file,fragP->fr_line,
			    ("attempt to .org/.space/.nops backwards? (%ld)"),
				     (long)fragP->fr_offset);
			fragP->fr_offset = 0;
		}
		if (fragP->fr_type == rs_space_nop)
			fragP->fr_type = rs_fill_nop;
		else
			fragP->fr_type = rs_fill;
		break;

	case rs_fill: case rs_fill_nop: break;
	case rs_leb128:
		{
			valueT		value = S_GET_VALUE(fragP->fr_symbol);
			int		size;

			if (!S_IS_DEFINED(fragP->fr_symbol)) {
				as_bad_where(fragP->fr_file,fragP->fr_line,
				("leb128 operand is an undefined symbol: %s"),
					     S_GET_NAME(fragP->fr_symbol));
			}
			size = output_leb128(fragP->fr_literal + fragP->fr_fix,value,
					     fragP->fr_subtype);

			fragP->fr_fix += size;
			fragP->fr_type = rs_fill;
			fragP->fr_var = 0;
			fragP->fr_offset = 0;
			fragP->fr_symbol = NULL;
		}
		break;

	case rs_cfa:
		eh_frame_convert_frag(fragP);
		break;

	case rs_dwarf2dbg:
		dwarf2dbg_convert_frag(fragP);
		break;

	case rs_sframe:
		as_bad("s frames aren't supported\n");
		break;

	case rs_machine_dependent:
		md_convert_frag(stdoutput,sec,fragP);

		gas_assert(fragP->fr_next == NULL
			   || (fragP->fr_next->fr_address - fragP->fr_address
			       == fragP->fr_fix));

		/* After md_convert_frag,we make the frag into a ".space 0".
		 * md_convert_frag() should set up any fixSs and constants
		 * required.  */
		frag_wane(fragP);
		break;

	default:
		BAD_CASE(fragP->fr_type);
		break;
	}
}

struct relax_seg_info { int	pass; int	changed; };

static void	relax_seg(asection * sec,void *xxx)
{
	segment_info_type *seginfo = seg_info(sec);
	struct relax_seg_info *info = (struct relax_seg_info *)xxx;

	if (seginfo && seginfo->frchainP
	    && relax_segment(seginfo->frchainP->frch_root,sec,info->pass))
		info->changed = 1;
}

static void	size_seg(asection * sec,void *xxx ATTRIBUTE_UNUSED)
{
	uint32_t	flags;
	fragS          *fragp;
	segment_info_type *seginfo;
	int		x;
	valueT		size   ,newsize;

	subseg_change(sec,0);

	seginfo = seg_info(sec);
	if (seginfo && seginfo->frchainP) {
		for (fragp = seginfo->frchainP->frch_root; fragp; fragp = fragp->fr_next)
			cvt_frag_to_fill(sec,fragp);
		for (fragp = seginfo->frchainP->frch_root;
		     fragp->fr_next;
		     fragp = fragp->fr_next)
			/* Walk to last elt.  */
			;
		size = fragp->fr_address + fragp->fr_fix;
	} else
		size = 0;

	flags = sec->flags;
	if (size == 0 && bfd_section_size(sec) != 0 &&
	    (flags & SEC_HAS_CONTENTS) != 0)
		return;

	if (size > 0 && !seginfo->bss)
		flags |= SEC_HAS_CONTENTS;

	sec->flags = flags;

	/* If permitted,allow the backend to pad out the section to some
	 * alignment boundary.  */
	if (do_not_pad_sections_to_alignment)
		newsize = size;
	else
		newsize = md_section_align(sec,size);
	x = set_section_size(sec,newsize);
	gas_assert(x);

	/* If the size had to be rounded up,add some padding in the last
	 * non-empty frag.  */
	gas_assert(newsize >= size);
	if (size != newsize) {
		fragS          *last = seginfo->frchainP->frch_last;
		fragp = seginfo->frchainP->frch_root;
		while (fragp->fr_next != last)
			fragp = fragp->fr_next;
		last->fr_address = size;
		if ((newsize - size) % fragp->fr_var == 0)
			fragp->fr_offset += (newsize - size) / fragp->fr_var;
		else
			/* If we hit this abort,it's likely due to
			 * subsegs_finish not providing sufficient alignment on
			 * the last frag,and the machine dependent code using
			 * alignment frags with fr_var greater than 1.  */
			abort();
	}
}

#ifdef DEBUG2
static void	dump_section_relocs(bfd * abfd ATTRIBUTE_UNUSED,asection * sec,FILE * stream)
{
	segment_info_type *seginfo = seg_info(sec);
	fixS           *fixp = seginfo->fix_root;

	if (!fixp)
		return;

	fprintf(stream,"sec %s relocs:\n",sec->name);
	while (fixp) {
		symbolS        *s = fixp->fx_addsy;

		fprintf(stream,"  %08lx: type %d ",(unsigned long)fixp,
			(int)fixp->fx_r_type);
		if (s == NULL)
			fprintf(stream,"no sym\n");
		else {
			print_symbol_value_1(stream,s);
			fprintf(stream,"\n");
		}
		fixp = fixp->fx_next;
	}
}
#else
#define dump_section_relocs(ABFD,SEC,STREAM)	((void) 0)
#endif

#ifndef EMIT_SECTION_SYMBOLS
#define EMIT_SECTION_SYMBOLS 1
#endif

/* Resolve U.A.OFFSET_SYM and U.A.SYM fields of RELOC_LIST entries,and check
 * for validity.  Convert RELOC_LIST from using U.A fields to U.B fields.  */
static void	resolve_reloc_expr_symbols(void)
{
	bfd_vma		addr_mask = 1;
	struct reloc_list *r;

	/* Avoid a shift by the width of type.  */
	addr_mask <<= 64 - 1;
	addr_mask <<= 1;
	addr_mask -= 1;

	for (r = reloc_list; r; r = r->next) {
		reloc_howto_type *howto = r->u.a.howto;
		expressionS    *symval;
		symbolS        *sym;
		bfd_vma		offset,addend;
		asection       *sec;

		resolve_symbol_value(r->u.a.offset_sym);
		symval = symbol_get_value_expression(r->u.a.offset_sym);

		offset = 0;
		sym = NULL;
		if (symval->X_op == O_constant)
			sym = r->u.a.offset_sym;
		else
			if (symval->X_op == O_symbol) {
				sym = symval->X_add_symbol;
				offset = symval->X_add_number;
				symval = symbol_get_value_expression(symval->X_add_symbol);
			}
		if (sym == NULL
		    || symval->X_op != O_constant
		    || (sec = S_GET_SEGMENT(sym)) == NULL
		    || !SEG_NORMAL(sec)) {
			as_bad_where(r->file,r->line,("invalid offset expression"));
			sec = NULL;
		} else
			offset += S_GET_VALUE(sym);

		sym = NULL;
		addend = r->u.a.addend;
		if (r->u.a.sym != NULL) {
			resolve_symbol_value(r->u.a.sym);
			symval = symbol_get_value_expression(r->u.a.sym);
			if (symval->X_op == O_constant)
				sym = r->u.a.sym;
			else
				if (symval->X_op == O_symbol) {
					sym = symval->X_add_symbol;
					addend += symval->X_add_number;
					symval = symbol_get_value_expression(symval->X_add_symbol);
				}
			if (symval->X_op != O_constant) {
				as_bad_where(r->file,r->line,("invalid reloc expression"));
				sec = NULL;
			} else
				if (sym != NULL && sec != NULL) {
				/* Convert relocs against local symbols to refer to the corresponding
				 * section symbol plus offset instead. Keep PC-relative relocs of the REL
				 * variety intact though to prevent the offset from overflowing the
				 * relocated field,unless it has enough bits to cover the whole
				 * address space.  */
					if (S_IS_LOCAL(sym)
					    && S_IS_DEFINED(sym)
					    && !symbol_section_p(sym)
					    && (sec->use_rela_p
						|| (howto->partial_inplace
						    && (!howto->pc_relative
					 || howto->src_mask == addr_mask)))) {
						asection       *symsec = S_GET_SEGMENT(sym);
						if (!(((symsec->flags & SEC_MERGE) != 0
						       && addend != 0)
						      || (symsec->flags & SEC_THREAD_LOCAL) != 0)) {
							addend += S_GET_VALUE(sym);
							sym = section_symbol(symsec);
						}
					}
					symbol_mark_used_in_reloc(sym);
				}
		}
		if (sym == NULL) {
			if (abs_section_sym == NULL)
				abs_section_sym = section_symbol(absolute_section);
			sym = abs_section_sym;
		}
		r->u.b.sec = sec;
		r->u.b.s = symbol_get_bfdsym(sym);
		r->u.b.r.sym_ptr_ptr = &r->u.b.s;
		r->u.b.r.address = offset;
		r->u.b.r.addend = addend;
		r->u.b.r.howto = howto;
	}
}

/* This pass over fixups decides whether symbols can be replaced with section
 * symbols.  */
static void	adjust_reloc_syms(asection * sec,void *xxx ATTRIBUTE_UNUSED)
{
	segment_info_type *seginfo = seg_info(sec);
	fixS           *fixp;

	if (seginfo == NULL)
		return;

	dump_section_relocs(abfd,sec,stderr);

	for (fixp = seginfo->fix_root; fixp; fixp = fixp->fx_next)
		if (fixp->fx_done)
			/* Ignore it.  */
			;
		else
			if (fixp->fx_addsy) {
				symbolS        *sym;
				asection       *symsec;

#ifdef DEBUG5
				fprintf(stderr,"\n\nadjusting fixup:\n");
				print_fixup(fixp);
#endif

				sym = fixp->fx_addsy;

				/* All symbols should have already been
				 * resolved at this point.  It is possible to
				 * see unresolved expression symbols,though,
				 * since they are not in the regular symbol
				 * table.  */
				resolve_symbol_value(sym);

				if (fixp->fx_subsy != NULL)
					resolve_symbol_value(fixp->fx_subsy);

				/* If this symbol is equated to an undefined or
				 * common symbol,convert the fixup to being
				 * against that symbol.  */
				while (symbol_equated_reloc_p(sym)
				       || S_IS_WEAKREFR(sym)) {
					symbolS        *newsym = symbol_get_value_expression(sym)->X_add_symbol;
					if (sym == newsym)
						break;
					fixp->fx_offset += symbol_get_value_expression(sym)->X_add_number;
					fixp->fx_addsy = newsym;
					sym = newsym;
				}

				/* If the symbol is undefined,common,weak,or
				 * global (ELF shared libs),we can't replace
				 * it with the section symbol.  */
				if (S_FORCE_RELOC(fixp->fx_addsy,1))
					continue;

				/* Is there some other (target cpu dependent)
				 * reason we can't adjust this one?  (E.g.
				 * relocations involving function addresses on
				 * the PA.  */
				if (!tc_fix_adjustable(fixp))
					continue;

				/* Since we're reducing to section symbols,
				 * don't attempt to reduce anything that's
				 * already using one.  */
				if (symbol_section_p(sym)) {
					/* Mark the section symbol used in
					 * relocation so that it will be
					 * included in the symbol table.  */
					symbol_mark_used_in_reloc(sym);
					continue;
				}
				symsec = S_GET_SEGMENT(sym);
				if (symsec == NULL)
					abort();

				if (bfd_is_abs_section(symsec)
				    || symsec == reg_section) {
					/* The fixup_segment routine normally
					 * will not use this symbol in a
					 * relocation.  */
					continue;
				}
				/* Don't try to reduce relocs which refer to
				 * non-local symbols in .linkonce sections.  It
				 * can lead to confusion when a debugging
				 * section refers to a .linkonce section.  I
				 * hope this will always be correct.  */
				if (symsec != sec && !S_IS_LOCAL(sym)) {
					if ((symsec->flags & SEC_LINK_ONCE) != 0
					    || (IS_ELF
					/* The GNU toolchain uses an extension
					 * for ELF: a section beginning with
					 * the magic string .gnu.linkonce is a
					 * linkonce section.  */
						&& startswith(segment_name(symsec),".gnu.linkonce")))
						continue;
				}
				/* Never adjust a reloc against local symbol in
				 * a merge section with non-zero addend.  */
				if ((symsec->flags & SEC_MERGE) != 0
				    && (fixp->fx_offset != 0 || fixp->fx_subsy != NULL))
					continue;

				/* Never adjust a reloc against TLS local
				 * symbol.  */
				if ((symsec->flags & SEC_THREAD_LOCAL) != 0)
					continue;

				/* We refetch the segment when calling
				 * section_symbol,rather than using symsec,
				 * because S_GET_VALUE may wind up changing the
				 * section when it calls resolve_symbol_value.  */
				fixp->fx_offset += S_GET_VALUE(sym);
				fixp->fx_addsy = section_symbol(S_GET_SEGMENT(sym));
#ifdef DEBUG5
				fprintf(stderr,"\nadjusted fixup:\n");
				print_fixup(fixp);
#endif
			}
	dump_section_relocs(abfd,sec,stderr);
}

static void	as_bad_subtract(fixS * fixp)
{
	as_bad_where(fixp->fx_file,fixp->fx_line,
		     ("can't resolve %s - %s"),
		     fixp->fx_addsy ? S_GET_NAME(fixp->fx_addsy) : "0",
		     S_GET_NAME(fixp->fx_subsy));
}

/* fixup_segment()
 * 
 * Go through all the fixS's in a segment and see which ones can be handled now.
 * (These consist of fixS where we have since discovered the value of a symbol,
 * or the address of the frag involved.) For each one,call md_apply_fix to put
 * the fix into the frag data. Ones that we couldn't completely handle here
 * will be output later by emit_relocations.  */
static void	fixup_segment(fixS * fixP,segT this_segment)
{
	valueT		add_number;
	fragS          *fragP;

	if (fixP != NULL && abs_section_sym == NULL)
		abs_section_sym = section_symbol(absolute_section);

	/*
	 * If the linker is doing the relaxing,we must not do any fixups.
	 * 
	 * Well,strictly speaking that's not true -- we could do any that are
	 * PC-relative and don't cross regions that could change size.
	 */
	if (linkrelax && TC_LINKRELAX_FIXUP(this_segment)) {
		for (; fixP; fixP = fixP->fx_next)
			if (!fixP->fx_done) {
				if (fixP->fx_addsy == NULL) {
					/*
					 * There was no symbol required by this
					 * relocation. However,BFD doesn't
					 * really handle relocations without
					 * symbols well. So fake up a local
					 * symbol in the absolute section.
					 */
					fixP->fx_addsy = abs_section_sym;
				}
				symbol_mark_used_in_reloc(fixP->fx_addsy);
				if (fixP->fx_subsy != NULL)
					symbol_mark_used_in_reloc(fixP->fx_subsy);
			}
		return;
	}
	for (; fixP; fixP = fixP->fx_next) {
		segT		add_symbol_segment = absolute_section;

#ifdef DEBUG5
		fprintf(stderr,"\nprocessing fixup:\n");
		print_fixup(fixP);
#endif

		fragP = fixP->fx_frag;
		know(fragP);
#ifdef TC_VALIDATE_FIX
		TC_VALIDATE_FIX(fixP,this_segment,skip);
#endif
		add_number = fixP->fx_offset;

		if (fixP->fx_addsy != NULL)
			add_symbol_segment = S_GET_SEGMENT(fixP->fx_addsy);

		if (fixP->fx_subsy != NULL) {
			segT		sub_symbol_segment;

			resolve_symbol_value(fixP->fx_subsy);
			sub_symbol_segment = S_GET_SEGMENT(fixP->fx_subsy);

			if (fixP->fx_addsy != NULL
			    && sub_symbol_segment == add_symbol_segment
			    && !S_FORCE_RELOC(fixP->fx_addsy,0)
			    && !S_FORCE_RELOC(fixP->fx_subsy,0)
			    && !TC_FORCE_RELOCATION_SUB_SAME(fixP,add_symbol_segment)) {
				add_number += S_GET_VALUE_WHERE(fixP->fx_addsy,fixP->fx_file,fixP->fx_line);
				add_number -= S_GET_VALUE_WHERE(fixP->fx_subsy,fixP->fx_file,fixP->fx_line);
				fixP->fx_offset = add_number;
				fixP->fx_addsy = NULL;
				fixP->fx_subsy = NULL;
			} else
				if (sub_symbol_segment == absolute_section
				    && !S_FORCE_RELOC(fixP->fx_subsy,0)
				    && !TC_FORCE_RELOCATION_SUB_ABS(fixP,add_symbol_segment)) {
					add_number -= S_GET_VALUE_WHERE(fixP->fx_subsy,fixP->fx_file,fixP->fx_line);
					fixP->fx_offset = add_number;
					fixP->fx_subsy = NULL;
				} else
					if (sub_symbol_segment == this_segment
					  && !S_FORCE_RELOC(fixP->fx_subsy,0)
					    && !TC_FORCE_RELOCATION_SUB_LOCAL(fixP,add_symbol_segment)) {
						add_number -= S_GET_VALUE_WHERE(fixP->fx_subsy,fixP->fx_file,fixP->fx_line);
						fixP->fx_offset = (add_number + fixP->fx_dot_value
								   + fixP->fx_dot_frag->fr_address);

						/* Make it pc-relative.  If the back-end code has not
						 * selected a pc-relative reloc,cancel the adjustment
						 * we do later on all pc-relative relocs.  */
						if (!fixP->fx_pcrel)
							add_number += MD_PCREL_FROM_SECTION(fixP,this_segment);
						fixP->fx_subsy = NULL;
						fixP->fx_pcrel = 1;
					} else
						if (!TC_VALIDATE_FIX_SUB(fixP,add_symbol_segment)) {
							if (!md_register_arithmetic
							    && (add_symbol_segment == reg_section
								|| sub_symbol_segment == reg_section))
								as_bad_where(fixP->fx_file,fixP->fx_line,
									     ("register value used as expression"));
							else
								as_bad_subtract(fixP);
						} else
							if (sub_symbol_segment != undefined_section
							    && !bfd_is_com_section(sub_symbol_segment)
							    && MD_APPLY_SYM_VALUE(fixP))
								add_number -= S_GET_VALUE_WHERE(fixP->fx_subsy,fixP->fx_file,fixP->fx_line);
		}
		if (fixP->fx_addsy) {
			if (add_symbol_segment == this_segment
			    && !S_FORCE_RELOC(fixP->fx_addsy,0)
			    && !TC_FORCE_RELOCATION_LOCAL(fixP)) {
				/*
				 * This fixup was made when the symbol's
				 * segment was SEG_UNKNOWN,but it is now in
				 * the local segment. So we know how to do the
				 * address without relocation.
				 */
				add_number += S_GET_VALUE_WHERE(fixP->fx_addsy,fixP->fx_file,fixP->fx_line);
				fixP->fx_offset = add_number;
				if (fixP->fx_pcrel)
					add_number -= MD_PCREL_FROM_SECTION(fixP,this_segment);
				fixP->fx_addsy = NULL;
				fixP->fx_pcrel = 0;
			} else
				if (add_symbol_segment == absolute_section
				    && !S_FORCE_RELOC(fixP->fx_addsy,0)
				    && !TC_FORCE_RELOCATION_ABS(fixP)) {
					add_number += S_GET_VALUE_WHERE(fixP->fx_addsy,fixP->fx_file,fixP->fx_line);
					fixP->fx_offset = add_number;
					fixP->fx_addsy = NULL;
				} else
					if (add_symbol_segment != undefined_section
					    && !bfd_is_com_section(add_symbol_segment)
					    && MD_APPLY_SYM_VALUE(fixP))
						add_number += S_GET_VALUE_WHERE(fixP->fx_addsy,fixP->fx_file,fixP->fx_line);
		}
		if (fixP->fx_pcrel) {
			add_number -= MD_PCREL_FROM_SECTION(fixP,this_segment);
			if (!fixP->fx_done && fixP->fx_addsy == NULL) {
				/* There was no symbol required by this
				 * relocation. However,BFD doesn't really
				 * handle relocations without symbols well. So
				 * fake up a local symbol in the absolute
				 * section.  */
				fixP->fx_addsy = abs_section_sym;
			}
		}
		if (!fixP->fx_done)
			md_apply_fix(fixP,&add_number,this_segment);

		if (!fixP->fx_done) {
			if (fixP->fx_addsy == NULL)
				fixP->fx_addsy = abs_section_sym;
			symbol_mark_used_in_reloc(fixP->fx_addsy);
			if (fixP->fx_subsy != NULL)
				symbol_mark_used_in_reloc(fixP->fx_subsy);
		}
		if (!fixP->fx_no_overflow && fixP->fx_size != 0) {
			if (fixP->fx_size < sizeof(valueT)) {
				valueT		mask;

				mask = 0;
				mask--;	/* Set all bits to one.  */
				mask <<= fixP->fx_size * 8 - (fixP->fx_signed ? 1 : 0);
				if ((add_number & mask) != 0
				    && (fixP->fx_signed
					? (add_number & mask) != mask
					: (-add_number & mask) != 0)) {
					char		buf       [50],buf2[50];
					bfd_sprintf_vma(stdoutput,buf,fragP->fr_address + fixP->fx_where);
					if (add_number > 1000)
						bfd_sprintf_vma(stdoutput,buf2,add_number);
					else
						sprintf(buf2,"%ld",(long)add_number);
					as_bad_where(fixP->fx_file,fixP->fx_line,
						     ngettext("value of %s too large for field "
							   "of %d byte at %s",
					    "value of %s too large for field "
							  "of %d bytes at %s",
							      fixP->fx_size),
						     buf2,fixP->fx_size,buf);
				}	/* Generic error checking.  */
			}
#ifdef WARN_SIGNED_OVERFLOW_WORD
			/* Warn if a .word value is too large when treated as a
			 * signed number.  We already know it is not too
			 * negative.  This is to catch over-large switches
			 * generated by gcc on the 68k.  */
			if (!flag_signed_overflow_ok
			    && fixP->fx_size == 2
			    && add_number > 0x7fff)
				as_bad_where(fixP->fx_file,fixP->fx_line,
					     ("signed .word overflow; switch may be too large; %ld at 0x%lx"),
					     (long)add_number,
				  (long)(fragP->fr_address + fixP->fx_where));
#endif
		}
#ifdef TC_VALIDATE_FIX
skip:		ATTRIBUTE_UNUSED_LABEL
			;
#endif
#ifdef DEBUG5
		fprintf(stderr,"result:\n");
		print_fixup(fixP);
#endif
	}			/* For each fixS in this segment.  */
}
#define N_ONES(n) (((((bfd_vma) 1 << ((n) - 1)) - 1) << 1)|1)
static void	fix_segment(asection * sec,void *xxx ATTRIBUTE_UNUSED)
{
	segment_info_type *seginfo = seg_info(sec);

	fixup_segment(seginfo->fix_root,sec);
}
bfd_reloc_status_type
bfd_check_overflow(enum complain_overflow how,
		   unsigned int bitsize,
		   unsigned int rightshift,
		   unsigned int addrsize,
		   bfd_vma relocation)
{
	bfd_vma		fieldmask,addrmask,signmask,ss,a;
	bfd_reloc_status_type flag = bfd_reloc_ok;

	if (bitsize == 0)
		return flag;

	/* Note: BITSIZE should always be <= ADDRSIZE,but in case it's not,
	 * we'll be permissive: extra bits in the field mask will automatically
	 * extend the address mask for purposes of the overflow check.  */
	fieldmask = N_ONES(bitsize);
	signmask = ~fieldmask;
	addrmask = N_ONES(addrsize)|(fieldmask << rightshift);
	a = (relocation & addrmask) >> rightshift;

	switch (how) {
	case complain_overflow_dont:
		break;

	case complain_overflow_signed:
		/* If any sign bits are set,all sign bits must be set.  That
		 * is,A must be a valid negative address after shifting.  */
		signmask = ~(fieldmask >> 1);
		/* Fall thru */

	case complain_overflow_bitfield:
		/* Bitfields are sometimes signed,sometimes unsigned.  We
		 * explicitly allow an address wrap too,which means a bitfield
		 * of n bits is allowed to store -2**n to 2**n-1.  Thus
		 * overflow if the value has some,but not all,bits set
		 * outside the field.  */
		ss = a & signmask;
		if (ss != 0 && ss != ((addrmask >> rightshift) & signmask))
			flag = bfd_reloc_overflow;
		break;

	case complain_overflow_unsigned:
		/* We have an overflow if the address does not fit in the
		 * field.  */
		if ((a & signmask) != 0)
			flag = bfd_reloc_overflow;
		break;

	default:
		abort();
	}

	return flag;
}
/* Read and return the section contents at DATA converted to a host integer
 * (bfd_vma).  The number of bytes read is given by the HOWTO.  */
static bfd_vma	read_reloc(bfd * abfd ATTRIBUTE_UNUSED,bfd_byte * data,reloc_howto_type * howto)
{
	switch (bfd_get_reloc_size(howto)) {
	case 0:
		break;
	case 1:
		return bfd_getl8(data);
	case 2:
		return bfd_getl16(data);
	case 3:
		return bfd_getl24(data);
	case 4:
		return bfd_getl32(data);
	case 8:
		return bfd_getl64(data);
	default:
		abort();
	}
	return 0;
}
/* Convert VAL to target format and write to DATA.  The number of bytes written
 * is given by the HOWTO.  */
static void	write_reloc(bfd * abfd ATTRIBUTE_UNUSED,bfd_vma val,bfd_byte * data,reloc_howto_type * howto)
{
	switch (bfd_get_reloc_size(howto)) {
	case 0:
		break;
	case 1:
		bfd_putl8(val,data);
		break;
	case 2:
		bfd_putl16(val,data);
		break;
	case 3:
		bfd_putl24(val,data);
		break;
	case 4:
		bfd_putl32(val,data);
		break;
	case 8:
		bfd_putl64(val,data);
		break;
	default:
		abort();
	}
}
/* Apply RELOCATION value to target bytes at DATA,according to HOWTO.  */
static void	apply_reloc(bfd * abfd,bfd_byte * data,reloc_howto_type * howto,
					bfd_vma	relocation)
{
	bfd_vma		val = read_reloc(abfd,data,howto);

	if (howto->negate)
		relocation = -relocation;

	val = ((val & ~howto->dst_mask)
	      |(((val & howto->src_mask) + relocation) & howto->dst_mask));

	write_reloc(abfd,val,data,howto);
}
/* HOWTO describes a relocation,at offset OCTET.  Return whether the
 * relocation field is within SECTION of ABFD.  */
static bool	bfd_reloc_offset_in_range(reloc_howto_type * howto,
				      		bfd *		abfd  ,
				      		asection *	section,
				      		size_t	octet)
{
	size_t		octet_end = bfd_get_section_limit_octets(abfd,section);
	size_t		reloc_size = bfd_get_reloc_size(howto);

	/* The reloc field must be contained entirely within the section. Allow
	 * zero length fields (marker relocs or NONE relocs where no relocation
	 * will be performed) at the end of the section.  */
	return octet <= octet_end && reloc_size <= octet_end - octet;
}

bfd_reloc_status_type bfd_install_relocation(bfd * abfd,
		     		arelent *	reloc_entry,void *data_start,
	       		bfd_vma	data_start_offset,asection * input_section,
				       		char        **error_message)
{
	bfd_vma		relocation;
	bfd_reloc_status_type flag = bfd_reloc_ok;
	size_t		octets;
	bfd_vma		output_base = 0;
	reloc_howto_type *howto = reloc_entry->howto;
	asection       *reloc_target_output_section;
	asymbol        *symbol;
	bfd_byte       *data;

	symbol = *(reloc_entry->sym_ptr_ptr);

	/* If there is a function supplied to handle this relocation type,call
	 * it.  It'll return `bfd_reloc_continue' if further processing can be
	 * done.  */
	if (howto && howto->special_function) {
		bfd_reloc_status_type cont;

		/* Note - we do not call bfd_reloc_offset_in_range here as the
		 * reloc_entry->address field might actually be valid for the
		 * backend concerned.  It is up to the special_function itself
		 * to call bfd_reloc_offset_in_range if needed.  */
		cont = howto->special_function(abfd,reloc_entry,symbol,
		/* XXX - Non-portable! */
					       ((bfd_byte *) data_start
						- data_start_offset),
					  input_section,abfd,error_message);
		if (cont != bfd_reloc_continue)
			return cont;
	}
	if (howto->install_addend)
		relocation = reloc_entry->addend;
	else {
		if (bfd_is_abs_section(symbol->section))
			return bfd_reloc_ok;

		/* Work out which section the relocation is targeted at and the
		 * initial relocation command value.  */

		/* Get symbol value.  (Common symbols are special.)  */
		if (bfd_is_com_section(symbol->section))
			relocation = 0;
		else
			relocation = symbol->value;

		reloc_target_output_section = symbol->section;

		/* Convert input-section-relative symbol value to absolute.  */
		if (!howto->partial_inplace)
			output_base = 0;
		else
			output_base = reloc_target_output_section->vma;

		/* If symbol addresses are in octets,convert to bytes.  */
		if (bfd_get_flavour(abfd) == bfd_target_elf_flavour
		    && (symbol->section->flags & SEC_ELF_OCTETS))
			relocation += output_base;

		/* Add in supplied addend.  */
		relocation += reloc_entry->addend;

		/* Here the variable relocation holds the final address of the
		 * symbol we are relocating against,plus any addend.  */

		if (howto->pc_relative) {
			relocation -= input_section->vma;

			if (howto->pcrel_offset && howto->partial_inplace)
				relocation -= reloc_entry->address;
		}
	}

	if (!howto->partial_inplace) {
		reloc_entry->addend = relocation;
		return flag;
	}
	reloc_entry->addend = relocation;

	/* Is the address of the relocation really within the section?  */
	octets = reloc_entry->address;
	if (!bfd_reloc_offset_in_range(howto,abfd,input_section,octets))
		return bfd_reloc_outofrange;

	/* FIXME: This overflow checking is incomplete,because the value might
	 * have overflowed before we get here.  For a correct check we need to
	 * compute the value in a size larger than bitsize,but we can't
	 * reasonably do that for a reloc the same size as a host machine word.  */
	if (howto->complain_on_overflow != complain_overflow_dont)
		flag = bfd_check_overflow(howto->complain_on_overflow,
					  howto->bitsize,
					  howto->rightshift,
					64,//bfd_arch_bits_per_address(abfd),
					  relocation);

	relocation >>= (bfd_vma) howto->rightshift;

	/* Shift everything up to where it's going to be used.  */
	relocation <<= (bfd_vma) howto->bitpos;

	data = (bfd_byte *) data_start + (octets - data_start_offset);
	apply_reloc(abfd,data,howto,relocation);
	return flag;
}
static void	install_reloc(asection * sec,arelent * reloc,fragS * fragp,
		 		const		char  *file,unsigned int line)
{
	char           *err;
	bfd_reloc_status_type s;
	asymbol        *sym;

	if (reloc->sym_ptr_ptr != NULL
	    && (sym = *reloc->sym_ptr_ptr) != NULL
	    && (sym->flags & BSF_KEEP) == 0
	    && ((sym->flags & BSF_SECTION_SYM) == 0
		|| (EMIT_SECTION_SYMBOLS
		    && !bfd_is_abs_section(sym->section))))
		as_bad_where(file,line,("redefined symbol cannot be used on reloc"));

	s = bfd_install_relocation(stdoutput,reloc,
				   fragp->fr_literal,fragp->fr_address,
				   sec,&err);
	switch (s) {
	case bfd_reloc_ok:
		break;
	case bfd_reloc_overflow:
		as_bad_where(file,line,("relocation overflow"));
		break;
	case bfd_reloc_outofrange:
		as_bad_where(file,line,("relocation out of range"));
		break;
	default:
		as_fatal(("%s:%u: bad return from bfd_install_relocation: %x"),
			 file,line,s);
	}
}

static fragS   *get_frag_for_reloc(fragS * last_frag,
		     		const		segment_info_type * seginfo,
			   		const		struct	reloc_list *r)
{
	fragS          *f;
	int i =0;

	for (f = last_frag; f != NULL; f = f->fr_next) {
		if (f->fr_address <= r->u.b.r.address
		    && r->u.b.r.address < f->fr_address + f->fr_fix)
				return f;
		i++;
	}

	for (f = seginfo->frchainP->frch_root; f != NULL; f = f->fr_next) {
		if (f->fr_address <= r->u.b.r.address
		    && r->u.b.r.address < f->fr_address + f->fr_fix)
			return f;
	}
	/* This third loop is needed, as Mr Modra told me in an email:
	 * The third loop (the one you're asking about) wasn't added with the
	 * above, but rather by commit 740bdc67c057 (also by Alan).  
	 * It contains testcase and justification.  (Hint: as last resort, 
	 * and only then, a reloc is associated with a frag at the _end_ 
	 * of section. frags can be var-length). */
	for (f = seginfo->frchainP->frch_root; f != NULL; f = f->fr_next)
		if (f->fr_address <= r->u.b.r.address
		    && r->u.b.r.address <= f->fr_address + f->fr_fix)
			return f;
	as_bad_where(r->file,r->line,"reloc not within fixed part of section");
	return NULL;
}

/* gas/write.c:1229 */
static void	write_relocs(asection * sec,void *xxx ATTRIBUTE_UNUSED)
{
	segment_info_type *seginfo = seg_info(sec);
	unsigned int	n;
	struct reloc_list *my_reloc_list,**rp,*r;
	arelent       **relocs;
	fixS           *fixp;
	fragS          *last_frag;

	/* If seginfo is NULL,we did not create this section; don't do
	 * anything with it.  */
	if (seginfo == NULL)
		return;

	n = 0;
	for (fixp = seginfo->fix_root; fixp; fixp = fixp->fx_next)
		n += !fixp->fx_done;

	/* Extract relocs for this section from reloc_list.  */
	rp = &reloc_list;

	my_reloc_list = NULL;
	while ((r = *rp) != NULL) {
		if (r->u.b.sec == sec) {
			*rp = r->next;
			r->next = my_reloc_list;
			my_reloc_list = r;
			n++;
		} else
			rp = &r->next;
	}

	relocs = XCNEWVEC(arelent *,n);

	n = 0;
	r = my_reloc_list;
	last_frag = NULL;
	for (fixp = seginfo->fix_root; fixp != (fixS *) NULL; fixp = fixp->fx_next) {
		int		fx_size   ,slack;
		valueT		loc;
		arelent       **reloc;
		arelent        *rel;

		reloc = &rel;

		if (fixp->fx_done)
			continue;

		fx_size = fixp->fx_size;
		slack = TC_FX_SIZE_SLACK(fixp);
		if (slack > 0)
			fx_size = fx_size > slack ? fx_size - slack : 0;
		loc = fixp->fx_where + fx_size;
		if (slack >= 0 && loc > fixp->fx_frag->fr_fix)
			as_bad_where(fixp->fx_file,fixp->fx_line,
			 ("internal error: fixup not contained within frag"));

		if (fixp->fx_addsy && symbol_removed_p(fixp->fx_addsy))
			obj_fixup_removed_symbol(&fixp->fx_addsy);
		if (fixp->fx_subsy && symbol_removed_p(fixp->fx_subsy))
			obj_fixup_removed_symbol(&fixp->fx_subsy);
		*reloc = tc_gen_reloc(sec,fixp);

		while (*reloc) {
			while (r != NULL && r->u.b.r.address < (*reloc)->address) {
				fragS          *f = get_frag_for_reloc(last_frag,seginfo,r);
				if (f != NULL) {
					last_frag = f;
					relocs[n++] = &r->u.b.r;
					install_reloc(sec,&r->u.b.r,f,r->file,r->line);
				}
				r = r->next;
			}
			if (n != 0 && (*reloc)->address < relocs[n - 1]->address) {
				size_t		lo = 0;
				size_t		hi = n - 1;
				bfd_vma		look = (*reloc)->address;
				while (lo < hi) {
					size_t		mid = (lo + hi) / 2;
					if (relocs[mid]->address > look)
						hi = mid;
					else {
						lo = mid + 1;
						if (relocs[mid]->address == look)
							break;
					}
				}
				while (lo < hi && relocs[lo]->address == look)
					lo++;
				memmove(relocs + lo + 1,relocs + lo,
					(n - lo) * sizeof(*relocs));
				n++;
				relocs[lo] = *reloc;
			} else
				relocs[n++] = *reloc;
			install_reloc(sec,*reloc,fixp->fx_frag,
				      fixp->fx_file,fixp->fx_line);
			break;
		}
	}

	while (r != NULL) {
		fragS          *f = get_frag_for_reloc(last_frag,seginfo,r);
		if (f != NULL) {
			last_frag = f;
			relocs[n++] = &r->u.b.r;
			install_reloc(sec,&r->u.b.r,f,r->file,r->line);
		}
		r = r->next;
	}

#ifdef DEBUG4
	{
		unsigned int	k ,j,nsyms;
		asymbol       **sympp;
		sympp = bfd_get_outsymbols(stdoutput);
		nsyms = bfd_get_symcount(stdoutput);
		for (k = 0; k < n; k++)
			if (((*relocs[k]->sym_ptr_ptr)->flags & BSF_SECTION_SYM) == 0) {
				for (j = 0; j < nsyms; j++)
					if (sympp[j] == *relocs[k]->sym_ptr_ptr)
						break;
				if (j == nsyms)
					abort();
			}
	}
#endif

	//bfd_set_reloc(stdoutput,sec,n ? relocs : NULL,n);
	if (n) {
		sec->flags |= SEC_RELOC;
		sec->orelocation = relocs;
		sec->reloc_count = n;
	}
	else sec->flags &= ~SEC_RELOC;
#ifdef SET_SECTION_RELOCS
	SET_SECTION_RELOCS(sec,relocs,n);
#endif

#ifdef DEBUG3
	{
		unsigned int	k;

		fprintf(stderr,"relocs for sec %s\n",sec->name);
		for (k = 0; k < n; k++) {
			arelent        *rel = relocs[k];
			asymbol        *s = *rel->sym_ptr_ptr;
			fprintf(stderr,"  reloc %2d @%p off %4lx : sym %-10s addend %lx\n",
				k,rel,(unsigned long)rel->address,s->name,
				(unsigned long)rel->addend);
		}
	}
#endif
}

static int	compress_frag(bool use_zstd,void *ctx,const char *contents,int in_size,
		 		fragS **	last_newf,struct obstack *ob)
{
	int		out_size;
	int		total_out_size = 0;
	fragS          *f = *last_newf;
	char           *next_out;
	int		avail_out;

	/*
	 * Call the compression routine repeatedly until it has finished
	 * processing the frag.
	 */
	while (in_size > 0) {
		/*
		 * Reserve all the space available in the current chunk. If
		 * none is available,start a new frag.
		 */
		avail_out = obstack_room(ob);
		if (avail_out <= 0) {
			obstack_finish(ob);
			f = frag_alloc(ob);
			f->fr_type = rs_fill;
			(*last_newf)->fr_next = f;
			*last_newf = f;
			avail_out = obstack_room(ob);
		}
		if (avail_out <= 0)
			as_fatal(("can't extend frag"));
		next_out = obstack_next_free(ob);
		obstack_blank_fast(ob,avail_out);
		out_size = compress_data(use_zstd,ctx,&contents,&in_size,&next_out,
					 &avail_out);
		if (out_size < 0)
			return -1;

		f->fr_fix += out_size;
		total_out_size += out_size;

		/* Return unused space.  */
		if (avail_out > 0)
			obstack_blank_fast(ob,-avail_out);
	}

	return total_out_size;
}

static void	compress_debug(asection * sec,void *xxx ATTRIBUTE_UNUSED)
{
	segment_info_type *seginfo = seg_info(sec);
	size_t		uncompressed_size = sec->size;
	uint32_t	flags = sec->flags;

	if (seginfo == NULL
	    || uncompressed_size < 32
	    || (flags & SEC_HAS_CONTENTS) == 0)
		return;

	const char     *section_name = bfd_section_name(sec);
	if (!startswith(section_name,".debug_")
	    && !startswith(section_name,".gnu.debuglto_.debug_")
	    && !startswith(section_name,".gnu.linkonce.wi."))
		return;

	bool		use_zstd = stdoutput->flags & BFD_COMPRESS_ZSTD;
	void           *ctx = compress_init(use_zstd);
	if (ctx == NULL)
		return;

	unsigned int	header_size;
	if ((stdoutput->flags & BFD_COMPRESS_GABI) == 0)
		header_size = 12;
	else
		header_size = bfd_get_compression_header_size(stdoutput,NULL);

	/* Create a new frag to contain the compression header.  */
	struct obstack *ob = &seginfo->frchainP->frch_obstack;
	fragS          *first_newf = frag_alloc(ob);
	if (obstack_room(ob) < header_size)
		first_newf = frag_alloc(ob);
	if (obstack_room(ob) < header_size)
		as_fatal(ngettext("can't extend frag %lu char",
				  "can't extend frag %lu chars",
				  (unsigned long)header_size),
			 (unsigned long)header_size);
	fragS          *last_newf = first_newf;
	obstack_blank_fast(ob,header_size);
	last_newf->fr_type = rs_fill;
	last_newf->fr_fix = header_size;
	char           *header = last_newf->fr_literal;
	size_t		compressed_size = header_size;

	/* Stream the frags through the compression engine,adding new frags as
	 * necessary to accommodate the compressed output.  */
	for (fragS * f = seginfo->frchainP->frch_root;
	     f;
	     f = f->fr_next) {
		offsetT		fill_size;
		char           *fill_literal;
		offsetT		count;
		int		out_size;

		gas_assert(f->fr_type == rs_fill);
		if (f->fr_fix) {
			out_size = compress_frag(use_zstd,ctx,f->fr_literal,f->fr_fix,
						 &last_newf,ob);
			if (out_size < 0)
				return;
			compressed_size += out_size;
		}
		fill_literal = f->fr_literal + f->fr_fix;
		fill_size = f->fr_var;
		count = f->fr_offset;
		gas_assert(count >= 0);
		if (fill_size && count) {
			while (count--) {
				out_size = compress_frag(use_zstd,ctx,fill_literal,
					      (int)fill_size,&last_newf,ob);
				if (out_size < 0)
					return;
				compressed_size += out_size;
			}
		}
	}

	/* Flush the compression state.  */
	for (;;) {
		int		avail_out;
		char           *next_out;
		int		out_size;

		/* Reserve all the space available in the current chunk. If
		 * none is available,start a new frag.  */
		avail_out = obstack_room(ob);
		if (avail_out <= 0) {
			fragS          *newf;

			obstack_finish(ob);
			newf = frag_alloc(ob);
			newf->fr_type = rs_fill;
			last_newf->fr_next = newf;
			last_newf = newf;
			avail_out = obstack_room(ob);
		}
		if (avail_out <= 0)
			as_fatal(("can't extend frag"));
		next_out = obstack_next_free(ob);
		obstack_blank_fast(ob,avail_out);
		int		x = compress_finish(use_zstd,ctx,&next_out,&avail_out,&out_size);
		if (x < 0)
			return;

		last_newf->fr_fix += out_size;
		compressed_size += out_size;

		/* Return unused space.  */
		if (avail_out > 0)
			obstack_blank_fast(ob,-avail_out);

		if (x == 0)
			break;
	}

	/* PR binutils/18087: If compression didn't make the section smaller,
	 * just keep it uncompressed.  */
	if (compressed_size >= uncompressed_size)
		return;

	/* Replace the uncompressed frag list with the compressed frag list.  */
	seginfo->frchainP->frch_root = first_newf;
	seginfo->frchainP->frch_last = last_newf;

	/* Update the section size and its name.  */
	bfd_update_compression_header(stdoutput,(uint8_t *) header,sec);
	bool		x = set_section_size(sec,compressed_size);
	gas_assert(x);
	if ((stdoutput->flags & BFD_COMPRESS_GABI) == 0
	    && section_name[1] == 'd') {
		char           *compressed_name = bfd_debug_name_to_zdebug(stdoutput,section_name);
		bfd_rename_section(sec,compressed_name);
	}
}

/* Genenerate COUNT bytes of no-op instructions to WHERE.  A target backend
 * must override this with proper no-op instructions.
 */

static void	md_generate_nops(fragS * f ATTRIBUTE_UNUSED,
			     		char         *where ATTRIBUTE_UNUSED,
			     		offsetT	count	ATTRIBUTE_UNUSED,
			  		int		control	ATTRIBUTE_UNUSED)
{
	as_bad(("unimplemented .nops directive"));
}

static void	write_contents(asection * sec,void *xxx ATTRIBUTE_UNUSED)
{
	segment_info_type *seginfo = seg_info(sec);
	addressT	offset = 0;
	fragS          *f;

	/* Write out the frags.  */
	if (seginfo == NULL
	    || !(sec->flags & SEC_HAS_CONTENTS))
		return;

	for (f = seginfo->frchainP->frch_root; f; f = f->fr_next) {
		int		x;
		addressT	fill_size;
		char           *fill_literal;
		offsetT		count;

		gas_assert(f->fr_type == rs_fill || f->fr_type == rs_fill_nop);
		if (f->fr_fix) {
			x = set_section_contents(stdoutput,sec,
					     f->fr_literal,(file_ptr) offset,
						 (size_t) f->fr_fix);
			if (!x)
				as_fatal(ngettext("can't write %ld byte "
						  "to section %s of %s: '%s'",
						  "can't write %ld bytes "
						  "to section %s of %s: '%s'",
						  (long)f->fr_fix),
					 (long)f->fr_fix,
					 bfd_section_name(sec),bfd_get_filename(stdoutput),
					 bfd_errmsg(bfd_get_error()));
			offset += f->fr_fix;
		}
		fill_size = f->fr_var;
		count = f->fr_offset;
		fill_literal = f->fr_literal + f->fr_fix;

		if (f->fr_type == rs_fill_nop) {
			gas_assert(count >= 0 && fill_size == 1);
			if (count > 0) {
				char           *buf = xmalloc(count);
				md_generate_nops(f,buf,count,*fill_literal);
				x = set_section_contents(stdoutput,sec,buf,(file_ptr) offset,
							 (size_t) count);
				if (!x)
					as_fatal(ngettext("can't fill %ld byte "
						  "in section %s of %s: '%s'",
						       "can't fill %ld bytes "
						  "in section %s of %s: '%s'",
							  (long)count),
						 (long)count,
						 bfd_section_name(sec),
						 bfd_get_filename(stdoutput),
						 bfd_errmsg(bfd_get_error()));
				offset += count;
				free(buf);
			}
			continue;
		}
		gas_assert(count >= 0);
		if (fill_size && count) {
			char		buf       [256];
			if (fill_size > sizeof(buf)) {
				/* Do it the old way. Can this ever happen?  */
				while (count--) {
					x = set_section_contents(stdoutput,sec,
								 fill_literal,
							    (file_ptr) offset,
							  (size_t) fill_size);
					if (!x)
						as_fatal(ngettext("can't fill %ld byte "
						  "in section %s of %s: '%s'",
						       "can't fill %ld bytes "
						  "in section %s of %s: '%s'",
							     (long)fill_size),
							 (long)fill_size,
							 bfd_section_name(sec),
						  bfd_get_filename(stdoutput),
						 bfd_errmsg(bfd_get_error()));
					offset += fill_size;
				}
			} else {
				/*
				 * Build a buffer full of fill objects and
				 * output it as often as necessary. This saves
				 * on the overhead of potentially lots of
				 * set_section_contents calls.
				 */
				int		n_per_buf ,i;
				if (fill_size == 1) {
					n_per_buf = sizeof(buf);
					memset(buf,*fill_literal,n_per_buf);
				} else {
					char           *bufp;
					n_per_buf = sizeof(buf) / fill_size;
					for (i = n_per_buf,bufp = buf; i; i--,bufp += fill_size)
						memcpy(bufp,fill_literal,fill_size);
				}
				for (; count > 0; count -= n_per_buf) {
					n_per_buf = n_per_buf > count ? count : n_per_buf;
					x = set_section_contents
						(stdoutput,sec,buf,(file_ptr) offset,
					      (size_t) n_per_buf * fill_size);
					if (!x)
						as_fatal(ngettext("can't fill %ld byte "
						  "in section %s of %s: '%s'",
						       "can't fill %ld bytes "
						  "in section %s of %s: '%s'",
						(long)(n_per_buf * fill_size)),
						(long)(n_per_buf * fill_size),
							 bfd_section_name(sec),
						  bfd_get_filename(stdoutput),
						 bfd_errmsg(bfd_get_error()));
					offset += n_per_buf * fill_size;
				}
			}
		}
	}
}

static void	merge_data_into_text(void)
{
	seg_info(text_section)->frchainP->frch_last->fr_next =
	seg_info(data_section)->frchainP->frch_root;
	seg_info(text_section)->frchainP->frch_last =
		seg_info(data_section)->frchainP->frch_last;
	seg_info(data_section)->frchainP = 0;
}

bool		bfd_set_symtab(bfd * abfd,asymbol ** location,unsigned int symcount)
{
	abfd->outsymbols = location;
	abfd->symcount = symcount;
	return true;
}
static void	set_symtab(void)
{
	int		nsyms;
	asymbol       **asympp;
	symbolS        *symp;
	bool		result;

	/* Count symbols.  We can't rely on a count made by the loop in
	 * write_object_file,because *_frob_file may add a new symbol or two.
	 * Generate unused section symbols only if needed.  */
	nsyms = 0;
	for (symp = symbol_rootP; symp; symp = symbol_next(symp))
		if (!symbol_removed_p(symp)
		    && (bfd_keep_unused_section_symbols(stdoutput)
			|| !symbol_section_p(symp)
			|| symbol_used_in_reloc_p(symp)))
			nsyms++;

	if (nsyms) {
		int		i;
		size_t		amt = (size_t) nsyms * sizeof(asymbol *);

		asympp = (asymbol **) bfd_alloc(stdoutput,amt);
		symp = symbol_rootP;
		for (i = 0; i < nsyms; symp = symbol_next(symp))
			if (!symbol_removed_p(symp)
			    && (bfd_keep_unused_section_symbols(stdoutput)
				|| !symbol_section_p(symp)
				|| symbol_used_in_reloc_p(symp))) {
				asympp[i] = symbol_get_bfdsym(symp);
				if (asympp[i]->flags != BSF_SECTION_SYM
				 || !(bfd_is_const_section(asympp[i]->section)
				  && asympp[i]->section->symbol == asympp[i]))
					asympp[i]->flags |= BSF_KEEP;
				symbol_mark_written(symp);
				/* Include this section symbol in the symbol table. */
				if (symbol_section_p(symp))
					asympp[i]->flags |= BSF_SECTION_SYM_USED;
				i++;
			}
	} else
		asympp = 0;
	result = bfd_set_symtab(stdoutput,asympp,nsyms);
	gas_assert(result);
	symbol_table_frozen = 1;
}

/* Finish the subsegments.  After every sub-segment,we fake an ".align ...".
 * This conforms to BSD4.2 brain-damage.  We then fake ".fill 0" because that
 * is the kind of frag that requires least thought.  ".align" frags like to
 * have a following frag since that makes calculating their intended length
 * trivial.
 */

/* The last subsegment gets an alignment corresponding to the alignment of the
 * section.  This allows proper nop-filling at the end of code-bearing
 * sections.  */
#define SUB_SEGMENT_ALIGN(SEG,FRCHAIN)					\
  (!(FRCHAIN)->frch_next && subseg_text_p (SEG)				\
   && !do_not_pad_sections_to_alignment					\
   ? get_recorded_alignment (SEG)					\
   : 0)

static void	subsegs_finish_section(asection * s)
{
	struct frchain *frchainP;
	segment_info_type *seginfo = seg_info(s);
	if (!seginfo)
		return;

	for (frchainP = seginfo->frchainP;
	     frchainP != NULL;
	     frchainP = frchainP->frch_next) {
		int		alignment;

		subseg_set(s,frchainP->frch_subseg);

		/* This now gets called even if we had errors.  In that case,
		 * any alignment is meaningless,and,moreover,will look weird
		 * if we are generating a listing.  */
		if (had_errors())
			do_not_pad_sections_to_alignment = 1;

		alignment = SUB_SEGMENT_ALIGN(now_seg,frchainP);
		if ((now_seg->flags & SEC_MERGE)
		    && now_seg->entsize) {
			unsigned int	entsize = now_seg->entsize;
			int		entalign = 0;

			while ((entsize & 1) == 0) {
				++entalign;
				entsize >>= 1;
			}

			if (entalign > alignment)
				alignment = entalign;
		}
		if (subseg_text_p(now_seg))
			frag_align_code(alignment,0);
		else
			frag_align(alignment,0,0);

		/* frag_align will have left a new frag. Use this last frag for
		 * an empty ".fill".
		 * 
		 * For this segment ... Create a last frag. Do not leave a "being
		 * filled in frag".  */
		frag_wane(frag_now);
		frag_now->fr_fix = 0;
		know(frag_now->fr_next == NULL);
	}
}

static void	subsegs_finish(void)
{
	asection       *s;

	for (s = stdoutput->sections; s; s = s->next)
		subsegs_finish_section(s);
}

#ifdef OBJ_ELF
/* Return the vendor name for a given object attributes section.  */
static const char *vendor_obj_attr_name(bfd * abfd ATTRIBUTE_UNUSED,int vendor)
{
	return (vendor == OBJ_ATTR_PROC ?
		//get_elf_backend_data(abfd)->obj_attrs_vendor
		"riscv" : "gnu");
}
/* Return the size of the object attributes section for VENDOR (OBJ_ATTR_PROC
 * or OBJ_ATTR_GNU),or 0 if there are no attributes for that vendor to record
 * and the vendor is OBJ_ATTR_GNU.  */
static bfd_vma	vendor_obj_attr_size(bfd * abfd,int vendor)
{
	bfd_vma		size;
	obj_attribute  *attr;
	obj_attribute_list *list;
	int		i;
	const char     *vendor_name = vendor_obj_attr_name(abfd,vendor);

	if (!vendor_name)
		return 0;

	attr = elf_known_obj_attributes(abfd)[vendor];
	size = 0;
	for (i = LEAST_KNOWN_OBJ_ATTRIBUTE; i < NUM_KNOWN_OBJ_ATTRIBUTES; i++)
		size += obj_attr_size(i,&attr[i]);

	for (list = elf_other_obj_attributes(abfd)[vendor];
	     list;
	     list = list->next)
		size += obj_attr_size(list->tag,&list->attr);

	/* <size> <vendor_name> NUL 0x1 <size> */
	return (size
		? size + 10 + strlen(vendor_name)
		: 0);
}
/* Return the size of the object attributes section.  */
static bfd_vma	elf_obj_attr_size(bfd * abfd)
{
	bfd_vma		size;

	size = vendor_obj_attr_size(abfd,OBJ_ATTR_PROC);
	size += vendor_obj_attr_size(abfd,OBJ_ATTR_GNU);

	/* 'A' <sections for each vendor> */
	return (size ? size + 1 : 0);
}
/* Return TRUE if the attribute has the default value (0/"").  */
static bool	is_default_attr(obj_attribute * attr)
{
	if (ATTR_TYPE_HAS_ERROR(attr->type))
		return true;
	if (ATTR_TYPE_HAS_INT_VAL(attr->type) && attr->i != 0)
		return false;
	if (ATTR_TYPE_HAS_STR_VAL(attr->type) && attr->s && *attr->s)
		return false;
	if (ATTR_TYPE_HAS_NO_DEFAULT(attr->type))
		return false;

	return true;
}
/* Return the size of a single attribute.  */
static bfd_vma	obj_attr_size(unsigned int tag,obj_attribute * attr)
{
	bfd_vma		size;

	if (is_default_attr(attr))
		return 0;

	size = uleb128_size(tag);
	if (ATTR_TYPE_HAS_INT_VAL(attr->type))
		size += uleb128_size(attr->i);
	if (ATTR_TYPE_HAS_STR_VAL(attr->type))
		size += strlen((char *)attr->s) + 1;
	return size;
}
/* Write attribute ATTR to butter P,and return a pointer to the following
 * byte.  */
static bfd_byte *write_obj_attribute(bfd_byte * p,unsigned tag,obj_attribute * attr)
{
	/* Suppress default entries.  */
	if (is_default_attr(attr))
		return p;

	p = write_uleb128(p,tag);
	if (ATTR_TYPE_HAS_INT_VAL(attr->type))
		p = write_uleb128(p,attr->i);
	if (ATTR_TYPE_HAS_STR_VAL(attr->type)) {
		int		len;

		len = strlen(attr->s) + 1;
		memcpy(p,attr->s,len);
		p += len;
	}
	return p;
}
/* Write the contents of the object attributes section (length SIZE) for VENDOR
 * to CONTENTS.  */
static void	vendor_set_obj_attr_contents(bfd * abfd,bfd_byte * contents,
				     		bfd_vma	size ,int vendor)
{
	bfd_byte       *p;
	obj_attribute  *attr;
	obj_attribute_list *list;
	int		i;
	const char     *vendor_name = vendor_obj_attr_name(abfd,vendor);
	size_t		vendor_length = strlen(vendor_name) + 1;

	p = contents;
	bfd_putl32(size,p);
	p += 4;
	memcpy(p,vendor_name,vendor_length);
	p += vendor_length;
	*(p++) = Tag_File;
	bfd_putl32(size - 4 - vendor_length,p);
	p += 4;

	attr = elf_known_obj_attributes(abfd)[vendor];
	for (i = LEAST_KNOWN_OBJ_ATTRIBUTE; i < NUM_KNOWN_OBJ_ATTRIBUTES; i++) {
		unsigned int	tag = i;
		p = write_obj_attribute(p,tag,&attr[tag]);
	}

	for (list = elf_other_obj_attributes(abfd)[vendor];
	     list;
	     list = list->next)
		p = write_obj_attribute(p,list->tag,&list->attr);
}
/* Write the contents of the object attributes section to CONTENTS.  */
void		bfd_elf_set_obj_attr_contents(bfd * abfd,bfd_byte * contents,bfd_vma size)
{
	bfd_byte       *p;
	int		vendor;
	bfd_vma		my_size;

	p = contents;
	*(p++) = 'A';
	my_size = 1;
	for (vendor = OBJ_ATTR_FIRST; vendor <= OBJ_ATTR_LAST; vendor++) {
		bfd_vma		vendor_size = vendor_obj_attr_size(abfd,vendor);
		if (vendor_size)
			vendor_set_obj_attr_contents(abfd,p,vendor_size,vendor);
		p += vendor_size;
		my_size += vendor_size;
	}

	if (size != my_size)
		abort();
}
static void	create_obj_attrs_section(void)
{
	segT		s;
	char           *p;
	offsetT		size;
	const char     *name;

	size = elf_obj_attr_size(stdoutput);
	if (size == 0)
		return;

	name=".riscv.attributes";//get_elf_backend_data(stdoutput)->obj_attrs_section
	s = subseg_new(name,0);
	elf_section_type(s) = 0x70000003; //SHT_RISCV_ATTRIBUTES;
	//=get_elf_backend_data(stdoutput)->obj_attrs_section_type;
	s->flags = SEC_READONLY|SEC_DATA;
	frag_now_fix();
	p = frag_more(size);
	bfd_elf_set_obj_attr_contents(stdoutput,(uint8_t *) p,size);

	subsegs_finish_section(s);
	relax_segment(seg_info(s)->frchainP->frch_root,s,0);
	size_seg(s,NULL);
}

/* Create a relocation against an entry in a GNU Build attribute section.  */
static void	create_note_reloc(segT sec,
			      		symbolS *	sym,
			      		size_t	note_offset,
			      		size_t	desc2_offset,
			      		offsetT	desc2_size ATTRIBUTE_UNUSED,
			      		int		reloc_type,
			      		bfd_vma	addend,
			      		char         *note ATTRIBUTE_UNUSED)
{
	struct reloc_list *reloc;

	reloc = XNEW(struct reloc_list);

	/* We create a .b type reloc as resolve_reloc_expr_symbols() has
	 * already been called.  */
	reloc->u.b.sec = sec;
	reloc->u.b.s = symbol_get_bfdsym(sym);
	reloc->u.b.r.sym_ptr_ptr = &reloc->u.b.s;
	reloc->u.b.r.address = note_offset + desc2_offset;
	reloc->u.b.r.addend = addend;
	reloc->u.b.r.howto = riscv_reloc_type_lookup(stdoutput,reloc_type);

	if (reloc->u.b.r.howto == NULL) {
		as_bad("unable to create reloc for build note");
		return;
	}
	reloc->file = N_("<gnu build note>");
	reloc->line = 0;

	reloc->next = reloc_list;
	reloc_list = reloc;
}

static void	maybe_generate_build_notes(void)
{
	segT		sec;
	char           *note;
	offsetT		note_size;
	offsetT		total_size;
	offsetT		desc_size;
	offsetT		desc2_offset;
	int		desc_reloc;
	symbolS        *sym;
	asymbol        *bsym;

	if (!flag_generate_build_notes
	    || bfd_get_section_by_name(stdoutput,
				       GNU_BUILD_ATTRS_SECTION_NAME) != NULL)
		return;

	/* Create a GNU Build Attribute section.  */
	sec = subseg_new(GNU_BUILD_ATTRS_SECTION_NAME,false);
	elf_section_type(sec) = SHT_NOTE;
	sec->flags = (SEC_READONLY|SEC_HAS_CONTENTS|SEC_DATA|SEC_OCTETS);
	bfd_set_section_alignment(sec,2);

	/* Work out the size of the notes that we will create,and the
	 * relocation we should use.  */
	{
		note_size = 36;
		desc_size = 16;	/* Two  8-byte offsets.  */
		desc2_offset = 28;
		desc_reloc = BFD_RELOC_64;
	}

	/* We have to create a note for *each* code section. Linker garbage
	 * collection might discard some.  */
	total_size = 0;
	note = NULL;

	for (sym = symbol_rootP; sym != NULL; sym = symbol_next(sym))
		if ((bsym = symbol_get_bfdsym(sym)) != NULL
		    && bsym->flags & BSF_SECTION_SYM
		    && bsym->section != NULL
		/* Skip linkonce sections - we cannot use these section symbols
		 * as they may disappear.  */
		    && (bsym->section->flags & (SEC_CODE|SEC_LINK_ONCE)) == SEC_CODE
		/* Not all linkonce sections are flagged...  */
		    && !startswith(S_GET_NAME(sym),".gnu.linkonce")) {
			/* Create a version note.  */
			frag_now_fix();
			note = frag_more(note_size);
			memset(note,0,note_size);

			if (target_big_endian) {
				note[3] = 8;	/* strlen (name) + 1.  */
				note[7] = desc_size;	/* Two N-byte offsets.  */
				note[10] = NT_GNU_BUILD_ATTRIBUTE_OPEN >> 8;
				note[11] = NT_GNU_BUILD_ATTRIBUTE_OPEN & 0xff;
			} else {
				note[0] = 8;	/* strlen (name) + 1.  */
				note[4] = desc_size;	/* Two N-byte offsets.  */
				note[8] = NT_GNU_BUILD_ATTRIBUTE_OPEN & 0xff;
				note[9] = NT_GNU_BUILD_ATTRIBUTE_OPEN >> 8;
			}

			/* The a1 version number indicates that this note was
			 * generated by the assembler and not the gcc annobin
			 * plugin.  */
			memcpy(note + 12,"GA$3a1",8);

			/* Create a relocation to install the start address of
			 * the note...  */
			create_note_reloc(sec,sym,total_size,20,desc_size / 2,desc_reloc,0,note);

			/* ...and another one to install the end address.  */
			create_note_reloc(sec,sym,total_size,desc2_offset,
					  desc_size / 2,
					  desc_reloc,
					  bfd_section_size(bsym->section),
					  note);

			/* Mark the section symbol used in relocation so that
			 * it will be included in the symbol table.  */
			symbol_mark_used_in_reloc(sym);

			total_size += note_size;
			/* FIXME: Maybe add a note recording the assembler
			 * command line and version ?  */
		}
	/* Install the note(s) into the section.  */
	if (total_size)
		set_section_contents(stdoutput,sec,(uint8_t *) note,0,total_size);
	subsegs_finish_section(sec);
	relax_segment(seg_info(sec)->frchainP->frch_root,sec,0);
	size_seg(sec,NULL);
}
#endif				/* OBJ_ELF */

/* Write the object file.  */
static void	write_object_file(void)
{
	struct relax_seg_info rsi;

	subsegs_finish();
	riscv_pre_output_hook();
	/*
	 * From now on,we don't care about sub-segments.  Build one frag chain
	 * for each segment. Linked through fr_next.
	 */
	/* Remove the sections created by gas for its own purposes.  */
	{
		int		i;

		bfd_section_list_remove(stdoutput,reg_section);
		bfd_section_list_remove(stdoutput,expr_section);
		stdoutput->section_count -= 2;
		i = 0;
		map_over_sections(renumber_sections,&i);
	}

	map_over_sections(chain_frchains_together,(char *)0);

	/*
	 * We have two segments. If user gave -R flag,then we must put the
	 * data frags into the text segment. Do this before relaxing so we know
	 * to take advantage of -R and make shorter addresses.
	 */
	if (flag_readonly_data_in_text) {
		merge_data_into_text();
	}
	rsi.pass = 0;
	while (1) {
		rsi.changed = 0;
		map_over_sections(relax_seg,&rsi);
		rsi.pass++;
		if (!rsi.changed)
			break;
	}

	/* Note - Most ports will use the default value of
	 * TC_FINALIZE_SYMS_BEFORE_SIZE_SEG,which 1.  This will force local
	 * symbols to be resolved,removing their frag information. Some ports
	 * however,will not have finished relaxing all of their frags and will
	 * still need the local symbol frag information.  These ports can set
	 * TC_FINALIZE_SYMS_BEFORE_SIZE_SEG to 0.  */
	finalize_syms = TC_FINALIZE_SYMS_BEFORE_SIZE_SEG;
	map_over_sections(size_seg,(char *)0);
	/* Relaxation has completed.  Freeze all syms.  */
	finalize_syms = 1;

	dwarf2dbg_final_check();

#ifdef OBJ_ELF
	if (IS_ELF)
		create_obj_attrs_section();
#endif

	/* Resolve symbol values.  This needs to be done before processing the
	 * relocations.  */
	if (symbol_rootP) {
		symbolS        *symp;

		for (symp = symbol_rootP; symp; symp = symbol_next(symp))
			resolve_symbol_value(symp);
	}
	resolve_local_symbol_values();
	resolve_reloc_expr_symbols();

#ifdef OBJ_ELF
	if (IS_ELF)
		maybe_generate_build_notes();
#endif

	elf_frob_file_before_adjust();

	map_over_sections(adjust_reloc_syms,(char *)0);

	map_over_sections(fix_segment,(char *)0);

	/* Set up symbol table,and write it out.  */
	if (symbol_rootP) {
		symbolS        *symp;
		bool		skip_next_symbol = false;

		for (symp = symbol_rootP; symp; symp = symbol_next(symp)) {
			int		punt = 0;
			const char     *name;

			if (skip_next_symbol) {
				/*
				 * Don't do anything besides moving the value
				 * of the symbol from the GAS value-field to
				 * the BFD value-field.
				 */
				symbol_get_bfdsym(symp)->value = S_GET_VALUE(symp);
				skip_next_symbol = false;
				continue;
			}
			name = S_GET_NAME(symp);
			if (name) {
				const char     *name2 =
				decode_local_label_name((char *)S_GET_NAME(symp));
				/*
				 * They only differ if `name' is a fb or dollar
				 * local label name.
				 */
				if (name2 != name && !S_IS_DEFINED(symp))
					as_bad(("local label `%s' is not defined"),name2);
			}
			/*
			 * Do it again,because adjust_reloc_syms might
			 * introduce more symbols.  They'll probably only be
			 * section symbols,but they'll still need to have the
			 * values computed.
			 */
			resolve_symbol_value(symp);

			/*
			 * Skip symbols which were equated to undefined or
			 * common symbols.
			 */
			if (symbol_equated_reloc_p(symp)
			    || S_IS_WEAKREFR(symp)) {
				const char     *sname = S_GET_NAME(symp);

				if (S_IS_COMMON(symp)
				    && !TC_FAKE_LABEL(sname)
				    && !S_IS_WEAKREFR(symp)) {
					expressionS    *e = symbol_get_value_expression(symp);

					as_bad(("`%s' can't be equated to common symbol `%s'"),
					  sname,S_GET_NAME(e->X_add_symbol));
				}
				if (S_GET_SEGMENT(symp) == reg_section) {
					/*
					 * Report error only if we know the
					 * symbol name.
					 */
					if (S_GET_NAME(symp) != reg_section->name)
						as_bad(("can't make global register symbol `%s'"),
						       sname);
				}
				symbol_remove(symp,&symbol_rootP,&symbol_lastP);
				continue;
			}
			elf_frob_symbol(symp,&punt);
#ifdef tc_frob_symbol
			if (!punt || symbol_used_in_reloc_p(symp))
				tc_frob_symbol(symp,punt);
#endif

			/*
			 * If we don't want to keep this symbol,splice it out
			 * of the chain now.  If EMIT_SECTION_SYMBOLS is 0,we
			 * never want section symbols.  Otherwise,we skip
			 * local symbols and symbols that the frob_symbol
			 * macros told us to punt,but we keep such symbols if
			 * they are used in relocs.
			 */
			if (symp == abs_section_sym
			    || (!EMIT_SECTION_SYMBOLS
				&& symbol_section_p(symp))
			/*
			 * Note that S_IS_EXTERNAL and S_IS_LOCAL are not
			 * always opposites.  Sometimes the former checks flags
			 * and the latter examines the name...
			 */
			    || (!S_IS_EXTERNAL(symp)
				&& (punt || S_IS_LOCAL(symp) ||
				(S_IS_WEAKREFD(symp) && !symbol_used_p(symp)))
				&& !symbol_used_in_reloc_p(symp))) {
				symbol_remove(symp,&symbol_rootP,&symbol_lastP);

				/*
				 * After symbol_remove,symbol_next(symp) still
				 * returns the one that came after it in the
				 * chain.  So we don't need to do any extra
				 * cleanup work here.
				 */
				continue;
			}
			/* Make sure we really got a value for the symbol.  */
			if (!symbol_resolved_p(symp)) {
				as_bad(("can't resolve value for symbol `%s'"),
				       S_GET_NAME(symp));
				symbol_mark_resolved(symp);
			}
			/*
			 * Set the value into the BFD symbol.  Up til now the
			 * value has only been kept in the gas symbolS struct.
			 */
			symbol_get_bfdsym(symp)->value = S_GET_VALUE(symp);

			/*
			 * A warning construct is a warning symbol followed by
			 * the symbol warned about.  Don't let anything
			 * object-format or target-specific muck with it; it's
			 * ready for output.
			 */
			if (symbol_get_bfdsym(symp)->flags & BSF_WARNING)
				skip_next_symbol = true;
		}
	}
	/*
	 * Now do any format-specific adjustments to the symbol table,such as
	 * adding file symbols.
	 */
	riscv_adjust_symtab();

	/* Stop if there is an error.  */
	if (!flag_always_generate_output && had_errors())
		return;

	/*
	 * Now that all the sizes are known,and contents correct,we can start
	 * writing to the file.
	 */
	set_symtab();

	/*
	 * If *_frob_file changes the symbol value at this point,it is
	 * responsible for moving the changed value into symp->bsym->value as
	 * well.  Hopefully all symbol value changing can be done in
	 * _frob_symbol.
	 */
	elf_frob_file();
	map_over_sections(write_relocs,(char *)0);
	elf_frob_file_after_relocs();

#if defined OBJ_ELF || defined OBJ_MAYBE_ELF
	if (IS_ELF && flag_use_elf_stt_common)
		stdoutput->flags |= BFD_CONVERT_ELF_COMMON|BFD_USE_ELF_STT_COMMON;
#endif

	/*
	 * Once all relocations have been written,we can compress the contents
	 * of the debug sections.  This needs to be done before we start
	 * writing any sections,because it will affect the file layout,which
	 * is fixed once we start writing contents.
	 */
	if (flag_compress_debug != COMPRESS_DEBUG_NONE) {
		uint32_t	flags = BFD_COMPRESS;
		if (flag_compress_debug == COMPRESS_DEBUG_GABI_ZLIB)
			flags = BFD_COMPRESS|BFD_COMPRESS_GABI;
		else
			if (flag_compress_debug == COMPRESS_DEBUG_ZSTD)
				flags = BFD_COMPRESS|BFD_COMPRESS_GABI|BFD_COMPRESS_ZSTD;
		stdoutput->flags |= flags & bfd_applicable_file_flags(stdoutput);
		if ((stdoutput->flags & BFD_COMPRESS) != 0)
			map_over_sections(compress_debug,(char *)0);
	}
	map_over_sections(write_contents,(char *)0);
}

/* Relax_align. Advance location counter to next address that has 'alignment'
 * lowest order bits all 0s,return size of adjustment made.  */
static relax_addressT relax_align(relax_addressT address,	/* Address now.  */
	  		int		alignment /* Alignment (binary).  */ )
{
	relax_addressT	mask;
	relax_addressT	new_address;

	mask = ~((relax_addressT) ~ 0 << alignment);
	new_address = (address + mask) & (~mask);
	return (new_address - address);
}

/* Now we have a segment,not a crowd of sub-segments,we can make fr_address
 * values.
 * 
 * Relax the frags.
 * 
 * After this,all frags in this segment have addresses that are correct within
 * the segment. Since segments live in different file addresses,these frag
 * addresses may not be the same as final object-file addresses.  */
static int	relax_segment(struct frag *segment_frag_root,segT segment,int pass)
{
	unsigned long	frag_count;
	struct frag    *fragP;
	relax_addressT	address;
	int		region;
	int		ret;

	/* In case md_estimate_size_before_relax() wants to make fixSs.  */
	subseg_change(segment,0);

	/*
	 * For each frag in segment: count and store  (a 1st guess of)
	 * fr_address.
	 */
	address = 0;
	region = 0;
	for (frag_count = 0,fragP = segment_frag_root;
	     fragP;
	     fragP = fragP->fr_next,frag_count++) {
		fragP->region = region;
		fragP->relax_marker = 0;
		fragP->fr_address = address;
		address += fragP->fr_fix;

		switch (fragP->fr_type) {
		case rs_fill:
			address += fragP->fr_offset * fragP->fr_var;
			break;

		case rs_align:
		case rs_align_code:
		case rs_align_test:
			{
				addressT	offset = relax_align(address,(int)fragP->fr_offset);

				if (fragP->fr_subtype != 0 && offset > fragP->fr_subtype)
					offset = 0;

				if (offset % fragP->fr_var != 0) {
					as_bad_where(fragP->fr_file,fragP->fr_line,
						     ngettext("alignment padding (%lu byte) "
						      "not a multiple of %ld",
					      "alignment padding (%lu bytes) "
						      "not a multiple of %ld",
						       (unsigned long)offset),
						     (unsigned long)offset,(long)fragP->fr_var);
					offset -= (offset % fragP->fr_var);
				}
				address += offset;
				region += 1;
			}
			break;

		case rs_org:
			/*
			 * Assume .org is nugatory. It will grow with 1st
			 * relax.
			 */
			region += 1;
			break;

		case rs_space:
		case rs_space_nop:
			break;

		case rs_machine_dependent:
			/*
			 * If fr_symbol is an expression,this call to
			 * resolve_symbol_value sets up the correct segment,
			 * which will likely be needed in
			 * md_estimate_size_before_relax.
			 */
			if (fragP->fr_symbol)
				resolve_symbol_value(fragP->fr_symbol);

			address += md_estimate_size_before_relax(fragP,segment);
			break;

		case rs_leb128:
			/*
			 * Initial guess is always 1; doing otherwise can
			 * result in stable solutions that are larger than the
			 * minimum.
			 */
			address += fragP->fr_offset = 1;
			break;

		case rs_cfa:
			address += eh_frame_estimate_size_before_relax(fragP);
			break;

		case rs_dwarf2dbg:
			address += dwarf2dbg_estimate_size_before_relax(fragP);
			break;

		case rs_sframe:
			as_bad("s frames aren't supported\n");
			break;

		default:
			BAD_CASE(fragP->fr_type);
			break;
		}
	}

	/* Do relax().  */
	{
		unsigned long	max_iterations;

		/* Cumulative address adjustment.  */
		offsetT		stretch;

		/*
		 * Have we made any adjustment this pass?  We can't just test
		 * stretch because one piece of code may have grown and another
		 * shrank.
		 */
		int		stretched;

		/*
		 * Most horrible,but gcc may give us some exception data that
		 * is impossible to assemble,of the form
		 * 
		 * .align 4 .byte 0,0 .uleb128 end - start start: .space 128*128
		 * - 1 .align 4 end:
		 * 
		 * If the leb128 is two bytes in size,then end-start is 128*128,
		 * which requires a three byte leb128.  If the leb128 is three
		 * bytes in size,then end-start is 128*128-1,which requires a
		 * two byte leb128.  We work around this dilemma by inserting
		 * an extra 4 bytes of alignment just after the .align.  This
		 * works because the data after the align is accessed relative
		 * to the end label.
		 * 
		 * This counter is used in a tiny state machine to detect whether
		 * a leb128 followed by an align is impossible to relax.
		 */
		int		rs_leb128_fudge = 0;

		/*
		 * We want to prevent going into an infinite loop where one
		 * frag grows depending upon the location of a symbol which is
		 * in turn moved by the growing frag.  eg:
		 * 
		 * foo = . .org foo+16 foo = .
		 * 
		 * So we dictate that this algorithm can be at most O2.
		 */
		max_iterations = frag_count * frag_count;
		/* Check for overflow.  */
		if (max_iterations < frag_count)
			max_iterations = frag_count;

		ret = 0;
		do {
			stretch = 0;
			stretched = 0;

			for (fragP = segment_frag_root; fragP; fragP = fragP->fr_next) {
				offsetT		growth = 0;
				addressT	was_address;
				offsetT		offset;
				symbolS        *symbolP;

				fragP->relax_marker ^= 1;
				was_address = fragP->fr_address;
				address = fragP->fr_address += stretch;
				symbolP = fragP->fr_symbol;
				offset = fragP->fr_offset;

				switch (fragP->fr_type) {
				case rs_fill:	/* .fill never relaxes.  */
					growth = 0;
					break;

				case rs_align:
				case rs_align_code:
				case rs_align_test:
					{
						addressT	oldoff,newoff;

						oldoff = relax_align(was_address + fragP->fr_fix,
								 (int)offset);
						newoff = relax_align(address + fragP->fr_fix,
								 (int)offset);

						if (fragP->fr_subtype != 0) {
							if (oldoff > fragP->fr_subtype)
								oldoff = 0;
							if (newoff > fragP->fr_subtype)
								newoff = 0;
						}
						growth = newoff - oldoff;

						/*
						 * If this align happens to
						 * follow a leb128 and we have
						 * determined that the leb128
						 * is bouncing in size,then
						 * break the cycle by inserting
						 * an extra alignment.
						 */
						if (growth < 0
						&& (rs_leb128_fudge & 16) != 0
						    && (rs_leb128_fudge & 15) >= 2) {
							segment_info_type *seginfo = seg_info(segment);
							struct obstack *ob = &seginfo->frchainP->frch_obstack;
							struct frag    *newf;

							newf = frag_alloc(ob);
							obstack_blank_fast(ob,fragP->fr_var);
							obstack_finish(ob);
							memcpy(newf,fragP,SIZEOF_STRUCT_FRAG);
							memcpy(newf->fr_literal,
							       fragP->fr_literal + fragP->fr_fix,
							       fragP->fr_var);
							newf->fr_type = rs_fill;
							newf->fr_address = address + fragP->fr_fix + newoff;
							newf->fr_fix = 0;
							newf->fr_offset = (((offsetT) 1 << fragP->fr_offset)
							     / fragP->fr_var);
							if (newf->fr_offset * newf->fr_var
							    != (offsetT) 1 << fragP->fr_offset) {
								newf->fr_offset = (offsetT) 1 << fragP->fr_offset;
								newf->fr_var = 1;
							}
							/*
							 * Include size of new
							 * frag in GROWTH.
							 */
							growth += newf->fr_offset * newf->fr_var;
							/*
							 * Adjust the new frag
							 * address for the
							 * amount we'll add
							 * when we process the
							 * new frag.
							 */
							newf->fr_address -= stretch + growth;
							newf->relax_marker ^= 1;
							fragP->fr_next = newf;
#ifdef DEBUG
							as_warn(("padding added"));
#endif
						}
					}
					break;

				case rs_org:
					{
						offsetT		target = offset;
						addressT	after;

						if (symbolP) {
							/*
							 * Convert from an
							 * actual address to an
							 * octet offset into
							 * the section.  Here
							 * it is assumed that
							 * the section's VMA is
							 * zero,and can omit
							 * subtracting it from
							 * the symbol's value
							 * to get the address
							 * offset.
							 */
							know(S_GET_SEGMENT(symbolP)->vma == 0);
							target += S_GET_VALUE(symbolP) * OCTETS_PER_BYTE;
						}
						know(fragP->fr_next);
						after = fragP->fr_next->fr_address + stretch;
						growth = target - after;

						/*
						 * Growth may be negative,but
						 * variable part of frag cannot
						 * have fewer than 0 chars.
						 * That is,we can't .org
						 * backwards.
						 */
						if ((offsetT) (address + fragP->fr_fix) > target) {
							growth = 0;

							/*
							 * Don't error on first
							 * few frag relax
							 * passes. The symbol
							 * might be an
							 * expression involving
							 * symbol values from
							 * other sections.  If
							 * those sections have
							 * not yet been
							 * processed their
							 * frags will all have
							 * zero addresses,so
							 * we will calculate
							 * incorrect values for
							 * them.  The number of
							 * passes we allow
							 * before giving an
							 * error is somewhat
							 * arbitrary.  It
							 * should be at least
							 * one,with larger
							 * values requiring
							 * increasingly
							 * contrived
							 * dependencies between
							 * frags to trigger a
							 * false error.
							 */
							if (pass < 2) {
								/*
								 * Force
								 * another
								 * pass.
								 */
								ret = 1;
								break;
							}
							as_bad_where(fragP->fr_file,fragP->fr_line,
								     ("attempt to move .org backwards"));

							/*
							 * We've issued an
							 * error message.
							 * Change the frag to
							 * avoid cascading
							 * errors.
							 */
							fragP->fr_type = rs_align;
							fragP->fr_subtype = 0;
							fragP->fr_offset = 0;
							fragP->fr_fix = after - address;
						}
					}
					break;

				case rs_space:
				case rs_space_nop:
					growth = 0;
					if (symbolP) {
						offsetT		amount;

						amount = S_GET_VALUE(symbolP);
						if (S_GET_SEGMENT(symbolP) != absolute_section
						    || S_IS_COMMON(symbolP)
						  || !S_IS_DEFINED(symbolP)) {
							as_bad_where(fragP->fr_file,fragP->fr_line,
								     (".space,.nops or .fill specifies non-absolute value"));
							/*
							 * Prevent repeat of
							 * this error message.
							 */
							fragP->fr_symbol = 0;
						} else
							if (amount < 0) {
								/*
								 * Don't error
								 * on first few
								 * frag relax
								 * passes. See
								 * rs_org
								 * comment for
								 * a longer
								 * explanation.
								 */
								if (pass < 2) {
									ret = 1;
									break;
								}
								as_warn_where(fragP->fr_file,fragP->fr_line,
									      (".space,.nops or .fill with negative value,ignored"));
								fragP->fr_symbol = 0;
							} else
								growth = (was_address + fragP->fr_fix + amount
									  - fragP->fr_next->fr_address);
					}
					break;

				case rs_machine_dependent:
					growth = md_relax_frag(segment,fragP,stretch);
					break;

				case rs_leb128:
					{
						valueT		value;
						offsetT		size;

						value = resolve_symbol_value(fragP->fr_symbol);
						size = sizeof_leb128(value,fragP->fr_subtype);
						growth = size - fragP->fr_offset;
						fragP->fr_offset = size;
					}
					break;

				case rs_cfa:
					growth = eh_frame_relax_frag(fragP);
					break;

				case rs_dwarf2dbg:
					growth = dwarf2dbg_relax_frag(fragP);
					break;

				case rs_sframe:
					as_bad("s frames aren't supported\n");
					//growth = sframe_relax_frag(fragP);
					break;

				default:
					BAD_CASE(fragP->fr_type);
					break;
				}
				if (growth) {
					stretch += growth;
					stretched = 1;
					if (fragP->fr_type == rs_leb128)
						rs_leb128_fudge += 16;
					else
						if (fragP->fr_type == rs_align
						&& (rs_leb128_fudge & 16) != 0
						    && stretch == 0)
							rs_leb128_fudge += 16;
						else
							rs_leb128_fudge = 0;
				}
			}

			if (stretch == 0
			    && (rs_leb128_fudge & 16) == 0
			    && (rs_leb128_fudge & -16) != 0)
				rs_leb128_fudge += 1;
			else
				rs_leb128_fudge = 0;
		}
		/* Until nothing further to relax.  */
		while (stretched && --max_iterations);

		if (stretched)
			as_fatal(("Infinite loop encountered whilst attempting to compute the addresses of symbols in section %s"),
				 segment_name(segment));
	}

	for (fragP = segment_frag_root; fragP; fragP = fragP->fr_next)
		if (fragP->last_fr_address != fragP->fr_address) {
			fragP->last_fr_address = fragP->fr_address;
			ret = 1;
		}
	return ret;
}

static void	number_to_chars_littleendian(char *buf,valueT val,int n)
{
	if (n <= 0)
		abort();
	while (n--) {
		*buf++ = val & 0xff;
		val >>= 8;
	}
}

/* ====================================================================== app.c */

#define MULTIBYTE_WARN_COUNT_LIMIT 10
static unsigned int multibyte_warn_count = 0;

static bool	scan_for_multibyte_characters(const unsigned char *start,
			     		const		unsigned char *end,
					  		bool		warn)
{
	if (end <= start)
		return false;

	if (warn && multibyte_warn_count > MULTIBYTE_WARN_COUNT_LIMIT)
		return false;

	bool		found = false;

	while (start < end) {
		unsigned char	c;

		if ((c = *start++) <= 0x7f)
			continue;

		if (!warn)
			return true;

		found = true;

		const char     *filename;
		unsigned int	lineno;

		filename = as_where(&lineno);
		if (filename == NULL)
			as_warn(("multibyte character (%#x) encountered in input"),c);
		else
			if (lineno == 0)
				as_warn(("multibyte character (%#x) encountered in %s"),c,filename);
			else
				as_warn(("multibyte character (%#x) encountered in %s at or near line %u"),c,filename,lineno);

		if (++multibyte_warn_count == MULTIBYTE_WARN_COUNT_LIMIT) {
			as_warn(("further multibyte character warnings suppressed"));
			break;
		}
	}

	return found;
}

/* =======================================================**** elf64-riscv.c */
/*
 * RISC-V-specific support for 64-bit ELF. This file handles RISC-V ELF
 * targets.
 * RISC-V ELF specific backend routines. */
enum riscv_spec_class {
	/* ISA spec.  */
	ISA_SPEC_CLASS_NONE = 0,ISA_SPEC_CLASS_2P2,ISA_SPEC_CLASS_20190608,
	ISA_SPEC_CLASS_20191213,ISA_SPEC_CLASS_DRAFT,

	/* Privileged spec.  */
	PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_1P10,
	PRIV_SPEC_CLASS_1P11,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT,
};

struct riscv_spec {
	const char     *name;
	enum riscv_spec_class spec_class;
};


#define RISCV_GET_SPEC_CLASS(UTYPE,LTYPE,NAME,CLASS)			\
  do									\
    {									\
      if (NAME == NULL)							\
	break;								\
									\
      int i_spec = UTYPE##_SPEC_CLASS_NONE + 1;				\
      for (; i_spec < UTYPE##_SPEC_CLASS_DRAFT; i_spec++)		\
	{								\
	  int j_spec = i_spec - UTYPE##_SPEC_CLASS_NONE -1;		\
	  if (riscv_##LTYPE##_specs[j_spec].name			\
	      && strcmp (riscv_##LTYPE##_specs[j_spec].name,NAME) == 0)\
	  {								\
	    CLASS = riscv_##LTYPE##_specs[j_spec].spec_class;		\
	    break;							\
	  }								\
	}								\
    }									\
  while (0)

#define RISCV_GET_SPEC_NAME(UTYPE,LTYPE,NAME,CLASS)			\
  (NAME) = riscv_##LTYPE##_specs[(CLASS) - UTYPE##_SPEC_CLASS_NONE - 1].name

#define RISCV_GET_ISA_SPEC_CLASS(NAME,CLASS)	\
  RISCV_GET_SPEC_CLASS(ISA,isa,NAME,CLASS)
#define RISCV_GET_PRIV_SPEC_CLASS(NAME,CLASS)	\
  RISCV_GET_SPEC_CLASS(PRIV,priv,NAME,CLASS)
#define RISCV_GET_PRIV_SPEC_NAME(NAME,CLASS)	\
  RISCV_GET_SPEC_NAME(PRIV,priv,NAME,CLASS)

static void	riscv_get_priv_spec_class_from_numbers(unsigned int,
			      		unsigned	int ,unsigned int,
			     		enum		riscv_spec_class *);

#define RISCV_UNKNOWN_VERSION -1

struct riscv_elf_params {
	/* Whether to relax code sequences to GP-relative addressing.  */
	bool		relax_gp;
};

static reloc_howto_type *
		riscv_reloc_name_lookup(bfd *,const char *);

static reloc_howto_type *riscv_reloc_type_lookup(bfd *,bfd_reloc_code_real_type);

/* The information of architecture attribute.  */
typedef struct riscv_subset_t {
	const char     *name;
	int		major_version;
	int		minor_version;
	struct riscv_subset_t *next;
} riscv_subset_t;

typedef struct {
	riscv_subset_t *head;
	riscv_subset_t *tail;
	const char     *arch_str;
}	riscv_subset_list_t;


static void	riscv_release_subset_list(riscv_subset_list_t *);
static void	riscv_add_subset(riscv_subset_list_t *,
			     		const		char  *,int,int);
static bool	riscv_lookup_subset(const riscv_subset_list_t *,
		  		const		char  *,riscv_subset_t **);

typedef struct {
	riscv_subset_list_t *subset_list;
	void            (*error_handler) (const char *,
					  ...)		ATTRIBUTE_PRINTF_1;
	unsigned       *xlen;
	enum riscv_spec_class *isa_spec;
	bool		check_unknown_prefixed_ext;
}	riscv_parse_subset_t;
/* Add/Remove an extension to/from the subset list.  This is used for the
 * .option rvc or norvc,and .option arch directives.  */
static bool	riscv_parse_subset(riscv_parse_subset_t * rps,const char *arch);
/* Parsing extension version. Return Value: Points to the end of version
 * Arguments: `p`: Curent parsing position. `major_version`: Parsed major
 * version. `minor_version`: Parsed minor version.  */
static const char *riscv_parsing_subset_version(const char *p,
	      		int          *major_version,int *minor_version)
{
	bool		major_p = true;
	int		version = 0;
	char		np;

	*major_version = 0;
	*minor_version = 0;
	for (; *p; ++p) {
		if (*p == 'p') {
			np = *(p + 1);

			/* Might be beginning of `p` extension.  */
			if (!ISDIGIT(np))
				break;
			*major_version = version;
			major_p = false;
			version = 0;
		} else
			if (ISDIGIT(*p))
				version = (version * 10) + (*p - '0');
			else
				break;
	}
	if (major_p)
		*major_version = version;
	else
		*minor_version = version;
	/* We can not find any version in string.  */
	if (*major_version == 0 && *minor_version == 0) {
		*major_version = RISCV_UNKNOWN_VERSION;
		*minor_version = RISCV_UNKNOWN_VERSION;
	}
	return p;
}
/* Array is used to compare the orders of standard extensions quickly.  */
static int	riscv_ext_order[26] = {0};
/* ISA extension prefixed name class.  Must define them in parsing order.  */
enum riscv_prefix_ext_class {
	RV_ISA_CLASS_Z = 1, RV_ISA_CLASS_S, RV_ISA_CLASS_ZXM,
	RV_ISA_CLASS_X, RV_ISA_CLASS_SINGLE
};
/* Record the strings of the prefixed extensions,and their corresponding
 * classes.  The more letters of the prefix string,the more forward it must be
 * defined.  Otherwise,the riscv_get_prefix_class will map it to the wrong
 * classes.  */
struct riscv_parse_prefix_config {
	/* Class of the extension. */
	enum riscv_prefix_ext_class class;
	/* Prefix string for error printing and internal parser usage.  */
	const char     *prefix;
};
static const struct riscv_parse_prefix_config parse_config[] = {
	{RV_ISA_CLASS_ZXM,"zxm"},
	{RV_ISA_CLASS_Z,"z"},
	{RV_ISA_CLASS_S,"s"},
	{RV_ISA_CLASS_X,"x"},
	{RV_ISA_CLASS_SINGLE,NULL}
};

/* List all extensions that binutils should know about.  */
struct riscv_supported_ext {
	const char     *name;
	enum riscv_spec_class isa_spec_class;
	int		major_version;
	int		minor_version;
	unsigned long	default_enable;
};
#define EXT_DEFAULT 1
/* The standard extensions must be added in canonical order.  */
static struct riscv_supported_ext riscv_supported_std_ext[] =
{
	{"e",ISA_SPEC_CLASS_20191213,1,9,0},
	{"e",ISA_SPEC_CLASS_20190608,1,9,0},
	{"e",ISA_SPEC_CLASS_2P2,1,9,0},
	{"i",ISA_SPEC_CLASS_20191213,2,1,0},
	{"i",ISA_SPEC_CLASS_20190608,2,1,0},
	{"i",ISA_SPEC_CLASS_2P2,2,0,0},
	/*
	 * The g is a special case which we don't want to output it,but still
	 * need it when adding implicit extensions.
	 */
	{"g",ISA_SPEC_CLASS_NONE,RISCV_UNKNOWN_VERSION,RISCV_UNKNOWN_VERSION,EXT_DEFAULT},
	{"m",ISA_SPEC_CLASS_20191213,2,0,0},
	{"m",ISA_SPEC_CLASS_20190608,2,0,0},
	{"m",ISA_SPEC_CLASS_2P2,2,0,0},
	{"a",ISA_SPEC_CLASS_20191213,2,1,0},
	{"a",ISA_SPEC_CLASS_20190608,2,0,0},
	{"a",ISA_SPEC_CLASS_2P2,2,0,0},
	{"f",ISA_SPEC_CLASS_20191213,2,2,0},
	{"f",ISA_SPEC_CLASS_20190608,2,2,0},
	{"f",ISA_SPEC_CLASS_2P2,2,0,0},
	{"d",ISA_SPEC_CLASS_20191213,2,2,0},
	{"d",ISA_SPEC_CLASS_20190608,2,2,0},
	{"d",ISA_SPEC_CLASS_2P2,2,0,0},
	{"q",ISA_SPEC_CLASS_20191213,2,2,0},
	{"q",ISA_SPEC_CLASS_20190608,2,2,0},
	{"q",ISA_SPEC_CLASS_2P2,2,0,0},
	{"c",ISA_SPEC_CLASS_20191213,2,0,0},
	{"c",ISA_SPEC_CLASS_20190608,2,0,0},
	{"c",ISA_SPEC_CLASS_2P2,2,0,0},
	{"v",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"h",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{NULL,0,0,0,0}
};
static struct riscv_supported_ext riscv_supported_std_z_ext[] =
{
	{"zicbom",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zicbop",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zicboz",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zicsr",ISA_SPEC_CLASS_20191213,2,0,0},
	{"zicsr",ISA_SPEC_CLASS_20190608,2,0,0},
	{"zifencei",ISA_SPEC_CLASS_20191213,2,0,0},
	{"zifencei",ISA_SPEC_CLASS_20190608,2,0,0},
	{"zihintpause",ISA_SPEC_CLASS_DRAFT,2,0,0},
	{"zmmul",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zawrs",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zfh",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zfhmin",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zfinx",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zdinx",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zqinx",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zhinx",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zhinxmin",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zbb",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zba",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zbc",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zbs",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zbkb",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zbkc",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zbkx",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zk",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zkn",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zknd",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zkne",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zknh",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zkr",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zks",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zksed",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zksh",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zkt",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zve32x",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zve32f",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zve32d",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zve64x",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zve64f",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zve64d",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zvl32b",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zvl64b",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zvl128b",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zvl256b",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zvl512b",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zvl1024b",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zvl2048b",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zvl4096b",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zvl8192b",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zvl16384b",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zvl32768b",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"zvl65536b",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"ztso",ISA_SPEC_CLASS_DRAFT,0,1,0},
	{NULL,0,0,0,0}
};
static struct riscv_supported_ext riscv_supported_std_s_ext[] =
{
	{"smaia",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"smepmp",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"smstateen",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"ssaia",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"sscofpmf",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"ssstateen",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"sstc",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"svinval",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"svnapot",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"svpbmt",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{NULL,0,0,0,0}
};
static struct riscv_supported_ext riscv_supported_std_zxm_ext[] = {
	{NULL,0,0,0,0}
};
static struct riscv_supported_ext riscv_supported_vendor_x_ext[] =
{
	{"xtheadba",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"xtheadbb",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"xtheadbs",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"xtheadcmo",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"xtheadcondmov",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"xtheadfmemidx",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"xtheadfmv",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"xtheadint",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"xtheadmac",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"xtheadmemidx",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"xtheadmempair",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{"xtheadsync",ISA_SPEC_CLASS_DRAFT,1,0,0},
	/*
	 * XVentanaCondOps:
	 * https://github.com/ventanamicro/ventana-custom-extensions/releases/do
	 * wnload/v1.0.0/ventana-custom-extensions-v1.0.0.pdf
	 */
	{"xventanacondops",ISA_SPEC_CLASS_DRAFT,1,0,0},
	{NULL,0,0,0,0}
};
/* Get the prefixed name class for the extensions,the class also means the
 * order of the prefixed extensions.  */
static enum riscv_prefix_ext_class riscv_get_prefix_class(const char *arch)
{
	int		i = 0;
	while (parse_config[i].class != RV_ISA_CLASS_SINGLE) {
		if (strncmp(arch,parse_config[i].prefix,
			    strlen(parse_config[i].prefix)) == 0)
			return parse_config[i].class;
		i++;
	}
	return RV_ISA_CLASS_SINGLE;
}
/* Check KNOWN_EXTS to see if the EXT is supported.  */
static bool	riscv_known_prefixed_ext(const char *ext,
			   		struct	riscv_supported_ext *known_exts)
{
	size_t		i;
	for (i = 0; known_exts[i].name != NULL; ++i)
		if (strcmp(ext,known_exts[i].name) == 0)
			return true;
	return false;
}
static bool	riscv_recognized_prefixed_ext(const char *ext)
{
	enum riscv_prefix_ext_class class = riscv_get_prefix_class(ext);
	switch (class) {
	case RV_ISA_CLASS_Z:
		return riscv_known_prefixed_ext(ext,riscv_supported_std_z_ext);
	case RV_ISA_CLASS_ZXM:
		return riscv_known_prefixed_ext(ext,riscv_supported_std_zxm_ext);
	case RV_ISA_CLASS_S:
		return riscv_known_prefixed_ext(ext,riscv_supported_std_s_ext);
	case RV_ISA_CLASS_X:
		/* Only the single x is unrecognized.  */
		if (strcmp(ext,"x") != 0)
			return true;
	default:
		break;
	}
	return false;
}
/* Remove the SUBSET from the subset list.  */
static void	riscv_remove_subset(riscv_subset_list_t * subset_list,
						const		char  *subset)
{
	riscv_subset_t *Current = subset_list->head;
	riscv_subset_t *pre = NULL;
	for (; Current != NULL; pre = Current,Current = Current->next) {
		if (strcmp(Current->name,subset) == 0) {
			if (pre == NULL)
				subset_list->head = Current->next;
			else
				pre->next = Current->next;
			if (Current->next == NULL)
				subset_list->tail = pre;
			free((void *)Current->name);
			free(Current);
			break;
		}
	}
}
/* Get the default versions from the riscv_supported_*ext tables.  */
static void	riscv_get_default_ext_version(enum riscv_spec_class *default_isa_spec,
				const		char  *name,int *major_version,
				    		int          *minor_version)
{
	if (name == NULL
	    || default_isa_spec == NULL
	    || *default_isa_spec == ISA_SPEC_CLASS_NONE)
		return;

	struct riscv_supported_ext *table = NULL;
	enum riscv_prefix_ext_class class = riscv_get_prefix_class(name);
	switch (class) {
	case RV_ISA_CLASS_ZXM:
		table = riscv_supported_std_zxm_ext;
		break;
	case RV_ISA_CLASS_Z:
		table = riscv_supported_std_z_ext;
		break;
	case RV_ISA_CLASS_S:
		table = riscv_supported_std_s_ext;
		break;
	case RV_ISA_CLASS_X:
		table = riscv_supported_vendor_x_ext;
		break;
	default:
		table = riscv_supported_std_ext;
	}

	int		i = 0;
	while (table != NULL && table[i].name != NULL) {
		if (strcmp(table[i].name,name) == 0
		    && (table[i].isa_spec_class == ISA_SPEC_CLASS_DRAFT
			|| table[i].isa_spec_class == *default_isa_spec)) {
			*major_version = table[i].major_version;
			*minor_version = table[i].minor_version;
			return;
		}
		i++;
	}
}
/* Add the extension to the subset list.  Search the list first,and then find
 * the right place to add.  */
static void	riscv_add_subset(riscv_subset_list_t * subset_list,
	       		const		char  *subset,int major,int minor)
{
	riscv_subset_t *Current,*new;

	if (riscv_lookup_subset(subset_list,subset,&Current))
		return;

	new = xmalloc(sizeof *new);
	new->name = strdup(subset);
	new->major_version = major;
	new->minor_version = minor;
	new->next = NULL;

	if (Current != NULL) {
		new->next = Current->next;
		Current->next = new;
	} else {
		new->next = subset_list->head;
		subset_list->head = new;
	}

	if (new->next == NULL)
		subset_list->tail = new;
}
/* Find the default versions for the extension before adding them to the subset
 * list,if their versions are RISCV_UNKNOWN_VERSION. Afterwards,report errors
 * if we can not find their default versions.  */
static void	riscv_parse_add_subset(riscv_parse_subset_t * rps,
				   		const		char  *subset,
				   		int		major   ,
				   		int		minor   ,
				   		bool		implicit)
{
	int		major_version = major;
	int		minor_version = minor;

	if (major_version == RISCV_UNKNOWN_VERSION
	    || minor_version == RISCV_UNKNOWN_VERSION)
		riscv_get_default_ext_version(rps->isa_spec,subset,
					      &major_version,&minor_version);

	/* We don't care the versions of the implicit extensions.  */
	if (!implicit
	    && (major_version == RISCV_UNKNOWN_VERSION
		|| minor_version == RISCV_UNKNOWN_VERSION)) {
		if (subset[0] == 'x')
			rps->error_handler
				(("x ISA extension `%s' must be set with the versions"),
				 subset);
		/* Allow old ISA spec can recognize zicsr and zifencei.  */
		else
			if (strcmp(subset,"zicsr") != 0
			    && strcmp(subset,"zifencei") != 0)
				rps->error_handler
					(("cannot find default versions of the ISA extension `%s'"),
					 subset);
		return;
	}
	riscv_add_subset(rps->subset_list,subset,
			 major_version,minor_version);
}
/* Check extensions conflicts.  */
static bool	riscv_parse_check_conflicts(riscv_parse_subset_t * rps)
{
	riscv_subset_t *subset = NULL;
	int		xlen = *rps->xlen;
	bool		no_conflict = true;

	if (riscv_lookup_subset(rps->subset_list,"e",&subset)
	    && xlen > 32) {
		rps->error_handler
			(("rv%d does not support the `e' extension"),xlen);
		no_conflict = false;
	}
	if (riscv_lookup_subset(rps->subset_list,"q",&subset)
	    && (subset->major_version < 2 || (subset->major_version == 2
					      && subset->minor_version < 2))
	    && xlen < 64) {
		rps->error_handler(("rv%d does not support the `q' extension"),xlen);
		no_conflict = false;
	}
	if (riscv_lookup_subset(rps->subset_list,"zfinx",&subset)
	    && riscv_lookup_subset(rps->subset_list,"f",&subset)) {
		rps->error_handler
			(("`zfinx' is conflict with the `f/d/q/zfh/zfhmin' extension"));
		no_conflict = false;
	}
	bool		support_zve = false;
	bool		support_zvl = false;
	riscv_subset_t *s = rps->subset_list->head;
	for (; s != NULL; s = s->next) {
		if (!support_zve
		    && strncmp(s->name,"zve",3) == 0)
			support_zve = true;
		if (!support_zvl
		    && strncmp(s->name,"zvl",3) == 0)
			support_zvl = true;
		if (support_zve && support_zvl)
			break;
	}
	if (support_zvl && !support_zve) {
		rps->error_handler
			(("zvl*b extensions need to enable either `v' or `zve' extension"));
		no_conflict = false;
	}
	return no_conflict;
}
/* Record all implicit information for the subsets.  */
struct riscv_implicit_subset {
	const char     *subset_name;
	const char     *implicit_name;
	/* A function to determine if we need to add the implicit subset.  */
			bool          (*check_func) (const char *,riscv_subset_t *);
};
static bool	check_implicit_always(const char *implicit ATTRIBUTE_UNUSED,
		       		riscv_subset_t * subset ATTRIBUTE_UNUSED)
{
	return true;
}
/* Add the IMPLICIT only when the version of SUBSET less than 2.1.  */
static bool	check_implicit_for_i(const char *implicit ATTRIBUTE_UNUSED,
				 		riscv_subset_t * subset)
{
	return (subset->major_version < 2
		|| (subset->major_version == 2
		    && subset->minor_version < 1));
}
static struct riscv_implicit_subset riscv_implicit_subsets[] =
{
	{"e","i",check_implicit_always},
	{"i","zicsr",check_implicit_for_i},
	{"i","zifencei",check_implicit_for_i},
	{"g","i",check_implicit_always},
	{"g","m",check_implicit_always},
	{"g","a",check_implicit_always},
	{"g","f",check_implicit_always},
	{"g","d",check_implicit_always},
	{"g","zicsr",check_implicit_always},
	{"g","zifencei",check_implicit_always},
	{"m","zmmul",check_implicit_always},
	{"h","zicsr",check_implicit_always},
	{"q","d",check_implicit_always},
	{"v","d",check_implicit_always},
	{"v","zve64d",check_implicit_always},
	{"v","zvl128b",check_implicit_always},
	{"zve64d","d",check_implicit_always},
	{"zve64d","zve64f",check_implicit_always},
	{"zve64f","zve32f",check_implicit_always},
	{"zve64f","zve64x",check_implicit_always},
	{"zve64f","zvl64b",check_implicit_always},
	{"zve32f","f",check_implicit_always},
	{"zve32f","zvl32b",check_implicit_always},
	{"zve32f","zve32x",check_implicit_always},
	{"zve64x","zve32x",check_implicit_always},
	{"zve64x","zvl64b",check_implicit_always},
	{"zve32x","zvl32b",check_implicit_always},
	{"zvl65536b","zvl32768b",check_implicit_always},
	{"zvl32768b","zvl16384b",check_implicit_always},
	{"zvl16384b","zvl8192b",check_implicit_always},
	{"zvl8192b","zvl4096b",check_implicit_always},
	{"zvl4096b","zvl2048b",check_implicit_always},
	{"zvl2048b","zvl1024b",check_implicit_always},
	{"zvl1024b","zvl512b",check_implicit_always},
	{"zvl512b","zvl256b",check_implicit_always},
	{"zvl256b","zvl128b",check_implicit_always},
	{"zvl128b","zvl64b",check_implicit_always},
	{"zvl64b","zvl32b",check_implicit_always},
	{"d","f",check_implicit_always},
	{"zfh","zfhmin",check_implicit_always},
	{"zfhmin","f",check_implicit_always},
	{"f","zicsr",check_implicit_always},
	{"zqinx","zdinx",check_implicit_always},
	{"zdinx","zfinx",check_implicit_always},
	{"zhinx","zhinxmin",check_implicit_always},
	{"zhinxmin","zfinx",check_implicit_always},
	{"zfinx","zicsr",check_implicit_always},
	{"zk","zkn",check_implicit_always},
	{"zk","zkr",check_implicit_always},
	{"zk","zkt",check_implicit_always},
	{"zkn","zbkb",check_implicit_always},
	{"zkn","zbkc",check_implicit_always},
	{"zkn","zbkx",check_implicit_always},
	{"zkn","zkne",check_implicit_always},
	{"zkn","zknd",check_implicit_always},
	{"zkn","zknh",check_implicit_always},
	{"zks","zbkb",check_implicit_always},
	{"zks","zbkc",check_implicit_always},
	{"zks","zbkx",check_implicit_always},
	{"zks","zksed",check_implicit_always},
	{"zks","zksh",check_implicit_always},
	{"smaia","ssaia",check_implicit_always},
	{"smstateen","ssstateen",check_implicit_always},
	{"smepmp","zicsr",check_implicit_always},
	{"ssaia","zicsr",check_implicit_always},
	{"sscofpmf","zicsr",check_implicit_always},
	{"ssstateen","zicsr",check_implicit_always},
	{"sstc","zicsr",check_implicit_always},
	{NULL,NULL,NULL}
};
/* Add the implicit extensions.  */
static void	riscv_parse_add_implicit_subsets(riscv_parse_subset_t * rps)
{
	struct riscv_implicit_subset *t = riscv_implicit_subsets;
	for (; t->subset_name; t++) {
		riscv_subset_t *subset = NULL;
		if (riscv_lookup_subset(rps->subset_list,t->subset_name,&subset)
		    && t->check_func(t->implicit_name,subset))
			riscv_parse_add_subset(rps,t->implicit_name,
					       RISCV_UNKNOWN_VERSION,
					       RISCV_UNKNOWN_VERSION,true);
	}
}
static bool	riscv_update_subset(riscv_parse_subset_t * rps,const char *str)
{
	const char     *p = str;

	do {
		int		major_version = RISCV_UNKNOWN_VERSION;
		int		minor_version = RISCV_UNKNOWN_VERSION;

		bool		removed = false;
		switch (*p) {
		case '+':
			removed = false;
			break;
		case '-':
			removed = true;
			break;
		default:
			riscv_release_subset_list(rps->subset_list);
			return riscv_parse_subset(rps,p);
		}
		++p;

		char           *subset = strdup(p);
		char           *q = subset;
		const char     *end_of_version;
		/* Extract the whole prefixed extension by ','.  */
		while (*q != '\0' && *q != ',')
			q++;

		/*
		 * Look forward to the first letter which is not
		 * <major>p<minor>.
		 */
		bool		find_any_version = false;
		bool		find_minor_version = false;
		size_t		len = q - subset;
		size_t		i;
		for (i = len; i > 0; i--) {
			q--;
			if (ISDIGIT(*q))
				find_any_version = true;
			else
				if (find_any_version
				    && !find_minor_version
				    && *q == 'p'
				    && ISDIGIT(*(q - 1)))
					find_minor_version = true;
				else
					break;
		}
		if (len > 0)
			q++;

		/*
		 * Check if the end of extension is 'p' or not.  If yes,then
		 * the second letter from the end cannot be number.
		 */
		if (len > 1 && *(q - 1) == 'p' && ISDIGIT(*(q - 2))) {
			*q = '\0';
			rps->error_handler
				(("invalid ISA extension ends with <number>p "
				  "in .option arch `%s'"),str);
			free(subset);
			return false;
		}
		end_of_version =
			riscv_parsing_subset_version(q,&major_version,&minor_version);
		*q = '\0';
		if (end_of_version == NULL) {
			free(subset);
			return false;
		}
		if (strlen(subset) == 0
		    || (strlen(subset) == 1
			&& riscv_ext_order[(*subset - 'a')] == 0)
		    || (strlen(subset) > 1
			&& rps->check_unknown_prefixed_ext
			&& !riscv_recognized_prefixed_ext(subset))) {
			rps->error_handler
				(("unknown ISA extension `%s' in .option arch `%s'"),
				 subset,str);
			free(subset);
			return false;
		}
		if (strcmp(subset,"i") == 0
		    || strcmp(subset,"e") == 0
		    || strcmp(subset,"g") == 0) {
			rps->error_handler
				(("cannot + or - base extension `%s' in .option "
				  "arch `%s'"),subset,str);
			free(subset);
			return false;
		}
		if (removed)
			riscv_remove_subset(rps->subset_list,subset);
		else
			riscv_parse_add_subset(rps,subset,major_version,minor_version,true);
		p += end_of_version - subset;
		free(subset);
	}
	while (*p++ == ',');

	riscv_parse_add_implicit_subsets(rps);
	return riscv_parse_check_conflicts(rps);
}
/* Release subset list.  */
static void	riscv_release_subset_list(riscv_subset_list_t * subset_list)
{
	while (subset_list->head != NULL) {
		riscv_subset_t *next = subset_list->head->next;
		free((void *)subset_list->head->name);
		free(subset_list->head);
		subset_list->head = next;
	}

	subset_list->tail = NULL;

	if (subset_list->arch_str != NULL) {
		free((void *)subset_list->arch_str);
		subset_list->arch_str = NULL;
	}
}
static void	riscv_add_subset(riscv_subset_list_t *, const char *,int,int);
static const struct riscv_supported_ext *riscv_all_supported_ext[] = {
	riscv_supported_std_ext, riscv_supported_std_z_ext,
	riscv_supported_std_s_ext, riscv_supported_std_zxm_ext,
	riscv_supported_vendor_x_ext, NULL
};
static void	riscv_set_default_arch(riscv_parse_subset_t * rps)
{
	unsigned long	enable = EXT_DEFAULT;
	int		i         ,j;
	for (i = 0; riscv_all_supported_ext[i] != NULL; i++) {
		const struct riscv_supported_ext *table = riscv_all_supported_ext[i];
		for (j = 0; table[j].name != NULL; j++) {
			bool		implicit = false;
			if (strcmp(table[j].name,"g") == 0)
				implicit = true;
			if (table[j].default_enable & enable)
				riscv_parse_add_subset(rps,table[j].name,
						       RISCV_UNKNOWN_VERSION,
					     RISCV_UNKNOWN_VERSION,implicit);
		}
	}
}
/* Parsing function for both standard and prefixed extensions. Return Value:
 * Points to the end of extensions. Arguments: `rps`: Hooks and status for
 * parsing extensions. `arch`: Full ISA string. `p`: Curent parsing position. */
static const char *riscv_parse_extensions(riscv_parse_subset_t * rps,
		     		const		char  *arch,const char *p)
{
	/* First letter must start with i,e or g.  */
	if (*p != 'e' && *p != 'i' && *p != 'g') {
		rps->error_handler("%s: first ISA extension must be `e',`i' or `g'",arch);
		return NULL;
	}
	while (*p != '\0') {
		if (*p == '_') {
			p++;
			continue;
		}
		char           *subset = strdup(p);
		char           *q = subset;	/* Start of version.  */
		const char     *end_of_version;
		bool		implicit = false;

		enum riscv_prefix_ext_class class = riscv_get_prefix_class(p);
		if (class == RV_ISA_CLASS_SINGLE) {
			if (riscv_ext_order[(*subset - 'a')] == 0) {
				rps->error_handler
					(("%s: unknown standard ISA extension or prefix class `%c'"),
					 arch,*subset);
				free(subset);
				return NULL;
			}
			q++;
		} else {
			/* Extract the whole prefixed extension by '_'.  */
			while (*++q != '\0' && *q != '_');
			/*
			 * Look forward to the first letter which is not
			 * <major>p<minor>.
			 */
			bool		find_any_version = false;
			bool		find_minor_version = false;
			while (1) {
				q--;
				if (ISDIGIT(*q))
					find_any_version = true;
				else
					if (find_any_version
					    && !find_minor_version
					    && *q == 'p'
					    && ISDIGIT(*(q - 1)))
						find_minor_version = true;
					else
						break;
			}
			q++;

			/* Check if the end of extension is 'p' or not.  If yes,then the 
			 * second letter from the end cannot be * number.  */
			if (*(q - 1) == 'p' && ISDIGIT(*(q - 2))) {
				*q = '\0';
				rps->error_handler("%s: invalid prefixed ISA extension `%s' ends with <number>p",
					 arch,subset);
				free(subset);
				return NULL;
			}
		}

		int		major_version = RISCV_UNKNOWN_VERSION;
		int		minor_version = RISCV_UNKNOWN_VERSION;
		end_of_version =
			riscv_parsing_subset_version(q,&major_version,&minor_version);
		*q = '\0';
		if (end_of_version == NULL) {
			free(subset);
			return NULL;
		}
		/* Check if the prefixed extension name is well-formed.  */
		if (class != RV_ISA_CLASS_SINGLE
		    && rps->check_unknown_prefixed_ext
		    && !riscv_recognized_prefixed_ext(subset)) {
			rps->error_handler
				(("%s: unknown prefixed ISA extension `%s'"),
				 arch,subset);
			free(subset);
			return NULL;
		}
		/* Added g as an implicit extension.  */
		if (class == RV_ISA_CLASS_SINGLE
		    && strcmp(subset,"g") == 0) {
			implicit = true;
			major_version = RISCV_UNKNOWN_VERSION;
			minor_version = RISCV_UNKNOWN_VERSION;
		}
		riscv_parse_add_subset(rps,subset,
				       major_version,
				       minor_version,implicit);
		p += end_of_version - subset;
		free(subset);

		if (class != RV_ISA_CLASS_SINGLE
		    && *p != '\0' && *p != '_') {
			rps->error_handler("%s: prefixed ISA extension must separate with _",
				 arch);
			return NULL;
		}
	}

	return p;
}
/* Function for parsing ISA string. Return Value: Return TRUE on success.
 * Arguments: `rps`: Hooks and status for parsing extensions. `arch`: Full ISA
 * string.  */
static bool	riscv_parse_subset(riscv_parse_subset_t * rps,
			       		const		char  *arch)
{
	const char     *p;

	/* Init the riscv_ext_order array to compare the order of extensions
	 * quickly.  */
	riscv_init_ext_order();

	if (arch == NULL) {
		riscv_set_default_arch(rps);
		riscv_parse_add_implicit_subsets(rps);
		return riscv_parse_check_conflicts(rps);
	}
	for (p = arch; *p != '\0'; p++) {
		if (ISUPPER(*p)) {
			rps->error_handler("%s: ISA string wth uppercase letters",arch);
			return false;
		}
	}

	p = arch;
	if (startswith(p,"rv32")) {
		*rps->xlen = 32;
		p += 4;
	} else
		if (startswith(p,"rv64")) {
			*rps->xlen = 64;
			p += 4;
		} else {
			/* ISA string shouldn't be NULL or empty here.  For linker,it might
			 * be empty when we failed to merge * the ISA string in the 
			 * riscv_merge_attributes.  For assembler,we might give an empty 
			 * string by .attribute arch,"" or -march=. However,We have
			 * already issued the correct error message in another side,so do 
			 * not issue this error when the ISA string is empty.  */
			if (strlen(arch))
				rps->error_handler("%s: ISA string must begin with rv32 or rv64",
						   arch);
			return false;
		}

	/* Parse single standard and prefixed extensions.  */
	if (riscv_parse_extensions(rps,arch,p) == NULL)
		return false;

	/* Finally add implicit extensions according to the current extensions. */
	riscv_parse_add_implicit_subsets(rps);

	/* Check the conflicts.  */
	return riscv_parse_check_conflicts(rps);
}
static void	riscv_release_subset_list(riscv_subset_list_t *);
static char    *riscv_arch_str(unsigned,const riscv_subset_list_t *);
static const bfd_arch_info_type * riscv_compatible(const bfd_arch_info_type * a,
			const bfd_arch_info_type * b)
{
	if (a->arch != b->arch)
		return NULL;

	/* Machine compatibility is checked in _bfd_riscv_elf_merge_private_bfd_data. */
	return a;
}

/* Return TRUE if STRING matches the architecture described by INFO.  */
static bool	riscv_scan(const struct bfd_arch_info *info,const char *string)
{
	if (bfd_default_scan(info,string))
		return true;

	/*
	 * The incoming STRING might take the form of riscv:rvXXzzz,where XX
	 * is 32 or 64,and zzz are one or more extension characters.  As we
	 * currently only have 3 architectures defined,'riscv','riscv:rv32',
	 * and 'riscv:rv64',we would like to ignore the zzz for the purpose of
	 * matching here.
	 * 
	 * However,we don't want the default 'riscv' to match over a more
	 * specific 'riscv:rv32' or 'riscv:rv64',so in the case of the default
	 * architecture (with the shorter 'riscv' name) we don't allow any
	 * special matching,but for the 'riscv:rvXX' cases,we allow a match
	 * with any additional trailing characters being ignored.
	 */
	if (!info->the_default
	    && strncasecmp(string,info->printable_name,
			   strlen(info->printable_name)) == 0)
		return true;

	return false;
}

#define N(BITS,NUMBER,PRINT,DEFAULT,NEXT)			\
  {								\
    BITS,     /* Bits in a word.  */				\
    BITS,     /* Bits in an address.  */			\
    8,	       /* Bits in a byte.  */				\
    bfd_arch_riscv,						\
    NUMBER,							\
    "riscv",							\
    PRINT,							\
    3,								\
    DEFAULT,							\
    riscv_compatible,						\
    riscv_scan,							\
    bfd_arch_default_fill,					\
    NEXT,							\
    0 /* Maximum offset of a reloc from the start of an insn.  */\
  }

/* This enum must be kept in the same order as arch_info_struct.  */
enum {
	I_riscv64,
	I_riscv32
};

#define NN(index) (&arch_info_struct[(index) + 1])

/*
 * This array must be kept in the same order as the anonymous enum above,and
 * each entry except the last should end with NN (my enum value).
 */
static const bfd_arch_info_type arch_info_struct[] =
{
	N(64,bfd_mach_riscv64,"riscv:rv64",false,NN(I_riscv64)),
	N(32,bfd_mach_riscv32,"riscv:rv32",false,NULL)
};

/* The default architecture is riscv:rv64.  */
static const bfd_arch_info_type bfd_riscv_arch =
N(64,0,"riscv",true,&arch_info_struct[0]);

/* List for all supported ISA spec versions.  */
static const struct riscv_spec riscv_isa_specs[] =
{
	{"2.2",ISA_SPEC_CLASS_2P2},
	{"20190608",ISA_SPEC_CLASS_20190608},
	{"20191213",ISA_SPEC_CLASS_20191213},
};

/* List for all supported privileged spec versions.  */
static const struct riscv_spec riscv_priv_specs[] =
{
	{"1.9.1",PRIV_SPEC_CLASS_1P9P1},
	{"1.10",PRIV_SPEC_CLASS_1P10},
	{"1.11",PRIV_SPEC_CLASS_1P11},
	{"1.12",PRIV_SPEC_CLASS_1P12},
};

/*
 * Get the corresponding CSR version class by giving privilege version numbers.
 * It is usually used to convert the priv
 * 
 * attribute numbers into the corresponding class.
 */

static void	riscv_get_priv_spec_class_from_numbers(unsigned int major,
	    		unsigned	int	minor,unsigned int revision,
			 		enum		riscv_spec_class *class)
{
	enum riscv_spec_class class_t = *class;
	char		buf       [36];

	if (revision != 0)
		snprintf(buf,sizeof(buf),"%u.%u.%u",major,minor,revision);
	else
		snprintf(buf,sizeof(buf),"%u.%u",major,minor);

	RISCV_GET_PRIV_SPEC_CLASS(buf,class_t);
	*class = class_t;
}

/* Return the number of digits for the input.  */
static size_t	riscv_estimate_digit(unsigned num)
{
	size_t		digit = 0;
	if (num == 0)
		return 1;

	for (digit = 0; num; num /= 10)
		digit++;

	return digit;
}

/* Similar to the strcmp.  It returns an integer less than,equal to,or
 * greater than zero if `subset2` is found,respectively,to be less than,to
 * match,or be greater than `subset1`.
 * 
 * The order values,Zero: Preserved keywords. Positive number: Standard
 * extensions. Negative number: Prefixed keywords. */

/* Canonical order for single letter extensions.  */
static const char riscv_ext_canonical_order[] = "eigmafdqlcbkjtpvnh";

/* Init the riscv_ext_order array.  */
static void	riscv_init_ext_order(void)
{
	static bool	inited = false;
	if (inited)
		return;

	/* The orders of all standard extensions are positive.  */
	int		order = 1;

	for (const char *ext = &riscv_ext_canonical_order[0]; *ext; ++ext)
		riscv_ext_order[(*ext - 'a')] = order++;

	/*
	 * Some of the prefixed keyword are not single letter,so we set their
	 * prefixed orders in the riscv_compare_subsets directly,not through
	 * the riscv_ext_order.
	 */

	inited = true;
}
static int	riscv_compare_subsets(const char *subset1,const char *subset2)
{
	int		order1 = riscv_ext_order[(*subset1 - 'a')];
	int		order2 = riscv_ext_order[(*subset2 - 'a')];

	/* Compare the standard extension first.  */
	if (order1 > 0 && order2 > 0)
		return order1 - order2;

	/* Set the prefixed orders to negative numbers.  */
	enum riscv_prefix_ext_class class1 = riscv_get_prefix_class(subset1);
	enum riscv_prefix_ext_class class2 = riscv_get_prefix_class(subset2);

	if (class1 != RV_ISA_CLASS_SINGLE)
		order1 = -(int)class1;
	if (class2 != RV_ISA_CLASS_SINGLE)
		order2 = -(int)class2;

	if (order1 == order2) {
		/* Compare the standard addition z extensions.  */
		if (class1 == RV_ISA_CLASS_Z) {
			order1 = riscv_ext_order[(*++subset1 - 'a')];
			order2 = riscv_ext_order[(*++subset2 - 'a')];
			if (order1 != order2)
				return order1 - order2;
		}
		return strcasecmp(++subset1,++subset2);
	}
	return order2 - order1;
}

static riscv_subset_list_t *
		riscv_copy_subset_list(riscv_subset_list_t *);

static bool	riscv_lookup_subset(const riscv_subset_list_t * subset_list,
						const		char  *subset,
						riscv_subset_t ** Current)
{
	riscv_subset_t *s,*pre_s = NULL;

	/* If the subset is added in order,then just add it at the tail.  */
	if (subset_list->tail != NULL
	    && riscv_compare_subsets(subset_list->tail->name,subset) < 0) {
		*Current = subset_list->tail;
		return false;
	}
	for (s = subset_list->head; s != NULL; pre_s = s,s = s->next) {
		int		cmp = riscv_compare_subsets(s->name,subset);
		if (cmp == 0) {
			*Current = s;
			return true;
		} else
			if (cmp > 0)
				break;
	}
	*Current = pre_s;

	return false;
}
static bool	riscv_subset_supports(riscv_parse_subset_t * rps,
				  		const		char  *feature)
{
	struct riscv_subset_t *subset;
	return riscv_lookup_subset(rps->subset_list,feature,&subset);
}

static bool	riscv_multi_subset_supports(riscv_parse_subset_t *,enum riscv_insn_class);

/* Each instuction belongs to an instruction class INSN_CLASS_*. Call
 * riscv_subset_supports_ext to determine the missing extension.  */
static const char *riscv_multi_subset_supports_ext(riscv_parse_subset_t * rps,
		     		enum		riscv_insn_class insn_class)
{
	switch (insn_class) {
	case INSN_CLASS_I: return "i";
	case INSN_CLASS_ZICBOM: return "zicbom";
	case INSN_CLASS_ZICBOP: return "zicbop";
	case INSN_CLASS_ZICBOZ: return "zicboz";
	case INSN_CLASS_ZICSR: return "zicsr";
	case INSN_CLASS_ZIFENCEI: return "zifencei";
	case INSN_CLASS_ZIHINTPAUSE: return "zihintpause";
	case INSN_CLASS_M: return "m";
	case INSN_CLASS_ZMMUL: return _("m' or `zmmul");
	case INSN_CLASS_A: return "a";
	case INSN_CLASS_ZAWRS: return "zawrs";
	case INSN_CLASS_F: return "f";
	case INSN_CLASS_D: return "d";
	case INSN_CLASS_Q: return "q";
	case INSN_CLASS_C: return "c";
	case INSN_CLASS_F_AND_C:
		if (!riscv_subset_supports(rps,"f")
		    && !riscv_subset_supports(rps,"c"))
			return ("f' and `c");
		else
			if (!riscv_subset_supports(rps,"f"))
				return "f";
			else
				return "c";
	case INSN_CLASS_D_AND_C:
		if (!riscv_subset_supports(rps,"d")
		    && !riscv_subset_supports(rps,"c"))
			return ("d' and `c");
		else
			if (!riscv_subset_supports(rps,"d"))
				return "d";
			else
				return "c";
	case INSN_CLASS_F_INX: return ("f' or `zfinx");
	case INSN_CLASS_D_INX: return ("d' or `zdinx");
	case INSN_CLASS_Q_INX: return ("q' or `zqinx");
	case INSN_CLASS_ZFH_INX: return ("zfh' or `zhinx");
	case INSN_CLASS_ZFHMIN: return "zfhmin";
	case INSN_CLASS_ZFHMIN_INX: return ("zfhmin' or `zhinxmin");
	case INSN_CLASS_ZFHMIN_AND_D_INX:
		if (riscv_subset_supports(rps,"zfhmin"))
			return "d";
		else
			if (riscv_subset_supports(rps,"d"))
				return "zfhmin";
			else
				if (riscv_subset_supports(rps,"zhinxmin"))
					return "zdinx";
				else
					if (riscv_subset_supports(rps,"zdinx"))
						return "zhinxmin";
					else
						return ("zfhmin' and `d',or `zhinxmin' and `zdinx");
	case INSN_CLASS_ZFHMIN_AND_Q_INX:
		if (riscv_subset_supports(rps,"zfhmin"))
			return "q";
		else
			if (riscv_subset_supports(rps,"q"))
				return "zfhmin";
			else
				if (riscv_subset_supports(rps,"zhinxmin"))
					return "zqinx";
				else
					if (riscv_subset_supports(rps,"zqinx"))
						return "zhinxmin";
					else
						return ("zfhmin' and `q',or `zhinxmin' and `zqinx");
	case INSN_CLASS_ZBA: return "zba";
	case INSN_CLASS_ZBB: return "zbb";
	case INSN_CLASS_ZBC: return "zbc";
	case INSN_CLASS_ZBS: return "zbs";
	case INSN_CLASS_ZBKB: return "zbkb";
	case INSN_CLASS_ZBKC: return "zbkc";
	case INSN_CLASS_ZBKX: return "zbkx";
	case INSN_CLASS_ZBB_OR_ZBKB: return ("zbb' or `zbkb");
	case INSN_CLASS_ZBC_OR_ZBKC: return ("zbc' or `zbkc");
	case INSN_CLASS_ZKND: return "zknd";
	case INSN_CLASS_ZKNE: return "zkne";
	case INSN_CLASS_ZKNH: return "zknh";
	case INSN_CLASS_ZKND_OR_ZKNE: return ("zknd' or `zkne");
	case INSN_CLASS_ZKSED: return "zksed";
	case INSN_CLASS_ZKSH: return "zksh";
	case INSN_CLASS_V: return ("v' or `zve64x' or `zve32x");
	case INSN_CLASS_ZVEF: return ("v' or `zve64d' or `zve64f' or `zve32f");
	case INSN_CLASS_SVINVAL: return "svinval";
	case INSN_CLASS_H: return ("h");
	case INSN_CLASS_XTHEADBA: return "xtheadba";
	case INSN_CLASS_XTHEADBB: return "xtheadbb";
	case INSN_CLASS_XTHEADBS: return "xtheadbs";
	case INSN_CLASS_XTHEADCMO: return "xtheadcmo";
	case INSN_CLASS_XTHEADCONDMOV: return "xtheadcondmov";
	case INSN_CLASS_XTHEADFMEMIDX: return "xtheadfmemidx";
	case INSN_CLASS_XTHEADFMV: return "xtheadfmv";
	case INSN_CLASS_XTHEADINT: return "xtheadint";
	case INSN_CLASS_XTHEADMAC: return "xtheadmac";
	case INSN_CLASS_XTHEADMEMIDX: return "xtheadmemidx";
	case INSN_CLASS_XTHEADMEMPAIR: return "xtheadmempair";
	case INSN_CLASS_XTHEADSYNC: return "xtheadsync";
	default:
		rps->error_handler
			(("internal: unreachable INSN_CLASS_*"));
		return NULL;
	}
}
//---------------------------------------------include "elf/riscv.h"
/* RISC-V ELF support for BFD. */
#ifndef _ELF_RISCV_H
#define _ELF_RISCV_H
/* Generic relocation support for BFD. */
/*
 * These macros are used by the various *.h target specific header files to
 * either generate an enum containing all the known relocations for that
 * target,or if RELOC_MACROS_GEN_FUNC is defined,a recognition function is
 * generated instead.  (This is used by binutils/readelf.c)
 * 
 * Given a header file like this:
 * 
 * START_RELOC_NUMBERS (foo) RELOC_NUMBER (R_foo_NONE,   0) RELOC_NUMBER
 * (R_foo_32,     1) EMPTY_RELOC  (R_foo_good) FAKE_RELOC   (R_foo_illegal,9)
 * END_RELOC_NUMBERS (R_foo_count)
 * 
 * Then the following will be produced by default (ie if RELOC_MACROS_GEN_FUNC is
 * *not* defined).
 * 
 * enum foo { R_foo_NONE = 0,R_foo_32 = 1,R_foo_good,R_foo_illegal = 9,
 * R_foo_count };
 * 
 * Note: The value of the symbol defined in the END_RELOC_NUMBERS macro
 * (R_foo_count in the case of the example above) will be set to the value of
 * the whichever *_RELOC macro precedes it plus one.  Therefore if you intend
 * to use the symbol as a sentinel for the highest valid macro value you should
 * make sure that the preceding *_RELOC macro is the highest valid number.  ie
 * a declaration like this:
 * 
 * START_RELOC_NUMBERS (foo) RELOC_NUMBER (R_foo_NONE,   0) RELOC_NUMBER
 * (R_foo_32,     1) FAKE_RELOC   (R_foo_illegal,9) FAKE_RELOC
 * (R_foo_synonym,0) END_RELOC_NUMBERS (R_foo_count)
 * 
 * will result in R_foo_count having a value of 1 (R_foo_synonym + 1) rather than
 * 10 or 2 as might be expected.
 * 
 * Alternatively you can assign a value to END_RELOC_NUMBERS symbol explicitly,
 * like this:
 * 
 * START_RELOC_NUMBERS (foo) RELOC_NUMBER (R_foo_NONE,   0) RELOC_NUMBER
 * (R_foo_32,     1) FAKE_RELOC   (R_foo_illegal,9) FAKE_RELOC
 * (R_foo_synonym,0) END_RELOC_NUMBERS (R_foo_count = 2)
 * 
 * If RELOC_MACROS_GEN_FUNC *is* defined,then instead the following function will
 * be generated:
 * 
 * static const char *foo (unsigned long rtype); static const char * foo (unsigned
 * long rtype) { switch (rtype) { case 0: return "R_foo_NONE"; case 1: return
 * "R_foo_32"; default: return NULL; } }
 */

/* Relocation types.  */
enum elf_riscv_reloc_type {
	R_RISCV_NONE = 0,R_RISCV_32 = 1,R_RISCV_64 = 2,R_RISCV_RELATIVE = 3,R_RISCV_COPY = 4,
	R_RISCV_JUMP_SLOT = 5,R_RISCV_TLS_DTPMOD32 = 6,R_RISCV_TLS_DTPMOD64 = 7,
	R_RISCV_TLS_DTPREL32 = 8,R_RISCV_TLS_DTPREL64 = 9,R_RISCV_TLS_TPREL32 = 10,
	R_RISCV_TLS_TPREL64 = 11,

	/* Relocation types not used by the dynamic linker.  */
	R_RISCV_BRANCH = 16,R_RISCV_JAL = 17,R_RISCV_CALL = 18,R_RISCV_CALL_PLT = 19,
	R_RISCV_GOT_HI20 = 20,R_RISCV_TLS_GOT_HI20 = 21,R_RISCV_TLS_GD_HI20 = 22,
	R_RISCV_PCREL_HI20 = 23,R_RISCV_PCREL_LO12_I = 24,R_RISCV_PCREL_LO12_S = 25,
	R_RISCV_HI20 = 26,R_RISCV_LO12_I = 27,R_RISCV_LO12_S = 28,
	R_RISCV_TPREL_HI20 = 29,R_RISCV_TPREL_LO12_I = 30,R_RISCV_TPREL_LO12_S = 31,
	R_RISCV_TPREL_ADD = 32,R_RISCV_ADD8 = 33,R_RISCV_ADD16 = 34,
	R_RISCV_ADD32 = 35,R_RISCV_ADD64 = 36,R_RISCV_SUB8 = 37,R_RISCV_SUB16 = 38,
	R_RISCV_SUB32 = 39,R_RISCV_SUB64 = 40,R_RISCV_ALIGN = 43,
	R_RISCV_RVC_BRANCH = 44,R_RISCV_RVC_JUMP = 45,R_RISCV_RVC_LUI = 46,
	R_RISCV_GPREL_I = 47,R_RISCV_GPREL_S = 48,R_RISCV_TPREL_I = 49,
	R_RISCV_TPREL_S = 50,R_RISCV_RELAX = 51,R_RISCV_SUB6 = 52,R_RISCV_SET6 = 53,
	R_RISCV_SET8 = 54,R_RISCV_SET16 = 55,R_RISCV_SET32 = 56,R_RISCV_32_PCREL = 57,
	R_RISCV_IRELATIVE = 58,
	/* Reserved 59 for R_RISCV_PLT32.  */
	R_RISCV_SET_ULEB128 = 60,R_RISCV_SUB_ULEB128 = 61,R_RISCV_max
};
/* Processor specific flags for the ELF header e_flags field.  */

/* File may contain compressed instructions.  */
#define EF_RISCV_RVC 0x0001
/* Which floating-point ABI a file uses.  */
#define EF_RISCV_FLOAT_ABI 0x0006
/* File uses the soft-float ABI.  */
#define EF_RISCV_FLOAT_ABI_SOFT 0x0000
/* File uses the single-float ABI.  */
#define EF_RISCV_FLOAT_ABI_SINGLE 0x0002
/* File uses the double-float ABI.  */
#define EF_RISCV_FLOAT_ABI_DOUBLE 0x0004
/* File uses the quad-float ABI.  */
#define EF_RISCV_FLOAT_ABI_QUAD 0x0006
/* File uses the 32E base integer instruction.  */
#define EF_RISCV_RVE 0x0008
/* The name of the global pointer symbol.  */
#define RISCV_GP_SYMBOL "__global_pointer$"
/* Processor specific dynamic array tags.  */
#define DT_RISCV_VARIANT_CC (DT_LOPROC + 1)
/* RISC-V specific values for st_other.  */
#define STO_RISCV_VARIANT_CC 0x80
/* File uses the TSO model. */
#define EF_RISCV_TSO 0x0010
/* Additional section types.  */
#define SHT_RISCV_ATTRIBUTES 0x70000003	/* Section holds attributes.  */
/* Processor specific program header types.  */

/* Location of RISC-V ELF attribute section. */
#define PT_RISCV_ATTRIBUTES 0x70000003

/* Object attributes.  */
enum {
	/* 0-3 are generic.  */
	Tag_RISCV_stack_align = 4,Tag_RISCV_arch = 5,Tag_RISCV_unaligned_access = 6,
	Tag_RISCV_priv_spec = 8,Tag_RISCV_priv_spec_minor = 10,
	Tag_RISCV_priv_spec_revision = 12
};
#endif				/* _ELF_RISCV_H */

#define ELF_MACHINE_CODE		EM_RISCV
#define ELF_MAXPAGESIZE			0x1000
#define ELF_COMMONPAGESIZE		0x1000

#define RISCV_ATTRIBUTES_SECTION_NAME ".riscv.attributes"
struct _bfd_riscv_elf_obj_tdata {
	struct elf_obj_tdata root;

	/* tls_type for each local got entry.  */
	char           *local_got_tls_type;
};

/* A second format for recording PC-relative hi relocations.  This stores the
 * information required to relax them to GP-relative addresses. */
#undef  elf_backend_obj_attrs_vendor
#define elf_backend_obj_attrs_vendor		"riscv"
#undef  elf_backend_obj_attrs_arg_type
#define elf_backend_obj_attrs_arg_type		riscv_elf_obj_attrs_arg_type
#undef  elf_backend_obj_attrs_section_type
#define elf_backend_obj_attrs_section_type	SHT_RISCV_ATTRIBUTES
#undef  elf_backend_obj_attrs_section
#define elf_backend_obj_attrs_section		RISCV_ATTRIBUTES_SECTION_NAME

#define USE_REL 0
/* ================================================================= tc-riscv.c */
/* tc-riscv.c -- RISC-V assembler */
/* Information about an instruction,including its format,operands and fixups.  */
struct riscv_cl_insn {
	/* The opcode's entry in riscv_opcodes.  */
	const struct riscv_opcode *insn_mo;
	/* The encoded instruction bits (first bits enough to extract
	 * instruction length on a long opcode).  */
	insn_t		insn_opcode;
	/* The long encoded instruction bits ([0] is non-zero on a long
	 * opcode).  */
	char		insn_long_opcode[RISCV_MAX_INSN_LEN];
	/* The frag that contains the instruction.  */
	struct frag    *frag;
	/* The offset into FRAG of the first instruction byte.  */
	long		where;
	/* The relocs associated with the instruction,if any.  */
	fixS           *fixp;
};

/* All RISC-V CSR belong to one of these classes.  */
enum riscv_csr_class {
	CSR_CLASS_NONE,
	CSR_CLASS_I,
	CSR_CLASS_I_32,		/* rv32 only */
	CSR_CLASS_F,		/* f-ext only */
	CSR_CLASS_ZKR,		/* zkr only */
	CSR_CLASS_V,		/* rvv only */
	CSR_CLASS_DEBUG,	/* debug CSR */
	CSR_CLASS_H,		/* hypervisor */
	CSR_CLASS_H_32,		/* hypervisor,rv32 only */
	CSR_CLASS_SMAIA,	/* Smaia */
	CSR_CLASS_SMAIA_32,	/* Smaia,rv32 only */
	CSR_CLASS_SMSTATEEN,	/* Smstateen only */
	CSR_CLASS_SMSTATEEN_32,	/* Smstateen RV32 only */
	CSR_CLASS_SSAIA,	/* Ssaia */
	CSR_CLASS_SSAIA_AND_H,	/* Ssaia with H */
	CSR_CLASS_SSAIA_32,	/* Ssaia,rv32 only */
	CSR_CLASS_SSAIA_AND_H_32,	/* Ssaia with H,rv32 only */
	CSR_CLASS_SSSTATEEN,	/* S[ms]stateen only */
	CSR_CLASS_SSSTATEEN_AND_H,	/* S[ms]stateen only (with H) */
	CSR_CLASS_SSSTATEEN_AND_H_32,	/* S[ms]stateen RV32 only (with H) */
	CSR_CLASS_SSCOFPMF,	/* Sscofpmf only */
	CSR_CLASS_SSCOFPMF_32,	/* Sscofpmf RV32 only */
	CSR_CLASS_SSTC,		/* Sstc only */
	CSR_CLASS_SSTC_AND_H,	/* Sstc only (with H) */
	CSR_CLASS_SSTC_32,	/* Sstc RV32 only */
	CSR_CLASS_SSTC_AND_H_32,/* Sstc RV32 only (with H) */
};

/* This structure holds all restricted conditions for a CSR.  */
struct riscv_csr_extra {
	/* Class to which this CSR belongs.  Used to decide whether or not this
	 * CSR is legal in the current -march context.  */
	enum riscv_csr_class csr_class;
	/* CSR may have differnet numbers in the previous priv spec.  */
	unsigned	address;
	/* Record the CSR is defined/valid in which versions.  */
	enum riscv_spec_class define_version;
	/* Record the CSR is aborted/invalid from which versions.  If it isn't
	 * aborted in the current version,then it should be
	 * PRIV_SPEC_CLASS_DRAFT.  */
	enum riscv_spec_class abort_version;
	/* The CSR may have more than one setting.  */
	struct riscv_csr_extra *next;
};

/* This structure contains information about errors that occur within the
 * riscv_ip function */
struct riscv_ip_error {
	/* General error message */
	const char     *msg;
	/* Statement that caused the error */
	char           *statement;
	/* Missing extension that needs to be enabled */
	const char     *missing_ext;
};

/* Need to sync the version with RISC-V compiler.  */
#ifndef DEFAULT_RISCV_ISA_SPEC
#define DEFAULT_RISCV_ISA_SPEC "20191213"
#endif

#ifndef DEFAULT_RISCV_PRIV_SPEC
#define DEFAULT_RISCV_PRIV_SPEC "1.11"
#endif

static const char *default_arch_with_ext = NULL;
static enum riscv_spec_class default_isa_spec = ISA_SPEC_CLASS_NONE;
static enum riscv_spec_class default_priv_spec = PRIV_SPEC_CLASS_NONE;

static unsigned	xlen = 0;	/* The width of an x-register.  */
static unsigned	abi_xlen = 0;	/* The width of a pointer in the ABI.  */
static bool	rve_abi = false;
enum float_abi {
	FLOAT_ABI_DEFAULT = -1,FLOAT_ABI_SOFT,FLOAT_ABI_SINGLE,
	FLOAT_ABI_DOUBLE,FLOAT_ABI_QUAD
};
static enum float_abi float_abi = FLOAT_ABI_DEFAULT;

#define LOAD_ADDRESS_INSN (abi_xlen == 64 ? "ld" : "lw")
#define ADD32_INSN (xlen == 64 ? "addiw" : "addi")

static unsigned	elf_flags = 0;
static bool	probing_insn_operands;
/*
 * Set the default_isa_spec.  Return 0 if the spec isn't supported. Otherwise,
 * return 1.
 */

static int	riscv_set_default_isa_spec(const char *s)
{
	enum riscv_spec_class class = ISA_SPEC_CLASS_NONE;
	RISCV_GET_ISA_SPEC_CLASS(s,class);
	if (class == ISA_SPEC_CLASS_NONE) {
		as_bad("unknown default ISA spec `%s' set by "
		       "-misa-spec or --with-isa-spec",s);
		return 0;
	} else
		default_isa_spec = class;
	return 1;
}

/*
 * Set the default_priv_spec.  Find the privileged elf attributes when the
 * input string is NULL.  Return 0 if the spec isn't supported. Otherwise,
 * return 1.
 */
static int	riscv_set_default_priv_spec(const char *s)
{
	enum riscv_spec_class class = PRIV_SPEC_CLASS_NONE;
	unsigned	major ,minor,revision;
	obj_attribute  *attr;

	RISCV_GET_PRIV_SPEC_CLASS(s,class);
	if (class != PRIV_SPEC_CLASS_NONE) {
		default_priv_spec = class;
		return 1;
	}
	if (s != NULL) {
		as_bad(("unknown default privileged spec `%s' set by "
			"-mpriv-spec or --with-priv-spec"),s);
		return 0;
	}
	/* Set the default_priv_spec by the privileged elf attributes.  */
	attr = elf_known_obj_attributes_proc(stdoutput);
	major = (unsigned)attr[Tag_RISCV_priv_spec].i;
	minor = (unsigned)attr[Tag_RISCV_priv_spec_minor].i;
	revision = (unsigned)attr[Tag_RISCV_priv_spec_revision].i;
	/* Version 0.0.0 is the default value and meningless.  */
	if (major == 0 && minor == 0 && revision == 0)
		return 1;

	riscv_get_priv_spec_class_from_numbers(major,minor,revision,&class);
	if (class != PRIV_SPEC_CLASS_NONE) {
		default_priv_spec = class;
		return 1;
	}
	/* Still can not find the privileged spec class.  */
	as_bad(("unknown default privileged spec `%d.%d.%d' set by "
		"privileged elf attributes"),major,minor,revision);
	return 0;
}

/* This is the set of options which the .option pseudo-op may modify.  */
struct riscv_set_options {
	int		pic;	/* Generate position-independent code.  */
	int		rvc;	/* Generate RVC code.  */
	int		relax;	/* Emit relocs the linker is allowed to relax.  */
	int		arch_attr;	/* Emit architecture and privileged elf
					 * attributes.  */
	int		csr_check;	/* Enable the CSR checking.  */
};

static struct riscv_set_options riscv_opts = {
	0,			/* pic */
	0,			/* rvc */
	1,			/* relax */
	DEFAULT_RISCV_ATTR,	/* arch_attr */
	0,			/* csr_check */
};

/*
 * Enable or disable the rvc flags for riscv_opts.  Turn on the rvc flag for
 * elf_flags once we have enabled c extension.
 */
static void	riscv_set_rvc(bool rvc_value)
{
	if (rvc_value)
		elf_flags |= EF_RISCV_RVC;

	riscv_opts.rvc = rvc_value;
}

/* Turn on the tso flag for elf_flags once we have enabled ztso extension.  */
static void	riscv_set_tso(void)
{
	elf_flags |= EF_RISCV_TSO;
}

/* Auxiliary function to convert subset info to string.  */
static void	riscv_arch_str1(riscv_subset_t * subset,
		  		char         *attr_str,char *buf,size_t bufsz)
{
	const char     *underline = "_";
	riscv_subset_t *subset_t = subset;

	if (subset_t == NULL)
		return;

	/* No underline between rvXX and i/e.  */
	if ((strcasecmp(subset_t->name,"i") == 0)
	    || (strcasecmp(subset_t->name,"e") == 0))
		underline = "";

	snprintf(buf,bufsz,"%s%s%dp%d",
		 underline,
		 subset_t->name,
		 subset_t->major_version,
		 subset_t->minor_version);

	strncat(attr_str,buf,bufsz);

	/* Skip 'i' extension after 'e',or skip extensions which versions are
	 * unknown.  */
	while (subset_t->next
	       && ((strcmp(subset_t->name,"e") == 0
		    && strcmp(subset_t->next->name,"i") == 0)
		   || subset_t->next->major_version == RISCV_UNKNOWN_VERSION
		   || subset_t->next->minor_version == RISCV_UNKNOWN_VERSION))
		subset_t = subset_t->next;

	riscv_arch_str1(subset_t->next,attr_str,buf,bufsz);
}
/* Auxiliary function to estimate string length of subset list.  */
static size_t	riscv_estimate_arch_strlen1(const riscv_subset_t * subset)
{
	if (subset == NULL)
		return 6;	/* For rv32/rv64/rv128 and string terminator.  */

	return riscv_estimate_arch_strlen1(subset->next)
		+ strlen(subset->name)
		+ riscv_estimate_digit(subset->major_version)
		+ 1		/* For version seperator 'p'.  */
		+ riscv_estimate_digit(subset->minor_version)
		+ 1 /* For underscore.  */ ;
}

/* Estimate the string length of this subset list.  */
static size_t	riscv_estimate_arch_strlen(const riscv_subset_list_t * subset_list)
{
	return riscv_estimate_arch_strlen1(subset_list->head);
}

/* Convert subset information into string with explicit versions.  */
static char    *riscv_arch_str(unsigned Xlen,const riscv_subset_list_t * subset)
{
	size_t		arch_str_len = riscv_estimate_arch_strlen(subset);
	char           *attr_str = xmalloc(arch_str_len);
	char           *buf = xmalloc(arch_str_len);

	snprintf(attr_str,arch_str_len,"rv%u",Xlen);

	riscv_arch_str1(subset->head,attr_str,buf,arch_str_len);
	free(buf);

	return attr_str;
}
/* The linked list hanging off of .subsets_list records all enabled extensions,
 * which are parsed from the architecture string.  The architecture string can
 * be set by the -march option,the elf architecture attributes,and the
 * --with-arch configure option.  */
static riscv_parse_subset_t riscv_rps_as =
{
	NULL,			/* subset_list,we will set it later once
				 * riscv_opts_stack is created or updated.  */
	as_bad,			/* error_handler.  */
	&xlen,			/* xlen.  */
	&default_isa_spec,	/* isa_spec.  */
	true,			/* check_unknown_prefixed_ext.  */
};

/* Update the architecture string in the subset_list.  */

static void	riscv_reset_subsets_list_arch_str(void)
{
	riscv_subset_list_t *subsets = riscv_rps_as.subset_list;
	if (subsets->arch_str != NULL)
		free((void *)subsets->arch_str);
	subsets->arch_str = riscv_arch_str(xlen,subsets);
}

/* This structure is used to hold a stack of .option values.  */
struct riscv_option_stack {
	struct riscv_option_stack *next;
	struct riscv_set_options options;
	riscv_subset_list_t *subset_list;
};

static struct riscv_option_stack *riscv_opts_stack = NULL;

/* Set which ISA and extensions are available.  */
static void	riscv_set_arch(const char *s)
{
	if (s != NULL && strcmp(s,"") == 0) {
		as_bad(("the architecture string of -march and elf architecture "
			"attributes cannot be empty"));
		return;
	}
	if (riscv_rps_as.subset_list == NULL) {
		riscv_rps_as.subset_list = XNEW(riscv_subset_list_t);
		riscv_rps_as.subset_list->head = NULL;
		riscv_rps_as.subset_list->tail = NULL;
		riscv_rps_as.subset_list->arch_str = NULL;
	}
	riscv_release_subset_list(riscv_rps_as.subset_list);
	riscv_parse_subset(&riscv_rps_as,s);
	riscv_reset_subsets_list_arch_str();

	riscv_set_rvc(false);
	if (riscv_subset_supports(&riscv_rps_as,"c"))
		riscv_set_rvc(true);

	if (riscv_subset_supports(&riscv_rps_as,"ztso"))
		riscv_set_tso();
}

/* Indicate -mabi option is explictly set.  */
static bool	explicit_mabi = false;

/* Set the abi information.  */
static void	riscv_set_abi(unsigned new_xlen,enum float_abi new_float_abi,bool rve)
{
	abi_xlen = new_xlen;
	float_abi = new_float_abi;
	rve_abi = rve;
}

/* If the -mabi option isn't set,then set the abi according to the ISA string.
 * Otherwise,check if there is any conflict.  */
static void	riscv_set_abi_by_arch(void)
{
	if (!explicit_mabi) {
		if (riscv_subset_supports(&riscv_rps_as,"q"))
			riscv_set_abi(xlen,FLOAT_ABI_QUAD,false);
		else
			if (riscv_subset_supports(&riscv_rps_as,"d"))
				riscv_set_abi(xlen,FLOAT_ABI_DOUBLE,false);
			else
				if (riscv_subset_supports(&riscv_rps_as,"e"))
					riscv_set_abi(xlen,FLOAT_ABI_SOFT,true);
				else
					riscv_set_abi(xlen,FLOAT_ABI_SOFT,false);
	} else {
		gas_assert(abi_xlen != 0 && xlen != 0 && float_abi != FLOAT_ABI_DEFAULT);
		if (abi_xlen > xlen)
			as_bad("can't have %d-bit ABI on %d-bit ISA",abi_xlen,xlen);
		else
			if (abi_xlen < xlen)
				as_bad("%d-bit ABI not yet supported on %d-bit ISA",abi_xlen,xlen);

		if (riscv_subset_supports(&riscv_rps_as,"e") && !rve_abi)
			as_bad("only the ilp32e ABI is supported for e extension");

		if (float_abi == FLOAT_ABI_SINGLE
		    && !riscv_subset_supports(&riscv_rps_as,"f"))
			as_bad("ilp32f/lp64f ABI can't be used when f extension "
			       "isn't supported");
		else
			if (float_abi == FLOAT_ABI_DOUBLE
			    && !riscv_subset_supports(&riscv_rps_as,"d"))
				as_bad("ilp32d/lp64d ABI can't be used when d extension "
				       "isn't supported");
			else
				if (float_abi == FLOAT_ABI_QUAD
				&& !riscv_subset_supports(&riscv_rps_as,"q"))
					as_bad("ilp32q/lp64q ABI can't be used when q extension "
					       "isn't supported");
	}

	/* Update the EF_RISCV_FLOAT_ABI field of elf_flags.  */
	elf_flags &= ~EF_RISCV_FLOAT_ABI;
	elf_flags |= float_abi << 1;

	if (rve_abi)
		elf_flags |= EF_RISCV_RVE;
}

/* Handle of the OPCODE hash table.  */
static htab_t	op_hash = NULL;

/* Handle of the type of .insn hash table. */
static htab_t	insn_type_hash = NULL;

/* This array holds the chars that only start a comment at the beginning of a
 * line.  If the line seems to have the form '# 123 filename' .line and .file
 * directives will appear in the pre-processed output
 * 
 * Note that input_file.c hand checks for '#' at the beginning of the first line
 * of the input file.  This is because the compiler outputs #NO_APP at the
 * beginning of its output.
 * 
 * Also note that C style comments are always supported.  */
/* This array holds machine specific line separator characters.  */
static const char line_separator_chars[] = ";";

/* Chars that can be used to separate mant from exp in floating point nums.  */
static const char EXP_CHARS[] = "eE";

/* * Chars that mean this number is a floating point constant. As in 0f12.456 or
 * 0d1.2345e12.  */
static const char FLT_CHARS[] = "rRsSfFdDxXpPhH";

/* Indicate we are already assemble any instructions or not.  */
static bool	start_assemble = false;

/* Indicate ELF attributes are explicitly set.  */
static bool	explicit_attr = false;

/* Indicate CSR or priv instructions are explicitly used.  */
static bool	explicit_priv_attr = false;

static char    *expr_parse_end;

/* Macros for encoding relaxation state for RVC branches and far jumps.  */
#define RELAX_BRANCH_ENCODE(uncond,rvc,length)	\
  ((relax_substateT) 					\
   (0xc0000000						\
   |((uncond) ? 1 : 0)				\
   |((rvc) ? 2 : 0)					\
   |((length) << 2)))
#define RELAX_BRANCH_P(i) (((i) & 0xf0000000) == 0xc0000000)
#define RELAX_BRANCH_LENGTH(i) (((i) >> 2) & 0xF)
#define RELAX_BRANCH_RVC(i) (((i) & 2) != 0)
#define RELAX_BRANCH_UNCOND(i) (((i) & 1) != 0)

/* Is the given value a sign-extended 32-bit value?  */
#define IS_SEXT_32BIT_NUM(x)						\
  (((x) &~ (offsetT) 0x7fffffff) == 0					\
   || (((x) &~ (offsetT) 0x7fffffff) == ~ (offsetT) 0x7fffffff))

/* Is the given value a zero-extended 32-bit value?  Or a negated one?  */
#define IS_ZEXT_32BIT_NUM(x)						\
  (((x) &~ (offsetT) 0xffffffff) == 0					\
   || (((x) &~ (offsetT) 0xffffffff) == ~ (offsetT) 0xffffffff))

/* Change INSN's opcode so that the operand given by FIELD has value VALUE.
 * INSN is a riscv_cl_insn structure and VALUE is evaluated exactly once.  */
#define INSERT_OPERAND(FIELD,INSN,VALUE) \
  INSERT_BITS ((INSN).insn_opcode,VALUE,OP_MASK_##FIELD,OP_SH_##FIELD)

#define INSERT_IMM(n,s,INSN,VALUE) \
  INSERT_BITS ((INSN).insn_opcode,VALUE,(1ULL<<n) - 1,s)

/* Determine if an instruction matches an opcode.  */
#define OPCODE_MATCHES(OPCODE,OP) \
  (((OPCODE) & MASK_##OP) == MATCH_##OP)

/* Create a new mapping symbol for the transition to STATE.  */
static void	make_mapping_symbol(enum riscv_seg_mstate State,
	   		valueT	value ,fragS * frag,const char *arch_str,
			     		bool		odd_data_padding)
{
	const char     *name;
	char           *buff = NULL;
	switch (State) {
	case MAP_DATA:
		name = "$d";
		break;
	case MAP_INSN:
		if (arch_str != NULL) {
			size_t		size = strlen(arch_str) + 3;	/* "$x" + '\0'  */
			buff = xmalloc(size);
			snprintf(buff,size,"$x%s",arch_str);
			name = buff;
		} else
			name = "$x";
		break;
	default:
		abort();
	}

	symbolS        *symbol = symbol_new(name,now_seg,frag,value);
	symbol_get_bfdsym(symbol)->flags |= (BSF_NO_FLAGS|BSF_LOCAL);
	if (arch_str != NULL) {
		/* Store current $x+arch into tc_segment_info.  */
		seg_info(now_seg)->tc_segment_info_data.arch_map_symbol = symbol;
		xfree((void *)buff);
	}
	/* If .fill or other data filling directive generates zero sized data,
	 * then mapping symbol for the following code will have the same value.
	 * 
	 * Please see gas/testsuite/gas/riscv/mapping.s: .text.zero.fill.first and
	 * .text.zero.fill.last.  */
	symbolS        *first = frag->tc_frag_data.first_map_symbol;
	symbolS        *last = frag->tc_frag_data.last_map_symbol;
	symbolS        *removed = NULL;
	if (value == 0) {
		if (first != NULL) {
			know(S_GET_VALUE(first) == S_GET_VALUE(symbol)
			     && first == last);
			/* Remove the old one.  */
			removed = first;
		}
		frag->tc_frag_data.first_map_symbol = symbol;
	} else
		if (last != NULL) {
			/* The mapping symbols should be added in offset order.  */
			know(S_GET_VALUE(last) <= S_GET_VALUE(symbol));
			/* Remove the old one.  */
			if (S_GET_VALUE(last) == S_GET_VALUE(symbol))
				removed = last;
		}
	frag->tc_frag_data.last_map_symbol = symbol;

	if (removed == NULL)
		return;

	if (odd_data_padding) {
		/*
		 * If the removed mapping symbol is $x+arch,then add it back
		 * to the next $x.
		 */
		const char     *str = strncmp(S_GET_NAME(removed),"$xrv",4) == 0
		? S_GET_NAME(removed) + 2 : NULL;
		make_mapping_symbol(MAP_INSN,frag->fr_fix + 1,frag,str,
				    false /* odd_data_padding */ );
	}
	symbol_remove(removed,&symbol_rootP,&symbol_lastP);
}

/* Set the mapping state for frag_now.  */
static void	riscv_mapping_state(enum riscv_seg_mstate to_state,
						int		max_chars,
						bool		fr_align_code)
{
	enum riscv_seg_mstate from_state =
	seg_info(now_seg)->tc_segment_info_data.map_state;
	bool		reset_seg_arch_str = false;

	if (!SEG_NORMAL(now_seg)
	/*
	 * For now we only add the mapping symbols to text sections. Therefore,
	 * the dis-assembler only show the actual contents distribution for
	 * text.  Other sections will be shown as data without the details.
	 */
	    || !subseg_text_p(now_seg))
		return;

	/*
	 * The mapping symbol should be emitted if not in the right mapping
	 * state.
	 */
	symbolS        *seg_arch_symbol =
	seg_info(now_seg)->tc_segment_info_data.arch_map_symbol;
	if (to_state == MAP_INSN && seg_arch_symbol == 0) {
		/* Always add $x+arch at the first instruction of section.  */
		reset_seg_arch_str = true;
	} else
		if (seg_arch_symbol != 0
		    && to_state == MAP_INSN
		    && !fr_align_code
		    && strcmp(riscv_rps_as.subset_list->arch_str,
			      S_GET_NAME(seg_arch_symbol) + 2) != 0) {
			reset_seg_arch_str = true;
		} else
			if (from_state == to_state)
				return;

	valueT		value = (valueT) (frag_now_fix() - max_chars);
	seg_info(now_seg)->tc_segment_info_data.map_state = to_state;
	const char     *arch_str = reset_seg_arch_str
	? riscv_rps_as.subset_list->arch_str : NULL;
	make_mapping_symbol(to_state,value,frag_now,arch_str,
			    false /* odd_data_padding */ );
}

/* Add the odd bytes of paddings for riscv_handle_align.  */
static void	riscv_add_odd_padding_symbol(fragS * frag)
{
	/* If there was already a mapping symbol,it should be removed in the
	 * make_mapping_symbol. Please see gas/testsuite/gas/riscv/mapping.s:
	 * .text.odd.align.*.  */
	make_mapping_symbol(MAP_DATA,frag->fr_fix,frag,
			  NULL /* arch_str */ ,true /* odd_data_padding */ );
}

/* Remove any excess mapping symbols generated for alignment frags in SEC.  We
 * may have created a mapping symbol before a zero byte alignment; remove it if
 * there's a mapping symbol after the alignment.  */
static void	riscv_check_mapping_symbols(asection * sec,
			 		void         *dummy ATTRIBUTE_UNUSED)
{
	segment_info_type *seginfo = seg_info(sec);
	fragS          *fragp;

	if (seginfo == NULL || seginfo->frchainP == NULL)
		return;

	for (fragp = seginfo->frchainP->frch_root;
	     fragp != NULL;
	     fragp = fragp->fr_next) {
		symbolS        *last = fragp->tc_frag_data.last_map_symbol;
		fragS          *next = fragp->fr_next;

		if (last == NULL || next == NULL)
			continue;

		/* Check the last mapping symbol if it is at the boundary of
		 * fragment.  */
		if (S_GET_VALUE(last) < next->fr_address)
			continue;
		know(S_GET_VALUE(last) == next->fr_address);

		do {
			symbolS        *next_first = next->tc_frag_data.first_map_symbol;
			if (next_first != NULL) {
				/* The last mapping symbol overlaps with
				 * another one which at the start of the next frag.
				 * 
				 * Please see the gas/testsuite/gas/riscv/mapping.s:
				 * .text.zero.fill.align.A and
				 * .text.zero.fill.align.B.
				 */
				know(S_GET_VALUE(last) == S_GET_VALUE(next_first));
				symbolS        *removed = last;
				if (strncmp(S_GET_NAME(last),"$xrv",4) == 0
				 && strcmp(S_GET_NAME(next_first),"$x") == 0)
					removed = next_first;
				symbol_remove(removed,&symbol_rootP,&symbol_lastP);
				break;
			}
			if (next->fr_next == NULL) {
				/* The last mapping symbol is at the end of the
				 * section.
				 * 
				 * Please see the
				 * gas/testsuite/gas/riscv/mapping.s:
				 * .text.last.section.  */
				know(next->fr_fix == 0 && next->fr_var == 0);
				symbol_remove(last,&symbol_rootP,&symbol_lastP);
				break;
			}
			/*
			 * Since we may have empty frags without any mapping
			 * symbols,keep looking until the non-empty frag.
			 */
			if (next->fr_address != next->fr_next->fr_address)
				break;

			next = next->fr_next;
		}
		while (next != NULL);
	}
}

/* The default target format to use.  */
static const char *riscv_target_format(void)
{
		return  "elf64-littleriscv" ;
}

/* Return the length of instruction INSN.  */
static inline unsigned int insn_length(const struct riscv_cl_insn *insn)
{
	return riscv_insn_length(insn->insn_opcode);
}

/* Initialise INSN from opcode entry MO.  Leave its position unspecified.  */
static void	create_insn(struct riscv_cl_insn *insn,const struct riscv_opcode *mo)
{
	insn->insn_mo = mo;
	insn->insn_opcode = mo->match;
	insn->insn_long_opcode[0] = 0;
	insn->frag = NULL;
	insn->where = 0;
	insn->fixp = NULL;
}

/* Install INSN at the location specified by its "frag" and "where" fields.  */
static void	install_insn(const struct riscv_cl_insn *insn)
{
	char           *f = insn->frag->fr_literal + insn->where;
	if (insn->insn_long_opcode[0] != 0)
		memcpy(f,insn->insn_long_opcode,insn_length(insn));
	else
		number_to_chars_littleendian(f,insn->insn_opcode,insn_length(insn));
}

/*
 * Move INSN to offset WHERE in FRAG.  Adjust the fixups accordingly and
 * install the opcode in the new location.
 */
static void	move_insn(struct riscv_cl_insn *insn,fragS * frag,long where)
{
	insn->frag = frag;
	insn->where = where;
	if (insn->fixp != NULL) {
		insn->fixp->fx_frag = frag;
		insn->fixp->fx_where = where;
	}
	install_insn(insn);
}

/* Add INSN to the end of the output.  */
static void	add_fixed_insn(struct riscv_cl_insn *insn)
{
	char           *f = frag_more(insn_length(insn));
	move_insn(insn,frag_now,f - frag_now->fr_literal);
}

static void	add_relaxed_insn(struct riscv_cl_insn *insn,int max_chars,int var,
	 		relax_substateT subtype,symbolS * symbol,offsetT offset)
{
	frag_grow(max_chars);
	move_insn(insn,frag_now,frag_more(0) - frag_now->fr_literal);
	frag_var(rs_machine_dependent,max_chars,var,
		 subtype,symbol,offset,NULL);
}

/*
 * Compute the length of a branch sequence,and adjust the stored length
 * accordingly.  If FRAGP is NULL,the worst-case length is returned.
 */
static unsigned	relaxed_branch_length(fragS * fragp,asection * sec,int update)
{
	int		jump      ,rvc,length = 8;

	if (!fragp)
		return length;

	jump = RELAX_BRANCH_UNCOND(fragp->fr_subtype);
	rvc = RELAX_BRANCH_RVC(fragp->fr_subtype);
	length = RELAX_BRANCH_LENGTH(fragp->fr_subtype);

	/* Assume jumps are in range; the linker will catch any that aren't.  */
	length = jump ? 4 : 8;

	if (fragp->fr_symbol != NULL
	    && S_IS_DEFINED(fragp->fr_symbol)
	    && !S_IS_WEAK(fragp->fr_symbol)
	    && sec == S_GET_SEGMENT(fragp->fr_symbol)) {
		offsetT		val = S_GET_VALUE(fragp->fr_symbol) + fragp->fr_offset;
		bfd_vma		rvc_range = jump ? RVC_JUMP_REACH : RVC_BRANCH_REACH;
		val -= fragp->fr_address + fragp->fr_fix;

		if (rvc && (bfd_vma) (val + rvc_range / 2) < rvc_range)
			length = 2;
		else
			if ((bfd_vma) (val + RISCV_BRANCH_REACH / 2) < RISCV_BRANCH_REACH)
				length = 4;
			else
				if (!jump && rvc)
					length = 6;
	}
	if (update)
		fragp->fr_subtype = RELAX_BRANCH_ENCODE(jump,rvc,length);

	return length;
}

/* Information about an opcode name,mnemonics and its value.  */
struct opcode_name_t {
	const char     *name;
	unsigned int	val;
};

/* List for all supported opcode name.  */
static const struct opcode_name_t opcode_name_list[] =
{
	{"C0",0x0},{"C1",0x1},{"C2",0x2},

	{"LOAD",0x03},{"LOAD_FP",0x07},{"CUSTOM_0",0x0b},
	{"MISC_MEM",0x0f},{"OP_IMM",0x13},{"AUIPC",0x17},
	{"OP_IMM_32",0x1b},
	/* 48b        0x1f.  */

	{"STORE",0x23},{"STORE_FP",0x27},{"CUSTOM_1",0x2b},
	{"AMO",0x2f},{"OP",0x33},{"LUI",0x37},
	{"OP_32",0x3b},
	/* 64b        0x3f.  */

	{"MADD",0x43},{"MSUB",0x47},{"NMADD",0x4f},
	{"NMSUB",0x4b},{"OP_FP",0x53},{"OP_V",0x57},
	{"CUSTOM_2",0x5b},
	/* 48b        0x5f.  */

	{"BRANCH",0x63},{"JALR",0x67},	/* reserved    0x5b.  */
	{"JAL",0x6f},{"SYSTEM",0x73},	/* reserved    0x77.  */
	{"CUSTOM_3",0x7b},
	/* >80b       0x7f.  */

	{NULL,0}
};

/* Hash table for lookup opcode name.  */
static htab_t	opcode_names_hash = NULL;

/* Initialization for hash table of opcode name.  */
static void	init_opcode_names_hash(void)
{
	const struct opcode_name_t *opcode;

	for (opcode = &opcode_name_list[0]; opcode->name != NULL; ++opcode)
		if (str_hash_insert(opcode_names_hash,opcode->name,opcode,0) != NULL)
			as_fatal(("internal: duplicate %s"),opcode->name);
}

/*
 * Find `s` is a valid opcode name or not,return the opcode name info if
 * found.
 */
static const struct opcode_name_t *opcode_name_lookup(char **s)
{
	char           *e;
	char		save_c;
	struct opcode_name_t *o;

	/* Find end of name.  */
	e = *s;
	if (is_name_beginner(*e))
		++e;
	while (is_part_of_name(*e))
		++e;

	/* Terminate name.  */
	save_c = *e;
	*e = '\0';

	o = (struct opcode_name_t *)str_hash_find(opcode_names_hash,*s);

	/* Advance to next token if one was recognized.  */
	if (o)
		*s = e;

	*e = save_c;
	expr_parse_end = e;

	return o;
}

/* All RISC-V registers belong to one of these classes.  */
enum reg_class {
	RCLASS_GPR,RCLASS_FPR,RCLASS_VECR,RCLASS_VECM,RCLASS_MAX,

	RCLASS_CSR
};

static htab_t	reg_names_hash = NULL;
static htab_t	csr_extra_hash = NULL;

#define ENCODE_REG_HASH(cls,n) \
  ((void *)(uintptr_t)((n) * RCLASS_MAX + (cls) + 1))
#define DECODE_REG_CLASS(hash) (((uintptr_t)(hash) - 1) % RCLASS_MAX)
#define DECODE_REG_NUM(hash) (((uintptr_t)(hash) - 1) / RCLASS_MAX)

static void	hash_reg_name(enum reg_class class,const char *name,unsigned n)
{
	void           *hash = ENCODE_REG_HASH(class,n);
	if (str_hash_insert(reg_names_hash,name,hash,0) != NULL)
		as_fatal(("internal: duplicate %s"),name);
}

static void	hash_reg_names(enum reg_class class,const char *const names[],unsigned n)
{
	unsigned	i;

	for (i = 0; i < n; i++)
		hash_reg_name(class,names[i],i);
}

/* Init hash table csr_extra_hash to handle CSR.  */
static void	riscv_init_csr_hash(const char *name,
						unsigned	address,
					enum		riscv_csr_class class,
	      		enum		riscv_spec_class define_version,
	       		enum		riscv_spec_class abort_version)
{
	struct riscv_csr_extra *entry,*pre_entry;
	bool		need_enrty = true;

	pre_entry = NULL;
	entry = (struct riscv_csr_extra *)str_hash_find(csr_extra_hash,name);
	while (need_enrty && entry != NULL) {
		if (entry->csr_class == class
		    && entry->address == address
		    && entry->define_version == define_version
		    && entry->abort_version == abort_version)
			need_enrty = false;
		pre_entry = entry;
		entry = entry->next;
	}

	/* Duplicate CSR.  */
	if (!need_enrty)
		return;

	entry = notes_alloc(sizeof(*entry));
	entry->csr_class = class;
	entry->address = address;
	entry->define_version = define_version;
	entry->abort_version = abort_version;
	entry->next = NULL;

	if (pre_entry == NULL)
		str_hash_insert(csr_extra_hash,name,entry,0);
	else
		pre_entry->next = entry;
}

/* Return the CSR address after checking the ISA dependency and the privileged
 * spec version.
 * 
 * There are one warning and two errors for CSR,
 * 
 * Invalid CSR: the CSR was defined,but isn't allowed for the current ISA or the
 * privileged spec,report warning only if -mcsr-check is set. Unknown CSR: the
 * CSR has never been defined,report error. Improper CSR: the CSR number over
 * the range (> 0xfff),report error.  */
static unsigned int riscv_csr_address(const char *csr_name,
				      		struct	riscv_csr_extra *entry)
{
	struct riscv_csr_extra *saved_entry = entry;
	enum riscv_csr_class csr_class = entry->csr_class;
	bool		need_check_version = false;
	bool		is_rv32_only = false;
	bool		is_h_required = false;
	const char     *extension = NULL;

	switch (csr_class) {
	case CSR_CLASS_I_32:
		is_rv32_only = true;
		/* Fall through.  */
	case CSR_CLASS_I:
		need_check_version = true;
		extension = "i";
		break;
	case CSR_CLASS_H_32:
		is_rv32_only = true;
		/* Fall through.  */
	case CSR_CLASS_H:
		extension = "h";
		break;
	case CSR_CLASS_F:
		extension = "f";
		break;
	case CSR_CLASS_ZKR:
		extension = "zkr";
		break;
	case CSR_CLASS_V:
		extension = "zve32x";
		break;
	case CSR_CLASS_SMAIA_32:
		is_rv32_only = true;
		/* Fall through.  */
	case CSR_CLASS_SMAIA:
		extension = "smaia";
		break;
	case CSR_CLASS_SMSTATEEN_32:
		is_rv32_only = true;
		/* Fall through.  */
	case CSR_CLASS_SMSTATEEN:
		extension = "smstateen";
		break;
	case CSR_CLASS_SSAIA:
	case CSR_CLASS_SSAIA_AND_H:
	case CSR_CLASS_SSAIA_32:
	case CSR_CLASS_SSAIA_AND_H_32:
		is_rv32_only = (csr_class == CSR_CLASS_SSAIA_32
				|| csr_class == CSR_CLASS_SSAIA_AND_H_32);
		is_h_required = (csr_class == CSR_CLASS_SSAIA_AND_H
				 || csr_class == CSR_CLASS_SSAIA_AND_H_32);
		extension = "ssaia";
		break;
	case CSR_CLASS_SSSTATEEN_AND_H_32:
		is_rv32_only = true;
		/* Fall through.  */
	case CSR_CLASS_SSSTATEEN_AND_H:
		is_h_required = true;
		/* Fall through.  */
	case CSR_CLASS_SSSTATEEN:
		extension = "ssstateen";
		break;
	case CSR_CLASS_SSCOFPMF_32:
		is_rv32_only = true;
		/* Fall through.  */
	case CSR_CLASS_SSCOFPMF:
		extension = "sscofpmf";
		break;
	case CSR_CLASS_SSTC: case CSR_CLASS_SSTC_AND_H:
	case CSR_CLASS_SSTC_32: case CSR_CLASS_SSTC_AND_H_32:
		is_rv32_only = (csr_class == CSR_CLASS_SSTC_32
				|| csr_class == CSR_CLASS_SSTC_AND_H_32);
		is_h_required = (csr_class == CSR_CLASS_SSTC_AND_H
				 || csr_class == CSR_CLASS_SSTC_AND_H_32);
		extension = "sstc";
		break;
	case CSR_CLASS_DEBUG:
		break;
	default:
		as_bad(("internal: bad RISC-V CSR class (0x%x)"),csr_class);
	}

	if (riscv_opts.csr_check) {
		if (is_rv32_only && xlen != 32)
			as_warn(("invalid CSR `%s',needs rv32i extension"),csr_name);
		if (is_h_required && !riscv_subset_supports(&riscv_rps_as,"h"))
			as_warn(("invalid CSR `%s',needs `h' extension"),csr_name);

		if (extension != NULL
		    && !riscv_subset_supports(&riscv_rps_as,extension))
			as_warn(("invalid CSR `%s',needs `%s' extension"),
				csr_name,extension);
	}
	while (entry != NULL) {
		if (!need_check_version
		    || (default_priv_spec >= entry->define_version
			&& default_priv_spec < entry->abort_version)) {
			/* Find the CSR according to the specific version.  */
			return entry->address;
		}
		entry = entry->next;
	}

	/*
	 * Can not find the CSR address from the chosen privileged version,so
	 * use the newly defined value.
	 */
	if (riscv_opts.csr_check) {
		const char     *priv_name = NULL;
		RISCV_GET_PRIV_SPEC_NAME(priv_name,default_priv_spec);
		if (priv_name != NULL)
			as_warn(("invalid CSR `%s' for the privileged spec `%s'"),
				csr_name,priv_name);
	}
	return saved_entry->address;
}

/*
 * Return -1 if the CSR has never been defined.  Otherwise,return the address.
 */
static unsigned int reg_csr_lookup_internal(const char *s)
{
	struct riscv_csr_extra *r =
	(struct riscv_csr_extra *)str_hash_find(csr_extra_hash,s);

	if (r == NULL)
		return -1U;

	return riscv_csr_address(s,r);
}

static unsigned int reg_lookup_internal(const char *s,enum reg_class class)
{
	void           *r;

	if (class == RCLASS_CSR)
		return reg_csr_lookup_internal(s);

	r = str_hash_find(reg_names_hash,s);
	if (r == NULL || DECODE_REG_CLASS(r) != class)
		return -1;

	if (riscv_subset_supports(&riscv_rps_as,"e")
	    && class == RCLASS_GPR
	    && DECODE_REG_NUM(r) > 15)
		return -1;

	return DECODE_REG_NUM(r);
}

static bool	reg_lookup(char **s,enum reg_class class,unsigned int *regnop)
{
	char           *e;
	char		save_c;
	int		reg = -1;

	/* Find end of name.  */
	e = *s;
	if (is_name_beginner(*e))
		++e;
	while (is_part_of_name(*e))
		++e;

	/* Terminate name.  */
	save_c = *e;
	*e = '\0';

	/* Look for the register.  Advance to next token if one was recognized.  */
	if ((reg = reg_lookup_internal(*s,class)) >= 0)
		*s = e;

	*e = save_c;
	if (regnop)
		*regnop = reg;
	return reg >= 0;
}

static bool	arg_lookup(char **s,const char *const *array,size_t size,unsigned *regnop)
{
	const char     *p = strchr(*s,',');
	size_t		i      ,len = p ? (size_t) (p - *s) : strlen(*s);

	if (len == 0)
		return false;

	for (i = 0; i < size; i++)
		if (array[i] != NULL && strncmp(array[i],*s,len) == 0
		    && array[i][len] == '\0') {
			*regnop = i;
			*s += len;
			return true;
		}
	return false;
}

#define USE_BITS(mask,shift) (used_bits |= ((insn_t)(mask) << (shift)))
#define USE_IMM(n,s) \
  (used_bits |= ((insn_t)((1ull<<n)-1) << (s)))

/*
 * For consistency checking,verify that all bits are specified either by the
 * match/mask part of the instruction definition,or by the operand list. The
 * `length` could be the actual instruction length or 0 for auto-detection.
 */
static bool	validate_riscv_insn(const struct riscv_opcode *opc,int length)
{
	const char     *oparg,*opargStart;
	insn_t		used_bits = opc->mask;
	int		insn_width;
	insn_t		required_bits;

	if (length == 0)
		length = riscv_insn_length(opc->match);
	/* We don't support instructions longer than 64-bits yet.  */
	if (length > 8)
		length = 8;
	insn_width = 8 * length;

	required_bits = ((insn_t) ~ 0ULL) >> (64 - insn_width);

	if ((used_bits & opc->match) != (opc->match & required_bits)) {
		as_bad(("internal: bad RISC-V opcode (mask error): %s %s"),
		       opc->name,opc->args);
		return false;
	}
	for (oparg = opc->args; *oparg; ++oparg) {
		opargStart = oparg;
		switch (*oparg) {
		case 'C':	/* RVC */
			switch (*++oparg) {
			case 'U':
				break;	/* CRS1,constrained to equal RD.  */
			case 'c':
				break;	/* CRS1,constrained to equal sp.  */
			case 'T':	/* CRS2,floating point.  */
			case 'V':
				USE_BITS(OP_MASK_CRS2,OP_SH_CRS2);
				break;
			case 'S':	/* CRS1S,floating point.  */
			case 's':
				USE_BITS(OP_MASK_CRS1S,OP_SH_CRS1S);
				break;
			case 'w':
				break;	/* CRS1S,constrained to equal RD.  */
			case 'D':	/* CRS2S,floating point.  */
			case 't':
				USE_BITS(OP_MASK_CRS2S,OP_SH_CRS2S);
				break;
			case 'x':
				break;	/* CRS2S,constrained to equal RD.  */
			case 'z':
				break;	/* CRS2S,constrained to be x0.  */
			case '>':	/* CITYPE immediate,compressed shift.  */
			case 'u':	/* CITYPE immediate,compressed lui.  */
			case 'v':	/* CITYPE immediate,li to compressed
					 * lui.  */
			case 'o':	/* CITYPE immediate,allow zero.  */
			case 'j':
				used_bits |= ENCODE_CITYPE_IMM(-1U);
				break;
			case 'L':
				used_bits |= ENCODE_CITYPE_ADDI16SP_IMM(-1U);
				break;
			case 'm':
				used_bits |= ENCODE_CITYPE_LWSP_IMM(-1U);
				break;
			case 'n':
				used_bits |= ENCODE_CITYPE_LDSP_IMM(-1U);
				break;
			case '6':
				used_bits |= ENCODE_CSSTYPE_IMM(-1U);
				break;
			case 'M':
				used_bits |= ENCODE_CSSTYPE_SWSP_IMM(-1U);
				break;
			case 'N':
				used_bits |= ENCODE_CSSTYPE_SDSP_IMM(-1U);
				break;
			case '8':
				used_bits |= ENCODE_CIWTYPE_IMM(-1U);
				break;
			case 'K':
				used_bits |= ENCODE_CIWTYPE_ADDI4SPN_IMM(-1U);
				break;
				/*
				 * CLTYPE and CSTYPE have the same immediate
				 * encoding.
				 */
			case '5':
				used_bits |= ENCODE_CLTYPE_IMM(-1U);
				break;
			case 'k':
				used_bits |= ENCODE_CLTYPE_LW_IMM(-1U);
				break;
			case 'l':
				used_bits |= ENCODE_CLTYPE_LD_IMM(-1U);
				break;
			case 'p':
				used_bits |= ENCODE_CBTYPE_IMM(-1U);
				break;
			case 'a':
				used_bits |= ENCODE_CJTYPE_IMM(-1U);
				break;
			case 'F':	/* Compressed funct for .insn
					 * directive.  */
				switch (*++oparg) {
				case '6':
					USE_BITS(OP_MASK_CFUNCT6,OP_SH_CFUNCT6);
					break;
				case '4':
					USE_BITS(OP_MASK_CFUNCT4,OP_SH_CFUNCT4);
					break;
				case '3':
					USE_BITS(OP_MASK_CFUNCT3,OP_SH_CFUNCT3);
					break;
				case '2':
					USE_BITS(OP_MASK_CFUNCT2,OP_SH_CFUNCT2);
					break;
				default:
					goto unknown_validate_operand;
				}
				break;
			default:
				goto unknown_validate_operand;
			}
			break;	/* end RVC */
		case 'V':	/* RVV */
			switch (*++oparg) {
			case 'd':
			case 'f':
				USE_BITS(OP_MASK_VD,OP_SH_VD);
				break;
			case 'e':
				USE_BITS(OP_MASK_VWD,OP_SH_VWD);
				break;
			case 's':
				USE_BITS(OP_MASK_VS1,OP_SH_VS1);
				break;
			case 't':
				USE_BITS(OP_MASK_VS2,OP_SH_VS2);
				break;
			case 'u':
				USE_BITS(OP_MASK_VS1,OP_SH_VS1);
				USE_BITS(OP_MASK_VS2,OP_SH_VS2);
				break;
			case 'v':
				USE_BITS(OP_MASK_VD,OP_SH_VD);
				USE_BITS(OP_MASK_VS1,OP_SH_VS1);
				USE_BITS(OP_MASK_VS2,OP_SH_VS2);
				break;
			case '0':
				break;
			case 'b':
				used_bits |= ENCODE_RVV_VB_IMM(-1U);
				break;
			case 'c':
				used_bits |= ENCODE_RVV_VC_IMM(-1U);
				break;
			case 'i':
			case 'j':
			case 'k':
				USE_BITS(OP_MASK_VIMM,OP_SH_VIMM);
				break;
			case 'm':
				USE_BITS(OP_MASK_VMASK,OP_SH_VMASK);
				break;
			case 'M':
				break;	/* Macro operand,must be a mask
					 * register.  */
			case 'T':
				break;	/* Macro operand,must be a vector
					 * register.  */
			default:
				goto unknown_validate_operand;
			}
			break;	/* end RVV */
		case ',':
			break;
		case '(':
			break;
		case ')':
			break;
		case '<':
			USE_BITS(OP_MASK_SHAMTW,OP_SH_SHAMTW);
			break;
		case '>':
			USE_BITS(OP_MASK_SHAMT,OP_SH_SHAMT);
			break;
		case 'A':
			break;	/* Macro operand,must be symbol.  */
		case 'B':
			break;	/* Macro operand,must be symbol or constant.  */
		case 'c':
			break;	/* Macro operand,must be symbol or constant.  */
		case 'I':
			break;	/* Macro operand,must be constant.  */
		case 'D':	/* RD,floating point.  */
		case 'd':
			USE_BITS(OP_MASK_RD,OP_SH_RD);
			break;
		case 'y':
			USE_BITS(OP_MASK_BS,OP_SH_BS);
			break;
		case 'Y':
			USE_BITS(OP_MASK_RNUM,OP_SH_RNUM);
			break;
		case 'Z':	/* RS1,CSR number.  */
		case 'S':	/* RS1,floating point.  */
		case 's':
			USE_BITS(OP_MASK_RS1,OP_SH_RS1);
			break;
		case 'U':	/* RS1 and RS2 are the same,floating point.  */
			USE_BITS(OP_MASK_RS1,OP_SH_RS1);
			/* Fall through.  */
		case 'T':	/* RS2,floating point.  */
		case 't':
			USE_BITS(OP_MASK_RS2,OP_SH_RS2);
			break;
		case 'R':	/* RS3,floating point.  */
		case 'r':
			USE_BITS(OP_MASK_RS3,OP_SH_RS3);
			break;
		case 'm':
			USE_BITS(OP_MASK_RM,OP_SH_RM);
			break;
		case 'E':
			USE_BITS(OP_MASK_CSR,OP_SH_CSR);
			break;
		case 'P':
			USE_BITS(OP_MASK_PRED,OP_SH_PRED);
			break;
		case 'Q':
			USE_BITS(OP_MASK_SUCC,OP_SH_SUCC);
			break;
		case 'o':	/* ITYPE immediate,load displacement.  */
		case 'j':
			used_bits |= ENCODE_ITYPE_IMM(-1U);
			break;
		case 'a':
			used_bits |= ENCODE_JTYPE_IMM(-1U);
			break;
		case 'p':
			used_bits |= ENCODE_BTYPE_IMM(-1U);
			break;
		case 'q':
			used_bits |= ENCODE_STYPE_IMM(-1U);
			break;
		case 'u':
			used_bits |= ENCODE_UTYPE_IMM(-1U);
			break;
		case 'z':
			break;	/* Zero immediate.  */
		case '[':
			break;	/* Unused operand.  */
		case ']':
			break;	/* Unused operand.  */
		case '0':
			break;	/* AMO displacement,must to zero.  */
		case '1':
			break;	/* Relaxation operand.  */
		case 'F':	/* Funct for .insn directive.  */
			switch (*++oparg) {
			case '7':
				USE_BITS(OP_MASK_FUNCT7,OP_SH_FUNCT7);
				break;
			case '3':
				USE_BITS(OP_MASK_FUNCT3,OP_SH_FUNCT3);
				break;
			case '2':
				USE_BITS(OP_MASK_FUNCT2,OP_SH_FUNCT2);
				break;
			default:
				goto unknown_validate_operand;
			}
			break;
		case 'O':	/* Opcode for .insn directive.  */
			switch (*++oparg) {
			case '4':
				USE_BITS(OP_MASK_OP,OP_SH_OP);
				break;
			case '2':
				USE_BITS(OP_MASK_OP2,OP_SH_OP2);
				break;
			default:
				goto unknown_validate_operand;
			}
			break;
		case 'W':	/* Various operands.  */
			switch (*++oparg) {
			case 'i':
				switch (*++oparg) {
				case 'f':
					used_bits |= ENCODE_STYPE_IMM(-1U);
					break;
				default:
					goto unknown_validate_operand;
				}
				break;
			default:
				goto unknown_validate_operand;
			}
			break;
		case 'X':	/* Integer immediate.  */
			{
				size_t		n;
				size_t		s;

				switch (*++oparg) {
				case 'l':	/* Literal.  */
					oparg += strcspn(oparg,",") - 1;
					break;
				case 's':	/* 'XsN@S' ... N-bit signed
						 * immediate at bit S.  */
					goto use_imm;
				case 'u':	/* 'XuN@S' ... N-bit unsigned
						 * immediate at bit S.  */
					goto use_imm;
			use_imm:
					n = strtol(oparg + 1,(char **)&oparg,10);
					if (*oparg != '@')
						goto unknown_validate_operand;
					s = strtol(oparg + 1,(char **)&oparg,10);
					oparg--;

					USE_IMM(n,s);
					break;
				default:
					goto unknown_validate_operand;
				}
			}
			break;
		default:
	unknown_validate_operand:
			as_bad(("internal: bad RISC-V opcode "
				"(unknown operand type `%s'): %s %s"),
			       opargStart,opc->name,opc->args);
			return false;
		}
	}

	if (used_bits != required_bits) {
		as_bad(("internal: bad RISC-V opcode "
			"(bits %#llx undefined or invalid): %s %s"),
		       (unsigned long long)(used_bits ^ required_bits),
		       opc->name,opc->args);
		return false;
	}
	return true;
}

#undef USE_BITS

struct percent_op_match {
	const char     *str;
	bfd_reloc_code_real_type reloc;
};

/*
 * Common hash table initialization function for instruction and .insn
 * directive.
 */
static htab_t	init_opcode_hash(const struct riscv_opcode *opcodes,
			       		bool		insn_directive_p)
{
	int		i = 0;
	int		length;
	htab_t		hash = str_htab_create();
	while (opcodes[i].name) {
		const char     *name = opcodes[i].name;
		if (str_hash_insert(hash,name,&opcodes[i],0) != NULL)
			as_fatal(("internal: duplicate %s"),name);

		do {
			if (opcodes[i].pinfo != INSN_MACRO) {
				if (insn_directive_p)
					length = ((name[0] == 'c') ? 2 : 4);
				else
					length = 0;	/* Let assembler
							 * determine the length.  */
				if (!validate_riscv_insn(&opcodes[i],length))
					as_fatal(("internal: broken assembler.  "
						  "No assembly attempted"));
			} else
				gas_assert(!insn_directive_p);
			++i;
		}
		while (opcodes[i].name && !strcmp(opcodes[i].name,name));
	}

	return hash;
}
struct init_csr_data {
	const char     *name;
	unsigned short	num;
	unsigned short	class;
	unsigned short	define_version;
	unsigned short	abort_version;
};
static struct init_csr_data csr_data[] = {
	{"cycle",CSR_CYCLE,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"time",CSR_TIME,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"instret",CSR_INSTRET,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter3",CSR_HPMCOUNTER3,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter4",CSR_HPMCOUNTER4,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter5",CSR_HPMCOUNTER5,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter6",CSR_HPMCOUNTER6,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter7",CSR_HPMCOUNTER7,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter8",CSR_HPMCOUNTER8,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter9",CSR_HPMCOUNTER9,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter10",CSR_HPMCOUNTER10,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter11",CSR_HPMCOUNTER11,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter12",CSR_HPMCOUNTER12,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter13",CSR_HPMCOUNTER13,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter14",CSR_HPMCOUNTER14,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter15",CSR_HPMCOUNTER15,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter16",CSR_HPMCOUNTER16,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter17",CSR_HPMCOUNTER17,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter18",CSR_HPMCOUNTER18,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter19",CSR_HPMCOUNTER19,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter20",CSR_HPMCOUNTER20,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter21",CSR_HPMCOUNTER21,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter22",CSR_HPMCOUNTER22,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter23",CSR_HPMCOUNTER23,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter24",CSR_HPMCOUNTER24,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter25",CSR_HPMCOUNTER25,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter26",CSR_HPMCOUNTER26,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter27",CSR_HPMCOUNTER27,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter28",CSR_HPMCOUNTER28,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter29",CSR_HPMCOUNTER29,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter30",CSR_HPMCOUNTER30,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter31",CSR_HPMCOUNTER31,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"cycleh",CSR_CYCLEH,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"timeh",CSR_TIMEH,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"instreth",CSR_INSTRETH,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter3h",CSR_HPMCOUNTER3H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter4h",CSR_HPMCOUNTER4H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter5h",CSR_HPMCOUNTER5H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter6h",CSR_HPMCOUNTER6H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter7h",CSR_HPMCOUNTER7H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter8h",CSR_HPMCOUNTER8H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter9h",CSR_HPMCOUNTER9H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter10h",CSR_HPMCOUNTER10H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter11h",CSR_HPMCOUNTER11H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter12h",CSR_HPMCOUNTER12H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter13h",CSR_HPMCOUNTER13H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter14h",CSR_HPMCOUNTER14H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter15h",CSR_HPMCOUNTER15H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter16h",CSR_HPMCOUNTER16H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter17h",CSR_HPMCOUNTER17H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter18h",CSR_HPMCOUNTER18H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter19h",CSR_HPMCOUNTER19H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter20h",CSR_HPMCOUNTER20H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter21h",CSR_HPMCOUNTER21H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter22h",CSR_HPMCOUNTER22H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter23h",CSR_HPMCOUNTER23H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter24h",CSR_HPMCOUNTER24H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter25h",CSR_HPMCOUNTER25H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter26h",CSR_HPMCOUNTER26H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter27h",CSR_HPMCOUNTER27H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter28h",CSR_HPMCOUNTER28H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter29h",CSR_HPMCOUNTER29H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter30h",CSR_HPMCOUNTER30H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"hpmcounter31h",CSR_HPMCOUNTER31H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	/* Privileged Supervisor CSRs.  */
	{"sstatus",CSR_SSTATUS,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"sie",CSR_SIE,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"stvec",CSR_STVEC,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"scounteren",CSR_SCOUNTEREN,CSR_CLASS_I,PRIV_SPEC_CLASS_1P10,PRIV_SPEC_CLASS_DRAFT},
	{"senvcfg",CSR_SENVCFG,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"sscratch",CSR_SSCRATCH,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"sepc",CSR_SEPC,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"scause",CSR_SCAUSE,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"stval",CSR_STVAL,CSR_CLASS_I,PRIV_SPEC_CLASS_1P10,PRIV_SPEC_CLASS_DRAFT},
	{"sip",CSR_SIP,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"satp",CSR_SATP,CSR_CLASS_I,PRIV_SPEC_CLASS_1P10,PRIV_SPEC_CLASS_DRAFT},
	/* Privileged Machine CSRs.  */
	{"mvendorid",CSR_MVENDORID,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"marchid",CSR_MARCHID,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mimpid",CSR_MIMPID,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhartid",CSR_MHARTID,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mconfigptr",CSR_MCONFIGPTR,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"mstatus",CSR_MSTATUS,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"misa",CSR_MISA,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"medeleg",CSR_MEDELEG,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mideleg",CSR_MIDELEG,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mie",CSR_MIE,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mtvec",CSR_MTVEC,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mcounteren",CSR_MCOUNTEREN,CSR_CLASS_I,PRIV_SPEC_CLASS_1P10,PRIV_SPEC_CLASS_DRAFT},
	{"mstatush",CSR_MSTATUSH,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"mscratch",CSR_MSCRATCH,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mepc",CSR_MEPC,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mcause",CSR_MCAUSE,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mtval",CSR_MTVAL,CSR_CLASS_I,PRIV_SPEC_CLASS_1P10,PRIV_SPEC_CLASS_DRAFT},
	{"mip",CSR_MIP,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mtinst",CSR_MTINST,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"mtval2",CSR_MTVAL2,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"menvcfg",CSR_MENVCFG,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"menvcfgh",CSR_MENVCFGH,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"mseccfg",CSR_MSECCFG,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"mseccfgh",CSR_MSECCFGH,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpcfg0",CSR_PMPCFG0,CSR_CLASS_I,PRIV_SPEC_CLASS_1P10,PRIV_SPEC_CLASS_DRAFT},
	{"pmpcfg1",CSR_PMPCFG1,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P10,PRIV_SPEC_CLASS_DRAFT},
	{"pmpcfg2",CSR_PMPCFG2,CSR_CLASS_I,PRIV_SPEC_CLASS_1P10,PRIV_SPEC_CLASS_DRAFT},
	{"pmpcfg3",CSR_PMPCFG3,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P10,PRIV_SPEC_CLASS_DRAFT},
	{"pmpcfg4",CSR_PMPCFG4,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpcfg5",CSR_PMPCFG5,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpcfg6",CSR_PMPCFG6,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpcfg7",CSR_PMPCFG7,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpcfg8",CSR_PMPCFG8,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpcfg9",CSR_PMPCFG9,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpcfg10",CSR_PMPCFG10,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpcfg11",CSR_PMPCFG11,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpcfg12",CSR_PMPCFG12,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpcfg13",CSR_PMPCFG13,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpcfg14",CSR_PMPCFG14,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpcfg15",CSR_PMPCFG15,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr0",CSR_PMPADDR0,CSR_CLASS_I,PRIV_SPEC_CLASS_1P10,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr1",CSR_PMPADDR1,CSR_CLASS_I,PRIV_SPEC_CLASS_1P10,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr2",CSR_PMPADDR2,CSR_CLASS_I,PRIV_SPEC_CLASS_1P10,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr3",CSR_PMPADDR3,CSR_CLASS_I,PRIV_SPEC_CLASS_1P10,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr4",CSR_PMPADDR4,CSR_CLASS_I,PRIV_SPEC_CLASS_1P10,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr5",CSR_PMPADDR5,CSR_CLASS_I,PRIV_SPEC_CLASS_1P10,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr6",CSR_PMPADDR6,CSR_CLASS_I,PRIV_SPEC_CLASS_1P10,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr7",CSR_PMPADDR7,CSR_CLASS_I,PRIV_SPEC_CLASS_1P10,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr8",CSR_PMPADDR8,CSR_CLASS_I,PRIV_SPEC_CLASS_1P10,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr9",CSR_PMPADDR9,CSR_CLASS_I,PRIV_SPEC_CLASS_1P10,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr10",CSR_PMPADDR10,CSR_CLASS_I,PRIV_SPEC_CLASS_1P10,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr11",CSR_PMPADDR11,CSR_CLASS_I,PRIV_SPEC_CLASS_1P10,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr12",CSR_PMPADDR12,CSR_CLASS_I,PRIV_SPEC_CLASS_1P10,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr13",CSR_PMPADDR13,CSR_CLASS_I,PRIV_SPEC_CLASS_1P10,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr14",CSR_PMPADDR14,CSR_CLASS_I,PRIV_SPEC_CLASS_1P10,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr15",CSR_PMPADDR15,CSR_CLASS_I,PRIV_SPEC_CLASS_1P10,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr16",CSR_PMPADDR16,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr17",CSR_PMPADDR17,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr18",CSR_PMPADDR18,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr19",CSR_PMPADDR19,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr20",CSR_PMPADDR20,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr21",CSR_PMPADDR21,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr22",CSR_PMPADDR22,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr23",CSR_PMPADDR23,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr24",CSR_PMPADDR24,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr25",CSR_PMPADDR25,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr26",CSR_PMPADDR26,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr27",CSR_PMPADDR27,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr28",CSR_PMPADDR28,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr29",CSR_PMPADDR29,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr30",CSR_PMPADDR30,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr31",CSR_PMPADDR31,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr32",CSR_PMPADDR32,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr33",CSR_PMPADDR33,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr34",CSR_PMPADDR34,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr35",CSR_PMPADDR35,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr36",CSR_PMPADDR36,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr37",CSR_PMPADDR37,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr38",CSR_PMPADDR38,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr39",CSR_PMPADDR39,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr40",CSR_PMPADDR40,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr41",CSR_PMPADDR41,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr42",CSR_PMPADDR42,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr43",CSR_PMPADDR43,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr44",CSR_PMPADDR44,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr45",CSR_PMPADDR45,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr46",CSR_PMPADDR46,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr47",CSR_PMPADDR47,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr48",CSR_PMPADDR48,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr49",CSR_PMPADDR49,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr50",CSR_PMPADDR50,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr51",CSR_PMPADDR51,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr52",CSR_PMPADDR52,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr53",CSR_PMPADDR53,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr54",CSR_PMPADDR54,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr55",CSR_PMPADDR55,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr56",CSR_PMPADDR56,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr57",CSR_PMPADDR57,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr58",CSR_PMPADDR58,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr59",CSR_PMPADDR59,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr60",CSR_PMPADDR60,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr61",CSR_PMPADDR61,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr62",CSR_PMPADDR62,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"pmpaddr63",CSR_PMPADDR63,CSR_CLASS_I,PRIV_SPEC_CLASS_1P12,PRIV_SPEC_CLASS_DRAFT},
	{"mcycle",CSR_MCYCLE,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"minstret",CSR_MINSTRET,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter3",CSR_MHPMCOUNTER3,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter4",CSR_MHPMCOUNTER4,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter5",CSR_MHPMCOUNTER5,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter6",CSR_MHPMCOUNTER6,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter7",CSR_MHPMCOUNTER7,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter8",CSR_MHPMCOUNTER8,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter9",CSR_MHPMCOUNTER9,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter10",CSR_MHPMCOUNTER10,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter11",CSR_MHPMCOUNTER11,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter12",CSR_MHPMCOUNTER12,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter13",CSR_MHPMCOUNTER13,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter14",CSR_MHPMCOUNTER14,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter15",CSR_MHPMCOUNTER15,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter16",CSR_MHPMCOUNTER16,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter17",CSR_MHPMCOUNTER17,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter18",CSR_MHPMCOUNTER18,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter19",CSR_MHPMCOUNTER19,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter20",CSR_MHPMCOUNTER20,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter21",CSR_MHPMCOUNTER21,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter22",CSR_MHPMCOUNTER22,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter23",CSR_MHPMCOUNTER23,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter24",CSR_MHPMCOUNTER24,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter25",CSR_MHPMCOUNTER25,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter26",CSR_MHPMCOUNTER26,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter27",CSR_MHPMCOUNTER27,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter28",CSR_MHPMCOUNTER28,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter29",CSR_MHPMCOUNTER29,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter30",CSR_MHPMCOUNTER30,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter31",CSR_MHPMCOUNTER31,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mcycleh",CSR_MCYCLEH,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"minstreth",CSR_MINSTRETH,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter3h",CSR_MHPMCOUNTER3H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter4h",CSR_MHPMCOUNTER4H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter5h",CSR_MHPMCOUNTER5H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter6h",CSR_MHPMCOUNTER6H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter7h",CSR_MHPMCOUNTER7H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter8h",CSR_MHPMCOUNTER8H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter9h",CSR_MHPMCOUNTER9H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter10h",CSR_MHPMCOUNTER10H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter11h",CSR_MHPMCOUNTER11H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter12h",CSR_MHPMCOUNTER12H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter13h",CSR_MHPMCOUNTER13H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter14h",CSR_MHPMCOUNTER14H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter15h",CSR_MHPMCOUNTER15H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter16h",CSR_MHPMCOUNTER16H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter17h",CSR_MHPMCOUNTER17H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter18h",CSR_MHPMCOUNTER18H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter19h",CSR_MHPMCOUNTER19H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter20h",CSR_MHPMCOUNTER20H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter21h",CSR_MHPMCOUNTER21H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter22h",CSR_MHPMCOUNTER22H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter23h",CSR_MHPMCOUNTER23H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter24h",CSR_MHPMCOUNTER24H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter25h",CSR_MHPMCOUNTER25H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter26h",CSR_MHPMCOUNTER26H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter27h",CSR_MHPMCOUNTER27H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter28h",CSR_MHPMCOUNTER28H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter29h",CSR_MHPMCOUNTER29H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter30h",CSR_MHPMCOUNTER30H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmcounter31h",CSR_MHPMCOUNTER31H,CSR_CLASS_I_32,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mcountinhibit",CSR_MCOUNTINHIBIT,CSR_CLASS_I,PRIV_SPEC_CLASS_1P11,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmevent3",CSR_MHPMEVENT3,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmevent4",CSR_MHPMEVENT4,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmevent5",CSR_MHPMEVENT5,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmevent6",CSR_MHPMEVENT6,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmevent7",CSR_MHPMEVENT7,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmevent8",CSR_MHPMEVENT8,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmevent9",CSR_MHPMEVENT9,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmevent10",CSR_MHPMEVENT10,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmevent11",CSR_MHPMEVENT11,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmevent12",CSR_MHPMEVENT12,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmevent13",CSR_MHPMEVENT13,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmevent14",CSR_MHPMEVENT14,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmevent15",CSR_MHPMEVENT15,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmevent16",CSR_MHPMEVENT16,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmevent17",CSR_MHPMEVENT17,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmevent18",CSR_MHPMEVENT18,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmevent19",CSR_MHPMEVENT19,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmevent20",CSR_MHPMEVENT20,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmevent21",CSR_MHPMEVENT21,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmevent22",CSR_MHPMEVENT22,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmevent23",CSR_MHPMEVENT23,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmevent24",CSR_MHPMEVENT24,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmevent25",CSR_MHPMEVENT25,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmevent26",CSR_MHPMEVENT26,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmevent27",CSR_MHPMEVENT27,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmevent28",CSR_MHPMEVENT28,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmevent29",CSR_MHPMEVENT29,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmevent30",CSR_MHPMEVENT30,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	{"mhpmevent31",CSR_MHPMEVENT31,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_DRAFT},
	/* Privileged Hypervisor CSRs.  */
	{"hstatus",CSR_HSTATUS,CSR_CLASS_H,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"hedeleg",CSR_HEDELEG,CSR_CLASS_H,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"hideleg",CSR_HIDELEG,CSR_CLASS_H,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"hie",CSR_HIE,CSR_CLASS_H,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"hcounteren",CSR_HCOUNTEREN,CSR_CLASS_H,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"hgeie",CSR_HGEIE,CSR_CLASS_H,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"htval",CSR_HTVAL,CSR_CLASS_H,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"hip",CSR_HIP,CSR_CLASS_H,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"hvip",CSR_HVIP,CSR_CLASS_H,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"htinst",CSR_HTINST,CSR_CLASS_H,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"hgeip",CSR_HGEIP,CSR_CLASS_H,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"henvcfg",CSR_HENVCFG,CSR_CLASS_H,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"henvcfgh",CSR_HENVCFGH,CSR_CLASS_H_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"hgatp",CSR_HGATP,CSR_CLASS_H,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"htimedelta",CSR_HTIMEDELTA,CSR_CLASS_H,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"htimedeltah",CSR_HTIMEDELTAH,CSR_CLASS_H_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"vsstatus",CSR_VSSTATUS,CSR_CLASS_H,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"vsie",CSR_VSIE,CSR_CLASS_H,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"vstvec",CSR_VSTVEC,CSR_CLASS_H,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"vsscratch",CSR_VSSCRATCH,CSR_CLASS_H,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"vsepc",CSR_VSEPC,CSR_CLASS_H,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"vscause",CSR_VSCAUSE,CSR_CLASS_H,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"vstval",CSR_VSTVAL,CSR_CLASS_H,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"vsip",CSR_VSIP,CSR_CLASS_H,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"vsatp",CSR_VSATP,CSR_CLASS_H,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	/* Smaia extension */
	{"miselect",CSR_MISELECT,CSR_CLASS_SMAIA,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mireg",CSR_MIREG,CSR_CLASS_SMAIA,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mtopei",CSR_MTOPEI,CSR_CLASS_SMAIA,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mtopi",CSR_MTOPI,CSR_CLASS_SMAIA,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mvien",CSR_MVIEN,CSR_CLASS_SMAIA,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mvip",CSR_MVIP,CSR_CLASS_SMAIA,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"midelegh",CSR_MIDELEGH,CSR_CLASS_SMAIA_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mieh",CSR_MIEH,CSR_CLASS_SMAIA_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mvienh",CSR_MVIENH,CSR_CLASS_SMAIA_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mviph",CSR_MVIPH,CSR_CLASS_SMAIA_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"miph",CSR_MIPH,CSR_CLASS_SMAIA_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	/* Smstateen/Ssstateen extensions.  */
	{"mstateen0",CSR_MSTATEEN0,CSR_CLASS_SMSTATEEN,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mstateen1",CSR_MSTATEEN1,CSR_CLASS_SMSTATEEN,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mstateen2",CSR_MSTATEEN2,CSR_CLASS_SMSTATEEN,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mstateen3",CSR_MSTATEEN3,CSR_CLASS_SMSTATEEN,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"sstateen0",CSR_SSTATEEN0,CSR_CLASS_SSSTATEEN,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"sstateen1",CSR_SSTATEEN1,CSR_CLASS_SSSTATEEN,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"sstateen2",CSR_SSTATEEN2,CSR_CLASS_SSSTATEEN,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"sstateen3",CSR_SSTATEEN3,CSR_CLASS_SSSTATEEN,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"hstateen0",CSR_HSTATEEN0,CSR_CLASS_SSSTATEEN_AND_H,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"hstateen1",CSR_HSTATEEN1,CSR_CLASS_SSSTATEEN_AND_H,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"hstateen2",CSR_HSTATEEN2,CSR_CLASS_SSSTATEEN_AND_H,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"hstateen3",CSR_HSTATEEN3,CSR_CLASS_SSSTATEEN_AND_H,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mstateen0h",CSR_MSTATEEN0H,CSR_CLASS_SMSTATEEN_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mstateen1h",CSR_MSTATEEN1H,CSR_CLASS_SMSTATEEN_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mstateen2h",CSR_MSTATEEN2H,CSR_CLASS_SMSTATEEN_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mstateen3h",CSR_MSTATEEN3H,CSR_CLASS_SMSTATEEN_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"hstateen0h",CSR_HSTATEEN0H,CSR_CLASS_SSSTATEEN_AND_H_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"hstateen1h",CSR_HSTATEEN1H,CSR_CLASS_SSSTATEEN_AND_H_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"hstateen2h",CSR_HSTATEEN2H,CSR_CLASS_SSSTATEEN_AND_H_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"hstateen3h",CSR_HSTATEEN3H,CSR_CLASS_SSSTATEEN_AND_H_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	/* Ssaia extension */
	{"siselect",CSR_SISELECT,CSR_CLASS_SSAIA,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"sireg",CSR_SIREG,CSR_CLASS_SSAIA,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"stopei",CSR_STOPEI,CSR_CLASS_SSAIA,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"stopi",CSR_STOPI,CSR_CLASS_SSAIA,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"sieh",CSR_SIEH,CSR_CLASS_SSAIA_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"siph",CSR_SIPH,CSR_CLASS_SSAIA_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"hvien",CSR_HVIEN,CSR_CLASS_SSAIA_AND_H,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"hvictl",CSR_HVICTL,CSR_CLASS_SSAIA_AND_H,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"hviprio1",CSR_HVIPRIO1,CSR_CLASS_SSAIA_AND_H,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"hviprio2",CSR_HVIPRIO2,CSR_CLASS_SSAIA_AND_H,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"vsiselect",CSR_VSISELECT,CSR_CLASS_SSAIA_AND_H,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"vsireg",CSR_VSIREG,CSR_CLASS_SSAIA_AND_H,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"vstopei",CSR_VSTOPEI,CSR_CLASS_SSAIA_AND_H,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"vstopi",CSR_VSTOPI,CSR_CLASS_SSAIA_AND_H,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"hidelegh",CSR_HIDELEGH,CSR_CLASS_SSAIA_AND_H_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"hvienh",CSR_HVIENH,CSR_CLASS_SSAIA_AND_H_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"hviph",CSR_HVIPH,CSR_CLASS_SSAIA_AND_H_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"hviprio1h",CSR_HVIPRIO1H,CSR_CLASS_SSAIA_AND_H_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"hviprio2h",CSR_HVIPRIO2H,CSR_CLASS_SSAIA_AND_H_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"vsieh",CSR_VSIEH,CSR_CLASS_SSAIA_AND_H_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"vsiph",CSR_VSIPH,CSR_CLASS_SSAIA_AND_H_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	/* Sscofpmf extension */
	{"scountovf",CSR_SCOUNTOVF,CSR_CLASS_SSCOFPMF,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mhpmevent3h",CSR_MHPMEVENT3H,CSR_CLASS_SSCOFPMF_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mhpmevent4h",CSR_MHPMEVENT4H,CSR_CLASS_SSCOFPMF_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mhpmevent5h",CSR_MHPMEVENT5H,CSR_CLASS_SSCOFPMF_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mhpmevent6h",CSR_MHPMEVENT6H,CSR_CLASS_SSCOFPMF_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mhpmevent7h",CSR_MHPMEVENT7H,CSR_CLASS_SSCOFPMF_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mhpmevent8h",CSR_MHPMEVENT8H,CSR_CLASS_SSCOFPMF_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mhpmevent9h",CSR_MHPMEVENT9H,CSR_CLASS_SSCOFPMF_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mhpmevent10h",CSR_MHPMEVENT10H,CSR_CLASS_SSCOFPMF_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mhpmevent11h",CSR_MHPMEVENT11H,CSR_CLASS_SSCOFPMF_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mhpmevent12h",CSR_MHPMEVENT12H,CSR_CLASS_SSCOFPMF_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mhpmevent13h",CSR_MHPMEVENT13H,CSR_CLASS_SSCOFPMF_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mhpmevent14h",CSR_MHPMEVENT14H,CSR_CLASS_SSCOFPMF_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mhpmevent15h",CSR_MHPMEVENT15H,CSR_CLASS_SSCOFPMF_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mhpmevent16h",CSR_MHPMEVENT16H,CSR_CLASS_SSCOFPMF_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mhpmevent17h",CSR_MHPMEVENT17H,CSR_CLASS_SSCOFPMF_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mhpmevent18h",CSR_MHPMEVENT18H,CSR_CLASS_SSCOFPMF_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mhpmevent19h",CSR_MHPMEVENT19H,CSR_CLASS_SSCOFPMF_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mhpmevent20h",CSR_MHPMEVENT20H,CSR_CLASS_SSCOFPMF_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mhpmevent21h",CSR_MHPMEVENT21H,CSR_CLASS_SSCOFPMF_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mhpmevent22h",CSR_MHPMEVENT22H,CSR_CLASS_SSCOFPMF_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mhpmevent23h",CSR_MHPMEVENT23H,CSR_CLASS_SSCOFPMF_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mhpmevent24h",CSR_MHPMEVENT24H,CSR_CLASS_SSCOFPMF_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mhpmevent25h",CSR_MHPMEVENT25H,CSR_CLASS_SSCOFPMF_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mhpmevent26h",CSR_MHPMEVENT26H,CSR_CLASS_SSCOFPMF_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mhpmevent27h",CSR_MHPMEVENT27H,CSR_CLASS_SSCOFPMF_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mhpmevent28h",CSR_MHPMEVENT28H,CSR_CLASS_SSCOFPMF_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mhpmevent29h",CSR_MHPMEVENT29H,CSR_CLASS_SSCOFPMF_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mhpmevent30h",CSR_MHPMEVENT30H,CSR_CLASS_SSCOFPMF_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mhpmevent31h",CSR_MHPMEVENT31H,CSR_CLASS_SSCOFPMF_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	/* Sstc extension */
	{"stimecmp",CSR_STIMECMP,CSR_CLASS_SSTC,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"stimecmph",CSR_STIMECMPH,CSR_CLASS_SSTC_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"vstimecmp",CSR_VSTIMECMP,CSR_CLASS_SSTC_AND_H,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"vstimecmph",CSR_VSTIMECMPH,CSR_CLASS_SSTC_AND_H_32,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	/* Dropped CSRs.  */
	{"mbase",CSR_MBASE,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_1P10},
	{"mbound",CSR_MBOUND,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_1P10},
	{"mibase",CSR_MIBASE,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_1P10},
	{"mibound",CSR_MIBOUND,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_1P10},
	{"mdbase",CSR_MDBASE,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_1P10},
	{"mdbound",CSR_MDBOUND,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_1P10},
	{"mscounteren",CSR_MSCOUNTEREN,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_1P10},
	{"mhcounteren",CSR_MHCOUNTEREN,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_1P10},
	{"ustatus",CSR_USTATUS,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_1P12},
	{"uie",CSR_UIE,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_1P12},
	{"utvec",CSR_UTVEC,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_1P12},
	{"uscratch",CSR_USCRATCH,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_1P12},
	{"uepc",CSR_UEPC,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_1P12},
	{"ucause",CSR_UCAUSE,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_1P12},
	{"utval",CSR_UTVAL,CSR_CLASS_I,PRIV_SPEC_CLASS_1P10,PRIV_SPEC_CLASS_1P12},
	{"uip",CSR_UIP,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_1P12},
	{"sedeleg",CSR_SEDELEG,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_1P12},
	{"sideleg",CSR_SIDELEG,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_1P12},
	/* Unprivileged Floating-Point CSRs.  */
	{"fflags",CSR_FFLAGS,CSR_CLASS_F,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"frm",CSR_FRM,CSR_CLASS_F,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"fcsr",CSR_FCSR,CSR_CLASS_F,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	/* Unprivileged Debug CSRs.  */
	{"dcsr",CSR_DCSR,CSR_CLASS_DEBUG,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"dpc",CSR_DPC,CSR_CLASS_DEBUG,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"dscratch0",CSR_DSCRATCH0,CSR_CLASS_DEBUG,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"dscratch1",CSR_DSCRATCH1,CSR_CLASS_DEBUG,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"tselect",CSR_TSELECT,CSR_CLASS_DEBUG,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"tdata1",CSR_TDATA1,CSR_CLASS_DEBUG,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"tdata2",CSR_TDATA2,CSR_CLASS_DEBUG,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"tdata3",CSR_TDATA3,CSR_CLASS_DEBUG,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"tinfo",CSR_TINFO,CSR_CLASS_DEBUG,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"tcontrol",CSR_TCONTROL,CSR_CLASS_DEBUG,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"hcontext",CSR_HCONTEXT,CSR_CLASS_DEBUG,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"scontext",CSR_SCONTEXT,CSR_CLASS_DEBUG,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mcontext",CSR_MCONTEXT,CSR_CLASS_DEBUG,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mscontext",CSR_MSCONTEXT,CSR_CLASS_DEBUG,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	/* Unprivileged Scalar Crypto CSRs.  */
	{"seed",CSR_SEED,CSR_CLASS_ZKR,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	/* Unprivileged Vector CSRs.  */
	{"vstart",CSR_VSTART,CSR_CLASS_V,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"vxsat",CSR_VXSAT,CSR_CLASS_V,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"vxrm",CSR_VXRM,CSR_CLASS_V,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"vcsr",CSR_VCSR,CSR_CLASS_V,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"vl",CSR_VL,CSR_CLASS_V,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"vtype",CSR_VTYPE,CSR_CLASS_V,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"vlenb",CSR_VLENB,CSR_CLASS_V,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"ubadaddr",CSR_UTVAL,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_1P10},
	{"sbadaddr",CSR_STVAL,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_1P10},
	{"sptbr",CSR_SATP,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_1P10},
	{"mbadaddr",CSR_MTVAL,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_1P10},
	{"mucounteren",CSR_MCOUNTINHIBIT,CSR_CLASS_I,PRIV_SPEC_CLASS_1P9P1,PRIV_SPEC_CLASS_1P10},
	{"dscratch",CSR_DSCRATCH0,CSR_CLASS_DEBUG,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mcontrol",CSR_TDATA1,CSR_CLASS_DEBUG,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"mcontrol6",CSR_TDATA1,CSR_CLASS_DEBUG,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"icount",CSR_TDATA1,CSR_CLASS_DEBUG,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"itrigger",CSR_TDATA1,CSR_CLASS_DEBUG,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"etrigger",CSR_TDATA1,CSR_CLASS_DEBUG,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"tmexttrigger",CSR_TDATA1,CSR_CLASS_DEBUG,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"textra32",CSR_TDATA3,CSR_CLASS_DEBUG,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
	{"textra64",CSR_TDATA3,CSR_CLASS_DEBUG,PRIV_SPEC_CLASS_NONE,PRIV_SPEC_CLASS_NONE},
};

/*
 * This function is called once,at assembler startup time.  It should set up
 * all the tables,etc. that the MD part of the assembler will need.
 */
static void	md_begin(void)
{
	unsigned long	mach = xlen == 64 ? bfd_mach_riscv64 : bfd_mach_riscv32;

	if (!bfd_default_set_arch_mach(stdoutput,bfd_arch_riscv,mach))
		as_warn(("could not set architecture and machine"));

	op_hash = init_opcode_hash(riscv_opcodes,false);
	insn_type_hash = init_opcode_hash(riscv_insn_types,true);

	reg_names_hash = str_htab_create();
	hash_reg_names(RCLASS_GPR,riscv_gpr_names_numeric,NGPR);
	hash_reg_names(RCLASS_GPR,riscv_gpr_names_abi,NGPR);
	hash_reg_names(RCLASS_FPR,riscv_fpr_names_numeric,NFPR);
	hash_reg_names(RCLASS_FPR,riscv_fpr_names_abi,NFPR);
	hash_reg_names(RCLASS_VECR,riscv_vecr_names_numeric,NVECR);
	hash_reg_names(RCLASS_VECM,riscv_vecm_names_numeric,NVECM);
	/* Add "fp" as an alias for "s0".  */
	hash_reg_name(RCLASS_GPR,"fp",8);

	/* Create and insert CSR hash tables.  */
	csr_extra_hash = str_htab_create();
	/* Unprivileged Counter/Timers CSRs.  */
	opcode_names_hash = str_htab_create();
	for (size_t i = 0; i < sizeof(csr_data) / sizeof(csr_data[0]); i++) {
		riscv_init_csr_hash(csr_data[i].name,csr_data[i].num,csr_data[i].class,
		       csr_data[i].define_version,csr_data[i].abort_version);
	}
	init_opcode_names_hash();

	/* Set the default alignment for the text section.  */
	record_alignment(text_section,riscv_opts.rvc ? 1 : 2);
}

static insn_t	riscv_apply_const_reloc(bfd_reloc_code_real_type reloc_type,bfd_vma value)
{
	switch (reloc_type) {
	case BFD_RELOC_32:
		return value;

	case BFD_RELOC_RISCV_HI20:
		return ENCODE_UTYPE_IMM(RISCV_CONST_HIGH_PART(value));

	case BFD_RELOC_RISCV_LO12_S:
		return ENCODE_STYPE_IMM(value);

	case BFD_RELOC_RISCV_LO12_I:
		return ENCODE_ITYPE_IMM(value);

	default:
		abort();
	}
}

/*
 * Output an instruction.  IP is the instruction information. ADDRESS_EXPR is
 * an operand of the instruction to be used with RELOC_TYPE.
 */
static void	append_insn(struct riscv_cl_insn *ip,expressionS * address_expr,
					bfd_reloc_code_real_type reloc_type)
{
	dwarf2_emit_insn(0);

	if (reloc_type != BFD_RELOC_UNUSED) {
		reloc_howto_type *howto;

		gas_assert(address_expr);
		if (reloc_type == BFD_RELOC_12_PCREL
		    || reloc_type == BFD_RELOC_RISCV_JMP) {
			int		j = reloc_type == BFD_RELOC_RISCV_JMP;
			int		best_case = insn_length(ip);
			unsigned	worst_case = relaxed_branch_length(NULL,NULL,0);

			if (now_seg == absolute_section) {
				as_bad(("relaxable branches not supported in absolute section"));
				return;
			}
			add_relaxed_insn(ip,worst_case,best_case,
			   RELAX_BRANCH_ENCODE(j,best_case == 2,worst_case),
					 address_expr->X_add_symbol,
					 address_expr->X_add_number);
			return;
		} else {
			howto = riscv_reloc_type_lookup(stdoutput,reloc_type);
			if (howto == NULL)
				as_bad(("internal: unsupported RISC-V relocation number %d"),
				       reloc_type);

			ip->fixp = fix_new_exp(ip->frag,ip->where,
					       bfd_get_reloc_size(howto),
					     address_expr,false,reloc_type);

			ip->fixp->fx_tcbit = riscv_opts.relax;
		}
	}
	add_fixed_insn(ip);

	/* We need to start a new frag after any instruction that can be
	 * optimized away or compressed by the linker during relaxation,to
	 * prevent the assembler from computing static offsets across such an
	 * instruction. This is necessary to get correct EH info.  */
	if (reloc_type == BFD_RELOC_RISCV_HI20
	    || reloc_type == BFD_RELOC_RISCV_PCREL_HI20
	    || reloc_type == BFD_RELOC_RISCV_TPREL_HI20
	    || reloc_type == BFD_RELOC_RISCV_TPREL_ADD) {
		frag_wane(frag_now);
		frag_new(0);
	}
}

/* Build an instruction created by a macro expansion.  This is passed a pointer
 * to the count of instructions created so far,an expression,the name of the
 * instruction to build,an operand format string,and corresponding arguments. */

static void	macro_build(expressionS * ep,const char *name,const char *fmt,...)
{
	const struct riscv_opcode *mo;
	struct riscv_cl_insn insn;
	bfd_reloc_code_real_type r;
	va_list		args;
	const char     *fmtStart;

	va_start(args,fmt);

	r = BFD_RELOC_UNUSED;
	mo = (struct riscv_opcode *)str_hash_find(op_hash,name);
	gas_assert(mo);

	/*
	 * Find a non-RVC variant of the instruction.  append_insn will
	 * compress it if possible.
	 */
	while (riscv_insn_length(mo->match) < 4)
		mo++;
	gas_assert(strcmp(name,mo->name) == 0);

	create_insn(&insn,mo);
	for (;; ++fmt) {
		fmtStart = fmt;
		switch (*fmt) {
		case 'V':	/* RVV */
			switch (*++fmt) {
			case 'd':
				INSERT_OPERAND(VD,insn,va_arg(args,int));
				continue;
			case 's':
				INSERT_OPERAND(VS1,insn,va_arg(args,int));
				continue;
			case 't':
				INSERT_OPERAND(VS2,insn,va_arg(args,int));
				continue;
			case 'm':
				{
					int		reg = va_arg(args,int);
					if (reg == -1) {
						INSERT_OPERAND(VMASK,insn,1);
						continue;
					} else
						if (reg == 0) {
							INSERT_OPERAND(VMASK,insn,0);
							continue;
						} else
							goto unknown_macro_argument;
				}
			default:
				goto unknown_macro_argument;
			}
			break;

		case 'd':
			INSERT_OPERAND(RD,insn,va_arg(args,int));
			continue;
		case 's':
			INSERT_OPERAND(RS1,insn,va_arg(args,int));
			continue;
		case 't':
			INSERT_OPERAND(RS2,insn,va_arg(args,int));
			continue;

		case 'j':
		case 'u':
		case 'q':
			gas_assert(ep != NULL);
			r = va_arg(args,int);
			continue;

		case '\0':
			break;
		case ',':
			continue;
		default:
	unknown_macro_argument:
			as_fatal(("internal: invalid macro argument `%s'"),fmtStart);
		}
		break;
	}
	va_end(args);
	gas_assert(r == BFD_RELOC_UNUSED ? ep == NULL : ep != NULL);

	append_insn(&insn,ep,r);
}

/* Build an instruction created by a macro expansion.  Like md_assemble but
 * accept a printf-style format string and arguments. */
static void	md_assemblef(const char *format,...)
{
	char           *buf = NULL;
	va_list		ap;
	int		r;

	va_start(ap,format);

	r = vasprintf(&buf,format,ap);

	if (r < 0)
		as_fatal(("internal: vasprintf failed"));

	md_assemble(buf);
	free(buf);

	va_end(ap);
}

/*
 * Sign-extend 32-bit mode constants that have bit 31 set and all higher bits
 * unset.
 */
static void	normalize_constant_expr(expressionS * ex)
{
	if (xlen > 32)
		return;
	if ((ex->X_op == O_constant || ex->X_op == O_symbol)
	    && IS_ZEXT_32BIT_NUM(ex->X_add_number))
		ex->X_add_number = (((ex->X_add_number & 0xffffffff) ^ 0x80000000)
				    - 0x80000000);
}

/*
 * Fail if an expression EX is not a constant.  IP is the instruction using EX.
 * MAYBE_CSR is true if the symbol may be an unrecognized CSR name.
 */
static void	check_absolute_expr(struct riscv_cl_insn *ip,expressionS * ex,
						bool		maybe_csr)
{
	if (ex->X_op == O_big)
		as_bad(("unsupported large constant"));
	else
		if (maybe_csr && ex->X_op == O_symbol)
			as_bad(("unknown CSR `%s'"),
			       S_GET_NAME(ex->X_add_symbol));
		else
			if (ex->X_op != O_constant)
				as_bad(("instruction %s requires absolute expression"),
				       ip->insn_mo->name);
	normalize_constant_expr(ex);
}

static symbolS *make_internal_label(void)
{
	return (symbolS *) local_symbol_make(FAKE_LABEL_NAME,now_seg,frag_now,
					     frag_now_fix());
}

/* Load an entry from the GOT.  */
static void	pcrel_access(int destreg,int tempreg,expressionS * ep,
			const		char  *lo_insn,const char *lo_pattern,
			 		bfd_reloc_code_real_type hi_reloc,
			 		bfd_reloc_code_real_type lo_reloc)
{
	expressionS	ep2;
	ep2.X_op = O_symbol;
	ep2.X_add_symbol = make_internal_label();
	ep2.X_add_number = 0;

	macro_build(ep,"auipc","d,u",tempreg,hi_reloc);
	macro_build(&ep2,lo_insn,lo_pattern,destreg,tempreg,lo_reloc);
}

static void	pcrel_load(int destreg,int tempreg,expressionS * ep,const char *lo_insn,
		       		bfd_reloc_code_real_type hi_reloc,
		       		bfd_reloc_code_real_type lo_reloc)
{
	pcrel_access(destreg,tempreg,ep,lo_insn,"d,s,j",hi_reloc,lo_reloc);
}

static void	pcrel_store(int srcreg,int tempreg,expressionS * ep,const char *lo_insn,
					bfd_reloc_code_real_type hi_reloc,
					bfd_reloc_code_real_type lo_reloc)
{
	pcrel_access(srcreg,tempreg,ep,lo_insn,"t,s,q",hi_reloc,lo_reloc);
}

/* PC-relative function call using AUIPC/JALR,relaxed to JAL.  */
static void	riscv_call(int destreg,int tempreg,expressionS * ep,
		       		bfd_reloc_code_real_type reloc)
{
	/* Ensure the jalr is emitted to the same frag as the auipc.  */
	frag_grow(8);
	macro_build(ep,"auipc","d,u",tempreg,reloc);
	macro_build(NULL,"jalr","d,s",destreg,tempreg);
	/* See comment at end of append_insn.  */
	frag_wane(frag_now);
	frag_new(0);
}

/* Load an integer constant into a register.  */
static void	load_const(int reg,expressionS * ep)
{
	int		shift = RISCV_IMM_BITS;
	bfd_vma		upper_imm,sign = (bfd_vma) 1 << (RISCV_IMM_BITS - 1);
	expressionS	upper = *ep,lower = *ep;
	lower.X_add_number = ((ep->X_add_number & (sign + sign - 1)) ^ sign) - sign;
	upper.X_add_number -= lower.X_add_number;

	if (ep->X_op != O_constant) {
		as_bad(("unsupported large constant"));
		return;
	}
	if (xlen > 32 && !IS_SEXT_32BIT_NUM(ep->X_add_number)) {
		/* Reduce to a signed 32-bit constant using SLLI and ADDI.  */
		while (((upper.X_add_number >> shift) & 1) == 0)
			shift++;

		upper.X_add_number = (int64_t) upper.X_add_number >> shift;
		load_const(reg,&upper);

		md_assemblef("slli x%d,x%d,0x%x",reg,reg,shift);
		if (lower.X_add_number != 0)
			md_assemblef("addi x%d,x%d,%" PRId64,reg,reg,
				     (int64_t) lower.X_add_number);
	} else {
		/*
		 * Simply emit LUI and/or ADDI to build a 32-bit signed
		 * constant.
		 */
		int		hi_reg = 0;

		if (upper.X_add_number != 0) {
			/* Discard low part and zero-extend upper immediate.  */
			upper_imm = ((uint32_t) upper.X_add_number >> shift);

			md_assemblef("lui x%d,0x%" PRIx64,reg,(uint64_t) upper_imm);
			hi_reg = reg;
		}
		if (lower.X_add_number != 0 || hi_reg == 0)
			md_assemblef("%s x%d,x%d,%" PRId64,ADD32_INSN,reg,hi_reg,
				     (int64_t) lower.X_add_number);
	}
}

/* Zero extend and sign extend byte/half-word/word.  */
static void	riscv_ext(int destreg,int srcreg,unsigned shift,bool sign)
{
	if (sign) {
		md_assemblef("slli x%d,x%d,0x%x",destreg,srcreg,shift);
		md_assemblef("srai x%d,x%d,0x%x",destreg,destreg,shift);
	} else {
		md_assemblef("slli x%d,x%d,0x%x",destreg,srcreg,shift);
		md_assemblef("srli x%d,x%d,0x%x",destreg,destreg,shift);
	}
}

/* Expand RISC-V Vector macros into one or more instructions.  */
static void	vector_macro(struct riscv_cl_insn *ip)
{
	int		vd = (ip->insn_opcode >> OP_SH_VD) & OP_MASK_VD;
	int		vs1 = (ip->insn_opcode >> OP_SH_VS1) & OP_MASK_VS1;
	int		vs2 = (ip->insn_opcode >> OP_SH_VS2) & OP_MASK_VS2;
	int		vm = (ip->insn_opcode >> OP_SH_VMASK) & OP_MASK_VMASK;
	int		vtemp = (ip->insn_opcode >> OP_SH_VFUNCT6) & OP_MASK_VFUNCT6;
	int		mask = ip->insn_mo->mask;

	switch (mask) {
	case M_VMSGE:
		if (vm) {
			/* Unmasked.  */
			macro_build(NULL,"vmslt.vx","Vd,Vt,sVm",vd,vs2,vs1,-1);
			macro_build(NULL,"vmnand.mm","Vd,Vt,Vs",vd,vd,vd);
			break;
		}
		if (vtemp != 0) {
			/* Masked.  Have vtemp to avoid overlap constraints.  */
			if (vd == vm) {
				macro_build(NULL,"vmslt.vx","Vd,Vt,s",vtemp,vs2,vs1);
				macro_build(NULL,"vmandnot.mm","Vd,Vt,Vs",vd,vm,vtemp);
			} else {
				/*
				 * Preserve the value of vd if not updating by
				 * vm.
				 */
				macro_build(NULL,"vmslt.vx","Vd,Vt,s",vtemp,vs2,vs1);
				macro_build(NULL,"vmandnot.mm","Vd,Vt,Vs",vtemp,vm,vtemp);
				macro_build(NULL,"vmandnot.mm","Vd,Vt,Vs",vd,vd,vm);
				macro_build(NULL,"vmor.mm","Vd,Vt,Vs",vd,vtemp,vd);
			}
		} else
			if (vd != vm) {
				/*
				 * Masked.  This may cause the vd overlaps vs2,
				 * when LMUL > 1.
				 */
				macro_build(NULL,"vmslt.vx","Vd,Vt,sVm",vd,vs2,vs1,vm);
				macro_build(NULL,"vmxor.mm","Vd,Vt,Vs",vd,vd,vm);
			} else
				as_bad(("must provide temp if destination overlaps mask"));
		break;

	case M_VMSGEU:
		if (vm) {
			/* Unmasked.  */
			macro_build(NULL,"vmsltu.vx","Vd,Vt,sVm",vd,vs2,vs1,-1);
			macro_build(NULL,"vmnand.mm","Vd,Vt,Vs",vd,vd,vd);
			break;
		}
		if (vtemp != 0) {
			/* Masked.  Have vtemp to avoid overlap constraints.  */
			if (vd == vm) {
				macro_build(NULL,"vmsltu.vx","Vd,Vt,s",vtemp,vs2,vs1);
				macro_build(NULL,"vmandnot.mm","Vd,Vt,Vs",vd,vm,vtemp);
			} else {
				/*
				 * Preserve the value of vd if not updating by
				 * vm.
				 */
				macro_build(NULL,"vmsltu.vx","Vd,Vt,s",vtemp,vs2,vs1);
				macro_build(NULL,"vmandnot.mm","Vd,Vt,Vs",vtemp,vm,vtemp);
				macro_build(NULL,"vmandnot.mm","Vd,Vt,Vs",vd,vd,vm);
				macro_build(NULL,"vmor.mm","Vd,Vt,Vs",vd,vtemp,vd);
			}
		} else
			if (vd != vm) {
				/*
				 * Masked.  This may cause the vd overlaps vs2,
				 * when LMUL > 1.
				 */
				macro_build(NULL,"vmsltu.vx","Vd,Vt,sVm",vd,vs2,vs1,vm);
				macro_build(NULL,"vmxor.mm","Vd,Vt,Vs",vd,vd,vm);
			} else
				as_bad(("must provide temp if destination overlaps mask"));
		break;

	default:
		break;
	}
}

/* Expand RISC-V assembly macros into one or more instructions.  */
static void	macro(struct riscv_cl_insn *ip,expressionS * imm_expr,
		  		bfd_reloc_code_real_type * imm_reloc)
{
	int		rd = (ip->insn_opcode >> OP_SH_RD) & OP_MASK_RD;
	int		rs1 = (ip->insn_opcode >> OP_SH_RS1) & OP_MASK_RS1;
	int		rs2 = (ip->insn_opcode >> OP_SH_RS2) & OP_MASK_RS2;
	int		mask = ip->insn_mo->mask;

	switch (mask) {
	case M_LI:
		load_const(rd,imm_expr);
		break;

	case M_LA:
	case M_LLA:
		/* Load the address of a symbol into a register.  */
		if (!IS_SEXT_32BIT_NUM(imm_expr->X_add_number))
			as_bad(("offset too large"));

		if (imm_expr->X_op == O_constant)
			load_const(rd,imm_expr);
		else
			if (riscv_opts.pic && mask == M_LA)	/* Global PIC symbol.  */
				pcrel_load(rd,rd,imm_expr,LOAD_ADDRESS_INSN,
					   BFD_RELOC_RISCV_GOT_HI20,BFD_RELOC_RISCV_PCREL_LO12_I);
			else	/* Local PIC symbol,or any non-PIC symbol.  */
				pcrel_load(rd,rd,imm_expr,"addi",
					   BFD_RELOC_RISCV_PCREL_HI20,BFD_RELOC_RISCV_PCREL_LO12_I);
		break;

	case M_LA_TLS_GD:
		pcrel_load(rd,rd,imm_expr,"addi",
		   BFD_RELOC_RISCV_TLS_GD_HI20,BFD_RELOC_RISCV_PCREL_LO12_I);
		break;

	case M_LA_TLS_IE:
		pcrel_load(rd,rd,imm_expr,LOAD_ADDRESS_INSN,
		  BFD_RELOC_RISCV_TLS_GOT_HI20,BFD_RELOC_RISCV_PCREL_LO12_I);
		break;

	case M_LB:
		pcrel_load(rd,rd,imm_expr,"lb",
		    BFD_RELOC_RISCV_PCREL_HI20,BFD_RELOC_RISCV_PCREL_LO12_I);
		break;

	case M_LBU:
		pcrel_load(rd,rd,imm_expr,"lbu",
		    BFD_RELOC_RISCV_PCREL_HI20,BFD_RELOC_RISCV_PCREL_LO12_I);
		break;

	case M_LH:
		pcrel_load(rd,rd,imm_expr,"lh",
		    BFD_RELOC_RISCV_PCREL_HI20,BFD_RELOC_RISCV_PCREL_LO12_I);
		break;

	case M_LHU:
		pcrel_load(rd,rd,imm_expr,"lhu",
		    BFD_RELOC_RISCV_PCREL_HI20,BFD_RELOC_RISCV_PCREL_LO12_I);
		break;

	case M_LW:
		pcrel_load(rd,rd,imm_expr,"lw",
		    BFD_RELOC_RISCV_PCREL_HI20,BFD_RELOC_RISCV_PCREL_LO12_I);
		break;

	case M_LWU:
		pcrel_load(rd,rd,imm_expr,"lwu",
		    BFD_RELOC_RISCV_PCREL_HI20,BFD_RELOC_RISCV_PCREL_LO12_I);
		break;

	case M_LD:
		pcrel_load(rd,rd,imm_expr,"ld",
		    BFD_RELOC_RISCV_PCREL_HI20,BFD_RELOC_RISCV_PCREL_LO12_I);
		break;

	case M_FLW:
		pcrel_load(rd,rs1,imm_expr,"flw",
		    BFD_RELOC_RISCV_PCREL_HI20,BFD_RELOC_RISCV_PCREL_LO12_I);
		break;

	case M_FLD:
		pcrel_load(rd,rs1,imm_expr,"fld",
		    BFD_RELOC_RISCV_PCREL_HI20,BFD_RELOC_RISCV_PCREL_LO12_I);
		break;

	case M_SB:
		pcrel_store(rs2,rs1,imm_expr,"sb",
		    BFD_RELOC_RISCV_PCREL_HI20,BFD_RELOC_RISCV_PCREL_LO12_S);
		break;

	case M_SH:
		pcrel_store(rs2,rs1,imm_expr,"sh",
		    BFD_RELOC_RISCV_PCREL_HI20,BFD_RELOC_RISCV_PCREL_LO12_S);
		break;

	case M_SW:
		pcrel_store(rs2,rs1,imm_expr,"sw",
		    BFD_RELOC_RISCV_PCREL_HI20,BFD_RELOC_RISCV_PCREL_LO12_S);
		break;

	case M_SD:
		pcrel_store(rs2,rs1,imm_expr,"sd",
		    BFD_RELOC_RISCV_PCREL_HI20,BFD_RELOC_RISCV_PCREL_LO12_S);
		break;

	case M_FSW:
		pcrel_store(rs2,rs1,imm_expr,"fsw",
		    BFD_RELOC_RISCV_PCREL_HI20,BFD_RELOC_RISCV_PCREL_LO12_S);
		break;

	case M_FSD:
		pcrel_store(rs2,rs1,imm_expr,"fsd",
		    BFD_RELOC_RISCV_PCREL_HI20,BFD_RELOC_RISCV_PCREL_LO12_S);
		break;

	case M_CALL:
		riscv_call(rd,rs1,imm_expr,*imm_reloc);
		break;

	case M_ZEXTH:
		riscv_ext(rd,rs1,xlen - 16,false);
		break;

	case M_ZEXTW:
		riscv_ext(rd,rs1,xlen - 32,false);
		break;

	case M_SEXTB:
		riscv_ext(rd,rs1,xlen - 8,true);
		break;

	case M_SEXTH:
		riscv_ext(rd,rs1,xlen - 16,true);
		break;

	case M_VMSGE:
	case M_VMSGEU:
		vector_macro(ip);
		break;

	case M_FLH:
		pcrel_load(rd,rs1,imm_expr,"flh",
		    BFD_RELOC_RISCV_PCREL_HI20,BFD_RELOC_RISCV_PCREL_LO12_I);
		break;
	case M_FSH:
		pcrel_store(rs2,rs1,imm_expr,"fsh",
		    BFD_RELOC_RISCV_PCREL_HI20,BFD_RELOC_RISCV_PCREL_LO12_S);
		break;

	default:
		as_bad(("internal: macro %s not implemented"),ip->insn_mo->name);
		break;
	}
}

static const struct percent_op_match percent_op_utype[] =
{
	{"tprel_hi",BFD_RELOC_RISCV_TPREL_HI20},
	{"pcrel_hi",BFD_RELOC_RISCV_PCREL_HI20},
	{"got_pcrel_hi",BFD_RELOC_RISCV_GOT_HI20},
	{"tls_ie_pcrel_hi",BFD_RELOC_RISCV_TLS_GOT_HI20},
	{"tls_gd_pcrel_hi",BFD_RELOC_RISCV_TLS_GD_HI20},
	{"hi",BFD_RELOC_RISCV_HI20},
	{0,0}
};

static const struct percent_op_match percent_op_itype[] =
{
	{"lo",BFD_RELOC_RISCV_LO12_I},
	{"tprel_lo",BFD_RELOC_RISCV_TPREL_LO12_I},
	{"pcrel_lo",BFD_RELOC_RISCV_PCREL_LO12_I},
	{0,0}
};

static const struct percent_op_match percent_op_stype[] =
{
	{"lo",BFD_RELOC_RISCV_LO12_S},
	{"tprel_lo",BFD_RELOC_RISCV_TPREL_LO12_S},
	{"pcrel_lo",BFD_RELOC_RISCV_PCREL_LO12_S},
	{0,0}
};

static const struct percent_op_match percent_op_rtype[] =
{
	{"tprel_add",BFD_RELOC_RISCV_TPREL_ADD},
	{0,0}
};

static const struct percent_op_match percent_op_null[] =
{
	{0,0}
};

/* Return true if *STR points to a relocation operator.  When returning true,
 * move *STR over the operator and store its relocation code in *RELOC. Leave
 * both *STR and *RELOC alone when returning false.  */
static bool	parse_relocation(char **str,bfd_reloc_code_real_type * reloc,
	      		const		struct	percent_op_match *percent_op)
{
	for (; percent_op->str; percent_op++)
		if (strncasecmp(*str + 1,percent_op->str,strlen(percent_op->str)) == 0) {
			size_t		len = 1 + strlen(percent_op->str);

			while (ISSPACE((*str)[len]))
				++len;
			if ((*str)[len] != '(')
				continue;

			*str += len;
			*reloc = percent_op->reloc;

			/*
			 * Check whether the output BFD supports this
			 * relocation. If not,issue an error and fall back on
			 * something safe.
			 */
			if (*reloc != BFD_RELOC_UNUSED
			    && !riscv_reloc_type_lookup(stdoutput,*reloc)) {
				as_bad("internal: relocation %s isn't supported by the "
				       "current ABI",percent_op->str);
				*reloc = BFD_RELOC_UNUSED;
			}
			return true;
		}
	return false;
}

static void	my_getExpression(expressionS * ep,char *str)
{
	char           *save_in;

	save_in = input_line_pointer;
	input_line_pointer = str;
	expression(ep);
	expr_parse_end = input_line_pointer;
	input_line_pointer = save_in;
}

/* Parse string STR as a 16-bit relocatable operand.  Store the expression in
 * *EP and the relocation,if any,in RELOC. Return the number of relocation
 * operators used (0 or 1).
 * 
 * On exit,EXPR_PARSE_END points to the first character after the expression.  */
static size_t	my_getSmallExpression(expressionS * ep,bfd_reloc_code_real_type * reloc,
     		char         *str,const struct percent_op_match *percent_op)
{
	size_t		reloc_index;
	unsigned	crux_depth,str_depth;
	bool		orig_probing = probing_insn_operands;
	char           *crux;

	/*
	 * Search for the start of the main expression.
	 * 
	 * End the loop with CRUX pointing to the start of the main expression and
	 * with CRUX_DEPTH containing the number of open brackets at that
	 * point.
	 */
	reloc_index = -1;
	str_depth = 0;
	do {
		reloc_index++;
		crux = str;
		crux_depth = str_depth;

		/*
		 * Skip over whitespace and brackets,keeping count of the
		 * number of brackets.
		 */
		while (*str == ' ' || *str == '\t' || *str == '(')
			if (*str++ == '(')
				str_depth++;
	}
	while (*str == '%'
	       && reloc_index < 1
	       && parse_relocation(&str,reloc,percent_op));

	if (*str == '%') {
		/* expression() will choke on anything looking like an
		 * (unrecognized) relocation specifier.  Don't even call it,
		 * avoiding multiple (and perhaps redundant) error messages;
		 * our caller will issue one.  */
		ep->X_op = O_illegal;
		return 0;
	}
	/* Anything inside parentheses or subject to a relocation operator
	 * cannot be a register and hence can be treated the same as operands
	 * to directives (other than .insn). */
	if (str_depth || reloc_index)
		probing_insn_operands = false;

	my_getExpression(ep,crux);
	str = expr_parse_end;

	probing_insn_operands = orig_probing;

	/* Match every open bracket.  */
	while (crux_depth > 0 && (*str == ')' || *str == ' ' || *str == '\t'))
		if (*str++ == ')')
			crux_depth--;

	if (crux_depth > 0)
		as_bad("unclosed '('");

	expr_parse_end = str;

	return reloc_index;
}

/* Parse opcode name,could be an mnemonics or number.  */
static size_t	my_getOpcodeExpression(expressionS * ep,bfd_reloc_code_real_type * reloc,
				     		char         *str)
{
	const struct opcode_name_t *o = opcode_name_lookup(&str);

	if (o != NULL) {
		ep->X_op = O_constant;
		ep->X_add_number = o->val;
		return 0;
	}
	return my_getSmallExpression(ep,reloc,str,percent_op_null);
}

/* Parse string STR as a vsetvli operand.  Store the expression in *EP. On
 * exit,EXPR_PARSE_END points to the first character after the expression.  */
static void	my_getVsetvliExpression(expressionS * ep,char *str)
{
	unsigned int	vsew_value = 0,vlmul_value = 0;
	unsigned int	vta_value = 0,vma_value = 0;
	bool		vsew_found = FALSE,vlmul_found = FALSE;
	bool		vta_found = FALSE,vma_found = FALSE;

	if (arg_lookup(&str,riscv_vsew,ARRAY_SIZE(riscv_vsew),&vsew_value)) {
		if (*str == ',')
			++str;
		if (vsew_found)
			as_bad(("multiple vsew constants"));
		vsew_found = TRUE;
	}
	if (arg_lookup(&str,riscv_vlmul,ARRAY_SIZE(riscv_vlmul),&vlmul_value)) {
		if (*str == ',')
			++str;
		if (vlmul_found)
			as_bad(("multiple vlmul constants"));
		vlmul_found = TRUE;
	}
	if (arg_lookup(&str,riscv_vta,ARRAY_SIZE(riscv_vta),&vta_value)) {
		if (*str == ',')
			++str;
		if (vta_found)
			as_bad(("multiple vta constants"));
		vta_found = TRUE;
	}
	if (arg_lookup(&str,riscv_vma,ARRAY_SIZE(riscv_vma),&vma_value)) {
		if (*str == ',')
			++str;
		if (vma_found)
			as_bad(("multiple vma constants"));
		vma_found = TRUE;
	}
	if (vsew_found || vlmul_found || vta_found || vma_found) {
		ep->X_op = O_constant;
		ep->X_add_number = (vlmul_value << OP_SH_VLMUL)
			| (vsew_value << OP_SH_VSEW)
			| (vta_value << OP_SH_VTA)
			| (vma_value << OP_SH_VMA);
		expr_parse_end = str;
	} else {
		my_getExpression(ep,str);
		str = expr_parse_end;
	}
}

/* Detect and handle implicitly zero load-store offsets.  For example,"lw t0,
 * (t1)" is shorthand for "lw t0,0(t1)".  Return true if such an implicit
 * offset was detected. */
static bool	riscv_handle_implicit_zero_offset(expressionS * ep,const char *s)
{
	/* Check whether there is only a single bracketed expression left. If
	 * so,it must be the base register and the constant must be zero.  */
	if (*s == '(' && strchr(s + 1,'(') == 0) {
		ep->X_op = O_constant;
		ep->X_add_number = 0;
		return true;
	}
	return false;
}

/* All RISC-V CSR instructions belong to one of these classes.  */
enum csr_insn_type {
	INSN_NOT_CSR,
	INSN_CSRRW,
	INSN_CSRRS,
	INSN_CSRRC
};

/* Return which CSR instruction is checking.  */
static enum csr_insn_type riscv_csr_insn_type(insn_t insn)
{
	if (((insn ^ MATCH_CSRRW) & MASK_CSRRW) == 0
	    || ((insn ^ MATCH_CSRRWI) & MASK_CSRRWI) == 0)
		return INSN_CSRRW;
	else
		if (((insn ^ MATCH_CSRRS) & MASK_CSRRS) == 0
		    || ((insn ^ MATCH_CSRRSI) & MASK_CSRRSI) == 0)
			return INSN_CSRRS;
		else
			if (((insn ^ MATCH_CSRRC) & MASK_CSRRC) == 0
			    || ((insn ^ MATCH_CSRRCI) & MASK_CSRRCI) == 0)
				return INSN_CSRRC;
			else
				return INSN_NOT_CSR;
}

/* CSRRW and CSRRWI always write CSR.  CSRRS,CSRRC,CSRRSI and CSRRCI write
 * CSR when RS1 isn't zero.  The CSR is read only if the [11:10] bits of CSR
 * address is 0x3. */
static bool	riscv_csr_read_only_check(insn_t insn)
{
	int		csr = (insn & (OP_MASK_CSR << OP_SH_CSR)) >> OP_SH_CSR;
	int		rs1 = (insn & (OP_MASK_RS1 << OP_SH_RS1)) >> OP_SH_RS1;
	int		readonly = (((csr & (0x3 << 10)) >> 10) == 0x3);
	enum csr_insn_type csr_insn = riscv_csr_insn_type(insn);

	if (readonly
	    && (((csr_insn == INSN_CSRRS
		  || csr_insn == INSN_CSRRC)
		 && rs1 != 0)
		|| csr_insn == INSN_CSRRW))
		return false;

	return true;
}

/* Return true if it is a privileged instruction.  Otherwise,return false.
 * 
 * uret is actually a N-ext instruction.  So it is better to regard it as an user
 * instruction rather than the priv instruction.
 * 
 * hret is used to return from traps in H-mode.  H-mode is removed since the v1.10
 * priv spec,but probably be added in the new hypervisor spec. Therefore,hret
 * should be controlled by the hypervisor spec rather than priv spec in the
 * future.
 * 
 * dret is defined in the debug spec,so it should be checked in the future,too.  */
static bool	riscv_is_priv_insn(insn_t insn)
{
	return (((insn ^ MATCH_SRET) & MASK_SRET) == 0
		|| ((insn ^ MATCH_MRET) & MASK_MRET) == 0
		|| ((insn ^ MATCH_SFENCE_VMA) & MASK_SFENCE_VMA) == 0
		|| ((insn ^ MATCH_WFI) & MASK_WFI) == 0
	/* The sfence.vm is dropped in the v1.10 priv specs,but we still need
	 * to check it here to keep the compatible. */
		|| ((insn ^ MATCH_SFENCE_VM) & MASK_SFENCE_VM) == 0);
}

static symbolS *deferred_sym_rootP;
static symbolS *deferred_sym_lastP;
/* Since symbols can't easily be freed,try to recycle ones which weren't
 * committed.  */
static symbolS *orphan_sym_rootP;
static symbolS *orphan_sym_lastP;

/* This routine assembles an instruction into its binary format.  As a side
 * effect,it sets the global variable imm_reloc to the type of relocation to
 * do if one of the operands is an address expression.  */
static struct riscv_ip_error riscv_ip(char *str,struct riscv_cl_insn *ip,expressionS * imm_expr,
		  		bfd_reloc_code_real_type * imm_reloc,htab_t hash)
{
	/* The operand string defined in the riscv_opcodes.  */
	const char     *oparg,*opargStart;
	/* The parsed operands from assembly.  */
	char           *asarg,*asargStart;
	char		save_c = 0;
	struct riscv_opcode *insn;
	unsigned int	regno;
	const struct percent_op_match *p;
	struct riscv_ip_error error;
	error.msg = "unrecognized opcode";
	error.statement = str;
	error.missing_ext = NULL;
	/* Indicate we are assembling instruction with CSR.  */
	bool		insn_with_csr = false;

	/* Parse the name of the instruction.  Terminate the string if
	 * whitespace is found so that str_hash_find only sees the name part of
	 * the string. */
	for (asarg = str; *asarg != '\0'; ++asarg)
		if (ISSPACE(*asarg)) {
			save_c = *asarg;
			*asarg++ = '\0';
			break;
		}
	insn = (struct riscv_opcode *)str_hash_find(hash,str);

	probing_insn_operands = true;

	asargStart = asarg;
	for (; insn && insn->name && strcmp(insn->name,str) == 0; insn++) {
		if ((insn->xlen_requirement != 0) && (xlen != insn->xlen_requirement))
			continue;

		if (!riscv_multi_subset_supports(&riscv_rps_as,insn->insn_class)) {
			error.missing_ext = riscv_multi_subset_supports_ext(&riscv_rps_as,
							    insn->insn_class);
			continue;
		}
		/* Reset error message of the previous round.  */
		error.msg = ("illegal operands");
		error.missing_ext = NULL;

		/* Purge deferred symbols from the previous round,if any.  */
		while (deferred_sym_rootP) {
			symbolS        *sym = deferred_sym_rootP;

			symbol_remove(sym,&deferred_sym_rootP,&deferred_sym_lastP);
			symbol_append(sym,orphan_sym_lastP,&orphan_sym_rootP,
				      &orphan_sym_lastP);
		}

		create_insn(ip,insn);

		imm_expr->X_op = O_absent;
		*imm_reloc = BFD_RELOC_UNUSED;
		p = percent_op_null;

		for (oparg = insn->args; ;++oparg) {
			opargStart = oparg;
			asarg += strspn(asarg," \t");
			switch (*oparg) {
			case '\0':	/* End of args.  */
				if (insn->pinfo != INSN_MACRO) {
					if (!insn->match_func(insn,ip->insn_opcode))
						break;

					/* For .insn,insn->match and * insn->mask are 0. */
					if (riscv_insn_length((insn->match == 0 && insn->mask == 0)
							      ? ip->insn_opcode
							   : insn->match) == 2
					    && !riscv_opts.rvc)
						break;
					if (riscv_is_priv_insn(ip->insn_opcode))
						explicit_priv_attr = true;
					/* Check if we write a read-only CSR by the CSR instruction. */
					if (insn_with_csr
					    && riscv_opts.csr_check
					    && !riscv_csr_read_only_check(ip->insn_opcode)) {
						/* Restore the character in advance,since we want to report 
						 * the detailed warning * message here.  */
						if (save_c)
							*(asargStart - 1) = save_c;
						as_warn(("read-only CSR is written `%s'"),str);
						insn_with_csr = false;
					}
					/* The (segmant) load and store with EEW 64 cannot be used when 
					 * zve32x is enabled.  */
					if (ip->insn_mo->pinfo & INSN_V_EEW64
					    && riscv_subset_supports(&riscv_rps_as,"zve32x")
					    && !riscv_subset_supports(&riscv_rps_as,"zve64x")) {
						error.msg = ("illegal opcode for zve32x");
						break;
					}
				}
				if (*asarg != '\0')
					break;

				/* Successful assembly.  */
				error.msg = NULL;
				insn_with_csr = false;

				/* Commit deferred symbols,if any.  */
				while (deferred_sym_rootP) {
					symbolS        *sym = deferred_sym_rootP;

					symbol_remove(sym,&deferred_sym_rootP,
						      &deferred_sym_lastP);
					symbol_append(sym,symbol_lastP,&symbol_rootP,
						      &symbol_lastP);
					symbol_table_insert(sym);
				}
				goto out;

			case 'C':	/* RVC */
				switch (*++oparg) {
				case 's':	/* RS1 x8-x15.  */
					if (!reg_lookup(&asarg,RCLASS_GPR,&regno)
					    || !(regno >= 8 && regno <= 15))
						break;
					INSERT_OPERAND(CRS1S,*ip,regno % 8);
					continue;
				case 'w':	/* RS1 x8-x15,constrained to
						 * equal RD x8-x15.  */
					if (!reg_lookup(&asarg,RCLASS_GPR,&regno)
					    || EXTRACT_OPERAND(CRS1S,ip->insn_opcode) + 8 != regno)
						break;
					continue;
				case 't':	/* RS2 x8-x15.  */
					if (!reg_lookup(&asarg,RCLASS_GPR,&regno)
					    || !(regno >= 8 && regno <= 15))
						break;
					INSERT_OPERAND(CRS2S,*ip,regno % 8);
					continue;
				case 'x':	/* RS2 x8-x15,constrained to
						 * equal RD x8-x15.  */
					if (!reg_lookup(&asarg,RCLASS_GPR,&regno)
					    || EXTRACT_OPERAND(CRS2S,ip->insn_opcode) + 8 != regno)
						break;
					continue;
				case 'U':	/* RS1,constrained to equal RD.  */
					if (!reg_lookup(&asarg,RCLASS_GPR,&regno)
					    || EXTRACT_OPERAND(RD,ip->insn_opcode) != regno)
						break;
					continue;
				case 'V':	/* RS2 */
					if (!reg_lookup(&asarg,RCLASS_GPR,&regno))
						break;
					INSERT_OPERAND(CRS2,*ip,regno);
					continue;
				case 'c':	/* RS1,constrained to equal sp.  */
					if (!reg_lookup(&asarg,RCLASS_GPR,&regno)
					    || regno != X_SP)
						break;
					continue;
				case 'z':	/* RS2,constrained to equal x0.  */
					if (!reg_lookup(&asarg,RCLASS_GPR,&regno)
					    || regno != 0)
						break;
					continue;
				case '>':	/* Shift amount,0 - (XLEN-1).  */
					if (my_getSmallExpression(imm_expr,imm_reloc,asarg,p)
					    || imm_expr->X_op != O_constant
					    || (unsigned long)imm_expr->X_add_number >= xlen)
						break;
					ip->insn_opcode |= ENCODE_CITYPE_IMM(imm_expr->X_add_number);
	rvc_imm_done:
					asarg = expr_parse_end;
					imm_expr->X_op = O_absent;
					continue;
				case '5':
					if (my_getSmallExpression(imm_expr,imm_reloc,asarg,p)
					    || imm_expr->X_op != O_constant
					    || imm_expr->X_add_number < 0
					    || imm_expr->X_add_number >= 32
					    || !VALID_CLTYPE_IMM((valueT) imm_expr->X_add_number))
						break;
					ip->insn_opcode |= ENCODE_CLTYPE_IMM(imm_expr->X_add_number);
					goto rvc_imm_done;
				case '6':
					if (my_getSmallExpression(imm_expr,imm_reloc,asarg,p)
					    || imm_expr->X_op != O_constant
					    || imm_expr->X_add_number < 0
					    || imm_expr->X_add_number >= 64
					    || !VALID_CSSTYPE_IMM((valueT) imm_expr->X_add_number))
						break;
					ip->insn_opcode |= ENCODE_CSSTYPE_IMM(imm_expr->X_add_number);
					goto rvc_imm_done;
				case '8':
					if (my_getSmallExpression(imm_expr,imm_reloc,asarg,p)
					    || imm_expr->X_op != O_constant
					    || imm_expr->X_add_number < 0
					    || imm_expr->X_add_number >= 256
					    || !VALID_CIWTYPE_IMM((valueT) imm_expr->X_add_number))
						break;
					ip->insn_opcode |= ENCODE_CIWTYPE_IMM(imm_expr->X_add_number);
					goto rvc_imm_done;
				case 'j':
					if (my_getSmallExpression(imm_expr,imm_reloc,asarg,p)
					    || imm_expr->X_op != O_constant
					    || imm_expr->X_add_number == 0
					    || !VALID_CITYPE_IMM((valueT) imm_expr->X_add_number))
						break;
					ip->insn_opcode |= ENCODE_CITYPE_IMM(imm_expr->X_add_number);
					goto rvc_imm_done;
				case 'k':
					if (riscv_handle_implicit_zero_offset(imm_expr,asarg))
						continue;
					if (my_getSmallExpression(imm_expr,imm_reloc,asarg,p)
					    || imm_expr->X_op != O_constant
					    || !VALID_CLTYPE_LW_IMM((valueT) imm_expr->X_add_number))
						break;
					ip->insn_opcode |= ENCODE_CLTYPE_LW_IMM(imm_expr->X_add_number);
					goto rvc_imm_done;
				case 'l':
					if (riscv_handle_implicit_zero_offset(imm_expr,asarg))
						continue;
					if (my_getSmallExpression(imm_expr,imm_reloc,asarg,p)
					    || imm_expr->X_op != O_constant
					    || !VALID_CLTYPE_LD_IMM((valueT) imm_expr->X_add_number))
						break;
					ip->insn_opcode |= ENCODE_CLTYPE_LD_IMM(imm_expr->X_add_number);
					goto rvc_imm_done;
				case 'm':
					if (riscv_handle_implicit_zero_offset(imm_expr,asarg))
						continue;
					if (my_getSmallExpression(imm_expr,imm_reloc,asarg,p)
					    || imm_expr->X_op != O_constant
					    || !VALID_CITYPE_LWSP_IMM((valueT) imm_expr->X_add_number))
						break;
					ip->insn_opcode |=
						ENCODE_CITYPE_LWSP_IMM(imm_expr->X_add_number);
					goto rvc_imm_done;
				case 'n':
					if (riscv_handle_implicit_zero_offset(imm_expr,asarg))
						continue;
					if (my_getSmallExpression(imm_expr,imm_reloc,asarg,p)
					    || imm_expr->X_op != O_constant
					    || !VALID_CITYPE_LDSP_IMM((valueT) imm_expr->X_add_number))
						break;
					ip->insn_opcode |=
						ENCODE_CITYPE_LDSP_IMM(imm_expr->X_add_number);
					goto rvc_imm_done;
				case 'o':
					if (my_getSmallExpression(imm_expr,imm_reloc,asarg,p)
					    || imm_expr->X_op != O_constant
					/* C.addiw,c.li,and c.andi allow zero immediate. C.addi allows 
					 * zero immediate as hint.  Otherwise this is same as 'j'. */
					    || !VALID_CITYPE_IMM((valueT) imm_expr->X_add_number))
						break;
					ip->insn_opcode |= ENCODE_CITYPE_IMM(imm_expr->X_add_number);
					goto rvc_imm_done;
				case 'K':
					if (my_getSmallExpression(imm_expr,imm_reloc,asarg,p)
					    || imm_expr->X_op != O_constant
					    || imm_expr->X_add_number == 0
					    || !VALID_CIWTYPE_ADDI4SPN_IMM((valueT) imm_expr->X_add_number))
						break;
					ip->insn_opcode |=
						ENCODE_CIWTYPE_ADDI4SPN_IMM(imm_expr->X_add_number);
					goto rvc_imm_done;
				case 'L':
					if (my_getSmallExpression(imm_expr,imm_reloc,asarg,p)
					    || imm_expr->X_op != O_constant
					    || !VALID_CITYPE_ADDI16SP_IMM((valueT) imm_expr->X_add_number))
						break;
					ip->insn_opcode |=
						ENCODE_CITYPE_ADDI16SP_IMM(imm_expr->X_add_number);
					goto rvc_imm_done;
				case 'M':
					if (riscv_handle_implicit_zero_offset(imm_expr,asarg))
						continue;
					if (my_getSmallExpression(imm_expr,imm_reloc,asarg,p)
					    || imm_expr->X_op != O_constant
					    || !VALID_CSSTYPE_SWSP_IMM((valueT) imm_expr->X_add_number))
						break;
					ip->insn_opcode |=
						ENCODE_CSSTYPE_SWSP_IMM(imm_expr->X_add_number);
					goto rvc_imm_done;
				case 'N':
					if (riscv_handle_implicit_zero_offset(imm_expr,asarg))
						continue;
					if (my_getSmallExpression(imm_expr,imm_reloc,asarg,p)
					    || imm_expr->X_op != O_constant
					    || !VALID_CSSTYPE_SDSP_IMM((valueT) imm_expr->X_add_number))
						break;
					ip->insn_opcode |=
						ENCODE_CSSTYPE_SDSP_IMM(imm_expr->X_add_number);
					goto rvc_imm_done;
				case 'u':
					p = percent_op_utype;
					if (my_getSmallExpression(imm_expr,imm_reloc,asarg,p))
						break;
			rvc_lui:
					if (imm_expr->X_op != O_constant
					    || imm_expr->X_add_number <= 0
					    || imm_expr->X_add_number >= RISCV_BIGIMM_REACH
					    || (imm_expr->X_add_number >= RISCV_RVC_IMM_REACH / 2
						&& (imm_expr->X_add_number <
						    RISCV_BIGIMM_REACH - RISCV_RVC_IMM_REACH / 2)))
						break;
					ip->insn_opcode |= ENCODE_CITYPE_IMM(imm_expr->X_add_number);
					goto rvc_imm_done;
				case 'v':
					if (my_getSmallExpression(imm_expr,imm_reloc,asarg,p)
					    || (imm_expr->X_add_number & (RISCV_IMM_REACH - 1))
					  || ((int32_t) imm_expr->X_add_number
					      != imm_expr->X_add_number))
						break;
					imm_expr->X_add_number =
						((uint32_t) imm_expr->X_add_number) >> RISCV_IMM_BITS;
					goto rvc_lui;
				case 'p':
					goto branch;
				case 'a':
					goto jump;
				case 'S':	/* Floating-point RS1 x8-x15.  */
					if (!reg_lookup(&asarg,RCLASS_FPR,&regno)
					    || !(regno >= 8 && regno <= 15))
						break;
					INSERT_OPERAND(CRS1S,*ip,regno % 8);
					continue;
				case 'D':	/* Floating-point RS2 x8-x15.  */
					if (!reg_lookup(&asarg,RCLASS_FPR,&regno)
					    || !(regno >= 8 && regno <= 15))
						break;
					INSERT_OPERAND(CRS2S,*ip,regno % 8);
					continue;
				case 'T':	/* Floating-point RS2.  */
					if (!reg_lookup(&asarg,RCLASS_FPR,&regno))
						break;
					INSERT_OPERAND(CRS2,*ip,regno);
					continue;
				case 'F':
					switch (*++oparg) {
					case '6':
						if (my_getSmallExpression(imm_expr,imm_reloc,asarg,p)
						|| imm_expr->X_op != O_constant
						 || imm_expr->X_add_number < 0
						    || imm_expr->X_add_number >= 64) {
							as_bad(("bad value for compressed funct6 "
								"field,value must be 0...63"));
							break;
						}
						INSERT_OPERAND(CFUNCT6,*ip,imm_expr->X_add_number);
						imm_expr->X_op = O_absent;
						asarg = expr_parse_end;
						continue;

					case '4':
						if (my_getSmallExpression(imm_expr,imm_reloc,asarg,p)
						|| imm_expr->X_op != O_constant
						 || imm_expr->X_add_number < 0
						    || imm_expr->X_add_number >= 16) {
							as_bad(("bad value for compressed funct4 "
								"field,value must be 0...15"));
							break;
						}
						INSERT_OPERAND(CFUNCT4,*ip,imm_expr->X_add_number);
						imm_expr->X_op = O_absent;
						asarg = expr_parse_end;
						continue;

					case '3':
						if (my_getSmallExpression(imm_expr,imm_reloc,asarg,p)
						|| imm_expr->X_op != O_constant
						 || imm_expr->X_add_number < 0
						    || imm_expr->X_add_number >= 8) {
							as_bad(("bad value for compressed funct3 "
								"field,value must be 0...7"));
							break;
						}
						INSERT_OPERAND(CFUNCT3,*ip,imm_expr->X_add_number);
						imm_expr->X_op = O_absent;
						asarg = expr_parse_end;
						continue;

					case '2':
						if (my_getSmallExpression(imm_expr,imm_reloc,asarg,p)
						|| imm_expr->X_op != O_constant
						 || imm_expr->X_add_number < 0
						    || imm_expr->X_add_number >= 4) {
							as_bad(("bad value for compressed funct2 "
								"field,value must be 0...3"));
							break;
						}
						INSERT_OPERAND(CFUNCT2,*ip,imm_expr->X_add_number);
						imm_expr->X_op = O_absent;
						asarg = expr_parse_end;
						continue;

					default:
						goto unknown_riscv_ip_operand;
					}
					break;

				default:
					goto unknown_riscv_ip_operand;
				}
				break;	/* end RVC */

			case 'V':	/* RVV */
				switch (*++oparg) {
				case 'd':	/* VD */
					if (!reg_lookup(&asarg,RCLASS_VECR,&regno))
						break;
					INSERT_OPERAND(VD,*ip,regno);
					continue;

				case 'e':	/* AMO VD */
					if (reg_lookup(&asarg,RCLASS_GPR,&regno) && regno == 0)
						INSERT_OPERAND(VWD,*ip,0);
					else
						if (reg_lookup(&asarg,RCLASS_VECR,&regno)) {
							INSERT_OPERAND(VWD,*ip,1);
							INSERT_OPERAND(VD,*ip,regno);
						} else
							break;
					continue;

				case 'f':	/* AMO VS3 */
					if (!reg_lookup(&asarg,RCLASS_VECR,&regno))
						break;
					if (!EXTRACT_OPERAND(VWD,ip->insn_opcode))
						INSERT_OPERAND(VD,*ip,regno);
					else {
						/* VS3 must match VD.  */
						if (EXTRACT_OPERAND(VD,ip->insn_opcode) != regno)
							break;
					}
					continue;

				case 's':	/* VS1 */
					if (!reg_lookup(&asarg,RCLASS_VECR,&regno))
						break;
					INSERT_OPERAND(VS1,*ip,regno);
					continue;

				case 't':	/* VS2 */
					if (!reg_lookup(&asarg,RCLASS_VECR,&regno))
						break;
					INSERT_OPERAND(VS2,*ip,regno);
					continue;

				case 'u':	/* VS1 == VS2 */
					if (!reg_lookup(&asarg,RCLASS_VECR,&regno))
						break;
					INSERT_OPERAND(VS1,*ip,regno);
					INSERT_OPERAND(VS2,*ip,regno);
					continue;

				case 'v':	/* VD == VS1 == VS2 */
					if (!reg_lookup(&asarg,RCLASS_VECR,&regno))
						break;
					INSERT_OPERAND(VD,*ip,regno);
					INSERT_OPERAND(VS1,*ip,regno);
					INSERT_OPERAND(VS2,*ip,regno);
					continue;

					/* The `V0` is carry-in register for v[m]adc and v[m]sbc,
					 * and is used to choose vs1/rs1/frs1/imm or vs2 for
					 * v[f]merge.  It use the same encoding as the vector
					 * mask register. */
				case '0':
					if (reg_lookup(&asarg,RCLASS_VECR,&regno) && regno == 0)
						continue;
					break;

				case 'b':	/* vtypei for vsetivli */
					my_getVsetvliExpression(imm_expr,asarg);
					check_absolute_expr(ip,imm_expr,FALSE);
					if (!VALID_RVV_VB_IMM(imm_expr->X_add_number))
						as_bad(("bad value for vsetivli immediate field,"
						    "value must be 0..1023"));
					ip->insn_opcode
						|= ENCODE_RVV_VB_IMM(imm_expr->X_add_number);
					imm_expr->X_op = O_absent;
					asarg = expr_parse_end;
					continue;

				case 'c':	/* vtypei for vsetvli */
					my_getVsetvliExpression(imm_expr,asarg);
					check_absolute_expr(ip,imm_expr,FALSE);
					if (!VALID_RVV_VC_IMM(imm_expr->X_add_number))
						as_bad(("bad value for vsetvli immediate field,"
						    "value must be 0..2047"));
					ip->insn_opcode
						|= ENCODE_RVV_VC_IMM(imm_expr->X_add_number);
					imm_expr->X_op = O_absent;
					asarg = expr_parse_end;
					continue;

				case 'i':	/* vector arith signed immediate */
					my_getExpression(imm_expr,asarg);
					check_absolute_expr(ip,imm_expr,FALSE);
					if (imm_expr->X_add_number > 15
					    || imm_expr->X_add_number < -16)
						as_bad(("bad value for vector immediate field,"
						   "value must be -16...15"));
					INSERT_OPERAND(VIMM,*ip,imm_expr->X_add_number);
					imm_expr->X_op = O_absent;
					asarg = expr_parse_end;
					continue;

				case 'j':	/* vector arith unsigned immediate */
					my_getExpression(imm_expr,asarg);
					check_absolute_expr(ip,imm_expr,FALSE);
					if (imm_expr->X_add_number < 0
					    || imm_expr->X_add_number >= 32)
						as_bad(("bad value for vector immediate field,"
						     "value must be 0...31"));
					INSERT_OPERAND(VIMM,*ip,imm_expr->X_add_number);
					imm_expr->X_op = O_absent;
					asarg = expr_parse_end;
					continue;

				case 'k':	/* vector arith signed immediate,minus 1 */
					my_getExpression(imm_expr,asarg);
					check_absolute_expr(ip,imm_expr,FALSE);
					if (imm_expr->X_add_number > 16
					    || imm_expr->X_add_number < -15)
						as_bad(("bad value for vector immediate field,"
						   "value must be -15...16"));
					INSERT_OPERAND(VIMM,*ip,imm_expr->X_add_number - 1);
					imm_expr->X_op = O_absent;
					asarg = expr_parse_end;
					continue;

				case 'm':	/* optional vector mask */
					if (*asarg == '\0') {
						INSERT_OPERAND(VMASK,*ip,1);
						continue;
					} else
						if (*asarg == ',' && asarg++
						    && reg_lookup(&asarg,RCLASS_VECM,&regno)
						    && regno == 0) {
							INSERT_OPERAND(VMASK,*ip,0);
							continue;
						}
					break;

				case 'M':	/* required vector mask */
					if (reg_lookup(&asarg,RCLASS_VECM,&regno) && regno == 0) {
						INSERT_OPERAND(VMASK,*ip,0);
						continue;
					}
					break;

				case 'T':	/* vector macro temporary register */
					if (!reg_lookup(&asarg,RCLASS_VECR,&regno) || regno == 0)
						break;
					/* Store it in the FUNCT6 field as we don't have anyplace 
					 * else to store it. */
					INSERT_OPERAND(VFUNCT6,*ip,regno);
					continue;

				default:
					goto unknown_riscv_ip_operand;
				}
				break;	/* end RVV */

			case ',':
				if (*asarg++ == *oparg)
					continue;
				asarg--;
				break;

			case '(': case ')': case '[': case ']':
				if (*asarg++ == *oparg)
					continue;
				break;

			case '<':	/* Shift amount,0 - 31.  */
				my_getExpression(imm_expr,asarg);
				check_absolute_expr(ip,imm_expr,false);
				if ((unsigned long)imm_expr->X_add_number > 31)
					as_bad(("improper shift amount (%" PRIu64 ")"),
					       imm_expr->X_add_number);
				INSERT_OPERAND(SHAMTW,*ip,imm_expr->X_add_number);
				imm_expr->X_op = O_absent;
				asarg = expr_parse_end;
				continue;

			case '>':	/* Shift amount,0 - (XLEN-1).  */
				my_getExpression(imm_expr,asarg);
				check_absolute_expr(ip,imm_expr,false);
				if ((unsigned long)imm_expr->X_add_number >= xlen)
					as_bad(("improper shift amount (%" PRIu64 ")"),
					       imm_expr->X_add_number);
				INSERT_OPERAND(SHAMT,*ip,imm_expr->X_add_number);
				imm_expr->X_op = O_absent;
				asarg = expr_parse_end;
				continue;

			case 'Z':	/* CSRRxI immediate.  */
				my_getExpression(imm_expr,asarg);
				check_absolute_expr(ip,imm_expr,false);
				if ((unsigned long)imm_expr->X_add_number > 31)
					as_bad(("improper CSRxI immediate (%" PRIu64 ")"),
					       imm_expr->X_add_number);
				INSERT_OPERAND(RS1,*ip,imm_expr->X_add_number);
				imm_expr->X_op = O_absent;
				asarg = expr_parse_end;
				continue;

			case 'E':	/* Control register.  */
				insn_with_csr = true;
				explicit_priv_attr = true;
				if (reg_lookup(&asarg,RCLASS_CSR,&regno))
					INSERT_OPERAND(CSR,*ip,regno);
				else {
					my_getExpression(imm_expr,asarg);
					check_absolute_expr(ip,imm_expr,true);
					if ((unsigned long)imm_expr->X_add_number > 0xfff)
						as_bad(("improper CSR address (%" PRIu64 ")"),
						       imm_expr->X_add_number);
					INSERT_OPERAND(CSR,*ip,imm_expr->X_add_number);
					imm_expr->X_op = O_absent;
					asarg = expr_parse_end;
				}
				continue;

			case 'm':	/* Rounding mode.  */
				if (arg_lookup(&asarg,riscv_rm,
					       ARRAY_SIZE(riscv_rm),&regno)) {
					INSERT_OPERAND(RM,*ip,regno);
					continue;
				}
				break;

			case 'P':
			case 'Q':	/* Fence predecessor/successor.  */
				if (arg_lookup(&asarg,riscv_pred_succ,
				       ARRAY_SIZE(riscv_pred_succ),&regno)) {
					if (*oparg == 'P')
						INSERT_OPERAND(PRED,*ip,regno);
					else
						INSERT_OPERAND(SUCC,*ip,regno);
					continue;
				}
				break;

			case 'd':	/* Destination register.  */
			case 's':	/* Source register.  */
			case 't':	/* Target register.  */
			case 'r':	/* RS3 */
				if (reg_lookup(&asarg,RCLASS_GPR,&regno)) {
					char		c = *oparg;
					if (*asarg == ' ')
						++asarg;

					/* Now that we have assembled one operand,we use the args
					 * string to figure out where it goes in the instruction */
					switch (c) {
					case 's':
						INSERT_OPERAND(RS1,*ip,regno);
						break;
					case 'd':
						INSERT_OPERAND(RD,*ip,regno);
						break;
					case 't':
						INSERT_OPERAND(RS2,*ip,regno);
						break;
					case 'r':
						INSERT_OPERAND(RS3,*ip,regno);
						break;
					}
					continue;
				}
				break;

			case 'D':	/* Floating point RD.  */
			case 'S':	/* Floating point RS1.  */
			case 'T':	/* Floating point RS2.  */
			case 'U':	/* Floating point RS1 and RS2.  */
			case 'R':	/* Floating point RS3.  */
				if (reg_lookup(&asarg,
				(riscv_subset_supports(&riscv_rps_as,"zfinx")
				 ? RCLASS_GPR : RCLASS_FPR),&regno)) {
					char		c = *oparg;
					if (*asarg == ' ')
						++asarg;
					switch (c) {
					case 'D':
						INSERT_OPERAND(RD,*ip,regno);
						break;
					case 'S':
						INSERT_OPERAND(RS1,*ip,regno);
						break;
					case 'U':
						INSERT_OPERAND(RS1,*ip,regno);
						/* Fall through.  */
					case 'T':
						INSERT_OPERAND(RS2,*ip,regno);
						break;
					case 'R':
						INSERT_OPERAND(RS3,*ip,regno);
						break;
					}
					continue;
				}
				break;

			case 'I':
				my_getExpression(imm_expr,asarg);
				if (imm_expr->X_op != O_big
				    && imm_expr->X_op != O_constant)
					break;
				normalize_constant_expr(imm_expr);
				asarg = expr_parse_end;
				continue;

			case 'A':
				my_getExpression(imm_expr,asarg);
				normalize_constant_expr(imm_expr);
				/* The 'A' format specifier must be a symbol.  */
				if (imm_expr->X_op != O_symbol)
					break;
				*imm_reloc = BFD_RELOC_32;
				asarg = expr_parse_end;
				continue;

			case 'B':
				my_getExpression(imm_expr,asarg);
				normalize_constant_expr(imm_expr);
				/* The 'B' format specifier must be a symbol or
				 * a constant. */
				if (imm_expr->X_op != O_symbol && imm_expr->X_op != O_constant)
					break;
				if (imm_expr->X_op == O_symbol)
					*imm_reloc = BFD_RELOC_32;
				asarg = expr_parse_end;
				continue;

			case 'j':	/* Sign-extended immediate.  */
				p = percent_op_itype;
				*imm_reloc = BFD_RELOC_RISCV_LO12_I;
				goto alu_op;
			case 'q':	/* Store displacement.  */
				p = percent_op_stype;
				*imm_reloc = BFD_RELOC_RISCV_LO12_S;
				goto load_store;
			case 'o':	/* Load displacement.  */
				p = percent_op_itype;
				*imm_reloc = BFD_RELOC_RISCV_LO12_I;
				goto load_store;
			case '1':
				/* This is used for TLS,where the fourth
				 * operand is %tprel_add,to get a relocation
				 * applied to an add instruction,for
				 * relaxation to use.  */
				p = percent_op_rtype;
				goto alu_op;
			case '0':	/* AMO displacement,which must be zero.  */
		load_store:
				if (riscv_handle_implicit_zero_offset(imm_expr,asarg))
					continue;
		alu_op:
				/* If this value won't fit into a 16 bit
				 * offset,then go find a macro that will
				 * generate the 32 bit offset code pattern. */
				if (!my_getSmallExpression(imm_expr,imm_reloc,asarg,p)) {
					normalize_constant_expr(imm_expr);
					if (imm_expr->X_op != O_constant
					    || (*oparg == '0' && imm_expr->X_add_number != 0)
					    || (*oparg == '1')
					    || imm_expr->X_add_number >= (signed) RISCV_IMM_REACH / 2
					    || imm_expr->X_add_number < -(signed) RISCV_IMM_REACH / 2)
						break;
				}
				asarg = expr_parse_end;
				continue;

			case 'p':	/* PC-relative offset.  */
		branch:
				*imm_reloc = BFD_RELOC_12_PCREL;
				my_getExpression(imm_expr,asarg);
				asarg = expr_parse_end;
				continue;

			case 'u':	/* Upper 20 bits.  */
				p = percent_op_utype;
				if (!my_getSmallExpression(imm_expr,imm_reloc,asarg,p)) {
					if (imm_expr->X_op != O_constant)
						break;

					if (imm_expr->X_add_number < 0
					    || imm_expr->X_add_number >= (signed) RISCV_BIGIMM_REACH)
						as_bad(("lui expression not in range 0..1048575"));

					*imm_reloc = BFD_RELOC_RISCV_HI20;
					imm_expr->X_add_number <<= RISCV_IMM_BITS;
				}
				asarg = expr_parse_end;
				continue;

			case 'a':	/* 20-bit PC-relative offset.  */
		jump:
				my_getExpression(imm_expr,asarg);
				asarg = expr_parse_end;
				*imm_reloc = BFD_RELOC_RISCV_JMP;
				continue;

			case 'c':
				my_getExpression(imm_expr,asarg);
				asarg = expr_parse_end;
				if (strcmp(asarg,"@plt") == 0)
					asarg += 4;
				*imm_reloc = BFD_RELOC_RISCV_CALL_PLT;
				continue;

			case 'O':
				switch (*++oparg) {
				case '4':
					if (my_getOpcodeExpression(imm_expr,imm_reloc,asarg)
					    || imm_expr->X_op != O_constant
					    || imm_expr->X_add_number < 0
					    || imm_expr->X_add_number >= 128
					    || (imm_expr->X_add_number & 0x3) != 3) {
						as_bad(("bad value for opcode field,"
						  "value must be 0...127 and "
						 "lower 2 bits must be 0x3"));
						break;
					}
					INSERT_OPERAND(OP,*ip,imm_expr->X_add_number);
					imm_expr->X_op = O_absent;
					asarg = expr_parse_end;
					continue;

				case '2':
					if (my_getOpcodeExpression(imm_expr,imm_reloc,asarg)
					    || imm_expr->X_op != O_constant
					    || imm_expr->X_add_number < 0
					    || imm_expr->X_add_number >= 3) {
						as_bad(("bad value for opcode field,"
						      "value must be 0...2"));
						break;
					}
					INSERT_OPERAND(OP2,*ip,imm_expr->X_add_number);
					imm_expr->X_op = O_absent;
					asarg = expr_parse_end;
					continue;

				default:
					goto unknown_riscv_ip_operand;
				}
				break;

			case 'F':
				switch (*++oparg) {
				case '7':
					if (my_getSmallExpression(imm_expr,imm_reloc,asarg,p)
					    || imm_expr->X_op != O_constant
					    || imm_expr->X_add_number < 0
					    || imm_expr->X_add_number >= 128) {
						as_bad(("bad value for funct7 field,"
						    "value must be 0...127"));
						break;
					}
					INSERT_OPERAND(FUNCT7,*ip,imm_expr->X_add_number);
					imm_expr->X_op = O_absent;
					asarg = expr_parse_end;
					continue;

				case '3':
					if (my_getSmallExpression(imm_expr,imm_reloc,asarg,p)
					    || imm_expr->X_op != O_constant
					    || imm_expr->X_add_number < 0
					    || imm_expr->X_add_number >= 8) {
						as_bad(("bad value for funct3 field,"
						      "value must be 0...7"));
						break;
					}
					INSERT_OPERAND(FUNCT3,*ip,imm_expr->X_add_number);
					imm_expr->X_op = O_absent;
					asarg = expr_parse_end;
					continue;

				case '2':
					if (my_getSmallExpression(imm_expr,imm_reloc,asarg,p)
					    || imm_expr->X_op != O_constant
					    || imm_expr->X_add_number < 0
					    || imm_expr->X_add_number >= 4) {
						as_bad(("bad value for funct2 field,"
						      "value must be 0...3"));
						break;
					}
					INSERT_OPERAND(FUNCT2,*ip,imm_expr->X_add_number);
					imm_expr->X_op = O_absent;
					asarg = expr_parse_end;
					continue;

				default:
					goto unknown_riscv_ip_operand;
				}
				break;

			case 'y':	/* bs immediate */
				my_getExpression(imm_expr,asarg);
				check_absolute_expr(ip,imm_expr,FALSE);
				if ((unsigned long)imm_expr->X_add_number > 3)
					as_bad(("Improper bs immediate (%lu)"),
					(unsigned long)imm_expr->X_add_number);
				INSERT_OPERAND(BS,*ip,imm_expr->X_add_number);
				imm_expr->X_op = O_absent;
				asarg = expr_parse_end;
				continue;

			case 'Y':	/* rnum immediate */
				my_getExpression(imm_expr,asarg);
				check_absolute_expr(ip,imm_expr,FALSE);
				if ((unsigned long)imm_expr->X_add_number > 10)
					as_bad(("Improper rnum immediate (%lu)"),
					(unsigned long)imm_expr->X_add_number);
				INSERT_OPERAND(RNUM,*ip,imm_expr->X_add_number);
				imm_expr->X_op = O_absent;
				asarg = expr_parse_end;
				continue;

			case 'z':
				if (my_getSmallExpression(imm_expr,imm_reloc,asarg,p)
				    || imm_expr->X_op != O_constant
				    || imm_expr->X_add_number != 0)
					break;
				asarg = expr_parse_end;
				imm_expr->X_op = O_absent;
				continue;

			case 'W':	/* Various operands.  */
				switch (*++oparg) {
				case 'i':
					switch (*++oparg) {
					case 'f':
						/*
						 * Prefetch offset for 'Zicbop'
						 * extension. pseudo S-type but
						 * lower 5-bits zero.
						 */
						if (riscv_handle_implicit_zero_offset(imm_expr,asarg))
							continue;
						my_getExpression(imm_expr,asarg);
						check_absolute_expr(ip,imm_expr,false);
						if (((unsigned)(imm_expr->X_add_number) & 0x1fU)
						    || imm_expr->X_add_number >= RISCV_IMM_REACH / 2
						    || imm_expr->X_add_number < -RISCV_IMM_REACH / 2)
							as_bad(_("improper prefetch offset (%ld)"),
							       (long)imm_expr->X_add_number);
						ip->insn_opcode |= ENCODE_STYPE_IMM(
										    (unsigned)(imm_expr->X_add_number) & ~0x1fU);
						imm_expr->X_op = O_absent;
						asarg = expr_parse_end;
						continue;
					default:
						goto unknown_riscv_ip_operand;
					}
					break;
				default:
					goto unknown_riscv_ip_operand;
				}
				break;

			case 'X':	/* Integer immediate.  */
				{
					size_t		n;
					size_t		s;
					bool		sign;

					switch (*++oparg) {
					case 'l':	/* Literal.  */
						n = strcspn(++oparg,",");
						if (strncmp(oparg,asarg,n))
							as_bad(("unexpected literal (%s)"),asarg);
						oparg += n - 1;
						asarg += n;
						continue;
					case 's':	/* 'XsN@S' ... N-bit
							 * signed immediate at
							 * bit S.  */
						sign = true;
						goto parse_imm;
					case 'u':	/* 'XuN@S' ... N-bit
							 * unsigned immediate at
							 * bit S.  */
						sign = false;
						goto parse_imm;
				parse_imm:
						n = strtol(oparg + 1,(char **)&oparg,10);
						if (*oparg != '@')
							goto unknown_riscv_ip_operand;
						s = strtol(oparg + 1,(char **)&oparg,10);
						oparg--;

						my_getExpression(imm_expr,asarg);
						check_absolute_expr(ip,imm_expr,false);
						if (!sign) {
							if (!VALIDATE_U_IMM(imm_expr->X_add_number,n))
								as_bad(("improper immediate value (%" PRIu64 ")"),
								       imm_expr->X_add_number);
						} else {
							if (!VALIDATE_S_IMM(imm_expr->X_add_number,n))
								as_bad(("improper immediate value (%" PRIi64 ")"),
								       imm_expr->X_add_number);
						}
						INSERT_IMM(n,s,*ip,imm_expr->X_add_number);
						imm_expr->X_op = O_absent;
						asarg = expr_parse_end;
						continue;
					default:
						goto unknown_riscv_ip_operand;
					}
				}
				break;

			default:
		unknown_riscv_ip_operand:
				as_fatal(("internal: unknown argument type `%s'"),
					 opargStart);
			}
			break;
		}
		asarg = asargStart;
		insn_with_csr = false;
	}

out:
	/* Restore the character we might have clobbered above.  */
	if (save_c)
		*(asargStart - 1) = save_c;

	probing_insn_operands = false;

	return error;
}

/* Similar to riscv_ip,but assembles an instruction according to the hardcode
 * values of .insn directive.  */
static const char *riscv_ip_hardcode(char *str,struct riscv_cl_insn *ip,
		       		expressionS *	imm_expr,const char *error)
{
	struct riscv_opcode *insn;
	insn_t		values  [2] = {0,0};
	unsigned int	num = 0;

	input_line_pointer = str;
	do {
		expression(imm_expr);
		switch (imm_expr->X_op) {
		case O_constant:
			values[num++] = (insn_t) imm_expr->X_add_number;
			break;
		case O_big:
			/* Extract lower 32-bits of a big number. Assume that
			 * generic_bignum_to_int32 work on such number.  */
			values[num++] = (insn_t) generic_bignum_to_int32();
			break;
		default:
			/* The first value isn't constant,so it should be
			 * .insn <type> <operands>.  We have been parsed it in
			 * the riscv_ip. */
			if (num == 0)
				return error;
			return ("values must be constant");
		}
	}
	while (*input_line_pointer++ == ',' && num < 2 && imm_expr->X_op != O_big);

	input_line_pointer--;
	if (*input_line_pointer != '\0')
		return ("unrecognized values");

	insn = XNEW(struct riscv_opcode);
	insn->match = values[num - 1];
	create_insn(ip,insn);
	unsigned int	bytes = riscv_insn_length(insn->match);

	if (num == 2 && values[0] != bytes)
		return ("value conflicts with instruction length");

	if (imm_expr->X_op == O_big) {
		unsigned int	llen = 0;
		for (LITTLENUM_TYPE lval = generic_bignum[imm_expr->X_add_number - 1];
		     lval != 0; llen++)
			lval >>= BITS_PER_CHAR;
		unsigned int	repr_bytes
		= (imm_expr->X_add_number - 1) * CHARS_PER_LITTLENUM + llen;
		if (bytes < repr_bytes)
			return ("value conflicts with instruction length");
		for (num = 0; num < imm_expr->X_add_number - 1; ++num)
			number_to_chars_littleendian(
			     ip->insn_long_opcode + num * CHARS_PER_LITTLENUM,
						     generic_bignum[num],
						     CHARS_PER_LITTLENUM);
		if (llen != 0)
			number_to_chars_littleendian(
			     ip->insn_long_opcode + num * CHARS_PER_LITTLENUM,
						     generic_bignum[num],
						     llen);
		memset(ip->insn_long_opcode + repr_bytes,0,bytes - repr_bytes);
		return NULL;
	}
	if (bytes < sizeof(values[0]) && values[num - 1] >> (8 * bytes) != 0)
		return ("value conflicts with instruction length");

	return NULL;
}

static void	md_assemble(char *str)
{
	struct riscv_cl_insn insn;
	expressionS	imm_expr;
	bfd_reloc_code_real_type imm_reloc = BFD_RELOC_UNUSED;

	/* The architecture and privileged elf attributes should be set before
	 * assembling.  */
	if (!start_assemble) {
		start_assemble = true;

		riscv_set_abi_by_arch();
		if (!riscv_set_default_priv_spec(NULL))
			return;
	}
	riscv_mapping_state(MAP_INSN,0,false /* fr_align_code */ );

	const struct riscv_ip_error error = riscv_ip(str,&insn,&imm_expr,
						     &imm_reloc,op_hash);

	if (error.msg) {
		if (error.missing_ext)
			as_bad("%s `%s',extension `%s' required",error.msg,
			       error.statement,error.missing_ext);
		else
			as_bad("%s `%s'",error.msg,error.statement);
		return;
	}
	if (insn.insn_mo->pinfo == INSN_MACRO)
		macro(&insn,&imm_expr,&imm_reloc);
	else
		append_insn(&insn,&imm_expr,imm_reloc);
}

void		md_number_to_chars(char *buf,valueT val,int n)
{
	number_to_chars_littleendian(buf,val,n);
}

static int	md_parse_option(int c,const char *arg)
{
	switch (c) {
	case OPTION_MARCH:
		default_arch_with_ext = arg;
		break;

	case OPTION_NO_PIC:
		riscv_opts.pic = false;
		break;

	case OPTION_PIC:
		riscv_opts.pic = true;
		break;

	case OPTION_MABI:
		if (strcmp(arg,"ilp32") == 0)
			riscv_set_abi(32,FLOAT_ABI_SOFT,false);
		else if (strcmp(arg,"ilp32e") == 0)
				riscv_set_abi(32,FLOAT_ABI_SOFT,true);
			else if (strcmp(arg,"ilp32f") == 0)
					riscv_set_abi(32,FLOAT_ABI_SINGLE,false);
				else if (strcmp(arg,"ilp32d") == 0)
						riscv_set_abi(32,FLOAT_ABI_DOUBLE,false);
					else if (strcmp(arg,"ilp32q") == 0)
							riscv_set_abi(32,FLOAT_ABI_QUAD,false);
						else if (strcmp(arg,"lp64") == 0)
								riscv_set_abi(64,FLOAT_ABI_SOFT,false);
							else if (strcmp(arg,"lp64f") == 0)
									riscv_set_abi(64,FLOAT_ABI_SINGLE,false);
								else if (strcmp(arg,"lp64d") == 0)
										riscv_set_abi(64,FLOAT_ABI_DOUBLE,false);
									else if (strcmp(arg,"lp64q") == 0)
											riscv_set_abi(64,FLOAT_ABI_QUAD,false);
										else return 0;
		explicit_mabi = true;
		break;

	case OPTION_RELAX:
		riscv_opts.relax = true;
		break;

	case OPTION_NO_RELAX:
		riscv_opts.relax = false;
		break;

	case OPTION_ARCH_ATTR:
		riscv_opts.arch_attr = true;
		break;

	case OPTION_NO_ARCH_ATTR:
		riscv_opts.arch_attr = false;
		break;

	case OPTION_CSR_CHECK:
		riscv_opts.csr_check = true;
		break;

	case OPTION_NO_CSR_CHECK:
		riscv_opts.csr_check = false;
		break;

	case OPTION_MISA_SPEC:
		return riscv_set_default_isa_spec(arg);

	case OPTION_MPRIV_SPEC:
		return riscv_set_default_priv_spec(arg);

	case OPTION_BIG_ENDIAN:
		target_big_endian = 1;
		break;

	case OPTION_LITTLE_ENDIAN:
		target_big_endian = 0;
		break;

	default:
		return 0;
	}

	return 1;
}

static void	riscv_after_parse_args(void)
{
	/* The --with-arch is optional for now,so we still need to set the
	 * xlen according to the default_arch,which is set by the --target. */
	if (xlen == 0) {
		xlen = 64;
	}
	/* Set default specs.  */
	if (default_isa_spec == ISA_SPEC_CLASS_NONE)
		riscv_set_default_isa_spec(DEFAULT_RISCV_ISA_SPEC);
	if (default_priv_spec == PRIV_SPEC_CLASS_NONE)
		riscv_set_default_priv_spec(DEFAULT_RISCV_PRIV_SPEC);

	riscv_set_arch(default_arch_with_ext);

	/* If the CIE to be produced has not been overridden on the command
	 * line,then produce version 3 by default.  This allows us to use the
	 * full range of registers in a .cfi_return_column directive.  */
	if (flag_dwarf_cie_version == -1)
		flag_dwarf_cie_version = 3;
}

static bool	riscv_parse_name(const char *name,struct expressionS *ep,
			     		enum		expr_mode mode)
{
	unsigned int	regno;
	symbolS        *sym;

	if (!probing_insn_operands)
		return false;

	gas_assert(mode == expr_normal);

	regno = reg_lookup_internal(name,RCLASS_GPR);
	if (regno == (unsigned int)-1)
		return false;

	if (symbol_find(name) != NULL)
		return false;

	/* Create a symbol without adding it to the symbol table yet. Insertion
	 * will happen only once we commit to using the insn we're probing
	 * operands for.  */
	for (sym = deferred_sym_rootP; sym; sym = symbol_next(sym))
		if (strcmp(name,S_GET_NAME(sym)) == 0)
			break;
	if (!sym) {
		for (sym = orphan_sym_rootP; sym; sym = symbol_next(sym))
			if (strcmp(name,S_GET_NAME(sym)) == 0) {
				symbol_remove(sym,&orphan_sym_rootP,&orphan_sym_lastP);
				break;
			}
		if (!sym)
			sym = symbol_create(name,undefined_section,
					    &zero_address_frag,0);

		symbol_append(sym,deferred_sym_lastP,&deferred_sym_rootP,
			      &deferred_sym_lastP);
	}
	ep->X_op = O_symbol;
	ep->X_add_symbol = sym;
	ep->X_add_number = 0;

	return true;
}

static long	md_pcrel_from(fixS * fixP)
{
	return fixP->fx_where + fixP->fx_frag->fr_address;
}

/* Apply a fixup to the object file.  */

static void	md_apply_fix(fixS * fixP,valueT * valP,segT seg ATTRIBUTE_UNUSED)
{
	unsigned int	subtype;
	uint8_t        *buf = (uint8_t *) (fixP->fx_frag->fr_literal + fixP->fx_where);
	bool		relaxable = false;
	offsetT		loc;
	segT		sub_segment;

	/* Remember value for tc_gen_reloc.  */
	fixP->fx_addnumber = *valP;

	switch (fixP->fx_r_type) {
	case BFD_RELOC_RISCV_HI20: case BFD_RELOC_RISCV_LO12_I:
	case BFD_RELOC_RISCV_LO12_S:
		bfd_putl32(riscv_apply_const_reloc(fixP->fx_r_type,*valP)
			  |bfd_getl32(buf),buf);
		if (fixP->fx_addsy == NULL)
			fixP->fx_done = true;
		relaxable = true;
		break;

	case BFD_RELOC_RISCV_GOT_HI20: case BFD_RELOC_RISCV_ADD8:
	case BFD_RELOC_RISCV_ADD16: case BFD_RELOC_RISCV_ADD32:
	case BFD_RELOC_RISCV_ADD64: case BFD_RELOC_RISCV_SUB6:
	case BFD_RELOC_RISCV_SUB8: case BFD_RELOC_RISCV_SUB16:
	case BFD_RELOC_RISCV_SUB32: case BFD_RELOC_RISCV_SUB64:
	case BFD_RELOC_RISCV_RELAX:
		/* cvt_frag_to_fill () has called output_leb128 ().  */
	case BFD_RELOC_RISCV_SET_ULEB128: case BFD_RELOC_RISCV_SUB_ULEB128:
		break;

	case BFD_RELOC_RISCV_TPREL_HI20: case BFD_RELOC_RISCV_TPREL_LO12_I:
	case BFD_RELOC_RISCV_TPREL_LO12_S: case BFD_RELOC_RISCV_TPREL_ADD:
		relaxable = true;
		/* Fall through.  */

	case BFD_RELOC_RISCV_TLS_GOT_HI20: case BFD_RELOC_RISCV_TLS_GD_HI20:
	case BFD_RELOC_RISCV_TLS_DTPREL32: case BFD_RELOC_RISCV_TLS_DTPREL64:
		if (fixP->fx_addsy != NULL)
			S_SET_THREAD_LOCAL(fixP->fx_addsy);
		else
			as_bad_where(fixP->fx_file,fixP->fx_line,
				     ("TLS relocation against a constant"));
		break;

	case BFD_RELOC_32:
		/* Use pc-relative relocation for FDE initial location. The
		 * symbol address in .eh_frame may be adjusted in
		 * _bfd_elf_discard_section_eh_frame,and the content of
		 * .eh_frame will be adjusted in
		 * _bfd_elf_write_section_eh_frame. Therefore,we cannot insert
		 * a relocation whose addend symbol is in .eh_frame.
		 * Othrewise,the value may be adjusted twice.  */
		if (fixP->fx_addsy && fixP->fx_subsy
		    && (sub_segment = S_GET_SEGMENT(fixP->fx_subsy))
		    && strcmp(sub_segment->name,".eh_frame") == 0
		    && S_GET_VALUE(fixP->fx_subsy)
		    == fixP->fx_frag->fr_address + fixP->fx_where) {
			fixP->fx_r_type = BFD_RELOC_RISCV_32_PCREL;
			fixP->fx_subsy = NULL;
			break;
		}
		/* Fall through.  */
	case BFD_RELOC_64: case BFD_RELOC_16: case BFD_RELOC_8:
	case BFD_RELOC_RISCV_CFA:
		if (fixP->fx_addsy && fixP->fx_subsy) {
			fixP->fx_next = xmemdup(fixP,sizeof(*fixP),sizeof(*fixP));
			fixP->fx_next->fx_addsy = fixP->fx_subsy;
			fixP->fx_next->fx_subsy = NULL;
			fixP->fx_next->fx_offset = 0;
			fixP->fx_subsy = NULL;

			switch (fixP->fx_r_type) {
			case BFD_RELOC_64:
				fixP->fx_r_type = BFD_RELOC_RISCV_ADD64;
				fixP->fx_next->fx_r_type = BFD_RELOC_RISCV_SUB64;
				break;

			case BFD_RELOC_32:
				fixP->fx_r_type = BFD_RELOC_RISCV_ADD32;
				fixP->fx_next->fx_r_type = BFD_RELOC_RISCV_SUB32;
				break;

			case BFD_RELOC_16:
				fixP->fx_r_type = BFD_RELOC_RISCV_ADD16;
				fixP->fx_next->fx_r_type = BFD_RELOC_RISCV_SUB16;
				break;

			case BFD_RELOC_8:
				fixP->fx_r_type = BFD_RELOC_RISCV_ADD8;
				fixP->fx_next->fx_r_type = BFD_RELOC_RISCV_SUB8;
				break;

			case BFD_RELOC_RISCV_CFA:
				/* Load the byte to get the subtype.  */
				subtype = bfd_get_8(NULL,&((fragS *) (fixP->fx_frag->fr_opcode))->fr_literal[fixP->fx_where]);
				loc = fixP->fx_frag->fr_fix - (subtype & 7);
				switch (subtype) {
				case DW_CFA_advance_loc1:
					fixP->fx_where = loc + 1;
					fixP->fx_next->fx_where = loc + 1;
					fixP->fx_r_type = BFD_RELOC_RISCV_SET8;
					fixP->fx_next->fx_r_type = BFD_RELOC_RISCV_SUB8;
					break;

				case DW_CFA_advance_loc2:
					fixP->fx_size = 2;
					fixP->fx_next->fx_size = 2;
					fixP->fx_where = loc + 1;
					fixP->fx_next->fx_where = loc + 1;
					fixP->fx_r_type = BFD_RELOC_RISCV_SET16;
					fixP->fx_next->fx_r_type = BFD_RELOC_RISCV_SUB16;
					break;

				case DW_CFA_advance_loc4:
					fixP->fx_size = 4;
					fixP->fx_next->fx_size = 4;
					fixP->fx_where = loc;
					fixP->fx_next->fx_where = loc;
					fixP->fx_r_type = BFD_RELOC_RISCV_SET32;
					fixP->fx_next->fx_r_type = BFD_RELOC_RISCV_SUB32;
					break;

				default:
					if (subtype < 0x80 && (subtype & 0x40)) {
						/* DW_CFA_advance_loc */
						fixP->fx_frag = (fragS *) fixP->fx_frag->fr_opcode;
						fixP->fx_next->fx_frag = fixP->fx_frag;
						fixP->fx_r_type = BFD_RELOC_RISCV_SET6;
						fixP->fx_next->fx_r_type = BFD_RELOC_RISCV_SUB6;
					} else
						as_fatal(("internal: bad CFA value #%d"),subtype);
					break;
				}
				break;

			default:
				/* This case is unreachable.  */
				abort();
			}
		}
		/* Fall through.  */

	case BFD_RELOC_RVA:
		/* If we are deleting this reloc entry,we must fill in the
		 * value now.  This can happen if we have a .word which is not
		 * resolved when it appears but is later defined.  */
		if (fixP->fx_addsy == NULL) {
			gas_assert(fixP->fx_size <= sizeof(valueT));
			md_number_to_chars((char *)buf,*valP,fixP->fx_size);
			fixP->fx_done = 1;
		}
		break;

	case BFD_RELOC_RISCV_JMP:
		if (fixP->fx_addsy) {
			/* Fill in a tentative value to improve objdump
			 * readability.  */
			bfd_vma		target = S_GET_VALUE(fixP->fx_addsy) + *valP;
			bfd_vma		delta = target - md_pcrel_from(fixP);
			bfd_putl32(bfd_getl32(buf)|ENCODE_JTYPE_IMM(delta),buf);
		}
		break;

	case BFD_RELOC_12_PCREL:
		if (fixP->fx_addsy) {
			/* Fill in a tentative value to improve objdump
			 * readability.  */
			bfd_vma		target = S_GET_VALUE(fixP->fx_addsy) + *valP;
			bfd_vma		delta = target - md_pcrel_from(fixP);
			bfd_putl32(bfd_getl32(buf)|ENCODE_BTYPE_IMM(delta),buf);
		}
		break;

	case BFD_RELOC_RISCV_RVC_BRANCH:
		if (fixP->fx_addsy) {
			/* Fill in a tentative value to improve objdump
			 * readability.  */
			bfd_vma		target = S_GET_VALUE(fixP->fx_addsy) + *valP;
			bfd_vma		delta = target - md_pcrel_from(fixP);
			bfd_putl16(bfd_getl16(buf)|ENCODE_CBTYPE_IMM(delta),buf);
		}
		break;

	case BFD_RELOC_RISCV_RVC_JUMP:
		if (fixP->fx_addsy) {
			/* Fill in a tentative value to improve objdump
			 * readability.  */
			bfd_vma		target = S_GET_VALUE(fixP->fx_addsy) + *valP;
			bfd_vma		delta = target - md_pcrel_from(fixP);
			bfd_putl16(bfd_getl16(buf)|ENCODE_CJTYPE_IMM(delta),buf);
		}
		break;

	case BFD_RELOC_RISCV_CALL: case BFD_RELOC_RISCV_CALL_PLT:
		relaxable = true;
		break;

	case BFD_RELOC_RISCV_PCREL_HI20: case BFD_RELOC_RISCV_PCREL_LO12_S:
	case BFD_RELOC_RISCV_PCREL_LO12_I:
		relaxable = riscv_opts.relax;
		break;

	case BFD_RELOC_RISCV_ALIGN:
		break;

	default:
		/* We ignore generic BFD relocations we don't know about.  */
		if (riscv_reloc_type_lookup(stdoutput,fixP->fx_r_type) != NULL)
			as_fatal(("internal: bad relocation #%d"),fixP->fx_r_type);
	}

	if (fixP->fx_subsy != NULL)
		as_bad_subtract(fixP);

	/* Add an R_RISCV_RELAX reloc if the reloc is relaxable.  */
	if (relaxable && fixP->fx_tcbit && fixP->fx_addsy != NULL) {
		fixP->fx_next = xmemdup(fixP,sizeof(*fixP),sizeof(*fixP));
		fixP->fx_next->fx_addsy = fixP->fx_next->fx_subsy = NULL;
		fixP->fx_next->fx_r_type = BFD_RELOC_RISCV_RELAX;
		fixP->fx_next->fx_size = 0;
	}
}

/* Because the value of .cfi_remember_state may changed after relaxation,we
 * insert a fix to relocate it again in link-time.  */
static void	riscv_pre_output_hook(void)
{
	const frchainS *frch;
	segT		s;

	/* Save the current segment info.  */
	segT		seg = now_seg;
	subsegT		subseg = now_subseg;

	for (s = stdoutput->sections; s; s = s->next)
		for (frch = seg_info(s)->frchainP; frch; frch = frch->frch_next) {
			fragS          *frag;

			for (frag = frch->frch_root; frag; frag = frag->fr_next) {
				if (frag->fr_type == rs_cfa) {
					expressionS	exp;
					expressionS    *symval;

					symval = symbol_get_value_expression(frag->fr_symbol);
					exp.X_op = O_subtract;
					exp.X_add_symbol = symval->X_add_symbol;
					exp.X_add_number = 0;
					exp.X_op_symbol = symval->X_op_symbol;

					/*
					 * We must set the segment before
					 * creating a frag after all frag
					 * chains have been chained together.
					 */
					subseg_set(s,frch->frch_subseg);

					fix_new_exp(frag,(int)frag->fr_offset,1,&exp,0,
						    BFD_RELOC_RISCV_CFA);
				}
			}
		}

	/* Restore the original segment info.  */
	subseg_set(seg,subseg);
}

/* Copy the subset in the subset list.  */
static struct riscv_subset_t *riscv_copy_subset(
			    		riscv_subset_list_t * subset_list,
				      		riscv_subset_t * subset)
{
	if (subset == NULL)
		return NULL;

	riscv_subset_t *new = xmalloc(sizeof *new);
	new->name = strdup(subset->name);
	new->major_version = subset->major_version;
	new->minor_version = subset->minor_version;
	new->next = riscv_copy_subset(subset_list,subset->next);

	if (subset->next == NULL)
		subset_list->tail = new;

	return new;
}
/* Copy the subset list.  */
static riscv_subset_list_t *riscv_copy_subset_list(
			       		riscv_subset_list_t * subset_list)
{
	riscv_subset_list_t *new = xmalloc(sizeof *new);
	new->head = riscv_copy_subset(new,subset_list->head);
	new->arch_str = strdup(subset_list->arch_str);
	return new;
}
/* Handle the .option pseudo-op.  */
static void	s_riscv_option(int x ATTRIBUTE_UNUSED)
{
	char           *name = input_line_pointer,ch;

	while (!is_end_of_line[(unsigned char)*input_line_pointer])
		++input_line_pointer;
	ch = *input_line_pointer;
	*input_line_pointer = '\0';

	if (strcmp(name,"rvc") == 0) {
		riscv_update_subset(&riscv_rps_as,"+c");
		riscv_reset_subsets_list_arch_str();
		riscv_set_rvc(true);
	} else
		if (strcmp(name,"norvc") == 0) {
			riscv_update_subset(&riscv_rps_as,"-c");
			riscv_reset_subsets_list_arch_str();
			riscv_set_rvc(false);
		} else
			if (strcmp(name,"pic") == 0)
				riscv_opts.pic = true;
			else
				if (strcmp(name,"nopic") == 0)
					riscv_opts.pic = false;
				else
					if (strcmp(name,"relax") == 0)
						riscv_opts.relax = true;
					else
						if (strcmp(name,"norelax") == 0)
							riscv_opts.relax = false;
						else
							if (strcmp(name,"csr-check") == 0)
								riscv_opts.csr_check = true;
							else
								if (strcmp(name,"no-csr-check") == 0)
									riscv_opts.csr_check = false;
								else
									if (strncmp(name,"arch,",5) == 0) {
										name += 5;
										if (ISSPACE(*name) && *name != '\0')
											name++;
										riscv_update_subset(&riscv_rps_as,name);
										riscv_reset_subsets_list_arch_str();

										riscv_set_rvc(false);
										if (riscv_subset_supports(&riscv_rps_as,"c"))
											riscv_set_rvc(true);

										if (riscv_subset_supports(&riscv_rps_as,"ztso"))
											riscv_set_tso();
									} else
										if (strcmp(name,"push") == 0) {
											struct riscv_option_stack *s;

											s = XNEW(struct riscv_option_stack);
											s->next = riscv_opts_stack;
											s->options = riscv_opts;
											s->subset_list = riscv_rps_as.subset_list;
											riscv_opts_stack = s;
											riscv_rps_as.subset_list = riscv_copy_subset_list(s->subset_list);
										} else
											if (strcmp(name,"pop") == 0) {
												struct riscv_option_stack *s;

												s = riscv_opts_stack;
												if (s == NULL)
													as_bad((".option pop with no .option push"));
												else {
													riscv_subset_list_t *release_subsets = riscv_rps_as.subset_list;
													riscv_opts_stack = s->next;
													riscv_opts = s->options;
													riscv_rps_as.subset_list = s->subset_list;
													riscv_release_subset_list(release_subsets);
													free(s);
												}
											} else {
												as_warn(("unrecognized .option directive: %s"),name);
											}
	*input_line_pointer = ch;
	demand_empty_rest_of_line();
}

/*
 * Handle the .dtprelword and .dtpreldword pseudo-ops.  They generate a 32-bit
 * or 64-bit DTP-relative relocation (BYTES says which) for use in DWARF debug
 * information.
 */
static void	s_dtprel(int bytes)
{
	expressionS	ex;
	char           *p;

	expression(&ex);

	if (ex.X_op != O_symbol) {
		as_bad(("unsupported use of %s"),(bytes == 8
						   ? ".dtpreldword"
						   : ".dtprelword"));
		ignore_rest_of_line();
	}
	p = frag_more(bytes);
	md_number_to_chars(p,0,bytes);
	fix_new_exp(frag_now,p - frag_now->fr_literal,bytes,&ex,false,
		    (bytes == 8
		     ? BFD_RELOC_RISCV_TLS_DTPREL64
		     : BFD_RELOC_RISCV_TLS_DTPREL32));

	demand_empty_rest_of_line();
}

/* Handle the .bss pseudo-op.  */

static void	s_bss(int ignore ATTRIBUTE_UNUSED)
{
	subseg_set(bss_section,0);
	demand_empty_rest_of_line();
}

static void	riscv_make_nops(char *buf,bfd_vma bytes)
{
	bfd_vma		i = 0;

	/*
	 * RISC-V instructions cannot begin or end on odd addresses,so this
	 * case means we are not within a valid instruction sequence.  It is
	 * thus safe to use a zero byte,even though that is not a valid
	 * instruction.
	 */
	if (bytes % 2 == 1)
		buf[i++] = 0;

	/* Use at most one 2-byte NOP.  */
	if ((bytes - i) % 4 == 2) {
		number_to_chars_littleendian(buf + i,RVC_NOP,2);
		i += 2;
	}
	/* Fill the remainder with 4-byte NOPs.  */
	for (; i < bytes; i += 4)
		number_to_chars_littleendian(buf + i,RISCV_NOP,4);
}

/*
 * Called from md_do_align.  Used to create an alignment frag in a code section
 * by emitting a worst-case NOP sequence that the linker will later relax to
 * the correct number of NOPs.  We can't compute the correct alignment now
 * because of other linker relaxations.
 */

static bool	riscv_frag_align_code(int n)
{
	bfd_vma		bytes = (bfd_vma) 1 << n;
	bfd_vma		insn_alignment = riscv_opts.rvc ? 2 : 4;
	bfd_vma		worst_case_bytes = bytes - insn_alignment;
	char           *nops;
	expressionS	ex;

	/*
	 * If we are moving to a smaller alignment than the instruction size,
	 * then no alignment is required.
	 */
	if (bytes <= insn_alignment)
		return true;

	/* When not relaxing,riscv_handle_align handles code alignment.  */
	if (!riscv_opts.relax)
		return false;

	/*
	 * Maybe we should use frag_var to create a new rs_align_code fragment,
	 * rather than just use frag_more to handle an alignment here?  So that
	 * we don't need to call riscv_mapping_state again later,and then only
	 * need to check frag->fr_type to see if it is frag_align_code.
	 */
	nops = frag_more(worst_case_bytes);

	ex.X_op = O_constant;
	ex.X_add_number = worst_case_bytes;

	riscv_make_nops(nops,worst_case_bytes);

	fix_new_exp(frag_now,nops - frag_now->fr_literal,0,
		    &ex,false,BFD_RELOC_RISCV_ALIGN);

	riscv_mapping_state(MAP_INSN,worst_case_bytes,true /* fr_align_code */ );

	/*
	 * We need to start a new frag after the alignment which may be removed
	 * by the linker,to prevent the assembler from computing static
	 * offsets. This is necessary to get correct EH info.
	 */
	frag_wane(frag_now);
	frag_new(0);

	return true;
}

/* Implement HANDLE_ALIGN.  */
static void	riscv_handle_align(fragS * fragP)
{
	switch (fragP->fr_type) {
	case rs_align_code:
		/* When relaxing,riscv_frag_align_code handles code alignment.  */
		if (!riscv_opts.relax) {
			bfd_signed_vma	bytes = (fragP->fr_next->fr_address
					 - fragP->fr_address - fragP->fr_fix);
			/* We have 4 byte uncompressed nops.  */
			bfd_signed_vma	size = 4;
			bfd_signed_vma	excess = bytes % size;
			bool		odd_padding = (excess % 2 == 1);
			char           *p = fragP->fr_literal + fragP->fr_fix;

			if (bytes <= 0)
				break;

			/*
			 * Insert zeros or compressed nops to get 4 byte
			 * alignment.
			 */
			if (excess) {
				if (odd_padding)
					riscv_add_odd_padding_symbol(fragP);
				riscv_make_nops(p,excess);
				fragP->fr_fix += excess;
				p += excess;
			}
			/*
			 * The frag will be changed to `rs_fill` later.  The
			 * function `write_contents` will try to fill the
			 * remaining spaces according to the patterns we give.
			 * In this case,we give a 4 byte uncompressed nop as
			 * the pattern,and set the size of the pattern into
			 * `fr_var`.  The nop will be output to the file
			 * `fr_offset` times.  However,`fr_offset` could be
			 * zero if we don't need to pad the boundary finally.
			 */
			riscv_make_nops(p,size);
			fragP->fr_var = size;
		}
		break;

	default:
		break;
	}
}

/* This usually called from frag_var.  */
static void	riscv_init_frag(fragS * fragP,int max_chars)
{
	/* Do not add mapping symbol to debug sections.  */
	if (now_seg->flags & SEC_DEBUGGING)
		return;

	switch (fragP->fr_type) {
	case rs_fill:
	case rs_align:
	case rs_align_test:
		riscv_mapping_state(MAP_DATA,max_chars,false /* fr_align_code */ );
		break;
	case rs_align_code:
		riscv_mapping_state(MAP_INSN,max_chars,true /* fr_align_code */ );
		break;
	default:
		break;
	}
}

static int	md_estimate_size_before_relax(fragS * fragp,asection * segtype)
{
	return (fragp->fr_var = relaxed_branch_length(fragp,segtype,false));
}

/*
 * Translate internal representation of relocation info to BFD target format.
 */
static arelent *tc_gen_reloc(asection * section ATTRIBUTE_UNUSED,fixS * fixp)
{
	arelent        *reloc = (arelent *) xmalloc(sizeof(arelent));

	reloc->sym_ptr_ptr = (asymbol **) xmalloc(sizeof(asymbol *));
	*reloc->sym_ptr_ptr = symbol_get_bfdsym(fixp->fx_addsy);
	reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
	reloc->addend = fixp->fx_addnumber;

	reloc->howto = riscv_reloc_type_lookup(stdoutput,fixp->fx_r_type);
	if (reloc->howto == NULL) {
		if ((fixp->fx_r_type == BFD_RELOC_16 || fixp->fx_r_type == BFD_RELOC_8)
		    && fixp->fx_addsy != NULL && fixp->fx_subsy != NULL) {
			/*
			 * We don't have R_RISCV_8/16,but for this special
			 * case,we can use R_RISCV_ADD8/16 with
			 * R_RISCV_SUB8/16.
			 */
			return reloc;
		}
		as_bad_where(fixp->fx_file,fixp->fx_line,
			     "cannot represent relocation type %d in object file",fixp->fx_r_type);
		return NULL;
	}
	return reloc;
}

int		riscv_relax_frag(asection * sec,fragS * fragp,long stretch ATTRIBUTE_UNUSED)
{
	if (RELAX_BRANCH_P(fragp->fr_subtype)) {
		offsetT		old_var = fragp->fr_var;
		fragp->fr_var = relaxed_branch_length(fragp,sec,true);
		return fragp->fr_var - old_var;
	}
	return 0;
}

/* Expand far branches to multi-instruction sequences.  */

static void	md_convert_frag_branch(fragS * fragp)
{
	uint8_t        *buf;
	expressionS	exp;
	fixS           *fixp;
	insn_t		insn;
	int		rs1       ,reloc;

	buf = (uint8_t *) fragp->fr_literal + fragp->fr_fix;

	exp.X_op = O_symbol;
	exp.X_add_symbol = fragp->fr_symbol;
	exp.X_add_number = fragp->fr_offset;

	gas_assert(fragp->fr_var == RELAX_BRANCH_LENGTH(fragp->fr_subtype));

	if (RELAX_BRANCH_RVC(fragp->fr_subtype)) {
		switch (RELAX_BRANCH_LENGTH(fragp->fr_subtype)) {
		case 8:
		case 4:
			/* Expand the RVC branch into a RISC-V one.  */
			insn = bfd_getl16(buf);
			rs1 = 8 + ((insn >> OP_SH_CRS1S) & OP_MASK_CRS1S);
			if ((insn & MASK_C_J) == MATCH_C_J)
				insn = MATCH_JAL;
			else
				if ((insn & MASK_C_JAL) == MATCH_C_JAL)
					insn = MATCH_JAL|(X_RA << OP_SH_RD);
				else
					if ((insn & MASK_C_BEQZ) == MATCH_C_BEQZ)
						insn = MATCH_BEQ|(rs1 << OP_SH_RS1);
					else
						if ((insn & MASK_C_BNEZ) == MATCH_C_BNEZ)
							insn = MATCH_BNE|(rs1 << OP_SH_RS1);
						else
							abort();
			bfd_putl32(insn,buf);
			break;

		case 6:
			/* Invert the branch condition.  Branch over the jump.  */
			insn = bfd_getl16(buf);
			insn ^= MATCH_C_BEQZ ^ MATCH_C_BNEZ;
			insn |= ENCODE_CBTYPE_IMM(6);
			bfd_putl16(insn,buf);
			buf += 2;
			goto jump;

		case 2:
			/* Just keep the RVC branch.  */
			reloc = RELAX_BRANCH_UNCOND(fragp->fr_subtype)
				? BFD_RELOC_RISCV_RVC_JUMP : BFD_RELOC_RISCV_RVC_BRANCH;
			fixp = fix_new_exp(fragp,buf - (uint8_t *) fragp->fr_literal,
					   2,&exp,false,reloc);
			buf += 2;
			goto done;

		default:
			abort();
		}
	}
	switch (RELAX_BRANCH_LENGTH(fragp->fr_subtype)) {
	case 8:
		gas_assert(!RELAX_BRANCH_UNCOND(fragp->fr_subtype));

		/* Invert the branch condition.  Branch over the jump.  */
		insn = bfd_getl32(buf);
		insn ^= MATCH_BEQ ^ MATCH_BNE;
		insn |= ENCODE_BTYPE_IMM(8);
		bfd_putl32(insn,buf);
		buf += 4;

jump:
		/* Jump to the target.  */
		fixp = fix_new_exp(fragp,buf - (uint8_t *) fragp->fr_literal,
				   4,&exp,false,BFD_RELOC_RISCV_JMP);
		bfd_putl32(MATCH_JAL,buf);
		buf += 4;
		break;

	case 4:
		reloc = RELAX_BRANCH_UNCOND(fragp->fr_subtype)
			? BFD_RELOC_RISCV_JMP : BFD_RELOC_12_PCREL;
		fixp = fix_new_exp(fragp,buf - (uint8_t *) fragp->fr_literal,
				   4,&exp,false,reloc);
		buf += 4;
		break;

	default:
		abort();
	}

done:
	fixp->fx_file = fragp->fr_file;
	fixp->fx_line = fragp->fr_line;

	gas_assert(buf == (uint8_t *) fragp->fr_literal
		   + fragp->fr_fix + fragp->fr_var);

	fragp->fr_fix += fragp->fr_var;
}

/*
 * Relax a machine dependent frag.  This returns the amount by which the
 * current size of the frag should change.
 */

void		md_convert_frag(bfd * abfd ATTRIBUTE_UNUSED,segT asec ATTRIBUTE_UNUSED,
		      		fragS *	fragp)
{
	gas_assert(RELAX_BRANCH_P(fragp->fr_subtype));
	md_convert_frag_branch(fragp);
}


/* Standard calling conventions leave the CFA at SP on entry.  */

void		riscv_cfi_frame_initial_instructions(void)
{
	cfi_add_CFA_def_cfa_register(X_SP);
}

int		tc_riscv_regname_to_dw2regnum(char *regname)
{
	int		reg;

	if ((reg = reg_lookup_internal(regname,RCLASS_GPR)) >= 0)
		return reg;

	if ((reg = reg_lookup_internal(regname,RCLASS_FPR)) >= 0)
		return reg + 32;

	if ((reg = reg_lookup_internal(regname,RCLASS_VECR)) >= 0)
		return reg + 96;

	/* CSRs are numbered 4096 -> 8191.  */
	if ((reg = reg_lookup_internal(regname,RCLASS_CSR)) >= 0)
		return reg + 4096;

	as_bad(("unknown register `%s'"),regname);
	return -1;
}

void		riscv_elf_final_processing(void)
{
	riscv_set_abi_by_arch();
	riscv_release_subset_list(riscv_rps_as.subset_list);
	elf_elfheader(stdoutput)->e_flags |= elf_flags;
}

/*
 * Parse the .sleb128 and .uleb128 pseudos.  Only allow constant expressions,
 * since these directives break relaxation when used with symbol deltas.
 */

static void	s_riscv_leb128(int sign)
{
	expressionS	exp;
	char           *save_in = input_line_pointer;

	expression(&exp);
	if (sign && exp.X_op != O_constant)
		as_bad(("non-constant .sleb128 is not supported"));
	else
		if (!sign && exp.X_op != O_constant && exp.X_op != O_subtract)
			as_bad((".uleb128 only supports constant or subtract expressions"));

	demand_empty_rest_of_line();

	input_line_pointer = save_in;
	return s_leb128(sign);
}

/* Parse the .insn directive.  There are three formats,Format 1: .insn <type>
 * <operand1>,<operand2>,... Format 2: .insn <length>,<value> Format 3:
 * .insn <value>. */
static void	s_riscv_insn(int x ATTRIBUTE_UNUSED)
{
	char           *str = input_line_pointer;
	struct riscv_cl_insn insn;
	expressionS	imm_expr;
	bfd_reloc_code_real_type imm_reloc = BFD_RELOC_UNUSED;
	char		save_c;

	while (!is_end_of_line[(unsigned char)*input_line_pointer])
		++input_line_pointer;

	save_c = *input_line_pointer;
	*input_line_pointer = '\0';

	riscv_mapping_state(MAP_INSN,0,false /* fr_align_code */ );

	struct riscv_ip_error error = riscv_ip(str,&insn,&imm_expr,
					       &imm_reloc,insn_type_hash);
	if (error.msg) {
		char           *save_in = input_line_pointer;
		error.msg = riscv_ip_hardcode(str,&insn,&imm_expr,error.msg);
		input_line_pointer = save_in;
	}
	if (error.msg) {
		if (error.missing_ext)
			as_bad("%s `%s',extension `%s' required",error.msg,error.statement,
			       error.missing_ext);
		else
			as_bad("%s `%s'",error.msg,error.statement);
	} else {
		gas_assert(insn.insn_mo->pinfo != INSN_MACRO);
		append_insn(&insn,&imm_expr,imm_reloc);
	}

	*input_line_pointer = save_c;
	demand_empty_rest_of_line();
}

/*
 * Update architecture and privileged elf attributes.  If we don't set them,
 * then try to output the default ones.
 */

static void	riscv_write_out_attrs(void)
{
	const char     *arch_str,*priv_str,*p;
	/*
	 * versions[0]: major version. versions[1]: minor version. versions[2]:
	 * revision version.
	 */
	unsigned	versions[3] = {0},number = 0;
	unsigned int	i;

	/* Re-write architecture elf attribute.  */
	arch_str = riscv_rps_as.subset_list->arch_str;
	bfd_elf_add_proc_attr_string(stdoutput,Tag_RISCV_arch,arch_str);

	/*
	 * For the file without any instruction,we don't set the
	 * default_priv_spec according to the privileged elf attributes since
	 * the md_assemble isn't called.
	 */
	if (!start_assemble
	    && !riscv_set_default_priv_spec(NULL))
		return;

	/*
	 * If we already have set privileged elf attributes,then no need to do
	 * anything.  Otherwise,don't generate or update them when no CSR and
	 * privileged instructions are used.
	 */
	if (!explicit_priv_attr)
		return;

	RISCV_GET_PRIV_SPEC_NAME(priv_str,default_priv_spec);
	p = priv_str;
	for (i = 0; *p; ++p) {
		if (*p == '.' && i < 3) {
			versions[i++] = number;
			number = 0;
		} else
			if (ISDIGIT(*p))
				number = (number * 10) + (*p - '0');
			else {
				as_bad(("internal: bad RISC-V privileged spec (%s)"),priv_str);
				return;
			}
	}
	versions[i] = number;

	/* Re-write privileged elf attributes.  */
	bfd_elf_add_proc_attr_int(stdoutput,Tag_RISCV_priv_spec,versions[0]);
	bfd_elf_add_proc_attr_int(stdoutput,Tag_RISCV_priv_spec_minor,versions[1]);
	bfd_elf_add_proc_attr_int(stdoutput,Tag_RISCV_priv_spec_revision,versions[2]);
}

/* Add the default contents for the .riscv.attributes section.  */

static void	riscv_set_public_attributes(void)
{
	if (riscv_opts.arch_attr || explicit_attr)
		riscv_write_out_attrs();
}

/*
 * Scan uleb128 subtraction expressions and insert fixups for them. e.g.,
 * .uleb128 .L1 - .L0 Because relaxation may change the value of the
 * subtraction,we must resolve them at link-time.
 */

static void	riscv_insert_uleb128_fixes(asection * sec,void *xxx ATTRIBUTE_UNUSED)
{
	segment_info_type *seginfo = seg_info(sec);
	struct frag    *fragP;

	subseg_set(sec,0);

	for (fragP = seginfo->frchainP->frch_root;
	     fragP; fragP = fragP->fr_next) {
		expressionS    *exp,*exp_dup;

		if (fragP->fr_type != rs_leb128 || fragP->fr_symbol == NULL)
			continue;

		exp = symbol_get_value_expression(fragP->fr_symbol);

		if (exp->X_op != O_subtract)
			continue;

		/* Only unsigned leb128 can be handled.  */
		gas_assert(fragP->fr_subtype == 0);
		exp_dup = xmemdup(exp,sizeof(*exp),sizeof(*exp));
		exp_dup->X_op = O_symbol;
		exp_dup->X_op_symbol = NULL;

		/*
		 * Insert relocations to resolve the subtraction at link-time.
		 * Emit the SET relocation first in riscv.
		 */
		exp_dup->X_add_symbol = exp->X_add_symbol;
		fix_new_exp(fragP,fragP->fr_fix,0,
			    exp_dup,0,BFD_RELOC_RISCV_SET_ULEB128);
		exp_dup->X_add_symbol = exp->X_op_symbol;
		fix_new_exp(fragP,fragP->fr_fix,0,
			    exp_dup,0,BFD_RELOC_RISCV_SUB_ULEB128);
	}
}

/* Called after all assembly has been done.  */
static void	riscv_md_finish(void)
{
	riscv_set_public_attributes();
	if (riscv_opts.relax)
		map_over_sections(riscv_insert_uleb128_fixes,NULL);
}

/* Adjust the symbol table.  */
static void	riscv_adjust_symtab(void)
{
	map_over_sections(riscv_check_mapping_symbols,(char *)0);
	elf_adjust_symtab();
}

/*
 * Given a symbolic attribute NAME,return the proper integer value. Returns -1
 * if the attribute is not known.
 */
static int	riscv_convert_symbolic_attribute(const char *name)
{
	static const struct {
		const char     *name;
		const int	tag;
	}
			attribute_table[] =
	{
		/*
		 * When you modify this table you should also modify the list
		 * in doc/c-riscv.texi.
		 */
#define T(tag) {#tag,Tag_RISCV_##tag},{"Tag_RISCV_" #tag,Tag_RISCV_##tag}
		T(arch),
		T(priv_spec),
		T(priv_spec_minor),
		T(priv_spec_revision),
		T(unaligned_access),
		T(stack_align),
#undef T
	};

	if (name == NULL)
		return -1;

	unsigned int	i;
	for (i = 0; i < ARRAY_SIZE(attribute_table); i++)
		if (strcmp(name,attribute_table[i].name) == 0)
			return attribute_table[i].tag;

	return -1;
}

/* Parse a .attribute directive.  */
static void	s_riscv_attribute(int ignored ATTRIBUTE_UNUSED)
{
	as_fatal("could not set architecture and machine");
}

/* Mark symbol that it follows a variant CC convention.  */
static void	s_variant_cc(int ignored ATTRIBUTE_UNUSED)
{
	char           *name;
	char		c;
	symbolS        *sym;
	asymbol        *bfdsym;
	elf_symbol_type *elfsym;

	c = get_symbol_name(&name);
	if (!*name)
		as_bad(("missing symbol name for .variant_cc directive"));
	sym = symbol_find_or_make(name);
	restore_line_pointer(c);
	demand_empty_rest_of_line();

	bfdsym = symbol_get_bfdsym(sym);
	elfsym = elf_symbol_from(bfdsym);
	gas_assert(elfsym);
	elfsym->internal_elf_sym.st_other |= STO_RISCV_VARIANT_CC;
}

/*
 * Same as elf_copy_symbol_attributes,but without copying st_other. This is
 * needed so RISC-V specific st_other values can be independently specified for
 * an IFUNC resolver (that is called by the dynamic linker) and the symbol it
 * resolves (aliased to the resolver).  In particular,if a function symbol has
 * special st_other value set via directives,then attaching an IFUNC resolver
 * to that symbol should not override the st_other setting.  Requiring the
 * directive on the IFUNC resolver symbol would be unexpected and problematic
 * in C code,where the two symbols appear as two independent function
 * declarations.
 */

void		riscv_elf_copy_symbol_attributes(symbolS * dest,symbolS * src)
{
	struct elf_obj_sy *srcelf = symbol_get_obj(src);
	struct elf_obj_sy *destelf = symbol_get_obj(dest);
	/*
	 * If size is unset,copy size from src.  Because we don't track
	 * whether .size has been used,we can't differentiate .size dest,0
	 * from the case where dest's size is unset.
	 */
	if (!destelf->size && S_GET_SIZE(dest) == 0) {
		if (srcelf->size) {
			destelf->size = XNEW(expressionS);
			*destelf->size = *srcelf->size;
		}
		S_SET_SIZE(dest,S_GET_SIZE(src));
	}
}

/* ============================================================**** riscv-opc.c */
/* RISC-V opcode list */

/* Register names used by gas and objdump.  */

static const char *const riscv_gpr_names_numeric[NGPR] =
{
	"x0","x1","x2","x3","x4","x5","x6","x7",
	"x8","x9","x10","x11","x12","x13","x14","x15",
	"x16","x17","x18","x19","x20","x21","x22","x23",
	"x24","x25","x26","x27","x28","x29","x30","x31"
};

static const char *const riscv_gpr_names_abi[NGPR] =
{
	"zero","ra","sp","gp","tp","t0","t1","t2",
	"s0","s1","a0","a1","a2","a3","a4","a5",
	"a6","a7","s2","s3","s4","s5","s6","s7",
	"s8","s9","s10","s11","t3","t4","t5","t6"
};

static const char *const riscv_fpr_names_numeric[NFPR] =
{
	"f0","f1","f2","f3","f4","f5","f6","f7",
	"f8","f9","f10","f11","f12","f13","f14","f15",
	"f16","f17","f18","f19","f20","f21","f22","f23",
	"f24","f25","f26","f27","f28","f29","f30","f31"
};

static const char *const riscv_fpr_names_abi[NFPR] =
{
	"ft0","ft1","ft2","ft3","ft4","ft5","ft6","ft7",
	"fs0","fs1","fa0","fa1","fa2","fa3","fa4","fa5",
	"fa6","fa7","fs2","fs3","fs4","fs5","fs6","fs7",
	"fs8","fs9","fs10","fs11","ft8","ft9","ft10","ft11"
};

/* Rounding modes.  */
static const char *const riscv_rm[8] =
{
	"rne","rtz","rdn","rup","rmm",0,0,"dyn"
};

/* FENCE: predecessor/successor sets.  */
static const char *const riscv_pred_succ[16] =
{
	0,"w","r","rw","o","ow","or","orw",
	"i","iw","ir","irw","io","iow","ior","iorw"
};

/* RVV registers.  */
static const char *const riscv_vecr_names_numeric[NVECR] =
{
	"v0","v1","v2","v3","v4","v5","v6","v7",
	"v8","v9","v10","v11","v12","v13","v14","v15",
	"v16","v17","v18","v19","v20","v21","v22","v23",
	"v24","v25","v26","v27","v28","v29","v30","v31"
};

/* RVV mask registers.  */
static const char *const riscv_vecm_names_numeric[NVECM] =
{
	"v0.t"
};

/* The vsetvli vsew constants.  */
static const char *const riscv_vsew[8] =
{
	"e8","e16","e32","e64",NULL,NULL,NULL,NULL
};

/* The vsetvli vlmul constants.  */
static const char *const riscv_vlmul[8] =
{
	"m1","m2","m4","m8",NULL,"mf8","mf4","mf2"
};

/* The vsetvli vta constants.  */
static const char *const riscv_vta[2] =
{
	"tu","ta"
};

/* The vsetvli vma constants.  */
static const char *const riscv_vma[2] =
{
	"mu","ma"
};

/*
 * The order of overloaded instructions matters.  Label arguments and register
 * arguments look the same. Instructions that can have either for arguments
 * must apear in the correct order in this table for the assembler to pick the
 * right one. In other words,entries with immediate operands must apear after
 * the same instruction with registers.
 * 
 * Because of the lookup algorithm used,entries with the same opcode name must be
 * contiguous.
 */

#define MASK_RS1 (OP_MASK_RS1 << OP_SH_RS1)
#define MASK_RS2 (OP_MASK_RS2 << OP_SH_RS2)
#define MASK_RD (OP_MASK_RD << OP_SH_RD)
#define MASK_CRS2 (OP_MASK_CRS2 << OP_SH_CRS2)
#define MASK_IMM ENCODE_ITYPE_IMM (-1U)
#define MASK_RVC_IMM ENCODE_CITYPE_IMM (-1U)
#define MASK_UIMM ENCODE_UTYPE_IMM (-1U)
#define MASK_RM (OP_MASK_RM << OP_SH_RM)
#define MASK_PRED (OP_MASK_PRED << OP_SH_PRED)
#define MASK_SUCC (OP_MASK_SUCC << OP_SH_SUCC)
#define MASK_AQ (OP_MASK_AQ << OP_SH_AQ)
#define MASK_RL (OP_MASK_RL << OP_SH_RL)
#define MASK_AQRL (MASK_AQ|MASK_RL)
#define MASK_SHAMT (OP_MASK_SHAMT << OP_SH_SHAMT)
#define MATCH_SHAMT_REV8_32 (0b11000 << OP_SH_SHAMT)
#define MATCH_SHAMT_REV8_64 (0b111000 << OP_SH_SHAMT)
#define MATCH_SHAMT_BREV8 (0b00111 << OP_SH_SHAMT)
#define MATCH_SHAMT_ZIP_32 (0b1111 << OP_SH_SHAMT)
#define MATCH_SHAMT_ORC_B (0b00111 << OP_SH_SHAMT)
#define MASK_VD (OP_MASK_VD << OP_SH_VD)
#define MASK_VS1 (OP_MASK_VS1 << OP_SH_VS1)
#define MASK_VS2 (OP_MASK_VS2 << OP_SH_VS2)
#define MASK_VMASK (OP_MASK_VMASK << OP_SH_VMASK)

static int	match_opcode(const struct riscv_opcode *op,insn_t insn)
{
	return ((insn ^ op->match) & op->mask) == 0;
}

static int	match_never(const struct riscv_opcode *op ATTRIBUTE_UNUSED,
		       		insn_t	insn	ATTRIBUTE_UNUSED)
{
	return 0;
}

static int	match_rs1_eq_rs2(const struct riscv_opcode *op,insn_t insn)
{
	int		rs1 = (insn & MASK_RS1) >> OP_SH_RS1;
	int		rs2 = (insn & MASK_RS2) >> OP_SH_RS2;
	return match_opcode(op,insn) && rs1 == rs2;
}

static int	match_rd_nonzero(const struct riscv_opcode *op,insn_t insn)
{
	return match_opcode(op,insn) && ((insn & MASK_RD) != 0);
}

static int	match_c_add(const struct riscv_opcode *op,insn_t insn)
{
	return match_rd_nonzero(op,insn) && ((insn & MASK_CRS2) != 0);
}

/*
 * We don't allow mv zero,X to become a c.mv hint,so we need a separate
 * matching function for this.
 */
static int	match_c_add_with_hint(const struct riscv_opcode *op,insn_t insn)
{
	return match_opcode(op,insn) && ((insn & MASK_CRS2) != 0);
}

static int	match_c_nop(const struct riscv_opcode *op,insn_t insn)
{
	return (match_opcode(op,insn)
		&& (((insn & MASK_RD) >> OP_SH_RD) == 0));
}

static int	match_c_addi16sp(const struct riscv_opcode *op,insn_t insn)
{
	return (match_opcode(op,insn)
		&& (((insn & MASK_RD) >> OP_SH_RD) == 2));
}

static int	match_c_lui(const struct riscv_opcode *op,insn_t insn)
{
	return (match_rd_nonzero(op,insn)
		&& (((insn & MASK_RD) >> OP_SH_RD) != 2)
		&& EXTRACT_CITYPE_LUI_IMM(insn) != 0);
}

/*
 * We don't allow lui zero,X to become a c.lui hint,so we need a separate
 * matching function for this.
 */
static int	match_c_lui_with_hint(const struct riscv_opcode *op,insn_t insn)
{
	return (match_opcode(op,insn)
		&& (((insn & MASK_RD) >> OP_SH_RD) != 2)
		&& EXTRACT_CITYPE_LUI_IMM(insn) != 0);
}

static int	match_c_addi4spn(const struct riscv_opcode *op,insn_t insn)
{
	return match_opcode(op,insn) && EXTRACT_CIWTYPE_ADDI4SPN_IMM(insn) != 0;
}

/* This requires a non-zero shift.  A zero rd is a hint,so is allowed.  */
static int	match_c_slli(const struct riscv_opcode *op,insn_t insn)
{
	return match_opcode(op,insn) && EXTRACT_CITYPE_IMM(insn) != 0;
}

/* This requires a non-zero rd,and a non-zero shift.  */
static int	match_slli_as_c_slli(const struct riscv_opcode *op,insn_t insn)
{
	return match_rd_nonzero(op,insn) && EXTRACT_CITYPE_IMM(insn) != 0;
}

/* This requires a zero shift.  A zero rd is a hint,so is allowed.  */
static int	match_c_slli64(const struct riscv_opcode *op,insn_t insn)
{
	return match_opcode(op,insn) && EXTRACT_CITYPE_IMM(insn) == 0;
}

/*
 * This is used for both srli and srai.  This requires a non-zero shift. A zero
 * rd is not possible.
 */
static int	match_srxi_as_c_srxi(const struct riscv_opcode *op,insn_t insn)
{
	return match_opcode(op,insn) && EXTRACT_CITYPE_IMM(insn) != 0;
}

static int	match_vs1_eq_vs2(const struct riscv_opcode *op,
			    		insn_t	insn)
{
	int		vs1 = (insn & MASK_VS1) >> OP_SH_VS1;
	int		vs2 = (insn & MASK_VS2) >> OP_SH_VS2;

	return match_opcode(op,insn) && vs1 == vs2;
}

static int	match_vd_eq_vs1_eq_vs2(const struct riscv_opcode *op,
				  		insn_t	insn)
{
	int		vd = (insn & MASK_VD) >> OP_SH_VD;
	int		vs1 = (insn & MASK_VS1) >> OP_SH_VS1;
	int		vs2 = (insn & MASK_VS2) >> OP_SH_VS2;

	return match_opcode(op,insn) && vd == vs1 && vs1 == vs2;
}

static int	match_th_load_inc(const struct riscv_opcode *op,
			     		insn_t	insn)
{
	/*
	 * Load-increment has the following restriction: The values of rd and
	 * rs1 must not be the same.
	 */
	int		rd = (insn & MASK_RD) >> OP_SH_RD;
	int		rs1 = (insn & MASK_RS1) >> OP_SH_RS1;

	return rd != rs1 && match_opcode(op,insn);
}

static int	match_th_load_pair(const struct riscv_opcode *op,
			      		insn_t	insn)
{
	/*
	 * Load pair instructions use the following encoding: - rd1 = RD
	 * (insn[11:7]) - rd2 = RS2 (insn[24:20]) - rs = RS1 ([19:15]) This
	 * function matches if the following restriction is met: The values of
	 * rd1,rd2,and rs1 must not be the same.
	 */
	int		rd1 = (insn & MASK_RD) >> OP_SH_RD;
	int		rd2 = (insn & MASK_RS2) >> OP_SH_RS2;
	int		rs = (insn & MASK_RS1) >> OP_SH_RS1;

	return rd1 != rd2 && rd1 != rs && rd2 != rs && match_opcode(op,insn);
}

static const struct riscv_opcode riscv_opcodes[] =
{
	/* name,xlen,isa,operands,match,mask,match_func,pinfo.  */

	/* Standard hints.  */
	{"prefetch.i",0,INSN_CLASS_ZICBOP,"Wif(s)",MATCH_PREFETCH_I,MASK_PREFETCH_I,match_opcode,0},
	{"prefetch.r",0,INSN_CLASS_ZICBOP,"Wif(s)",MATCH_PREFETCH_R,MASK_PREFETCH_R,match_opcode,0},
	{"prefetch.w",0,INSN_CLASS_ZICBOP,"Wif(s)",MATCH_PREFETCH_W,MASK_PREFETCH_W,match_opcode,0},
	{"pause",0,INSN_CLASS_ZIHINTPAUSE,"",MATCH_PAUSE,MASK_PAUSE,match_opcode,0},

	/* Basic RVI instructions and aliases.  */
	{"unimp",0,INSN_CLASS_C,"",0,0xffffU,match_opcode,INSN_ALIAS},
	{"unimp",0,INSN_CLASS_I,"",MATCH_CSRRW|(CSR_CYCLE << OP_SH_CSR),0xffffffffU,match_opcode,0},	/* csrw cycle,x0  */
	{"ebreak",0,INSN_CLASS_C,"",MATCH_C_EBREAK,MASK_C_EBREAK,match_opcode,INSN_ALIAS},
	{"ebreak",0,INSN_CLASS_I,"",MATCH_EBREAK,MASK_EBREAK,match_opcode,0},
	{"sbreak",0,INSN_CLASS_C,"",MATCH_C_EBREAK,MASK_C_EBREAK,match_opcode,INSN_ALIAS},
	{"sbreak",0,INSN_CLASS_I,"",MATCH_EBREAK,MASK_EBREAK,match_opcode,INSN_ALIAS},
	{"ret",0,INSN_CLASS_C,"",MATCH_C_JR|(X_RA << OP_SH_RD),MASK_C_JR|MASK_RD,match_opcode,INSN_ALIAS|INSN_BRANCH},
	{"ret",0,INSN_CLASS_I,"",MATCH_JALR|(X_RA << OP_SH_RS1),MASK_JALR|MASK_RD|MASK_RS1|MASK_IMM,match_opcode,INSN_ALIAS|INSN_BRANCH},
	{"jr",0,INSN_CLASS_C,"d",MATCH_C_JR,MASK_C_JR,match_rd_nonzero,INSN_ALIAS|INSN_BRANCH},
	{"jr",0,INSN_CLASS_I,"s",MATCH_JALR,MASK_JALR|MASK_RD|MASK_IMM,match_opcode,INSN_ALIAS|INSN_BRANCH},
	{"jr",0,INSN_CLASS_I,"o(s)",MATCH_JALR,MASK_JALR|MASK_RD,match_opcode,INSN_ALIAS|INSN_BRANCH},
	{"jr",0,INSN_CLASS_I,"s,j",MATCH_JALR,MASK_JALR|MASK_RD,match_opcode,INSN_ALIAS|INSN_BRANCH},
	{"jalr",0,INSN_CLASS_C,"d",MATCH_C_JALR,MASK_C_JALR,match_rd_nonzero,INSN_ALIAS|INSN_JSR},
	{"jalr",0,INSN_CLASS_I,"s",MATCH_JALR|(X_RA << OP_SH_RD),MASK_JALR|MASK_RD|MASK_IMM,match_opcode,INSN_ALIAS|INSN_JSR},
	{"jalr",0,INSN_CLASS_I,"o(s)",MATCH_JALR|(X_RA << OP_SH_RD),MASK_JALR|MASK_RD,match_opcode,INSN_ALIAS|INSN_JSR},
	{"jalr",0,INSN_CLASS_I,"s,j",MATCH_JALR|(X_RA << OP_SH_RD),MASK_JALR|MASK_RD,match_opcode,INSN_ALIAS|INSN_JSR},
	{"jalr",0,INSN_CLASS_I,"d,s",MATCH_JALR,MASK_JALR|MASK_IMM,match_opcode,INSN_ALIAS|INSN_JSR},
	{"jalr",0,INSN_CLASS_I,"d,o(s)",MATCH_JALR,MASK_JALR,match_opcode,INSN_JSR},
	{"jalr",0,INSN_CLASS_I,"d,s,j",MATCH_JALR,MASK_JALR,match_opcode,INSN_JSR},
	{"j",0,INSN_CLASS_C,"Ca",MATCH_C_J,MASK_C_J,match_opcode,INSN_ALIAS|INSN_BRANCH},
	{"j",0,INSN_CLASS_I,"a",MATCH_JAL,MASK_JAL|MASK_RD,match_opcode,INSN_ALIAS|INSN_BRANCH},
	{"jal",32,INSN_CLASS_C,"Ca",MATCH_C_JAL,MASK_C_JAL,match_opcode,INSN_ALIAS|INSN_JSR},
	{"jal",0,INSN_CLASS_I,"a",MATCH_JAL|(X_RA << OP_SH_RD),MASK_JAL|MASK_RD,match_opcode,INSN_ALIAS|INSN_JSR},
	{"jal",0,INSN_CLASS_I,"d,a",MATCH_JAL,MASK_JAL,match_opcode,INSN_JSR},
	{"call",0,INSN_CLASS_I,"d,c",(X_T1 << OP_SH_RS1),(int)M_CALL,match_never,INSN_MACRO},
	{"call",0,INSN_CLASS_I,"c",(X_RA << OP_SH_RS1)|(X_RA << OP_SH_RD),(int)M_CALL,match_never,INSN_MACRO},
	{"tail",0,INSN_CLASS_I,"c",(X_T1 << OP_SH_RS1),(int)M_CALL,match_never,INSN_MACRO},
	{"jump",0,INSN_CLASS_I,"c,s",0,(int)M_CALL,match_never,INSN_MACRO},
	{"nop",0,INSN_CLASS_C,"",MATCH_C_ADDI,0xffff,match_opcode,INSN_ALIAS},
	{"nop",0,INSN_CLASS_I,"",MATCH_ADDI,MASK_ADDI|MASK_RD|MASK_RS1|MASK_IMM,match_opcode,INSN_ALIAS},
	{"lui",0,INSN_CLASS_C,"d,Cu",MATCH_C_LUI,MASK_C_LUI,match_c_lui,INSN_ALIAS},
	{"lui",0,INSN_CLASS_I,"d,u",MATCH_LUI,MASK_LUI,match_opcode,0},
	{"li",0,INSN_CLASS_C,"d,Cv",MATCH_C_LUI,MASK_C_LUI,match_c_lui,INSN_ALIAS},
	{"li",0,INSN_CLASS_C,"d,Co",MATCH_C_LI,MASK_C_LI,match_rd_nonzero,INSN_ALIAS},
	{"li",0,INSN_CLASS_I,"d,j",MATCH_ADDI,MASK_ADDI|MASK_RS1,match_opcode,INSN_ALIAS},	/* addi  */
	{"li",0,INSN_CLASS_I,"d,I",0,(int)M_LI,match_never,INSN_MACRO},
	{"mv",0,INSN_CLASS_C,"d,CV",MATCH_C_MV,MASK_C_MV,match_c_add,INSN_ALIAS},
	{"mv",0,INSN_CLASS_I,"d,s",MATCH_ADDI,MASK_ADDI|MASK_IMM,match_opcode,INSN_ALIAS},
	{"move",0,INSN_CLASS_C,"d,CV",MATCH_C_MV,MASK_C_MV,match_c_add,INSN_ALIAS},
	{"move",0,INSN_CLASS_I,"d,s",MATCH_ADDI,MASK_ADDI|MASK_IMM,match_opcode,INSN_ALIAS},
	{"zext.b",0,INSN_CLASS_I,"d,s",MATCH_ANDI|ENCODE_ITYPE_IMM(255),MASK_ANDI|MASK_IMM,match_opcode,INSN_ALIAS},
	{"and",0,INSN_CLASS_C,"Cs,Cw,Ct",MATCH_C_AND,MASK_C_AND,match_opcode,INSN_ALIAS},
	{"and",0,INSN_CLASS_C,"Cs,Ct,Cw",MATCH_C_AND,MASK_C_AND,match_opcode,INSN_ALIAS},
	{"and",0,INSN_CLASS_C,"Cs,Cw,Co",MATCH_C_ANDI,MASK_C_ANDI,match_opcode,INSN_ALIAS},
	{"and",0,INSN_CLASS_I,"d,s,t",MATCH_AND,MASK_AND,match_opcode,0},
	{"and",0,INSN_CLASS_I,"d,s,j",MATCH_ANDI,MASK_ANDI,match_opcode,INSN_ALIAS},
	{"andi",0,INSN_CLASS_C,"Cs,Cw,Co",MATCH_C_ANDI,MASK_C_ANDI,match_opcode,INSN_ALIAS},
	{"andi",0,INSN_CLASS_I,"d,s,j",MATCH_ANDI,MASK_ANDI,match_opcode,0},
	{"beqz",0,INSN_CLASS_C,"Cs,Cp",MATCH_C_BEQZ,MASK_C_BEQZ,match_opcode,INSN_ALIAS|INSN_CONDBRANCH},
	{"beqz",0,INSN_CLASS_I,"s,p",MATCH_BEQ,MASK_BEQ|MASK_RS2,match_opcode,INSN_ALIAS|INSN_CONDBRANCH},
	{"beq",0,INSN_CLASS_C,"Cs,Cz,Cp",MATCH_C_BEQZ,MASK_C_BEQZ,match_opcode,INSN_ALIAS|INSN_CONDBRANCH},
	{"beq",0,INSN_CLASS_I,"s,t,p",MATCH_BEQ,MASK_BEQ,match_opcode,INSN_CONDBRANCH},
	{"blez",0,INSN_CLASS_I,"t,p",MATCH_BGE,MASK_BGE|MASK_RS1,match_opcode,INSN_ALIAS|INSN_CONDBRANCH},
	{"bgez",0,INSN_CLASS_I,"s,p",MATCH_BGE,MASK_BGE|MASK_RS2,match_opcode,INSN_ALIAS|INSN_CONDBRANCH},
	{"bge",0,INSN_CLASS_I,"s,t,p",MATCH_BGE,MASK_BGE,match_opcode,INSN_CONDBRANCH},
	{"bgeu",0,INSN_CLASS_I,"s,t,p",MATCH_BGEU,MASK_BGEU,match_opcode,INSN_CONDBRANCH},
	{"ble",0,INSN_CLASS_I,"t,s,p",MATCH_BGE,MASK_BGE,match_opcode,INSN_ALIAS|INSN_CONDBRANCH},
	{"bleu",0,INSN_CLASS_I,"t,s,p",MATCH_BGEU,MASK_BGEU,match_opcode,INSN_ALIAS|INSN_CONDBRANCH},
	{"bltz",0,INSN_CLASS_I,"s,p",MATCH_BLT,MASK_BLT|MASK_RS2,match_opcode,INSN_ALIAS|INSN_CONDBRANCH},
	{"bgtz",0,INSN_CLASS_I,"t,p",MATCH_BLT,MASK_BLT|MASK_RS1,match_opcode,INSN_ALIAS|INSN_CONDBRANCH},
	{"blt",0,INSN_CLASS_I,"s,t,p",MATCH_BLT,MASK_BLT,match_opcode,INSN_CONDBRANCH},
	{"bltu",0,INSN_CLASS_I,"s,t,p",MATCH_BLTU,MASK_BLTU,match_opcode,INSN_CONDBRANCH},
	{"bgt",0,INSN_CLASS_I,"t,s,p",MATCH_BLT,MASK_BLT,match_opcode,INSN_ALIAS|INSN_CONDBRANCH},
	{"bgtu",0,INSN_CLASS_I,"t,s,p",MATCH_BLTU,MASK_BLTU,match_opcode,INSN_ALIAS|INSN_CONDBRANCH},
	{"bnez",0,INSN_CLASS_C,"Cs,Cp",MATCH_C_BNEZ,MASK_C_BNEZ,match_opcode,INSN_ALIAS|INSN_CONDBRANCH},
	{"bnez",0,INSN_CLASS_I,"s,p",MATCH_BNE,MASK_BNE|MASK_RS2,match_opcode,INSN_ALIAS|INSN_CONDBRANCH},
	{"bne",0,INSN_CLASS_C,"Cs,Cz,Cp",MATCH_C_BNEZ,MASK_C_BNEZ,match_opcode,INSN_ALIAS|INSN_CONDBRANCH},
	{"bne",0,INSN_CLASS_I,"s,t,p",MATCH_BNE,MASK_BNE,match_opcode,INSN_CONDBRANCH},
	{"add",0,INSN_CLASS_C,"d,CU,CV",MATCH_C_ADD,MASK_C_ADD,match_c_add,INSN_ALIAS},
	{"add",0,INSN_CLASS_C,"d,CV,CU",MATCH_C_ADD,MASK_C_ADD,match_c_add,INSN_ALIAS},
	{"add",0,INSN_CLASS_C,"d,CU,Co",MATCH_C_ADDI,MASK_C_ADDI,match_rd_nonzero,INSN_ALIAS},
	{"add",0,INSN_CLASS_C,"Ct,Cc,CK",MATCH_C_ADDI4SPN,MASK_C_ADDI4SPN,match_c_addi4spn,INSN_ALIAS},
	{"add",0,INSN_CLASS_C,"Cc,Cc,CL",MATCH_C_ADDI16SP,MASK_C_ADDI16SP,match_c_addi16sp,INSN_ALIAS},
	{"add",0,INSN_CLASS_C,"d,Cz,CV",MATCH_C_MV,MASK_C_MV,match_c_add,INSN_ALIAS},
	{"add",0,INSN_CLASS_I,"d,s,t",MATCH_ADD,MASK_ADD,match_opcode,0},
	{"add",0,INSN_CLASS_I,"d,s,t,1",MATCH_ADD,MASK_ADD,match_opcode,0},
	{"add",0,INSN_CLASS_I,"d,s,j",MATCH_ADDI,MASK_ADDI,match_opcode,INSN_ALIAS},
	{"addi",0,INSN_CLASS_C,"Ct,Cc,CK",MATCH_C_ADDI4SPN,MASK_C_ADDI4SPN,match_c_addi4spn,INSN_ALIAS},
	{"addi",0,INSN_CLASS_C,"d,CU,Cj",MATCH_C_ADDI,MASK_C_ADDI,match_rd_nonzero,INSN_ALIAS},
	{"addi",0,INSN_CLASS_C,"d,CU,z",MATCH_C_NOP,MASK_C_ADDI|MASK_RVC_IMM,match_c_nop,INSN_ALIAS},
	{"addi",0,INSN_CLASS_C,"Cc,Cc,CL",MATCH_C_ADDI16SP,MASK_C_ADDI16SP,match_c_addi16sp,INSN_ALIAS},
	{"addi",0,INSN_CLASS_C,"d,Cz,Co",MATCH_C_LI,MASK_C_LI,match_rd_nonzero,INSN_ALIAS},
	{"addi",0,INSN_CLASS_C,"d,CV,z",MATCH_C_MV,MASK_C_MV,match_c_add,INSN_ALIAS},
	{"addi",0,INSN_CLASS_I,"d,s,j",MATCH_ADDI,MASK_ADDI,match_opcode,0},
	{"la",0,INSN_CLASS_I,"d,B",0,(int)M_LA,match_never,INSN_MACRO},
	{"lla",0,INSN_CLASS_I,"d,B",0,(int)M_LLA,match_never,INSN_MACRO},
	{"la.tls.gd",0,INSN_CLASS_I,"d,A",0,(int)M_LA_TLS_GD,match_never,INSN_MACRO},
	{"la.tls.ie",0,INSN_CLASS_I,"d,A",0,(int)M_LA_TLS_IE,match_never,INSN_MACRO},
	{"neg",0,INSN_CLASS_I,"d,t",MATCH_SUB,MASK_SUB|MASK_RS1,match_opcode,INSN_ALIAS},	/* sub 0  */
	{"sll",0,INSN_CLASS_C,"d,CU,C>",MATCH_C_SLLI,MASK_C_SLLI,match_slli_as_c_slli,INSN_ALIAS},
	{"sll",0,INSN_CLASS_I,"d,s,t",MATCH_SLL,MASK_SLL,match_opcode,0},
	{"sll",0,INSN_CLASS_I,"d,s,>",MATCH_SLLI,MASK_SLLI,match_opcode,INSN_ALIAS},
	{"slli",0,INSN_CLASS_C,"d,CU,C>",MATCH_C_SLLI,MASK_C_SLLI,match_slli_as_c_slli,INSN_ALIAS},
	{"slli",0,INSN_CLASS_I,"d,s,>",MATCH_SLLI,MASK_SLLI,match_opcode,0},
	{"srl",0,INSN_CLASS_C,"Cs,Cw,C>",MATCH_C_SRLI,MASK_C_SRLI,match_srxi_as_c_srxi,INSN_ALIAS},
	{"srl",0,INSN_CLASS_I,"d,s,t",MATCH_SRL,MASK_SRL,match_opcode,0},
	{"srl",0,INSN_CLASS_I,"d,s,>",MATCH_SRLI,MASK_SRLI,match_opcode,INSN_ALIAS},
	{"srli",0,INSN_CLASS_C,"Cs,Cw,C>",MATCH_C_SRLI,MASK_C_SRLI,match_srxi_as_c_srxi,INSN_ALIAS},
	{"srli",0,INSN_CLASS_I,"d,s,>",MATCH_SRLI,MASK_SRLI,match_opcode,0},
	{"sra",0,INSN_CLASS_C,"Cs,Cw,C>",MATCH_C_SRAI,MASK_C_SRAI,match_srxi_as_c_srxi,INSN_ALIAS},
	{"sra",0,INSN_CLASS_I,"d,s,t",MATCH_SRA,MASK_SRA,match_opcode,0},
	{"sra",0,INSN_CLASS_I,"d,s,>",MATCH_SRAI,MASK_SRAI,match_opcode,INSN_ALIAS},
	{"srai",0,INSN_CLASS_C,"Cs,Cw,C>",MATCH_C_SRAI,MASK_C_SRAI,match_srxi_as_c_srxi,INSN_ALIAS},
	{"srai",0,INSN_CLASS_I,"d,s,>",MATCH_SRAI,MASK_SRAI,match_opcode,0},
	{"sub",0,INSN_CLASS_C,"Cs,Cw,Ct",MATCH_C_SUB,MASK_C_SUB,match_opcode,INSN_ALIAS},
	{"sub",0,INSN_CLASS_I,"d,s,t",MATCH_SUB,MASK_SUB,match_opcode,0},
	{"lb",0,INSN_CLASS_I,"d,o(s)",MATCH_LB,MASK_LB,match_opcode,INSN_DREF|INSN_1_BYTE},
	{"lb",0,INSN_CLASS_I,"d,A",0,(int)M_LB,match_never,INSN_MACRO},
	{"lbu",0,INSN_CLASS_I,"d,o(s)",MATCH_LBU,MASK_LBU,match_opcode,INSN_DREF|INSN_1_BYTE},
	{"lbu",0,INSN_CLASS_I,"d,A",0,(int)M_LBU,match_never,INSN_MACRO},
	{"lh",0,INSN_CLASS_I,"d,o(s)",MATCH_LH,MASK_LH,match_opcode,INSN_DREF|INSN_2_BYTE},
	{"lh",0,INSN_CLASS_I,"d,A",0,(int)M_LH,match_never,INSN_MACRO},
	{"lhu",0,INSN_CLASS_I,"d,o(s)",MATCH_LHU,MASK_LHU,match_opcode,INSN_DREF|INSN_2_BYTE},
	{"lhu",0,INSN_CLASS_I,"d,A",0,(int)M_LHU,match_never,INSN_MACRO},
	{"lw",0,INSN_CLASS_C,"d,Cm(Cc)",MATCH_C_LWSP,MASK_C_LWSP,match_rd_nonzero,INSN_ALIAS|INSN_DREF|INSN_4_BYTE},
	{"lw",0,INSN_CLASS_C,"Ct,Ck(Cs)",MATCH_C_LW,MASK_C_LW,match_opcode,INSN_ALIAS|INSN_DREF|INSN_4_BYTE},
	{"lw",0,INSN_CLASS_I,"d,o(s)",MATCH_LW,MASK_LW,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"lw",0,INSN_CLASS_I,"d,A",0,(int)M_LW,match_never,INSN_MACRO},
	{"not",0,INSN_CLASS_I,"d,s",MATCH_XORI|MASK_IMM,MASK_XORI|MASK_IMM,match_opcode,INSN_ALIAS},
	{"or",0,INSN_CLASS_I,"d,s,j",MATCH_ORI,MASK_ORI,match_opcode,INSN_ALIAS},
	{"or",0,INSN_CLASS_C,"Cs,Cw,Ct",MATCH_C_OR,MASK_C_OR,match_opcode,INSN_ALIAS},
	{"or",0,INSN_CLASS_C,"Cs,Ct,Cw",MATCH_C_OR,MASK_C_OR,match_opcode,INSN_ALIAS},
	{"or",0,INSN_CLASS_I,"d,s,t",MATCH_OR,MASK_OR,match_opcode,0},
	{"ori",0,INSN_CLASS_I,"d,s,j",MATCH_ORI,MASK_ORI,match_opcode,0},
	{"auipc",0,INSN_CLASS_I,"d,u",MATCH_AUIPC,MASK_AUIPC,match_opcode,0},
	{"seqz",0,INSN_CLASS_I,"d,s",MATCH_SLTIU|ENCODE_ITYPE_IMM(1),MASK_SLTIU|MASK_IMM,match_opcode,INSN_ALIAS},
	{"snez",0,INSN_CLASS_I,"d,t",MATCH_SLTU,MASK_SLTU|MASK_RS1,match_opcode,INSN_ALIAS},
	{"sltz",0,INSN_CLASS_I,"d,s",MATCH_SLT,MASK_SLT|MASK_RS2,match_opcode,INSN_ALIAS},
	{"sgtz",0,INSN_CLASS_I,"d,t",MATCH_SLT,MASK_SLT|MASK_RS1,match_opcode,INSN_ALIAS},
	{"slti",0,INSN_CLASS_I,"d,s,j",MATCH_SLTI,MASK_SLTI,match_opcode,0},
	{"slt",0,INSN_CLASS_I,"d,s,t",MATCH_SLT,MASK_SLT,match_opcode,0},
	{"slt",0,INSN_CLASS_I,"d,s,j",MATCH_SLTI,MASK_SLTI,match_opcode,INSN_ALIAS},
	{"sltiu",0,INSN_CLASS_I,"d,s,j",MATCH_SLTIU,MASK_SLTIU,match_opcode,0},
	{"sltu",0,INSN_CLASS_I,"d,s,t",MATCH_SLTU,MASK_SLTU,match_opcode,0},
	{"sltu",0,INSN_CLASS_I,"d,s,j",MATCH_SLTIU,MASK_SLTIU,match_opcode,INSN_ALIAS},
	{"sgt",0,INSN_CLASS_I,"d,t,s",MATCH_SLT,MASK_SLT,match_opcode,INSN_ALIAS},
	{"sgtu",0,INSN_CLASS_I,"d,t,s",MATCH_SLTU,MASK_SLTU,match_opcode,INSN_ALIAS},
	{"sb",0,INSN_CLASS_I,"t,q(s)",MATCH_SB,MASK_SB,match_opcode,INSN_DREF|INSN_1_BYTE},
	{"sb",0,INSN_CLASS_I,"t,A,s",0,(int)M_SB,match_never,INSN_MACRO},
	{"sh",0,INSN_CLASS_I,"t,q(s)",MATCH_SH,MASK_SH,match_opcode,INSN_DREF|INSN_2_BYTE},
	{"sh",0,INSN_CLASS_I,"t,A,s",0,(int)M_SH,match_never,INSN_MACRO},
	{"sw",0,INSN_CLASS_C,"CV,CM(Cc)",MATCH_C_SWSP,MASK_C_SWSP,match_opcode,INSN_ALIAS|INSN_DREF|INSN_4_BYTE},
	{"sw",0,INSN_CLASS_C,"Ct,Ck(Cs)",MATCH_C_SW,MASK_C_SW,match_opcode,INSN_ALIAS|INSN_DREF|INSN_4_BYTE},
	{"sw",0,INSN_CLASS_I,"t,q(s)",MATCH_SW,MASK_SW,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"sw",0,INSN_CLASS_I,"t,A,s",0,(int)M_SW,match_never,INSN_MACRO},
	{"fence",0,INSN_CLASS_I,"",MATCH_FENCE|MASK_PRED|MASK_SUCC,MASK_FENCE|MASK_RD|MASK_RS1|MASK_IMM,match_opcode,INSN_ALIAS},
	{"fence",0,INSN_CLASS_I,"P,Q",MATCH_FENCE,MASK_FENCE|MASK_RD|MASK_RS1|(MASK_IMM & ~MASK_PRED & ~MASK_SUCC),match_opcode,0},
	{"fence.i",0,INSN_CLASS_ZIFENCEI,"",MATCH_FENCE_I,MASK_FENCE|MASK_RD|MASK_RS1|MASK_IMM,match_opcode,0},
	{"fence.tso",0,INSN_CLASS_I,"",MATCH_FENCE_TSO,MASK_FENCE_TSO|MASK_RD|MASK_RS1,match_opcode,0},
	{"rdcycle",0,INSN_CLASS_I,"d",MATCH_RDCYCLE,MASK_RDCYCLE,match_opcode,INSN_ALIAS},
	{"rdinstret",0,INSN_CLASS_I,"d",MATCH_RDINSTRET,MASK_RDINSTRET,match_opcode,INSN_ALIAS},
	{"rdtime",0,INSN_CLASS_I,"d",MATCH_RDTIME,MASK_RDTIME,match_opcode,INSN_ALIAS},
	{"rdcycleh",32,INSN_CLASS_I,"d",MATCH_RDCYCLEH,MASK_RDCYCLEH,match_opcode,INSN_ALIAS},
	{"rdinstreth",32,INSN_CLASS_I,"d",MATCH_RDINSTRETH,MASK_RDINSTRETH,match_opcode,INSN_ALIAS},
	{"rdtimeh",32,INSN_CLASS_I,"d",MATCH_RDTIMEH,MASK_RDTIMEH,match_opcode,INSN_ALIAS},
	{"ecall",0,INSN_CLASS_I,"",MATCH_SCALL,MASK_SCALL,match_opcode,0},
	{"scall",0,INSN_CLASS_I,"",MATCH_SCALL,MASK_SCALL,match_opcode,0},
	{"xor",0,INSN_CLASS_I,"d,s,j",MATCH_XORI,MASK_XORI,match_opcode,INSN_ALIAS},
	{"xor",0,INSN_CLASS_C,"Cs,Cw,Ct",MATCH_C_XOR,MASK_C_XOR,match_opcode,INSN_ALIAS},
	{"xor",0,INSN_CLASS_C,"Cs,Ct,Cw",MATCH_C_XOR,MASK_C_XOR,match_opcode,INSN_ALIAS},
	{"xor",0,INSN_CLASS_I,"d,s,t",MATCH_XOR,MASK_XOR,match_opcode,0},
	{"xori",0,INSN_CLASS_I,"d,s,j",MATCH_XORI,MASK_XORI,match_opcode,0},
	{"lwu",64,INSN_CLASS_I,"d,o(s)",MATCH_LWU,MASK_LWU,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"lwu",64,INSN_CLASS_I,"d,A",0,(int)M_LWU,match_never,INSN_MACRO},
	{"ld",64,INSN_CLASS_C,"d,Cn(Cc)",MATCH_C_LDSP,MASK_C_LDSP,match_rd_nonzero,INSN_ALIAS|INSN_DREF|INSN_8_BYTE},
	{"ld",64,INSN_CLASS_C,"Ct,Cl(Cs)",MATCH_C_LD,MASK_C_LD,match_opcode,INSN_ALIAS|INSN_DREF|INSN_8_BYTE},
	{"ld",64,INSN_CLASS_I,"d,o(s)",MATCH_LD,MASK_LD,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"ld",64,INSN_CLASS_I,"d,A",0,(int)M_LD,match_never,INSN_MACRO},
	{"sd",64,INSN_CLASS_C,"CV,CN(Cc)",MATCH_C_SDSP,MASK_C_SDSP,match_opcode,INSN_ALIAS|INSN_DREF|INSN_8_BYTE},
	{"sd",64,INSN_CLASS_C,"Ct,Cl(Cs)",MATCH_C_SD,MASK_C_SD,match_opcode,INSN_ALIAS|INSN_DREF|INSN_8_BYTE},
	{"sd",64,INSN_CLASS_I,"t,q(s)",MATCH_SD,MASK_SD,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"sd",64,INSN_CLASS_I,"t,A,s",0,(int)M_SD,match_never,INSN_MACRO},
	{"sext.w",64,INSN_CLASS_C,"d,CU",MATCH_C_ADDIW,MASK_C_ADDIW|MASK_RVC_IMM,match_rd_nonzero,INSN_ALIAS},
	{"sext.w",64,INSN_CLASS_I,"d,s",MATCH_ADDIW,MASK_ADDIW|MASK_IMM,match_opcode,INSN_ALIAS},
	{"addw",64,INSN_CLASS_C,"Cs,Cw,Ct",MATCH_C_ADDW,MASK_C_ADDW,match_opcode,INSN_ALIAS},
	{"addw",64,INSN_CLASS_C,"Cs,Ct,Cw",MATCH_C_ADDW,MASK_C_ADDW,match_opcode,INSN_ALIAS},
	{"addw",64,INSN_CLASS_C,"d,CU,Co",MATCH_C_ADDIW,MASK_C_ADDIW,match_rd_nonzero,INSN_ALIAS},
	{"addw",64,INSN_CLASS_I,"d,s,t",MATCH_ADDW,MASK_ADDW,match_opcode,0},
	{"addw",64,INSN_CLASS_I,"d,s,j",MATCH_ADDIW,MASK_ADDIW,match_opcode,INSN_ALIAS},
	{"addiw",64,INSN_CLASS_C,"d,CU,Co",MATCH_C_ADDIW,MASK_C_ADDIW,match_rd_nonzero,INSN_ALIAS},
	{"addiw",64,INSN_CLASS_I,"d,s,j",MATCH_ADDIW,MASK_ADDIW,match_opcode,0},
	{"negw",64,INSN_CLASS_I,"d,t",MATCH_SUBW,MASK_SUBW|MASK_RS1,match_opcode,INSN_ALIAS},	/* sub 0  */
	{"sllw",64,INSN_CLASS_I,"d,s,t",MATCH_SLLW,MASK_SLLW,match_opcode,0},
	{"sllw",64,INSN_CLASS_I,"d,s,<",MATCH_SLLIW,MASK_SLLIW,match_opcode,INSN_ALIAS},
	{"slliw",64,INSN_CLASS_I,"d,s,<",MATCH_SLLIW,MASK_SLLIW,match_opcode,0},
	{"srlw",64,INSN_CLASS_I,"d,s,t",MATCH_SRLW,MASK_SRLW,match_opcode,0},
	{"srlw",64,INSN_CLASS_I,"d,s,<",MATCH_SRLIW,MASK_SRLIW,match_opcode,INSN_ALIAS},
	{"srliw",64,INSN_CLASS_I,"d,s,<",MATCH_SRLIW,MASK_SRLIW,match_opcode,0},
	{"sraw",64,INSN_CLASS_I,"d,s,t",MATCH_SRAW,MASK_SRAW,match_opcode,0},
	{"sraw",64,INSN_CLASS_I,"d,s,<",MATCH_SRAIW,MASK_SRAIW,match_opcode,INSN_ALIAS},
	{"sraiw",64,INSN_CLASS_I,"d,s,<",MATCH_SRAIW,MASK_SRAIW,match_opcode,0},
	{"subw",64,INSN_CLASS_C,"Cs,Cw,Ct",MATCH_C_SUBW,MASK_C_SUBW,match_opcode,INSN_ALIAS},
	{"subw",64,INSN_CLASS_I,"d,s,t",MATCH_SUBW,MASK_SUBW,match_opcode,0},

	/* Atomic memory operation instruction subset.  */
	{"lr.w",0,INSN_CLASS_A,"d,0(s)",MATCH_LR_W,MASK_LR_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"sc.w",0,INSN_CLASS_A,"d,t,0(s)",MATCH_SC_W,MASK_SC_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"amoadd.w",0,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOADD_W,MASK_AMOADD_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"amoswap.w",0,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOSWAP_W,MASK_AMOSWAP_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"amoand.w",0,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOAND_W,MASK_AMOAND_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"amoor.w",0,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOOR_W,MASK_AMOOR_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"amoxor.w",0,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOXOR_W,MASK_AMOXOR_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"amomax.w",0,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOMAX_W,MASK_AMOMAX_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"amomaxu.w",0,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOMAXU_W,MASK_AMOMAXU_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"amomin.w",0,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOMIN_W,MASK_AMOMIN_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"amominu.w",0,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOMINU_W,MASK_AMOMINU_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"lr.w.aq",0,INSN_CLASS_A,"d,0(s)",MATCH_LR_W|MASK_AQ,MASK_LR_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"sc.w.aq",0,INSN_CLASS_A,"d,t,0(s)",MATCH_SC_W|MASK_AQ,MASK_SC_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"amoadd.w.aq",0,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOADD_W|MASK_AQ,MASK_AMOADD_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"amoswap.w.aq",0,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOSWAP_W|MASK_AQ,MASK_AMOSWAP_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"amoand.w.aq",0,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOAND_W|MASK_AQ,MASK_AMOAND_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"amoor.w.aq",0,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOOR_W|MASK_AQ,MASK_AMOOR_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"amoxor.w.aq",0,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOXOR_W|MASK_AQ,MASK_AMOXOR_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"amomax.w.aq",0,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOMAX_W|MASK_AQ,MASK_AMOMAX_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"amomaxu.w.aq",0,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOMAXU_W|MASK_AQ,MASK_AMOMAXU_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"amomin.w.aq",0,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOMIN_W|MASK_AQ,MASK_AMOMIN_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"amominu.w.aq",0,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOMINU_W|MASK_AQ,MASK_AMOMINU_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"lr.w.rl",0,INSN_CLASS_A,"d,0(s)",MATCH_LR_W|MASK_RL,MASK_LR_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"sc.w.rl",0,INSN_CLASS_A,"d,t,0(s)",MATCH_SC_W|MASK_RL,MASK_SC_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"amoadd.w.rl",0,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOADD_W|MASK_RL,MASK_AMOADD_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"amoswap.w.rl",0,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOSWAP_W|MASK_RL,MASK_AMOSWAP_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"amoand.w.rl",0,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOAND_W|MASK_RL,MASK_AMOAND_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"amoor.w.rl",0,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOOR_W|MASK_RL,MASK_AMOOR_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"amoxor.w.rl",0,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOXOR_W|MASK_RL,MASK_AMOXOR_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"amomax.w.rl",0,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOMAX_W|MASK_RL,MASK_AMOMAX_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"amomaxu.w.rl",0,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOMAXU_W|MASK_RL,MASK_AMOMAXU_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"amomin.w.rl",0,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOMIN_W|MASK_RL,MASK_AMOMIN_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"amominu.w.rl",0,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOMINU_W|MASK_RL,MASK_AMOMINU_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"lr.w.aqrl",0,INSN_CLASS_A,"d,0(s)",MATCH_LR_W|MASK_AQRL,MASK_LR_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"sc.w.aqrl",0,INSN_CLASS_A,"d,t,0(s)",MATCH_SC_W|MASK_AQRL,MASK_SC_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"amoadd.w.aqrl",0,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOADD_W|MASK_AQRL,MASK_AMOADD_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"amoswap.w.aqrl",0,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOSWAP_W|MASK_AQRL,MASK_AMOSWAP_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"amoand.w.aqrl",0,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOAND_W|MASK_AQRL,MASK_AMOAND_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"amoor.w.aqrl",0,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOOR_W|MASK_AQRL,MASK_AMOOR_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"amoxor.w.aqrl",0,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOXOR_W|MASK_AQRL,MASK_AMOXOR_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"amomax.w.aqrl",0,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOMAX_W|MASK_AQRL,MASK_AMOMAX_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"amomaxu.w.aqrl",0,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOMAXU_W|MASK_AQRL,MASK_AMOMAXU_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"amomin.w.aqrl",0,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOMIN_W|MASK_AQRL,MASK_AMOMIN_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"amominu.w.aqrl",0,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOMINU_W|MASK_AQRL,MASK_AMOMINU_W|MASK_AQRL,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"lr.d",64,INSN_CLASS_A,"d,0(s)",MATCH_LR_D,MASK_LR_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"sc.d",64,INSN_CLASS_A,"d,t,0(s)",MATCH_SC_D,MASK_SC_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"amoadd.d",64,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOADD_D,MASK_AMOADD_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"amoswap.d",64,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOSWAP_D,MASK_AMOSWAP_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"amoand.d",64,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOAND_D,MASK_AMOAND_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"amoor.d",64,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOOR_D,MASK_AMOOR_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"amoxor.d",64,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOXOR_D,MASK_AMOXOR_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"amomax.d",64,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOMAX_D,MASK_AMOMAX_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"amomaxu.d",64,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOMAXU_D,MASK_AMOMAXU_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"amomin.d",64,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOMIN_D,MASK_AMOMIN_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"amominu.d",64,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOMINU_D,MASK_AMOMINU_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"lr.d.aq",64,INSN_CLASS_A,"d,0(s)",MATCH_LR_D|MASK_AQ,MASK_LR_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"sc.d.aq",64,INSN_CLASS_A,"d,t,0(s)",MATCH_SC_D|MASK_AQ,MASK_SC_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"amoadd.d.aq",64,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOADD_D|MASK_AQ,MASK_AMOADD_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"amoswap.d.aq",64,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOSWAP_D|MASK_AQ,MASK_AMOSWAP_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"amoand.d.aq",64,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOAND_D|MASK_AQ,MASK_AMOAND_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"amoor.d.aq",64,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOOR_D|MASK_AQ,MASK_AMOOR_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"amoxor.d.aq",64,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOXOR_D|MASK_AQ,MASK_AMOXOR_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"amomax.d.aq",64,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOMAX_D|MASK_AQ,MASK_AMOMAX_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"amomaxu.d.aq",64,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOMAXU_D|MASK_AQ,MASK_AMOMAXU_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"amomin.d.aq",64,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOMIN_D|MASK_AQ,MASK_AMOMIN_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"amominu.d.aq",64,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOMINU_D|MASK_AQ,MASK_AMOMINU_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"lr.d.rl",64,INSN_CLASS_A,"d,0(s)",MATCH_LR_D|MASK_RL,MASK_LR_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"sc.d.rl",64,INSN_CLASS_A,"d,t,0(s)",MATCH_SC_D|MASK_RL,MASK_SC_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"amoadd.d.rl",64,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOADD_D|MASK_RL,MASK_AMOADD_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"amoswap.d.rl",64,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOSWAP_D|MASK_RL,MASK_AMOSWAP_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"amoand.d.rl",64,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOAND_D|MASK_RL,MASK_AMOAND_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"amoor.d.rl",64,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOOR_D|MASK_RL,MASK_AMOOR_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"amoxor.d.rl",64,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOXOR_D|MASK_RL,MASK_AMOXOR_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"amomax.d.rl",64,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOMAX_D|MASK_RL,MASK_AMOMAX_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"amomaxu.d.rl",64,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOMAXU_D|MASK_RL,MASK_AMOMAXU_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"amomin.d.rl",64,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOMIN_D|MASK_RL,MASK_AMOMIN_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"amominu.d.rl",64,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOMINU_D|MASK_RL,MASK_AMOMINU_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"lr.d.aqrl",64,INSN_CLASS_A,"d,0(s)",MATCH_LR_D|MASK_AQRL,MASK_LR_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"sc.d.aqrl",64,INSN_CLASS_A,"d,t,0(s)",MATCH_SC_D|MASK_AQRL,MASK_SC_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"amoadd.d.aqrl",64,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOADD_D|MASK_AQRL,MASK_AMOADD_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"amoswap.d.aqrl",64,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOSWAP_D|MASK_AQRL,MASK_AMOSWAP_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"amoand.d.aqrl",64,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOAND_D|MASK_AQRL,MASK_AMOAND_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"amoor.d.aqrl",64,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOOR_D|MASK_AQRL,MASK_AMOOR_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"amoxor.d.aqrl",64,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOXOR_D|MASK_AQRL,MASK_AMOXOR_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"amomax.d.aqrl",64,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOMAX_D|MASK_AQRL,MASK_AMOMAX_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"amomaxu.d.aqrl",64,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOMAXU_D|MASK_AQRL,MASK_AMOMAXU_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"amomin.d.aqrl",64,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOMIN_D|MASK_AQRL,MASK_AMOMIN_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"amominu.d.aqrl",64,INSN_CLASS_A,"d,t,0(s)",MATCH_AMOMINU_D|MASK_AQRL,MASK_AMOMINU_D|MASK_AQRL,match_opcode,INSN_DREF|INSN_8_BYTE},

	/* Multiply/Divide instruction subset.  */
	{"mul",0,INSN_CLASS_ZMMUL,"d,s,t",MATCH_MUL,MASK_MUL,match_opcode,0},
	{"mulh",0,INSN_CLASS_ZMMUL,"d,s,t",MATCH_MULH,MASK_MULH,match_opcode,0},
	{"mulhu",0,INSN_CLASS_ZMMUL,"d,s,t",MATCH_MULHU,MASK_MULHU,match_opcode,0},
	{"mulhsu",0,INSN_CLASS_ZMMUL,"d,s,t",MATCH_MULHSU,MASK_MULHSU,match_opcode,0},
	{"div",0,INSN_CLASS_M,"d,s,t",MATCH_DIV,MASK_DIV,match_opcode,0},
	{"divu",0,INSN_CLASS_M,"d,s,t",MATCH_DIVU,MASK_DIVU,match_opcode,0},
	{"rem",0,INSN_CLASS_M,"d,s,t",MATCH_REM,MASK_REM,match_opcode,0},
	{"remu",0,INSN_CLASS_M,"d,s,t",MATCH_REMU,MASK_REMU,match_opcode,0},
	{"mulw",64,INSN_CLASS_ZMMUL,"d,s,t",MATCH_MULW,MASK_MULW,match_opcode,0},
	{"divw",64,INSN_CLASS_M,"d,s,t",MATCH_DIVW,MASK_DIVW,match_opcode,0},
	{"divuw",64,INSN_CLASS_M,"d,s,t",MATCH_DIVUW,MASK_DIVUW,match_opcode,0},
	{"remw",64,INSN_CLASS_M,"d,s,t",MATCH_REMW,MASK_REMW,match_opcode,0},
	{"remuw",64,INSN_CLASS_M,"d,s,t",MATCH_REMUW,MASK_REMUW,match_opcode,0},

	/* Half-precision floating-point instruction subset.  */
	{"flh",0,INSN_CLASS_ZFHMIN,"D,o(s)",MATCH_FLH,MASK_FLH,match_opcode,INSN_DREF|INSN_2_BYTE},
	{"flh",0,INSN_CLASS_ZFHMIN,"D,A,s",0,(int)M_FLH,match_never,INSN_MACRO},
	{"fsh",0,INSN_CLASS_ZFHMIN,"T,q(s)",MATCH_FSH,MASK_FSH,match_opcode,INSN_DREF|INSN_2_BYTE},
	{"fsh",0,INSN_CLASS_ZFHMIN,"T,A,s",0,(int)M_FSH,match_never,INSN_MACRO},
	{"fmv.x.h",0,INSN_CLASS_ZFHMIN,"d,S",MATCH_FMV_X_H,MASK_FMV_X_H,match_opcode,0},
	{"fmv.h.x",0,INSN_CLASS_ZFHMIN,"D,s",MATCH_FMV_H_X,MASK_FMV_H_X,match_opcode,0},
	{"fmv.h",0,INSN_CLASS_ZFH_INX,"D,U",MATCH_FSGNJ_H,MASK_FSGNJ_H,match_rs1_eq_rs2,INSN_ALIAS},
	{"fneg.h",0,INSN_CLASS_ZFH_INX,"D,U",MATCH_FSGNJN_H,MASK_FSGNJN_H,match_rs1_eq_rs2,INSN_ALIAS},
	{"fabs.h",0,INSN_CLASS_ZFH_INX,"D,U",MATCH_FSGNJX_H,MASK_FSGNJX_H,match_rs1_eq_rs2,INSN_ALIAS},
	{"fsgnj.h",0,INSN_CLASS_ZFH_INX,"D,S,T",MATCH_FSGNJ_H,MASK_FSGNJ_H,match_opcode,0},
	{"fsgnjn.h",0,INSN_CLASS_ZFH_INX,"D,S,T",MATCH_FSGNJN_H,MASK_FSGNJN_H,match_opcode,0},
	{"fsgnjx.h",0,INSN_CLASS_ZFH_INX,"D,S,T",MATCH_FSGNJX_H,MASK_FSGNJX_H,match_opcode,0},
	{"fadd.h",0,INSN_CLASS_ZFH_INX,"D,S,T",MATCH_FADD_H|MASK_RM,MASK_FADD_H|MASK_RM,match_opcode,0},
	{"fadd.h",0,INSN_CLASS_ZFH_INX,"D,S,T,m",MATCH_FADD_H,MASK_FADD_H,match_opcode,0},
	{"fsub.h",0,INSN_CLASS_ZFH_INX,"D,S,T",MATCH_FSUB_H|MASK_RM,MASK_FSUB_H|MASK_RM,match_opcode,0},
	{"fsub.h",0,INSN_CLASS_ZFH_INX,"D,S,T,m",MATCH_FSUB_H,MASK_FSUB_H,match_opcode,0},
	{"fmul.h",0,INSN_CLASS_ZFH_INX,"D,S,T",MATCH_FMUL_H|MASK_RM,MASK_FMUL_H|MASK_RM,match_opcode,0},
	{"fmul.h",0,INSN_CLASS_ZFH_INX,"D,S,T,m",MATCH_FMUL_H,MASK_FMUL_H,match_opcode,0},
	{"fdiv.h",0,INSN_CLASS_ZFH_INX,"D,S,T",MATCH_FDIV_H|MASK_RM,MASK_FDIV_H|MASK_RM,match_opcode,0},
	{"fdiv.h",0,INSN_CLASS_ZFH_INX,"D,S,T,m",MATCH_FDIV_H,MASK_FDIV_H,match_opcode,0},
	{"fsqrt.h",0,INSN_CLASS_ZFH_INX,"D,S",MATCH_FSQRT_H|MASK_RM,MASK_FSQRT_H|MASK_RM,match_opcode,0},
	{"fsqrt.h",0,INSN_CLASS_ZFH_INX,"D,S,m",MATCH_FSQRT_H,MASK_FSQRT_H,match_opcode,0},
	{"fmin.h",0,INSN_CLASS_ZFH_INX,"D,S,T",MATCH_FMIN_H,MASK_FMIN_H,match_opcode,0},
	{"fmax.h",0,INSN_CLASS_ZFH_INX,"D,S,T",MATCH_FMAX_H,MASK_FMAX_H,match_opcode,0},
	{"fmadd.h",0,INSN_CLASS_ZFH_INX,"D,S,T,R",MATCH_FMADD_H|MASK_RM,MASK_FMADD_H|MASK_RM,match_opcode,0},
	{"fmadd.h",0,INSN_CLASS_ZFH_INX,"D,S,T,R,m",MATCH_FMADD_H,MASK_FMADD_H,match_opcode,0},
	{"fnmadd.h",0,INSN_CLASS_ZFH_INX,"D,S,T,R",MATCH_FNMADD_H|MASK_RM,MASK_FNMADD_H|MASK_RM,match_opcode,0},
	{"fnmadd.h",0,INSN_CLASS_ZFH_INX,"D,S,T,R,m",MATCH_FNMADD_H,MASK_FNMADD_H,match_opcode,0},
	{"fmsub.h",0,INSN_CLASS_ZFH_INX,"D,S,T,R",MATCH_FMSUB_H|MASK_RM,MASK_FMSUB_H|MASK_RM,match_opcode,0},
	{"fmsub.h",0,INSN_CLASS_ZFH_INX,"D,S,T,R,m",MATCH_FMSUB_H,MASK_FMSUB_H,match_opcode,0},
	{"fnmsub.h",0,INSN_CLASS_ZFH_INX,"D,S,T,R",MATCH_FNMSUB_H|MASK_RM,MASK_FNMSUB_H|MASK_RM,match_opcode,0},
	{"fnmsub.h",0,INSN_CLASS_ZFH_INX,"D,S,T,R,m",MATCH_FNMSUB_H,MASK_FNMSUB_H,match_opcode,0},
	{"fcvt.w.h",0,INSN_CLASS_ZFH_INX,"d,S",MATCH_FCVT_W_H|MASK_RM,MASK_FCVT_W_H|MASK_RM,match_opcode,0},
	{"fcvt.w.h",0,INSN_CLASS_ZFH_INX,"d,S,m",MATCH_FCVT_W_H,MASK_FCVT_W_H,match_opcode,0},
	{"fcvt.wu.h",0,INSN_CLASS_ZFH_INX,"d,S",MATCH_FCVT_WU_H|MASK_RM,MASK_FCVT_WU_H|MASK_RM,match_opcode,0},
	{"fcvt.wu.h",0,INSN_CLASS_ZFH_INX,"d,S,m",MATCH_FCVT_WU_H,MASK_FCVT_WU_H,match_opcode,0},
	{"fcvt.h.w",0,INSN_CLASS_ZFH_INX,"D,s",MATCH_FCVT_H_W|MASK_RM,MASK_FCVT_H_W|MASK_RM,match_opcode,0},
	{"fcvt.h.w",0,INSN_CLASS_ZFH_INX,"D,s,m",MATCH_FCVT_H_W,MASK_FCVT_H_W,match_opcode,0},
	{"fcvt.h.wu",0,INSN_CLASS_ZFH_INX,"D,s",MATCH_FCVT_H_WU|MASK_RM,MASK_FCVT_H_WU|MASK_RM,match_opcode,0},
	{"fcvt.h.wu",0,INSN_CLASS_ZFH_INX,"D,s,m",MATCH_FCVT_H_WU,MASK_FCVT_H_WU,match_opcode,0},
	{"fcvt.s.h",0,INSN_CLASS_ZFHMIN_INX,"D,S",MATCH_FCVT_S_H,MASK_FCVT_S_H|MASK_RM,match_opcode,0},
	{"fcvt.d.h",0,INSN_CLASS_ZFHMIN_AND_D_INX,"D,S",MATCH_FCVT_D_H,MASK_FCVT_D_H|MASK_RM,match_opcode,0},
	{"fcvt.q.h",0,INSN_CLASS_ZFHMIN_AND_Q_INX,"D,S",MATCH_FCVT_Q_H,MASK_FCVT_Q_H|MASK_RM,match_opcode,0},
	{"fcvt.h.s",0,INSN_CLASS_ZFHMIN_INX,"D,S",MATCH_FCVT_H_S|MASK_RM,MASK_FCVT_H_S|MASK_RM,match_opcode,0},
	{"fcvt.h.s",0,INSN_CLASS_ZFHMIN_INX,"D,S,m",MATCH_FCVT_H_S,MASK_FCVT_H_S,match_opcode,0},
	{"fcvt.h.d",0,INSN_CLASS_ZFHMIN_AND_D_INX,"D,S",MATCH_FCVT_H_D|MASK_RM,MASK_FCVT_H_D|MASK_RM,match_opcode,0},
	{"fcvt.h.d",0,INSN_CLASS_ZFHMIN_AND_D_INX,"D,S,m",MATCH_FCVT_H_D,MASK_FCVT_H_D,match_opcode,0},
	{"fcvt.h.q",0,INSN_CLASS_ZFHMIN_AND_Q_INX,"D,S",MATCH_FCVT_H_Q|MASK_RM,MASK_FCVT_H_Q|MASK_RM,match_opcode,0},
	{"fcvt.h.q",0,INSN_CLASS_ZFHMIN_AND_Q_INX,"D,S,m",MATCH_FCVT_H_Q,MASK_FCVT_H_Q,match_opcode,0},
	{"fclass.h",0,INSN_CLASS_ZFH_INX,"d,S",MATCH_FCLASS_H,MASK_FCLASS_H,match_opcode,0},
	{"feq.h",0,INSN_CLASS_ZFH_INX,"d,S,T",MATCH_FEQ_H,MASK_FEQ_H,match_opcode,0},
	{"flt.h",0,INSN_CLASS_ZFH_INX,"d,S,T",MATCH_FLT_H,MASK_FLT_H,match_opcode,0},
	{"fle.h",0,INSN_CLASS_ZFH_INX,"d,S,T",MATCH_FLE_H,MASK_FLE_H,match_opcode,0},
	{"fgt.h",0,INSN_CLASS_ZFH_INX,"d,T,S",MATCH_FLT_H,MASK_FLT_H,match_opcode,0},
	{"fge.h",0,INSN_CLASS_ZFH_INX,"d,T,S",MATCH_FLE_H,MASK_FLE_H,match_opcode,0},
	{"fcvt.l.h",64,INSN_CLASS_ZFH_INX,"d,S",MATCH_FCVT_L_H|MASK_RM,MASK_FCVT_L_H|MASK_RM,match_opcode,0},
	{"fcvt.l.h",64,INSN_CLASS_ZFH_INX,"d,S,m",MATCH_FCVT_L_H,MASK_FCVT_L_H,match_opcode,0},
	{"fcvt.lu.h",64,INSN_CLASS_ZFH_INX,"d,S",MATCH_FCVT_LU_H|MASK_RM,MASK_FCVT_LU_H|MASK_RM,match_opcode,0},
	{"fcvt.lu.h",64,INSN_CLASS_ZFH_INX,"d,S,m",MATCH_FCVT_LU_H,MASK_FCVT_LU_H,match_opcode,0},
	{"fcvt.h.l",64,INSN_CLASS_ZFH_INX,"D,s",MATCH_FCVT_H_L|MASK_RM,MASK_FCVT_H_L|MASK_RM,match_opcode,0},
	{"fcvt.h.l",64,INSN_CLASS_ZFH_INX,"D,s,m",MATCH_FCVT_H_L,MASK_FCVT_H_L,match_opcode,0},
	{"fcvt.h.lu",64,INSN_CLASS_ZFH_INX,"D,s",MATCH_FCVT_H_LU|MASK_RM,MASK_FCVT_H_LU|MASK_RM,match_opcode,0},
	{"fcvt.h.lu",64,INSN_CLASS_ZFH_INX,"D,s,m",MATCH_FCVT_H_LU,MASK_FCVT_H_LU,match_opcode,0},

	/* Single-precision floating-point instruction subset.  */
	{"frcsr",0,INSN_CLASS_F_INX,"d",MATCH_FRCSR,MASK_FRCSR,match_opcode,INSN_ALIAS},
	{"frsr",0,INSN_CLASS_F_INX,"d",MATCH_FRCSR,MASK_FRCSR,match_opcode,INSN_ALIAS},
	{"fscsr",0,INSN_CLASS_F_INX,"s",MATCH_FSCSR,MASK_FSCSR|MASK_RD,match_opcode,INSN_ALIAS},
	{"fscsr",0,INSN_CLASS_F_INX,"d,s",MATCH_FSCSR,MASK_FSCSR,match_opcode,INSN_ALIAS},
	{"fssr",0,INSN_CLASS_F_INX,"s",MATCH_FSCSR,MASK_FSCSR|MASK_RD,match_opcode,INSN_ALIAS},
	{"fssr",0,INSN_CLASS_F_INX,"d,s",MATCH_FSCSR,MASK_FSCSR,match_opcode,INSN_ALIAS},
	{"frrm",0,INSN_CLASS_F_INX,"d",MATCH_FRRM,MASK_FRRM,match_opcode,INSN_ALIAS},
	{"fsrm",0,INSN_CLASS_F_INX,"s",MATCH_FSRM,MASK_FSRM|MASK_RD,match_opcode,INSN_ALIAS},
	{"fsrm",0,INSN_CLASS_F_INX,"d,s",MATCH_FSRM,MASK_FSRM,match_opcode,INSN_ALIAS},
	{"fsrmi",0,INSN_CLASS_F_INX,"d,Z",MATCH_FSRMI,MASK_FSRMI,match_opcode,INSN_ALIAS},
	{"fsrmi",0,INSN_CLASS_F_INX,"Z",MATCH_FSRMI,MASK_FSRMI|MASK_RD,match_opcode,INSN_ALIAS},
	{"frflags",0,INSN_CLASS_F_INX,"d",MATCH_FRFLAGS,MASK_FRFLAGS,match_opcode,INSN_ALIAS},
	{"fsflags",0,INSN_CLASS_F_INX,"s",MATCH_FSFLAGS,MASK_FSFLAGS|MASK_RD,match_opcode,INSN_ALIAS},
	{"fsflags",0,INSN_CLASS_F_INX,"d,s",MATCH_FSFLAGS,MASK_FSFLAGS,match_opcode,INSN_ALIAS},
	{"fsflagsi",0,INSN_CLASS_F_INX,"d,Z",MATCH_FSFLAGSI,MASK_FSFLAGSI,match_opcode,INSN_ALIAS},
	{"fsflagsi",0,INSN_CLASS_F_INX,"Z",MATCH_FSFLAGSI,MASK_FSFLAGSI|MASK_RD,match_opcode,INSN_ALIAS},
	{"flw",32,INSN_CLASS_F_AND_C,"D,Cm(Cc)",MATCH_C_FLWSP,MASK_C_FLWSP,match_opcode,INSN_ALIAS|INSN_DREF|INSN_4_BYTE},
	{"flw",32,INSN_CLASS_F_AND_C,"CD,Ck(Cs)",MATCH_C_FLW,MASK_C_FLW,match_opcode,INSN_ALIAS|INSN_DREF|INSN_4_BYTE},
	{"flw",0,INSN_CLASS_F,"D,o(s)",MATCH_FLW,MASK_FLW,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"flw",0,INSN_CLASS_F,"D,A,s",0,(int)M_FLW,match_never,INSN_MACRO},
	{"fsw",32,INSN_CLASS_F_AND_C,"CT,CM(Cc)",MATCH_C_FSWSP,MASK_C_FSWSP,match_opcode,INSN_ALIAS|INSN_DREF|INSN_4_BYTE},
	{"fsw",32,INSN_CLASS_F_AND_C,"CD,Ck(Cs)",MATCH_C_FSW,MASK_C_FSW,match_opcode,INSN_ALIAS|INSN_DREF|INSN_4_BYTE},
	{"fsw",0,INSN_CLASS_F,"T,q(s)",MATCH_FSW,MASK_FSW,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"fsw",0,INSN_CLASS_F,"T,A,s",0,(int)M_FSW,match_never,INSN_MACRO},
	{"fmv.x.w",0,INSN_CLASS_F,"d,S",MATCH_FMV_X_S,MASK_FMV_X_S,match_opcode,0},
	{"fmv.w.x",0,INSN_CLASS_F,"D,s",MATCH_FMV_S_X,MASK_FMV_S_X,match_opcode,0},
	{"fmv.x.s",0,INSN_CLASS_F,"d,S",MATCH_FMV_X_S,MASK_FMV_X_S,match_opcode,0},
	{"fmv.s.x",0,INSN_CLASS_F,"D,s",MATCH_FMV_S_X,MASK_FMV_S_X,match_opcode,0},
	{"fmv.s",0,INSN_CLASS_F_INX,"D,U",MATCH_FSGNJ_S,MASK_FSGNJ_S,match_rs1_eq_rs2,INSN_ALIAS},
	{"fneg.s",0,INSN_CLASS_F_INX,"D,U",MATCH_FSGNJN_S,MASK_FSGNJN_S,match_rs1_eq_rs2,INSN_ALIAS},
	{"fabs.s",0,INSN_CLASS_F_INX,"D,U",MATCH_FSGNJX_S,MASK_FSGNJX_S,match_rs1_eq_rs2,INSN_ALIAS},
	{"fsgnj.s",0,INSN_CLASS_F_INX,"D,S,T",MATCH_FSGNJ_S,MASK_FSGNJ_S,match_opcode,0},
	{"fsgnjn.s",0,INSN_CLASS_F_INX,"D,S,T",MATCH_FSGNJN_S,MASK_FSGNJN_S,match_opcode,0},
	{"fsgnjx.s",0,INSN_CLASS_F_INX,"D,S,T",MATCH_FSGNJX_S,MASK_FSGNJX_S,match_opcode,0},
	{"fadd.s",0,INSN_CLASS_F_INX,"D,S,T",MATCH_FADD_S|MASK_RM,MASK_FADD_S|MASK_RM,match_opcode,0},
	{"fadd.s",0,INSN_CLASS_F_INX,"D,S,T,m",MATCH_FADD_S,MASK_FADD_S,match_opcode,0},
	{"fsub.s",0,INSN_CLASS_F_INX,"D,S,T",MATCH_FSUB_S|MASK_RM,MASK_FSUB_S|MASK_RM,match_opcode,0},
	{"fsub.s",0,INSN_CLASS_F_INX,"D,S,T,m",MATCH_FSUB_S,MASK_FSUB_S,match_opcode,0},
	{"fmul.s",0,INSN_CLASS_F_INX,"D,S,T",MATCH_FMUL_S|MASK_RM,MASK_FMUL_S|MASK_RM,match_opcode,0},
	{"fmul.s",0,INSN_CLASS_F_INX,"D,S,T,m",MATCH_FMUL_S,MASK_FMUL_S,match_opcode,0},
	{"fdiv.s",0,INSN_CLASS_F_INX,"D,S,T",MATCH_FDIV_S|MASK_RM,MASK_FDIV_S|MASK_RM,match_opcode,0},
	{"fdiv.s",0,INSN_CLASS_F_INX,"D,S,T,m",MATCH_FDIV_S,MASK_FDIV_S,match_opcode,0},
	{"fsqrt.s",0,INSN_CLASS_F_INX,"D,S",MATCH_FSQRT_S|MASK_RM,MASK_FSQRT_S|MASK_RM,match_opcode,0},
	{"fsqrt.s",0,INSN_CLASS_F_INX,"D,S,m",MATCH_FSQRT_S,MASK_FSQRT_S,match_opcode,0},
	{"fmin.s",0,INSN_CLASS_F_INX,"D,S,T",MATCH_FMIN_S,MASK_FMIN_S,match_opcode,0},
	{"fmax.s",0,INSN_CLASS_F_INX,"D,S,T",MATCH_FMAX_S,MASK_FMAX_S,match_opcode,0},
	{"fmadd.s",0,INSN_CLASS_F_INX,"D,S,T,R",MATCH_FMADD_S|MASK_RM,MASK_FMADD_S|MASK_RM,match_opcode,0},
	{"fmadd.s",0,INSN_CLASS_F_INX,"D,S,T,R,m",MATCH_FMADD_S,MASK_FMADD_S,match_opcode,0},
	{"fnmadd.s",0,INSN_CLASS_F_INX,"D,S,T,R",MATCH_FNMADD_S|MASK_RM,MASK_FNMADD_S|MASK_RM,match_opcode,0},
	{"fnmadd.s",0,INSN_CLASS_F_INX,"D,S,T,R,m",MATCH_FNMADD_S,MASK_FNMADD_S,match_opcode,0},
	{"fmsub.s",0,INSN_CLASS_F_INX,"D,S,T,R",MATCH_FMSUB_S|MASK_RM,MASK_FMSUB_S|MASK_RM,match_opcode,0},
	{"fmsub.s",0,INSN_CLASS_F_INX,"D,S,T,R,m",MATCH_FMSUB_S,MASK_FMSUB_S,match_opcode,0},
	{"fnmsub.s",0,INSN_CLASS_F_INX,"D,S,T,R",MATCH_FNMSUB_S|MASK_RM,MASK_FNMSUB_S|MASK_RM,match_opcode,0},
	{"fnmsub.s",0,INSN_CLASS_F_INX,"D,S,T,R,m",MATCH_FNMSUB_S,MASK_FNMSUB_S,match_opcode,0},
	{"fcvt.w.s",0,INSN_CLASS_F_INX,"d,S",MATCH_FCVT_W_S|MASK_RM,MASK_FCVT_W_S|MASK_RM,match_opcode,0},
	{"fcvt.w.s",0,INSN_CLASS_F_INX,"d,S,m",MATCH_FCVT_W_S,MASK_FCVT_W_S,match_opcode,0},
	{"fcvt.wu.s",0,INSN_CLASS_F_INX,"d,S",MATCH_FCVT_WU_S|MASK_RM,MASK_FCVT_WU_S|MASK_RM,match_opcode,0},
	{"fcvt.wu.s",0,INSN_CLASS_F_INX,"d,S,m",MATCH_FCVT_WU_S,MASK_FCVT_WU_S,match_opcode,0},
	{"fcvt.s.w",0,INSN_CLASS_F_INX,"D,s",MATCH_FCVT_S_W|MASK_RM,MASK_FCVT_S_W|MASK_RM,match_opcode,0},
	{"fcvt.s.w",0,INSN_CLASS_F_INX,"D,s,m",MATCH_FCVT_S_W,MASK_FCVT_S_W,match_opcode,0},
	{"fcvt.s.wu",0,INSN_CLASS_F_INX,"D,s",MATCH_FCVT_S_WU|MASK_RM,MASK_FCVT_S_WU|MASK_RM,match_opcode,0},
	{"fcvt.s.wu",0,INSN_CLASS_F_INX,"D,s,m",MATCH_FCVT_S_WU,MASK_FCVT_S_WU,match_opcode,0},
	{"fclass.s",0,INSN_CLASS_F_INX,"d,S",MATCH_FCLASS_S,MASK_FCLASS_S,match_opcode,0},
	{"feq.s",0,INSN_CLASS_F_INX,"d,S,T",MATCH_FEQ_S,MASK_FEQ_S,match_opcode,0},
	{"flt.s",0,INSN_CLASS_F_INX,"d,S,T",MATCH_FLT_S,MASK_FLT_S,match_opcode,0},
	{"fle.s",0,INSN_CLASS_F_INX,"d,S,T",MATCH_FLE_S,MASK_FLE_S,match_opcode,0},
	{"fgt.s",0,INSN_CLASS_F_INX,"d,T,S",MATCH_FLT_S,MASK_FLT_S,match_opcode,0},
	{"fge.s",0,INSN_CLASS_F_INX,"d,T,S",MATCH_FLE_S,MASK_FLE_S,match_opcode,0},
	{"fcvt.l.s",64,INSN_CLASS_F_INX,"d,S",MATCH_FCVT_L_S|MASK_RM,MASK_FCVT_L_S|MASK_RM,match_opcode,0},
	{"fcvt.l.s",64,INSN_CLASS_F_INX,"d,S,m",MATCH_FCVT_L_S,MASK_FCVT_L_S,match_opcode,0},
	{"fcvt.lu.s",64,INSN_CLASS_F_INX,"d,S",MATCH_FCVT_LU_S|MASK_RM,MASK_FCVT_LU_S|MASK_RM,match_opcode,0},
	{"fcvt.lu.s",64,INSN_CLASS_F_INX,"d,S,m",MATCH_FCVT_LU_S,MASK_FCVT_LU_S,match_opcode,0},
	{"fcvt.s.l",64,INSN_CLASS_F_INX,"D,s",MATCH_FCVT_S_L|MASK_RM,MASK_FCVT_S_L|MASK_RM,match_opcode,0},
	{"fcvt.s.l",64,INSN_CLASS_F_INX,"D,s,m",MATCH_FCVT_S_L,MASK_FCVT_S_L,match_opcode,0},
	{"fcvt.s.lu",64,INSN_CLASS_F_INX,"D,s",MATCH_FCVT_S_LU|MASK_RM,MASK_FCVT_S_LU|MASK_RM,match_opcode,0},
	{"fcvt.s.lu",64,INSN_CLASS_F_INX,"D,s,m",MATCH_FCVT_S_LU,MASK_FCVT_S_LU,match_opcode,0},

	/* Double-precision floating-point instruction subset.  */
	{"fld",0,INSN_CLASS_D_AND_C,"D,Cn(Cc)",MATCH_C_FLDSP,MASK_C_FLDSP,match_opcode,INSN_ALIAS|INSN_DREF|INSN_8_BYTE},
	{"fld",0,INSN_CLASS_D_AND_C,"CD,Cl(Cs)",MATCH_C_FLD,MASK_C_FLD,match_opcode,INSN_ALIAS|INSN_DREF|INSN_8_BYTE},
	{"fld",0,INSN_CLASS_D,"D,o(s)",MATCH_FLD,MASK_FLD,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"fld",0,INSN_CLASS_D,"D,A,s",0,(int)M_FLD,match_never,INSN_MACRO},
	{"fsd",0,INSN_CLASS_D_AND_C,"CT,CN(Cc)",MATCH_C_FSDSP,MASK_C_FSDSP,match_opcode,INSN_ALIAS|INSN_DREF|INSN_8_BYTE},
	{"fsd",0,INSN_CLASS_D_AND_C,"CD,Cl(Cs)",MATCH_C_FSD,MASK_C_FSD,match_opcode,INSN_ALIAS|INSN_DREF|INSN_8_BYTE},
	{"fsd",0,INSN_CLASS_D,"T,q(s)",MATCH_FSD,MASK_FSD,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"fsd",0,INSN_CLASS_D,"T,A,s",0,(int)M_FSD,match_never,INSN_MACRO},
	{"fmv.d",0,INSN_CLASS_D_INX,"D,U",MATCH_FSGNJ_D,MASK_FSGNJ_D,match_rs1_eq_rs2,INSN_ALIAS},
	{"fneg.d",0,INSN_CLASS_D_INX,"D,U",MATCH_FSGNJN_D,MASK_FSGNJN_D,match_rs1_eq_rs2,INSN_ALIAS},
	{"fabs.d",0,INSN_CLASS_D_INX,"D,U",MATCH_FSGNJX_D,MASK_FSGNJX_D,match_rs1_eq_rs2,INSN_ALIAS},
	{"fsgnj.d",0,INSN_CLASS_D_INX,"D,S,T",MATCH_FSGNJ_D,MASK_FSGNJ_D,match_opcode,0},
	{"fsgnjn.d",0,INSN_CLASS_D_INX,"D,S,T",MATCH_FSGNJN_D,MASK_FSGNJN_D,match_opcode,0},
	{"fsgnjx.d",0,INSN_CLASS_D_INX,"D,S,T",MATCH_FSGNJX_D,MASK_FSGNJX_D,match_opcode,0},
	{"fadd.d",0,INSN_CLASS_D_INX,"D,S,T",MATCH_FADD_D|MASK_RM,MASK_FADD_D|MASK_RM,match_opcode,0},
	{"fadd.d",0,INSN_CLASS_D_INX,"D,S,T,m",MATCH_FADD_D,MASK_FADD_D,match_opcode,0},
	{"fsub.d",0,INSN_CLASS_D_INX,"D,S,T",MATCH_FSUB_D|MASK_RM,MASK_FSUB_D|MASK_RM,match_opcode,0},
	{"fsub.d",0,INSN_CLASS_D_INX,"D,S,T,m",MATCH_FSUB_D,MASK_FSUB_D,match_opcode,0},
	{"fmul.d",0,INSN_CLASS_D_INX,"D,S,T",MATCH_FMUL_D|MASK_RM,MASK_FMUL_D|MASK_RM,match_opcode,0},
	{"fmul.d",0,INSN_CLASS_D_INX,"D,S,T,m",MATCH_FMUL_D,MASK_FMUL_D,match_opcode,0},
	{"fdiv.d",0,INSN_CLASS_D_INX,"D,S,T",MATCH_FDIV_D|MASK_RM,MASK_FDIV_D|MASK_RM,match_opcode,0},
	{"fdiv.d",0,INSN_CLASS_D_INX,"D,S,T,m",MATCH_FDIV_D,MASK_FDIV_D,match_opcode,0},
	{"fsqrt.d",0,INSN_CLASS_D_INX,"D,S",MATCH_FSQRT_D|MASK_RM,MASK_FSQRT_D|MASK_RM,match_opcode,0},
	{"fsqrt.d",0,INSN_CLASS_D_INX,"D,S,m",MATCH_FSQRT_D,MASK_FSQRT_D,match_opcode,0},
	{"fmin.d",0,INSN_CLASS_D_INX,"D,S,T",MATCH_FMIN_D,MASK_FMIN_D,match_opcode,0},
	{"fmax.d",0,INSN_CLASS_D_INX,"D,S,T",MATCH_FMAX_D,MASK_FMAX_D,match_opcode,0},
	{"fmadd.d",0,INSN_CLASS_D_INX,"D,S,T,R",MATCH_FMADD_D|MASK_RM,MASK_FMADD_D|MASK_RM,match_opcode,0},
	{"fmadd.d",0,INSN_CLASS_D_INX,"D,S,T,R,m",MATCH_FMADD_D,MASK_FMADD_D,match_opcode,0},
	{"fnmadd.d",0,INSN_CLASS_D_INX,"D,S,T,R",MATCH_FNMADD_D|MASK_RM,MASK_FNMADD_D|MASK_RM,match_opcode,0},
	{"fnmadd.d",0,INSN_CLASS_D_INX,"D,S,T,R,m",MATCH_FNMADD_D,MASK_FNMADD_D,match_opcode,0},
	{"fmsub.d",0,INSN_CLASS_D_INX,"D,S,T,R",MATCH_FMSUB_D|MASK_RM,MASK_FMSUB_D|MASK_RM,match_opcode,0},
	{"fmsub.d",0,INSN_CLASS_D_INX,"D,S,T,R,m",MATCH_FMSUB_D,MASK_FMSUB_D,match_opcode,0},
	{"fnmsub.d",0,INSN_CLASS_D_INX,"D,S,T,R",MATCH_FNMSUB_D|MASK_RM,MASK_FNMSUB_D|MASK_RM,match_opcode,0},
	{"fnmsub.d",0,INSN_CLASS_D_INX,"D,S,T,R,m",MATCH_FNMSUB_D,MASK_FNMSUB_D,match_opcode,0},
	{"fcvt.w.d",0,INSN_CLASS_D_INX,"d,S",MATCH_FCVT_W_D|MASK_RM,MASK_FCVT_W_D|MASK_RM,match_opcode,0},
	{"fcvt.w.d",0,INSN_CLASS_D_INX,"d,S,m",MATCH_FCVT_W_D,MASK_FCVT_W_D,match_opcode,0},
	{"fcvt.wu.d",0,INSN_CLASS_D_INX,"d,S",MATCH_FCVT_WU_D|MASK_RM,MASK_FCVT_WU_D|MASK_RM,match_opcode,0},
	{"fcvt.wu.d",0,INSN_CLASS_D_INX,"d,S,m",MATCH_FCVT_WU_D,MASK_FCVT_WU_D,match_opcode,0},
	{"fcvt.d.w",0,INSN_CLASS_D_INX,"D,s",MATCH_FCVT_D_W,MASK_FCVT_D_W|MASK_RM,match_opcode,0},
	{"fcvt.d.wu",0,INSN_CLASS_D_INX,"D,s",MATCH_FCVT_D_WU,MASK_FCVT_D_WU|MASK_RM,match_opcode,0},
	{"fcvt.d.s",0,INSN_CLASS_D_INX,"D,S",MATCH_FCVT_D_S,MASK_FCVT_D_S|MASK_RM,match_opcode,0},
	{"fcvt.s.d",0,INSN_CLASS_D_INX,"D,S",MATCH_FCVT_S_D|MASK_RM,MASK_FCVT_S_D|MASK_RM,match_opcode,0},
	{"fcvt.s.d",0,INSN_CLASS_D_INX,"D,S,m",MATCH_FCVT_S_D,MASK_FCVT_S_D,match_opcode,0},
	{"fclass.d",0,INSN_CLASS_D_INX,"d,S",MATCH_FCLASS_D,MASK_FCLASS_D,match_opcode,0},
	{"feq.d",0,INSN_CLASS_D_INX,"d,S,T",MATCH_FEQ_D,MASK_FEQ_D,match_opcode,0},
	{"flt.d",0,INSN_CLASS_D_INX,"d,S,T",MATCH_FLT_D,MASK_FLT_D,match_opcode,0},
	{"fle.d",0,INSN_CLASS_D_INX,"d,S,T",MATCH_FLE_D,MASK_FLE_D,match_opcode,0},
	{"fgt.d",0,INSN_CLASS_D_INX,"d,T,S",MATCH_FLT_D,MASK_FLT_D,match_opcode,0},
	{"fge.d",0,INSN_CLASS_D_INX,"d,T,S",MATCH_FLE_D,MASK_FLE_D,match_opcode,0},
	{"fmv.x.d",64,INSN_CLASS_D,"d,S",MATCH_FMV_X_D,MASK_FMV_X_D,match_opcode,0},
	{"fmv.d.x",64,INSN_CLASS_D,"D,s",MATCH_FMV_D_X,MASK_FMV_D_X,match_opcode,0},
	{"fcvt.l.d",64,INSN_CLASS_D_INX,"d,S",MATCH_FCVT_L_D|MASK_RM,MASK_FCVT_L_D|MASK_RM,match_opcode,0},
	{"fcvt.l.d",64,INSN_CLASS_D_INX,"d,S,m",MATCH_FCVT_L_D,MASK_FCVT_L_D,match_opcode,0},
	{"fcvt.lu.d",64,INSN_CLASS_D_INX,"d,S",MATCH_FCVT_LU_D|MASK_RM,MASK_FCVT_LU_D|MASK_RM,match_opcode,0},
	{"fcvt.lu.d",64,INSN_CLASS_D_INX,"d,S,m",MATCH_FCVT_LU_D,MASK_FCVT_LU_D,match_opcode,0},
	{"fcvt.d.l",64,INSN_CLASS_D_INX,"D,s",MATCH_FCVT_D_L|MASK_RM,MASK_FCVT_D_L|MASK_RM,match_opcode,0},
	{"fcvt.d.l",64,INSN_CLASS_D_INX,"D,s,m",MATCH_FCVT_D_L,MASK_FCVT_D_L,match_opcode,0},
	{"fcvt.d.lu",64,INSN_CLASS_D_INX,"D,s",MATCH_FCVT_D_LU|MASK_RM,MASK_FCVT_D_LU|MASK_RM,match_opcode,0},
	{"fcvt.d.lu",64,INSN_CLASS_D_INX,"D,s,m",MATCH_FCVT_D_LU,MASK_FCVT_D_LU,match_opcode,0},

	/* Quad-precision floating-point instruction subset.  */
	{"flq",0,INSN_CLASS_Q,"D,o(s)",MATCH_FLQ,MASK_FLQ,match_opcode,INSN_DREF|INSN_16_BYTE},
	{"flq",0,INSN_CLASS_Q,"D,A,s",0,(int)M_FLQ,match_never,INSN_MACRO},
	{"fsq",0,INSN_CLASS_Q,"T,q(s)",MATCH_FSQ,MASK_FSQ,match_opcode,INSN_DREF|INSN_16_BYTE},
	{"fsq",0,INSN_CLASS_Q,"T,A,s",0,(int)M_FSQ,match_never,INSN_MACRO},
	{"fmv.q",0,INSN_CLASS_Q_INX,"D,U",MATCH_FSGNJ_Q,MASK_FSGNJ_Q,match_rs1_eq_rs2,INSN_ALIAS},
	{"fneg.q",0,INSN_CLASS_Q_INX,"D,U",MATCH_FSGNJN_Q,MASK_FSGNJN_Q,match_rs1_eq_rs2,INSN_ALIAS},
	{"fabs.q",0,INSN_CLASS_Q_INX,"D,U",MATCH_FSGNJX_Q,MASK_FSGNJX_Q,match_rs1_eq_rs2,INSN_ALIAS},
	{"fsgnj.q",0,INSN_CLASS_Q_INX,"D,S,T",MATCH_FSGNJ_Q,MASK_FSGNJ_Q,match_opcode,0},
	{"fsgnjn.q",0,INSN_CLASS_Q_INX,"D,S,T",MATCH_FSGNJN_Q,MASK_FSGNJN_Q,match_opcode,0},
	{"fsgnjx.q",0,INSN_CLASS_Q_INX,"D,S,T",MATCH_FSGNJX_Q,MASK_FSGNJX_Q,match_opcode,0},
	{"fadd.q",0,INSN_CLASS_Q_INX,"D,S,T",MATCH_FADD_Q|MASK_RM,MASK_FADD_Q|MASK_RM,match_opcode,0},
	{"fadd.q",0,INSN_CLASS_Q_INX,"D,S,T,m",MATCH_FADD_Q,MASK_FADD_Q,match_opcode,0},
	{"fsub.q",0,INSN_CLASS_Q_INX,"D,S,T",MATCH_FSUB_Q|MASK_RM,MASK_FSUB_Q|MASK_RM,match_opcode,0},
	{"fsub.q",0,INSN_CLASS_Q_INX,"D,S,T,m",MATCH_FSUB_Q,MASK_FSUB_Q,match_opcode,0},
	{"fmul.q",0,INSN_CLASS_Q_INX,"D,S,T",MATCH_FMUL_Q|MASK_RM,MASK_FMUL_Q|MASK_RM,match_opcode,0},
	{"fmul.q",0,INSN_CLASS_Q_INX,"D,S,T,m",MATCH_FMUL_Q,MASK_FMUL_Q,match_opcode,0},
	{"fdiv.q",0,INSN_CLASS_Q_INX,"D,S,T",MATCH_FDIV_Q|MASK_RM,MASK_FDIV_Q|MASK_RM,match_opcode,0},
	{"fdiv.q",0,INSN_CLASS_Q_INX,"D,S,T,m",MATCH_FDIV_Q,MASK_FDIV_Q,match_opcode,0},
	{"fsqrt.q",0,INSN_CLASS_Q_INX,"D,S",MATCH_FSQRT_Q|MASK_RM,MASK_FSQRT_Q|MASK_RM,match_opcode,0},
	{"fsqrt.q",0,INSN_CLASS_Q_INX,"D,S,m",MATCH_FSQRT_Q,MASK_FSQRT_Q,match_opcode,0},
	{"fmin.q",0,INSN_CLASS_Q_INX,"D,S,T",MATCH_FMIN_Q,MASK_FMIN_Q,match_opcode,0},
	{"fmax.q",0,INSN_CLASS_Q_INX,"D,S,T",MATCH_FMAX_Q,MASK_FMAX_Q,match_opcode,0},
	{"fmadd.q",0,INSN_CLASS_Q_INX,"D,S,T,R",MATCH_FMADD_Q|MASK_RM,MASK_FMADD_Q|MASK_RM,match_opcode,0},
	{"fmadd.q",0,INSN_CLASS_Q_INX,"D,S,T,R,m",MATCH_FMADD_Q,MASK_FMADD_Q,match_opcode,0},
	{"fnmadd.q",0,INSN_CLASS_Q_INX,"D,S,T,R",MATCH_FNMADD_Q|MASK_RM,MASK_FNMADD_Q|MASK_RM,match_opcode,0},
	{"fnmadd.q",0,INSN_CLASS_Q_INX,"D,S,T,R,m",MATCH_FNMADD_Q,MASK_FNMADD_Q,match_opcode,0},
	{"fmsub.q",0,INSN_CLASS_Q_INX,"D,S,T,R",MATCH_FMSUB_Q|MASK_RM,MASK_FMSUB_Q|MASK_RM,match_opcode,0},
	{"fmsub.q",0,INSN_CLASS_Q_INX,"D,S,T,R,m",MATCH_FMSUB_Q,MASK_FMSUB_Q,match_opcode,0},
	{"fnmsub.q",0,INSN_CLASS_Q_INX,"D,S,T,R",MATCH_FNMSUB_Q|MASK_RM,MASK_FNMSUB_Q|MASK_RM,match_opcode,0},
	{"fnmsub.q",0,INSN_CLASS_Q_INX,"D,S,T,R,m",MATCH_FNMSUB_Q,MASK_FNMSUB_Q,match_opcode,0},
	{"fcvt.w.q",0,INSN_CLASS_Q_INX,"d,S",MATCH_FCVT_W_Q|MASK_RM,MASK_FCVT_W_Q|MASK_RM,match_opcode,0},
	{"fcvt.w.q",0,INSN_CLASS_Q_INX,"d,S,m",MATCH_FCVT_W_Q,MASK_FCVT_W_Q,match_opcode,0},
	{"fcvt.wu.q",0,INSN_CLASS_Q_INX,"d,S",MATCH_FCVT_WU_Q|MASK_RM,MASK_FCVT_WU_Q|MASK_RM,match_opcode,0},
	{"fcvt.wu.q",0,INSN_CLASS_Q_INX,"d,S,m",MATCH_FCVT_WU_Q,MASK_FCVT_WU_Q,match_opcode,0},
	{"fcvt.q.w",0,INSN_CLASS_Q_INX,"D,s",MATCH_FCVT_Q_W,MASK_FCVT_Q_W|MASK_RM,match_opcode,0},
	{"fcvt.q.wu",0,INSN_CLASS_Q_INX,"D,s",MATCH_FCVT_Q_WU,MASK_FCVT_Q_WU|MASK_RM,match_opcode,0},
	{"fcvt.q.s",0,INSN_CLASS_Q_INX,"D,S",MATCH_FCVT_Q_S,MASK_FCVT_Q_S|MASK_RM,match_opcode,0},
	{"fcvt.q.d",0,INSN_CLASS_Q_INX,"D,S",MATCH_FCVT_Q_D,MASK_FCVT_Q_D|MASK_RM,match_opcode,0},
	{"fcvt.s.q",0,INSN_CLASS_Q_INX,"D,S",MATCH_FCVT_S_Q|MASK_RM,MASK_FCVT_S_Q|MASK_RM,match_opcode,0},
	{"fcvt.s.q",0,INSN_CLASS_Q_INX,"D,S,m",MATCH_FCVT_S_Q,MASK_FCVT_S_Q,match_opcode,0},
	{"fcvt.d.q",0,INSN_CLASS_Q_INX,"D,S",MATCH_FCVT_D_Q|MASK_RM,MASK_FCVT_D_Q|MASK_RM,match_opcode,0},
	{"fcvt.d.q",0,INSN_CLASS_Q_INX,"D,S,m",MATCH_FCVT_D_Q,MASK_FCVT_D_Q,match_opcode,0},
	{"fclass.q",0,INSN_CLASS_Q_INX,"d,S",MATCH_FCLASS_Q,MASK_FCLASS_Q,match_opcode,0},
	{"feq.q",0,INSN_CLASS_Q_INX,"d,S,T",MATCH_FEQ_Q,MASK_FEQ_Q,match_opcode,0},
	{"flt.q",0,INSN_CLASS_Q_INX,"d,S,T",MATCH_FLT_Q,MASK_FLT_Q,match_opcode,0},
	{"fle.q",0,INSN_CLASS_Q_INX,"d,S,T",MATCH_FLE_Q,MASK_FLE_Q,match_opcode,0},
	{"fgt.q",0,INSN_CLASS_Q_INX,"d,T,S",MATCH_FLT_Q,MASK_FLT_Q,match_opcode,0},
	{"fge.q",0,INSN_CLASS_Q_INX,"d,T,S",MATCH_FLE_Q,MASK_FLE_Q,match_opcode,0},
	{"fcvt.l.q",64,INSN_CLASS_Q_INX,"d,S",MATCH_FCVT_L_Q|MASK_RM,MASK_FCVT_L_Q|MASK_RM,match_opcode,0},
	{"fcvt.l.q",64,INSN_CLASS_Q_INX,"d,S,m",MATCH_FCVT_L_Q,MASK_FCVT_L_Q,match_opcode,0},
	{"fcvt.lu.q",64,INSN_CLASS_Q_INX,"d,S",MATCH_FCVT_LU_Q|MASK_RM,MASK_FCVT_LU_Q|MASK_RM,match_opcode,0},
	{"fcvt.lu.q",64,INSN_CLASS_Q_INX,"d,S,m",MATCH_FCVT_LU_Q,MASK_FCVT_LU_Q,match_opcode,0},
	{"fcvt.q.l",64,INSN_CLASS_Q_INX,"D,s",MATCH_FCVT_Q_L,MASK_FCVT_Q_L|MASK_RM,match_opcode,0},
	{"fcvt.q.l",64,INSN_CLASS_Q_INX,"D,s,m",MATCH_FCVT_Q_L,MASK_FCVT_Q_L,match_opcode,0},
	{"fcvt.q.lu",64,INSN_CLASS_Q_INX,"D,s",MATCH_FCVT_Q_LU,MASK_FCVT_Q_LU|MASK_RM,match_opcode,0},
	{"fcvt.q.lu",64,INSN_CLASS_Q_INX,"D,s,m",MATCH_FCVT_Q_LU,MASK_FCVT_Q_LU,match_opcode,0},

	/* Compressed instructions.  */
	{"c.unimp",0,INSN_CLASS_C,"",0,0xffffU,match_opcode,0},
	{"c.ebreak",0,INSN_CLASS_C,"",MATCH_C_EBREAK,MASK_C_EBREAK,match_opcode,0},
	{"c.jr",0,INSN_CLASS_C,"d",MATCH_C_JR,MASK_C_JR,match_rd_nonzero,INSN_BRANCH},
	{"c.jalr",0,INSN_CLASS_C,"d",MATCH_C_JALR,MASK_C_JALR,match_rd_nonzero,INSN_JSR},
	{"c.j",0,INSN_CLASS_C,"Ca",MATCH_C_J,MASK_C_J,match_opcode,INSN_BRANCH},
	{"c.jal",32,INSN_CLASS_C,"Ca",MATCH_C_JAL,MASK_C_JAL,match_opcode,INSN_JSR},
	{"c.beqz",0,INSN_CLASS_C,"Cs,Cp",MATCH_C_BEQZ,MASK_C_BEQZ,match_opcode,INSN_CONDBRANCH},
	{"c.bnez",0,INSN_CLASS_C,"Cs,Cp",MATCH_C_BNEZ,MASK_C_BNEZ,match_opcode,INSN_CONDBRANCH},
	{"c.lwsp",0,INSN_CLASS_C,"d,Cm(Cc)",MATCH_C_LWSP,MASK_C_LWSP,match_rd_nonzero,0},
	{"c.lw",0,INSN_CLASS_C,"Ct,Ck(Cs)",MATCH_C_LW,MASK_C_LW,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"c.swsp",0,INSN_CLASS_C,"CV,CM(Cc)",MATCH_C_SWSP,MASK_C_SWSP,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"c.sw",0,INSN_CLASS_C,"Ct,Ck(Cs)",MATCH_C_SW,MASK_C_SW,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"c.nop",0,INSN_CLASS_C,"",MATCH_C_ADDI,0xffff,match_opcode,INSN_ALIAS},
	{"c.nop",0,INSN_CLASS_C,"Cj",MATCH_C_ADDI,MASK_C_ADDI|MASK_RD,match_opcode,INSN_ALIAS},
	{"c.mv",0,INSN_CLASS_C,"d,CV",MATCH_C_MV,MASK_C_MV,match_c_add_with_hint,0},
	{"c.lui",0,INSN_CLASS_C,"d,Cu",MATCH_C_LUI,MASK_C_LUI,match_c_lui_with_hint,0},
	{"c.li",0,INSN_CLASS_C,"d,Co",MATCH_C_LI,MASK_C_LI,match_opcode,0},
	{"c.addi4spn",0,INSN_CLASS_C,"Ct,Cc,CK",MATCH_C_ADDI4SPN,MASK_C_ADDI4SPN,match_c_addi4spn,0},
	{"c.addi16sp",0,INSN_CLASS_C,"Cc,CL",MATCH_C_ADDI16SP,MASK_C_ADDI16SP,match_c_addi16sp,0},
	{"c.addi",0,INSN_CLASS_C,"d,Co",MATCH_C_ADDI,MASK_C_ADDI,match_opcode,0},
	{"c.add",0,INSN_CLASS_C,"d,CV",MATCH_C_ADD,MASK_C_ADD,match_c_add_with_hint,0},
	{"c.sub",0,INSN_CLASS_C,"Cs,Ct",MATCH_C_SUB,MASK_C_SUB,match_opcode,0},
	{"c.and",0,INSN_CLASS_C,"Cs,Ct",MATCH_C_AND,MASK_C_AND,match_opcode,0},
	{"c.or",0,INSN_CLASS_C,"Cs,Ct",MATCH_C_OR,MASK_C_OR,match_opcode,0},
	{"c.xor",0,INSN_CLASS_C,"Cs,Ct",MATCH_C_XOR,MASK_C_XOR,match_opcode,0},
	{"c.slli",0,INSN_CLASS_C,"d,C>",MATCH_C_SLLI,MASK_C_SLLI,match_c_slli,0},
	{"c.srli",0,INSN_CLASS_C,"Cs,C>",MATCH_C_SRLI,MASK_C_SRLI,match_c_slli,0},
	{"c.srai",0,INSN_CLASS_C,"Cs,C>",MATCH_C_SRAI,MASK_C_SRAI,match_c_slli,0},
	{"c.slli64",0,INSN_CLASS_C,"d",MATCH_C_SLLI64,MASK_C_SLLI64,match_c_slli64,0},
	{"c.srli64",0,INSN_CLASS_C,"Cs",MATCH_C_SRLI64,MASK_C_SRLI64,match_c_slli64,0},
	{"c.srai64",0,INSN_CLASS_C,"Cs",MATCH_C_SRAI64,MASK_C_SRAI64,match_c_slli64,0},
	{"c.andi",0,INSN_CLASS_C,"Cs,Co",MATCH_C_ANDI,MASK_C_ANDI,match_opcode,0},
	{"c.addiw",64,INSN_CLASS_C,"d,Co",MATCH_C_ADDIW,MASK_C_ADDIW,match_rd_nonzero,0},
	{"c.addw",64,INSN_CLASS_C,"Cs,Ct",MATCH_C_ADDW,MASK_C_ADDW,match_opcode,0},
	{"c.subw",64,INSN_CLASS_C,"Cs,Ct",MATCH_C_SUBW,MASK_C_SUBW,match_opcode,0},
	{"c.ldsp",64,INSN_CLASS_C,"d,Cn(Cc)",MATCH_C_LDSP,MASK_C_LDSP,match_rd_nonzero,INSN_DREF|INSN_8_BYTE},
	{"c.ld",64,INSN_CLASS_C,"Ct,Cl(Cs)",MATCH_C_LD,MASK_C_LD,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"c.sdsp",64,INSN_CLASS_C,"CV,CN(Cc)",MATCH_C_SDSP,MASK_C_SDSP,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"c.sd",64,INSN_CLASS_C,"Ct,Cl(Cs)",MATCH_C_SD,MASK_C_SD,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"c.fldsp",0,INSN_CLASS_D_AND_C,"D,Cn(Cc)",MATCH_C_FLDSP,MASK_C_FLDSP,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"c.fld",0,INSN_CLASS_D_AND_C,"CD,Cl(Cs)",MATCH_C_FLD,MASK_C_FLD,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"c.fsdsp",0,INSN_CLASS_D_AND_C,"CT,CN(Cc)",MATCH_C_FSDSP,MASK_C_FSDSP,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"c.fsd",0,INSN_CLASS_D_AND_C,"CD,Cl(Cs)",MATCH_C_FSD,MASK_C_FSD,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"c.flwsp",32,INSN_CLASS_F_AND_C,"D,Cm(Cc)",MATCH_C_FLWSP,MASK_C_FLWSP,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"c.flw",32,INSN_CLASS_F_AND_C,"CD,Ck(Cs)",MATCH_C_FLW,MASK_C_FLW,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"c.fswsp",32,INSN_CLASS_F_AND_C,"CT,CM(Cc)",MATCH_C_FSWSP,MASK_C_FSWSP,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"c.fsw",32,INSN_CLASS_F_AND_C,"CD,Ck(Cs)",MATCH_C_FSW,MASK_C_FSW,match_opcode,INSN_DREF|INSN_4_BYTE},

	/* Zicbom and Zicboz instructions.  */
	{"cbo.clean",0,INSN_CLASS_ZICBOM,"0(s)",MATCH_CBO_CLEAN,MASK_CBO_CLEAN,match_opcode,0},
	{"cbo.flush",0,INSN_CLASS_ZICBOM,"0(s)",MATCH_CBO_FLUSH,MASK_CBO_FLUSH,match_opcode,0},
	{"cbo.inval",0,INSN_CLASS_ZICBOM,"0(s)",MATCH_CBO_INVAL,MASK_CBO_INVAL,match_opcode,0},
	{"cbo.zero",0,INSN_CLASS_ZICBOZ,"0(s)",MATCH_CBO_ZERO,MASK_CBO_ZERO,match_opcode,0},

	/* Zawrs instructions.  */
	{"wrs.nto",0,INSN_CLASS_ZAWRS,"",MATCH_WRS_NTO,MASK_WRS_NTO,match_opcode,0},
	{"wrs.sto",0,INSN_CLASS_ZAWRS,"",MATCH_WRS_STO,MASK_WRS_STO,match_opcode,0},

	/* Zbb or zbkb instructions.  */
	{"clz",0,INSN_CLASS_ZBB,"d,s",MATCH_CLZ,MASK_CLZ,match_opcode,0},
	{"ctz",0,INSN_CLASS_ZBB,"d,s",MATCH_CTZ,MASK_CTZ,match_opcode,0},
	{"cpop",0,INSN_CLASS_ZBB,"d,s",MATCH_CPOP,MASK_CPOP,match_opcode,0},
	{"min",0,INSN_CLASS_ZBB,"d,s,t",MATCH_MIN,MASK_MIN,match_opcode,0},
	{"max",0,INSN_CLASS_ZBB,"d,s,t",MATCH_MAX,MASK_MAX,match_opcode,0},
	{"minu",0,INSN_CLASS_ZBB,"d,s,t",MATCH_MINU,MASK_MINU,match_opcode,0},
	{"maxu",0,INSN_CLASS_ZBB,"d,s,t",MATCH_MAXU,MASK_MAXU,match_opcode,0},
	{"sext.b",0,INSN_CLASS_ZBB,"d,s",MATCH_SEXT_B,MASK_SEXT_B,match_opcode,0},
	{"sext.b",0,INSN_CLASS_I,"d,s",0,(int)M_SEXTB,match_never,INSN_MACRO},
	{"sext.h",0,INSN_CLASS_ZBB,"d,s",MATCH_SEXT_H,MASK_SEXT_H,match_opcode,0},
	{"sext.h",0,INSN_CLASS_I,"d,s",0,(int)M_SEXTH,match_never,INSN_MACRO},
	{"zext.h",32,INSN_CLASS_ZBB,"d,s",MATCH_PACK,MASK_PACK|MASK_RS2,match_opcode,0},
	{"zext.h",64,INSN_CLASS_ZBB,"d,s",MATCH_PACKW,MASK_PACKW|MASK_RS2,match_opcode,0},
	{"zext.h",0,INSN_CLASS_I,"d,s",0,(int)M_ZEXTH,match_never,INSN_MACRO},
	{"orc.b",0,INSN_CLASS_ZBB,"d,s",MATCH_GORCI|MATCH_SHAMT_ORC_B,MASK_GORCI|MASK_SHAMT,match_opcode,0},
	{"clzw",64,INSN_CLASS_ZBB,"d,s",MATCH_CLZW,MASK_CLZW,match_opcode,0},
	{"ctzw",64,INSN_CLASS_ZBB,"d,s",MATCH_CTZW,MASK_CTZW,match_opcode,0},
	{"cpopw",64,INSN_CLASS_ZBB,"d,s",MATCH_CPOPW,MASK_CPOPW,match_opcode,0},
	{"brev8",32,INSN_CLASS_ZBKB,"d,s",MATCH_GREVI|MATCH_SHAMT_BREV8,MASK_GREVI|MASK_SHAMT,match_opcode,0},
	{"brev8",64,INSN_CLASS_ZBKB,"d,s",MATCH_GREVI|MATCH_SHAMT_BREV8,MASK_GREVI|MASK_SHAMT,match_opcode,0},
	{"zip",32,INSN_CLASS_ZBKB,"d,s",MATCH_SHFLI|MATCH_SHAMT_ZIP_32,MASK_SHFLI|MASK_SHAMT,match_opcode,0},
	{"unzip",32,INSN_CLASS_ZBKB,"d,s",MATCH_UNSHFLI|MATCH_SHAMT_ZIP_32,MASK_UNSHFLI|MASK_SHAMT,match_opcode,0},
	{"pack",0,INSN_CLASS_ZBKB,"d,s,t",MATCH_PACK,MASK_PACK,match_opcode,0},
	{"packh",0,INSN_CLASS_ZBKB,"d,s,t",MATCH_PACKH,MASK_PACKH,match_opcode,0},
	{"packw",64,INSN_CLASS_ZBKB,"d,s,t",MATCH_PACKW,MASK_PACKW,match_opcode,0},
	{"andn",0,INSN_CLASS_ZBB_OR_ZBKB,"d,s,t",MATCH_ANDN,MASK_ANDN,match_opcode,0},
	{"orn",0,INSN_CLASS_ZBB_OR_ZBKB,"d,s,t",MATCH_ORN,MASK_ORN,match_opcode,0},
	{"xnor",0,INSN_CLASS_ZBB_OR_ZBKB,"d,s,t",MATCH_XNOR,MASK_XNOR,match_opcode,0},
	{"rol",0,INSN_CLASS_ZBB_OR_ZBKB,"d,s,t",MATCH_ROL,MASK_ROL,match_opcode,0},
	{"ror",0,INSN_CLASS_ZBB_OR_ZBKB,"d,s,t",MATCH_ROR,MASK_ROR,match_opcode,0},
	{"ror",0,INSN_CLASS_ZBB_OR_ZBKB,"d,s,>",MATCH_RORI,MASK_RORI,match_opcode,INSN_ALIAS},
	{"rori",0,INSN_CLASS_ZBB_OR_ZBKB,"d,s,>",MATCH_RORI,MASK_RORI,match_opcode,0},
	{"rev8",32,INSN_CLASS_ZBB_OR_ZBKB,"d,s",MATCH_GREVI|MATCH_SHAMT_REV8_32,MASK_GREVI|MASK_SHAMT,match_opcode,0},
	{"rev8",64,INSN_CLASS_ZBB_OR_ZBKB,"d,s",MATCH_GREVI|MATCH_SHAMT_REV8_64,MASK_GREVI|MASK_SHAMT,match_opcode,0},
	{"rolw",64,INSN_CLASS_ZBB_OR_ZBKB,"d,s,t",MATCH_ROLW,MASK_ROLW,match_opcode,0},
	{"rorw",64,INSN_CLASS_ZBB_OR_ZBKB,"d,s,t",MATCH_RORW,MASK_RORW,match_opcode,0},
	{"rorw",64,INSN_CLASS_ZBB_OR_ZBKB,"d,s,<",MATCH_RORIW,MASK_RORIW,match_opcode,INSN_ALIAS},
	{"roriw",64,INSN_CLASS_ZBB_OR_ZBKB,"d,s,<",MATCH_RORIW,MASK_RORIW,match_opcode,0},

	/* Zba instructions.  */
	{"sh1add",0,INSN_CLASS_ZBA,"d,s,t",MATCH_SH1ADD,MASK_SH1ADD,match_opcode,0},
	{"sh2add",0,INSN_CLASS_ZBA,"d,s,t",MATCH_SH2ADD,MASK_SH2ADD,match_opcode,0},
	{"sh3add",0,INSN_CLASS_ZBA,"d,s,t",MATCH_SH3ADD,MASK_SH3ADD,match_opcode,0},
	{"sh1add.uw",64,INSN_CLASS_ZBA,"d,s,t",MATCH_SH1ADD_UW,MASK_SH1ADD_UW,match_opcode,0},
	{"sh2add.uw",64,INSN_CLASS_ZBA,"d,s,t",MATCH_SH2ADD_UW,MASK_SH2ADD_UW,match_opcode,0},
	{"sh3add.uw",64,INSN_CLASS_ZBA,"d,s,t",MATCH_SH3ADD_UW,MASK_SH3ADD_UW,match_opcode,0},
	{"zext.w",64,INSN_CLASS_ZBA,"d,s",MATCH_ADD_UW,MASK_ADD_UW|MASK_RS2,match_opcode,INSN_ALIAS},
	{"zext.w",64,INSN_CLASS_I,"d,s",0,(int)M_ZEXTW,match_never,INSN_MACRO},
	{"add.uw",64,INSN_CLASS_ZBA,"d,s,t",MATCH_ADD_UW,MASK_ADD_UW,match_opcode,0},
	{"slli.uw",64,INSN_CLASS_ZBA,"d,s,>",MATCH_SLLI_UW,MASK_SLLI_UW,match_opcode,0},

	/* Zbc or zbkc instructions.  */
	{"clmul",0,INSN_CLASS_ZBC_OR_ZBKC,"d,s,t",MATCH_CLMUL,MASK_CLMUL,match_opcode,0},
	{"clmulh",0,INSN_CLASS_ZBC_OR_ZBKC,"d,s,t",MATCH_CLMULH,MASK_CLMULH,match_opcode,0},
	{"clmulr",0,INSN_CLASS_ZBC,"d,s,t",MATCH_CLMULR,MASK_CLMULR,match_opcode,0},

	/* Zbs instructions.  */
	{"bclr",0,INSN_CLASS_ZBS,"d,s,t",MATCH_BCLR,MASK_BCLR,match_opcode,0},
	{"bclr",0,INSN_CLASS_ZBS,"d,s,>",MATCH_BCLRI,MASK_BCLRI,match_opcode,INSN_ALIAS},
	{"bclri",0,INSN_CLASS_ZBS,"d,s,>",MATCH_BCLRI,MASK_BCLRI,match_opcode,0},
	{"bset",0,INSN_CLASS_ZBS,"d,s,t",MATCH_BSET,MASK_BSET,match_opcode,0},
	{"bset",0,INSN_CLASS_ZBS,"d,s,>",MATCH_BSETI,MASK_BSETI,match_opcode,INSN_ALIAS},
	{"bseti",0,INSN_CLASS_ZBS,"d,s,>",MATCH_BSETI,MASK_BSETI,match_opcode,0},
	{"binv",0,INSN_CLASS_ZBS,"d,s,t",MATCH_BINV,MASK_BINV,match_opcode,0},
	{"binv",0,INSN_CLASS_ZBS,"d,s,>",MATCH_BINVI,MASK_BINVI,match_opcode,INSN_ALIAS},
	{"binvi",0,INSN_CLASS_ZBS,"d,s,>",MATCH_BINVI,MASK_BINVI,match_opcode,0},
	{"bext",0,INSN_CLASS_ZBS,"d,s,t",MATCH_BEXT,MASK_BEXT,match_opcode,0},
	{"bext",0,INSN_CLASS_ZBS,"d,s,>",MATCH_BEXTI,MASK_BEXTI,match_opcode,INSN_ALIAS},
	{"bexti",0,INSN_CLASS_ZBS,"d,s,>",MATCH_BEXTI,MASK_BEXTI,match_opcode,0},

	/* Zbkx instructions.  */
	{"xperm4",0,INSN_CLASS_ZBKX,"d,s,t",MATCH_XPERM4,MASK_XPERM4,match_opcode,0},
	{"xperm8",0,INSN_CLASS_ZBKX,"d,s,t",MATCH_XPERM8,MASK_XPERM8,match_opcode,0},

	/* Zknd instructions.  */
	{"aes32dsi",32,INSN_CLASS_ZKND,"d,s,t,y",MATCH_AES32DSI,MASK_AES32DSI,match_opcode,0},
	{"aes32dsmi",32,INSN_CLASS_ZKND,"d,s,t,y",MATCH_AES32DSMI,MASK_AES32DSMI,match_opcode,0},
	{"aes64ds",64,INSN_CLASS_ZKND,"d,s,t",MATCH_AES64DS,MASK_AES64DS,match_opcode,0},
	{"aes64dsm",64,INSN_CLASS_ZKND,"d,s,t",MATCH_AES64DSM,MASK_AES64DSM,match_opcode,0},
	{"aes64im",64,INSN_CLASS_ZKND,"d,s",MATCH_AES64IM,MASK_AES64IM,match_opcode,0},
	{"aes64ks1i",64,INSN_CLASS_ZKND_OR_ZKNE,"d,s,Y",MATCH_AES64KS1I,MASK_AES64KS1I,match_opcode,0},
	{"aes64ks2",64,INSN_CLASS_ZKND_OR_ZKNE,"d,s,t",MATCH_AES64KS2,MASK_AES64KS2,match_opcode,0},

	/* Zkne instructions.  */
	{"aes32esi",32,INSN_CLASS_ZKNE,"d,s,t,y",MATCH_AES32ESI,MASK_AES32ESI,match_opcode,0},
	{"aes32esmi",32,INSN_CLASS_ZKNE,"d,s,t,y",MATCH_AES32ESMI,MASK_AES32ESMI,match_opcode,0},
	{"aes64es",64,INSN_CLASS_ZKNE,"d,s,t",MATCH_AES64ES,MASK_AES64ES,match_opcode,0},
	{"aes64esm",64,INSN_CLASS_ZKNE,"d,s,t",MATCH_AES64ESM,MASK_AES64ESM,match_opcode,0},

	/* Zknh instructions.  */
	{"sha256sig0",0,INSN_CLASS_ZKNH,"d,s",MATCH_SHA256SIG0,MASK_SHA256SIG0,match_opcode,0},
	{"sha256sig1",0,INSN_CLASS_ZKNH,"d,s",MATCH_SHA256SIG1,MASK_SHA256SIG1,match_opcode,0},
	{"sha256sum0",0,INSN_CLASS_ZKNH,"d,s",MATCH_SHA256SUM0,MASK_SHA256SUM0,match_opcode,0},
	{"sha256sum1",0,INSN_CLASS_ZKNH,"d,s",MATCH_SHA256SUM1,MASK_SHA256SUM1,match_opcode,0},
	{"sha512sig0h",32,INSN_CLASS_ZKNH,"d,s,t",MATCH_SHA512SIG0H,MASK_SHA512SIG0H,match_opcode,0},
	{"sha512sig0l",32,INSN_CLASS_ZKNH,"d,s,t",MATCH_SHA512SIG0L,MASK_SHA512SIG0L,match_opcode,0},
	{"sha512sig1h",32,INSN_CLASS_ZKNH,"d,s,t",MATCH_SHA512SIG1H,MASK_SHA512SIG1H,match_opcode,0},
	{"sha512sig1l",32,INSN_CLASS_ZKNH,"d,s,t",MATCH_SHA512SIG1L,MASK_SHA512SIG1L,match_opcode,0},
	{"sha512sum0r",32,INSN_CLASS_ZKNH,"d,s,t",MATCH_SHA512SUM0R,MASK_SHA512SUM0R,match_opcode,0},
	{"sha512sum1r",32,INSN_CLASS_ZKNH,"d,s,t",MATCH_SHA512SUM1R,MASK_SHA512SUM1R,match_opcode,0},
	{"sha512sig0",64,INSN_CLASS_ZKNH,"d,s",MATCH_SHA512SIG0,MASK_SHA512SIG0,match_opcode,0},
	{"sha512sig1",64,INSN_CLASS_ZKNH,"d,s",MATCH_SHA512SIG1,MASK_SHA512SIG1,match_opcode,0},
	{"sha512sum0",64,INSN_CLASS_ZKNH,"d,s",MATCH_SHA512SUM0,MASK_SHA512SUM0,match_opcode,0},
	{"sha512sum1",64,INSN_CLASS_ZKNH,"d,s",MATCH_SHA512SUM1,MASK_SHA512SUM1,match_opcode,0},

	/* Zksed instructions.  */
	{"sm4ed",0,INSN_CLASS_ZKSED,"d,s,t,y",MATCH_SM4ED,MASK_SM4ED,match_opcode,0},
	{"sm4ks",0,INSN_CLASS_ZKSED,"d,s,t,y",MATCH_SM4KS,MASK_SM4KS,match_opcode,0},

	/* Zksh instructions  */
	{"sm3p0",0,INSN_CLASS_ZKSH,"d,s",MATCH_SM3P0,MASK_SM3P0,match_opcode,0},
	{"sm3p1",0,INSN_CLASS_ZKSH,"d,s",MATCH_SM3P1,MASK_SM3P1,match_opcode,0},

	/* RVV instructions.  */
	{"vsetvl",0,INSN_CLASS_V,"d,s,t",MATCH_VSETVL,MASK_VSETVL,match_opcode,0},
	{"vsetvli",0,INSN_CLASS_V,"d,s,Vc",MATCH_VSETVLI,MASK_VSETVLI,match_opcode,0},
	{"vsetivli",0,INSN_CLASS_V,"d,Z,Vb",MATCH_VSETIVLI,MASK_VSETIVLI,match_opcode,0},

	{"vlm.v",0,INSN_CLASS_V,"Vd,0(s)",MATCH_VLMV,MASK_VLMV,match_opcode,INSN_DREF},
	{"vsm.v",0,INSN_CLASS_V,"Vd,0(s)",MATCH_VSMV,MASK_VSMV,match_opcode,INSN_DREF},
	{"vle1.v",0,INSN_CLASS_V,"Vd,0(s)",MATCH_VLMV,MASK_VLMV,match_opcode,INSN_DREF|INSN_ALIAS},
	{"vse1.v",0,INSN_CLASS_V,"Vd,0(s)",MATCH_VSMV,MASK_VSMV,match_opcode,INSN_DREF|INSN_ALIAS},

	{"vle8.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLE8V,MASK_VLE8V,match_opcode,INSN_DREF},
	{"vle16.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLE16V,MASK_VLE16V,match_opcode,INSN_DREF},
	{"vle32.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLE32V,MASK_VLE32V,match_opcode,INSN_DREF},
	{"vle64.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLE64V,MASK_VLE64V,match_opcode,INSN_DREF|INSN_V_EEW64},

	{"vse8.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VSE8V,MASK_VSE8V,match_opcode,INSN_DREF},
	{"vse16.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VSE16V,MASK_VSE16V,match_opcode,INSN_DREF},
	{"vse32.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VSE32V,MASK_VSE32V,match_opcode,INSN_DREF},
	{"vse64.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VSE64V,MASK_VSE64V,match_opcode,INSN_DREF|INSN_V_EEW64},

	{"vlse8.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VLSE8V,MASK_VLSE8V,match_opcode,INSN_DREF},
	{"vlse16.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VLSE16V,MASK_VLSE16V,match_opcode,INSN_DREF},
	{"vlse32.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VLSE32V,MASK_VLSE32V,match_opcode,INSN_DREF},
	{"vlse64.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VLSE64V,MASK_VLSE64V,match_opcode,INSN_DREF|INSN_V_EEW64},

	{"vsse8.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VSSE8V,MASK_VSSE8V,match_opcode,INSN_DREF},
	{"vsse16.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VSSE16V,MASK_VSSE16V,match_opcode,INSN_DREF},
	{"vsse32.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VSSE32V,MASK_VSSE32V,match_opcode,INSN_DREF},
	{"vsse64.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VSSE64V,MASK_VSSE64V,match_opcode,INSN_DREF|INSN_V_EEW64},

	{"vloxei8.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLOXEI8V,MASK_VLOXEI8V,match_opcode,INSN_DREF},
	{"vloxei16.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLOXEI16V,MASK_VLOXEI16V,match_opcode,INSN_DREF},
	{"vloxei32.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLOXEI32V,MASK_VLOXEI32V,match_opcode,INSN_DREF},
	{"vloxei64.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLOXEI64V,MASK_VLOXEI64V,match_opcode,INSN_DREF|INSN_V_EEW64},

	{"vsoxei8.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSOXEI8V,MASK_VSOXEI8V,match_opcode,INSN_DREF},
	{"vsoxei16.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSOXEI16V,MASK_VSOXEI16V,match_opcode,INSN_DREF},
	{"vsoxei32.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSOXEI32V,MASK_VSOXEI32V,match_opcode,INSN_DREF},
	{"vsoxei64.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSOXEI64V,MASK_VSOXEI64V,match_opcode,INSN_DREF|INSN_V_EEW64},

	{"vluxei8.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLUXEI8V,MASK_VLUXEI8V,match_opcode,INSN_DREF},
	{"vluxei16.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLUXEI16V,MASK_VLUXEI16V,match_opcode,INSN_DREF},
	{"vluxei32.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLUXEI32V,MASK_VLUXEI32V,match_opcode,INSN_DREF},
	{"vluxei64.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLUXEI64V,MASK_VLUXEI64V,match_opcode,INSN_DREF|INSN_V_EEW64},

	{"vsuxei8.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSUXEI8V,MASK_VSUXEI8V,match_opcode,INSN_DREF},
	{"vsuxei16.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSUXEI16V,MASK_VSUXEI16V,match_opcode,INSN_DREF},
	{"vsuxei32.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSUXEI32V,MASK_VSUXEI32V,match_opcode,INSN_DREF},
	{"vsuxei64.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSUXEI64V,MASK_VSUXEI64V,match_opcode,INSN_DREF|INSN_V_EEW64},

	{"vle8ff.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLE8FFV,MASK_VLE8FFV,match_opcode,INSN_DREF},
	{"vle16ff.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLE16FFV,MASK_VLE16FFV,match_opcode,INSN_DREF},
	{"vle32ff.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLE32FFV,MASK_VLE32FFV,match_opcode,INSN_DREF},
	{"vle64ff.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLE64FFV,MASK_VLE64FFV,match_opcode,INSN_DREF|INSN_V_EEW64},

	{"vlseg2e8.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG2E8V,MASK_VLSEG2E8V,match_opcode,INSN_DREF},
	{"vsseg2e8.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VSSEG2E8V,MASK_VSSEG2E8V,match_opcode,INSN_DREF},
	{"vlseg3e8.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG3E8V,MASK_VLSEG3E8V,match_opcode,INSN_DREF},
	{"vsseg3e8.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VSSEG3E8V,MASK_VSSEG3E8V,match_opcode,INSN_DREF},
	{"vlseg4e8.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG4E8V,MASK_VLSEG4E8V,match_opcode,INSN_DREF},
	{"vsseg4e8.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VSSEG4E8V,MASK_VSSEG4E8V,match_opcode,INSN_DREF},
	{"vlseg5e8.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG5E8V,MASK_VLSEG5E8V,match_opcode,INSN_DREF},
	{"vsseg5e8.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VSSEG5E8V,MASK_VSSEG5E8V,match_opcode,INSN_DREF},
	{"vlseg6e8.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG6E8V,MASK_VLSEG6E8V,match_opcode,INSN_DREF},
	{"vsseg6e8.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VSSEG6E8V,MASK_VSSEG6E8V,match_opcode,INSN_DREF},
	{"vlseg7e8.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG7E8V,MASK_VLSEG7E8V,match_opcode,INSN_DREF},
	{"vsseg7e8.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VSSEG7E8V,MASK_VSSEG7E8V,match_opcode,INSN_DREF},
	{"vlseg8e8.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG8E8V,MASK_VLSEG8E8V,match_opcode,INSN_DREF},
	{"vsseg8e8.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VSSEG8E8V,MASK_VSSEG8E8V,match_opcode,INSN_DREF},

	{"vlseg2e16.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG2E16V,MASK_VLSEG2E16V,match_opcode,INSN_DREF},
	{"vsseg2e16.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VSSEG2E16V,MASK_VSSEG2E16V,match_opcode,INSN_DREF},
	{"vlseg3e16.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG3E16V,MASK_VLSEG3E16V,match_opcode,INSN_DREF},
	{"vsseg3e16.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VSSEG3E16V,MASK_VSSEG3E16V,match_opcode,INSN_DREF},
	{"vlseg4e16.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG4E16V,MASK_VLSEG4E16V,match_opcode,INSN_DREF},
	{"vsseg4e16.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VSSEG4E16V,MASK_VSSEG4E16V,match_opcode,INSN_DREF},
	{"vlseg5e16.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG5E16V,MASK_VLSEG5E16V,match_opcode,INSN_DREF},
	{"vsseg5e16.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VSSEG5E16V,MASK_VSSEG5E16V,match_opcode,INSN_DREF},
	{"vlseg6e16.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG6E16V,MASK_VLSEG6E16V,match_opcode,INSN_DREF},
	{"vsseg6e16.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VSSEG6E16V,MASK_VSSEG6E16V,match_opcode,INSN_DREF},
	{"vlseg7e16.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG7E16V,MASK_VLSEG7E16V,match_opcode,INSN_DREF},
	{"vsseg7e16.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VSSEG7E16V,MASK_VSSEG7E16V,match_opcode,INSN_DREF},
	{"vlseg8e16.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG8E16V,MASK_VLSEG8E16V,match_opcode,INSN_DREF},
	{"vsseg8e16.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VSSEG8E16V,MASK_VSSEG8E16V,match_opcode,INSN_DREF},

	{"vlseg2e32.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG2E32V,MASK_VLSEG2E32V,match_opcode,INSN_DREF},
	{"vsseg2e32.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VSSEG2E32V,MASK_VSSEG2E32V,match_opcode,INSN_DREF},
	{"vlseg3e32.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG3E32V,MASK_VLSEG3E32V,match_opcode,INSN_DREF},
	{"vsseg3e32.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VSSEG3E32V,MASK_VSSEG3E32V,match_opcode,INSN_DREF},
	{"vlseg4e32.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG4E32V,MASK_VLSEG4E32V,match_opcode,INSN_DREF},
	{"vsseg4e32.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VSSEG4E32V,MASK_VSSEG4E32V,match_opcode,INSN_DREF},
	{"vlseg5e32.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG5E32V,MASK_VLSEG5E32V,match_opcode,INSN_DREF},
	{"vsseg5e32.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VSSEG5E32V,MASK_VSSEG5E32V,match_opcode,INSN_DREF},
	{"vlseg6e32.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG6E32V,MASK_VLSEG6E32V,match_opcode,INSN_DREF},
	{"vsseg6e32.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VSSEG6E32V,MASK_VSSEG6E32V,match_opcode,INSN_DREF},
	{"vlseg7e32.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG7E32V,MASK_VLSEG7E32V,match_opcode,INSN_DREF},
	{"vsseg7e32.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VSSEG7E32V,MASK_VSSEG7E32V,match_opcode,INSN_DREF},
	{"vlseg8e32.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG8E32V,MASK_VLSEG8E32V,match_opcode,INSN_DREF},
	{"vsseg8e32.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VSSEG8E32V,MASK_VSSEG8E32V,match_opcode,INSN_DREF},

	{"vlseg2e64.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG2E64V,MASK_VLSEG2E64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vsseg2e64.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VSSEG2E64V,MASK_VSSEG2E64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vlseg3e64.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG3E64V,MASK_VLSEG3E64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vsseg3e64.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VSSEG3E64V,MASK_VSSEG3E64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vlseg4e64.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG4E64V,MASK_VLSEG4E64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vsseg4e64.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VSSEG4E64V,MASK_VSSEG4E64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vlseg5e64.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG5E64V,MASK_VLSEG5E64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vsseg5e64.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VSSEG5E64V,MASK_VSSEG5E64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vlseg6e64.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG6E64V,MASK_VLSEG6E64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vsseg6e64.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VSSEG6E64V,MASK_VSSEG6E64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vlseg7e64.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG7E64V,MASK_VLSEG7E64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vsseg7e64.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VSSEG7E64V,MASK_VSSEG7E64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vlseg8e64.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG8E64V,MASK_VLSEG8E64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vsseg8e64.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VSSEG8E64V,MASK_VSSEG8E64V,match_opcode,INSN_DREF|INSN_V_EEW64},

	{"vlsseg2e8.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VLSSEG2E8V,MASK_VLSSEG2E8V,match_opcode,INSN_DREF},
	{"vssseg2e8.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VSSSEG2E8V,MASK_VSSSEG2E8V,match_opcode,INSN_DREF},
	{"vlsseg3e8.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VLSSEG3E8V,MASK_VLSSEG3E8V,match_opcode,INSN_DREF},
	{"vssseg3e8.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VSSSEG3E8V,MASK_VSSSEG3E8V,match_opcode,INSN_DREF},
	{"vlsseg4e8.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VLSSEG4E8V,MASK_VLSSEG4E8V,match_opcode,INSN_DREF},
	{"vssseg4e8.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VSSSEG4E8V,MASK_VSSSEG4E8V,match_opcode,INSN_DREF},
	{"vlsseg5e8.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VLSSEG5E8V,MASK_VLSSEG5E8V,match_opcode,INSN_DREF},
	{"vssseg5e8.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VSSSEG5E8V,MASK_VSSSEG5E8V,match_opcode,INSN_DREF},
	{"vlsseg6e8.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VLSSEG6E8V,MASK_VLSSEG6E8V,match_opcode,INSN_DREF},
	{"vssseg6e8.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VSSSEG6E8V,MASK_VSSSEG6E8V,match_opcode,INSN_DREF},
	{"vlsseg7e8.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VLSSEG7E8V,MASK_VLSSEG7E8V,match_opcode,INSN_DREF},
	{"vssseg7e8.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VSSSEG7E8V,MASK_VSSSEG7E8V,match_opcode,INSN_DREF},
	{"vlsseg8e8.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VLSSEG8E8V,MASK_VLSSEG8E8V,match_opcode,INSN_DREF},
	{"vssseg8e8.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VSSSEG8E8V,MASK_VSSSEG8E8V,match_opcode,INSN_DREF},

	{"vlsseg2e16.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VLSSEG2E16V,MASK_VLSSEG2E16V,match_opcode,INSN_DREF},
	{"vssseg2e16.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VSSSEG2E16V,MASK_VSSSEG2E16V,match_opcode,INSN_DREF},
	{"vlsseg3e16.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VLSSEG3E16V,MASK_VLSSEG3E16V,match_opcode,INSN_DREF},
	{"vssseg3e16.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VSSSEG3E16V,MASK_VSSSEG3E16V,match_opcode,INSN_DREF},
	{"vlsseg4e16.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VLSSEG4E16V,MASK_VLSSEG4E16V,match_opcode,INSN_DREF},
	{"vssseg4e16.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VSSSEG4E16V,MASK_VSSSEG4E16V,match_opcode,INSN_DREF},
	{"vlsseg5e16.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VLSSEG5E16V,MASK_VLSSEG5E16V,match_opcode,INSN_DREF},
	{"vssseg5e16.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VSSSEG5E16V,MASK_VSSSEG5E16V,match_opcode,INSN_DREF},
	{"vlsseg6e16.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VLSSEG6E16V,MASK_VLSSEG6E16V,match_opcode,INSN_DREF},
	{"vssseg6e16.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VSSSEG6E16V,MASK_VSSSEG6E16V,match_opcode,INSN_DREF},
	{"vlsseg7e16.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VLSSEG7E16V,MASK_VLSSEG7E16V,match_opcode,INSN_DREF},
	{"vssseg7e16.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VSSSEG7E16V,MASK_VSSSEG7E16V,match_opcode,INSN_DREF},
	{"vlsseg8e16.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VLSSEG8E16V,MASK_VLSSEG8E16V,match_opcode,INSN_DREF},
	{"vssseg8e16.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VSSSEG8E16V,MASK_VSSSEG8E16V,match_opcode,INSN_DREF},

	{"vlsseg2e32.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VLSSEG2E32V,MASK_VLSSEG2E32V,match_opcode,INSN_DREF},
	{"vssseg2e32.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VSSSEG2E32V,MASK_VSSSEG2E32V,match_opcode,INSN_DREF},
	{"vlsseg3e32.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VLSSEG3E32V,MASK_VLSSEG3E32V,match_opcode,INSN_DREF},
	{"vssseg3e32.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VSSSEG3E32V,MASK_VSSSEG3E32V,match_opcode,INSN_DREF},
	{"vlsseg4e32.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VLSSEG4E32V,MASK_VLSSEG4E32V,match_opcode,INSN_DREF},
	{"vssseg4e32.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VSSSEG4E32V,MASK_VSSSEG4E32V,match_opcode,INSN_DREF},
	{"vlsseg5e32.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VLSSEG5E32V,MASK_VLSSEG5E32V,match_opcode,INSN_DREF},
	{"vssseg5e32.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VSSSEG5E32V,MASK_VSSSEG5E32V,match_opcode,INSN_DREF},
	{"vlsseg6e32.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VLSSEG6E32V,MASK_VLSSEG6E32V,match_opcode,INSN_DREF},
	{"vssseg6e32.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VSSSEG6E32V,MASK_VSSSEG6E32V,match_opcode,INSN_DREF},
	{"vlsseg7e32.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VLSSEG7E32V,MASK_VLSSEG7E32V,match_opcode,INSN_DREF},
	{"vssseg7e32.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VSSSEG7E32V,MASK_VSSSEG7E32V,match_opcode,INSN_DREF},
	{"vlsseg8e32.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VLSSEG8E32V,MASK_VLSSEG8E32V,match_opcode,INSN_DREF},
	{"vssseg8e32.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VSSSEG8E32V,MASK_VSSSEG8E32V,match_opcode,INSN_DREF},

	{"vlsseg2e64.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VLSSEG2E64V,MASK_VLSSEG2E64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vssseg2e64.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VSSSEG2E64V,MASK_VSSSEG2E64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vlsseg3e64.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VLSSEG3E64V,MASK_VLSSEG3E64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vssseg3e64.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VSSSEG3E64V,MASK_VSSSEG3E64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vlsseg4e64.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VLSSEG4E64V,MASK_VLSSEG4E64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vssseg4e64.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VSSSEG4E64V,MASK_VSSSEG4E64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vlsseg5e64.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VLSSEG5E64V,MASK_VLSSEG5E64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vssseg5e64.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VSSSEG5E64V,MASK_VSSSEG5E64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vlsseg6e64.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VLSSEG6E64V,MASK_VLSSEG6E64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vssseg6e64.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VSSSEG6E64V,MASK_VSSSEG6E64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vlsseg7e64.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VLSSEG7E64V,MASK_VLSSEG7E64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vssseg7e64.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VSSSEG7E64V,MASK_VSSSEG7E64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vlsseg8e64.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VLSSEG8E64V,MASK_VLSSEG8E64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vssseg8e64.v",0,INSN_CLASS_V,"Vd,0(s),tVm",MATCH_VSSSEG8E64V,MASK_VSSSEG8E64V,match_opcode,INSN_DREF|INSN_V_EEW64},

	{"vloxseg2ei8.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLOXSEG2EI8V,MASK_VLOXSEG2EI8V,match_opcode,INSN_DREF},
	{"vsoxseg2ei8.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSOXSEG2EI8V,MASK_VSOXSEG2EI8V,match_opcode,INSN_DREF},
	{"vloxseg3ei8.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLOXSEG3EI8V,MASK_VLOXSEG3EI8V,match_opcode,INSN_DREF},
	{"vsoxseg3ei8.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSOXSEG3EI8V,MASK_VSOXSEG3EI8V,match_opcode,INSN_DREF},
	{"vloxseg4ei8.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLOXSEG4EI8V,MASK_VLOXSEG4EI8V,match_opcode,INSN_DREF},
	{"vsoxseg4ei8.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSOXSEG4EI8V,MASK_VSOXSEG4EI8V,match_opcode,INSN_DREF},
	{"vloxseg5ei8.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLOXSEG5EI8V,MASK_VLOXSEG5EI8V,match_opcode,INSN_DREF},
	{"vsoxseg5ei8.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSOXSEG5EI8V,MASK_VSOXSEG5EI8V,match_opcode,INSN_DREF},
	{"vloxseg6ei8.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLOXSEG6EI8V,MASK_VLOXSEG6EI8V,match_opcode,INSN_DREF},
	{"vsoxseg6ei8.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSOXSEG6EI8V,MASK_VSOXSEG6EI8V,match_opcode,INSN_DREF},
	{"vloxseg7ei8.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLOXSEG7EI8V,MASK_VLOXSEG7EI8V,match_opcode,INSN_DREF},
	{"vsoxseg7ei8.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSOXSEG7EI8V,MASK_VSOXSEG7EI8V,match_opcode,INSN_DREF},
	{"vloxseg8ei8.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLOXSEG8EI8V,MASK_VLOXSEG8EI8V,match_opcode,INSN_DREF},
	{"vsoxseg8ei8.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSOXSEG8EI8V,MASK_VSOXSEG8EI8V,match_opcode,INSN_DREF},

	{"vloxseg2ei16.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLOXSEG2EI16V,MASK_VLOXSEG2EI16V,match_opcode,INSN_DREF},
	{"vsoxseg2ei16.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSOXSEG2EI16V,MASK_VSOXSEG2EI16V,match_opcode,INSN_DREF},
	{"vloxseg3ei16.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLOXSEG3EI16V,MASK_VLOXSEG3EI16V,match_opcode,INSN_DREF},
	{"vsoxseg3ei16.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSOXSEG3EI16V,MASK_VSOXSEG3EI16V,match_opcode,INSN_DREF},
	{"vloxseg4ei16.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLOXSEG4EI16V,MASK_VLOXSEG4EI16V,match_opcode,INSN_DREF},
	{"vsoxseg4ei16.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSOXSEG4EI16V,MASK_VSOXSEG4EI16V,match_opcode,INSN_DREF},
	{"vloxseg5ei16.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLOXSEG5EI16V,MASK_VLOXSEG5EI16V,match_opcode,INSN_DREF},
	{"vsoxseg5ei16.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSOXSEG5EI16V,MASK_VSOXSEG5EI16V,match_opcode,INSN_DREF},
	{"vloxseg6ei16.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLOXSEG6EI16V,MASK_VLOXSEG6EI16V,match_opcode,INSN_DREF},
	{"vsoxseg6ei16.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSOXSEG6EI16V,MASK_VSOXSEG6EI16V,match_opcode,INSN_DREF},
	{"vloxseg7ei16.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLOXSEG7EI16V,MASK_VLOXSEG7EI16V,match_opcode,INSN_DREF},
	{"vsoxseg7ei16.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSOXSEG7EI16V,MASK_VSOXSEG7EI16V,match_opcode,INSN_DREF},
	{"vloxseg8ei16.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLOXSEG8EI16V,MASK_VLOXSEG8EI16V,match_opcode,INSN_DREF},
	{"vsoxseg8ei16.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSOXSEG8EI16V,MASK_VSOXSEG8EI16V,match_opcode,INSN_DREF},

	{"vloxseg2ei32.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLOXSEG2EI32V,MASK_VLOXSEG2EI32V,match_opcode,INSN_DREF},
	{"vsoxseg2ei32.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSOXSEG2EI32V,MASK_VSOXSEG2EI32V,match_opcode,INSN_DREF},
	{"vloxseg3ei32.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLOXSEG3EI32V,MASK_VLOXSEG3EI32V,match_opcode,INSN_DREF},
	{"vsoxseg3ei32.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSOXSEG3EI32V,MASK_VSOXSEG3EI32V,match_opcode,INSN_DREF},
	{"vloxseg4ei32.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLOXSEG4EI32V,MASK_VLOXSEG4EI32V,match_opcode,INSN_DREF},
	{"vsoxseg4ei32.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSOXSEG4EI32V,MASK_VSOXSEG4EI32V,match_opcode,INSN_DREF},
	{"vloxseg5ei32.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLOXSEG5EI32V,MASK_VLOXSEG5EI32V,match_opcode,INSN_DREF},
	{"vsoxseg5ei32.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSOXSEG5EI32V,MASK_VSOXSEG5EI32V,match_opcode,INSN_DREF},
	{"vloxseg6ei32.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLOXSEG6EI32V,MASK_VLOXSEG6EI32V,match_opcode,INSN_DREF},
	{"vsoxseg6ei32.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSOXSEG6EI32V,MASK_VSOXSEG6EI32V,match_opcode,INSN_DREF},
	{"vloxseg7ei32.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLOXSEG7EI32V,MASK_VLOXSEG7EI32V,match_opcode,INSN_DREF},
	{"vsoxseg7ei32.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSOXSEG7EI32V,MASK_VSOXSEG7EI32V,match_opcode,INSN_DREF},
	{"vloxseg8ei32.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLOXSEG8EI32V,MASK_VLOXSEG8EI32V,match_opcode,INSN_DREF},
	{"vsoxseg8ei32.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSOXSEG8EI32V,MASK_VSOXSEG8EI32V,match_opcode,INSN_DREF},

	{"vloxseg2ei64.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLOXSEG2EI64V,MASK_VLOXSEG2EI64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vsoxseg2ei64.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSOXSEG2EI64V,MASK_VSOXSEG2EI64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vloxseg3ei64.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLOXSEG3EI64V,MASK_VLOXSEG3EI64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vsoxseg3ei64.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSOXSEG3EI64V,MASK_VSOXSEG3EI64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vloxseg4ei64.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLOXSEG4EI64V,MASK_VLOXSEG4EI64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vsoxseg4ei64.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSOXSEG4EI64V,MASK_VSOXSEG4EI64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vloxseg5ei64.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLOXSEG5EI64V,MASK_VLOXSEG5EI64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vsoxseg5ei64.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSOXSEG5EI64V,MASK_VSOXSEG5EI64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vloxseg6ei64.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLOXSEG6EI64V,MASK_VLOXSEG6EI64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vsoxseg6ei64.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSOXSEG6EI64V,MASK_VSOXSEG6EI64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vloxseg7ei64.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLOXSEG7EI64V,MASK_VLOXSEG7EI64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vsoxseg7ei64.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSOXSEG7EI64V,MASK_VSOXSEG7EI64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vloxseg8ei64.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLOXSEG8EI64V,MASK_VLOXSEG8EI64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vsoxseg8ei64.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSOXSEG8EI64V,MASK_VSOXSEG8EI64V,match_opcode,INSN_DREF|INSN_V_EEW64},

	{"vluxseg2ei8.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLUXSEG2EI8V,MASK_VLUXSEG2EI8V,match_opcode,INSN_DREF},
	{"vsuxseg2ei8.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSUXSEG2EI8V,MASK_VSUXSEG2EI8V,match_opcode,INSN_DREF},
	{"vluxseg3ei8.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLUXSEG3EI8V,MASK_VLUXSEG3EI8V,match_opcode,INSN_DREF},
	{"vsuxseg3ei8.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSUXSEG3EI8V,MASK_VSUXSEG3EI8V,match_opcode,INSN_DREF},
	{"vluxseg4ei8.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLUXSEG4EI8V,MASK_VLUXSEG4EI8V,match_opcode,INSN_DREF},
	{"vsuxseg4ei8.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSUXSEG4EI8V,MASK_VSUXSEG4EI8V,match_opcode,INSN_DREF},
	{"vluxseg5ei8.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLUXSEG5EI8V,MASK_VLUXSEG5EI8V,match_opcode,INSN_DREF},
	{"vsuxseg5ei8.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSUXSEG5EI8V,MASK_VSUXSEG5EI8V,match_opcode,INSN_DREF},
	{"vluxseg6ei8.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLUXSEG6EI8V,MASK_VLUXSEG6EI8V,match_opcode,INSN_DREF},
	{"vsuxseg6ei8.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSUXSEG6EI8V,MASK_VSUXSEG6EI8V,match_opcode,INSN_DREF},
	{"vluxseg7ei8.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLUXSEG7EI8V,MASK_VLUXSEG7EI8V,match_opcode,INSN_DREF},
	{"vsuxseg7ei8.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSUXSEG7EI8V,MASK_VSUXSEG7EI8V,match_opcode,INSN_DREF},
	{"vluxseg8ei8.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLUXSEG8EI8V,MASK_VLUXSEG8EI8V,match_opcode,INSN_DREF},
	{"vsuxseg8ei8.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSUXSEG8EI8V,MASK_VSUXSEG8EI8V,match_opcode,INSN_DREF},

	{"vluxseg2ei16.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLUXSEG2EI16V,MASK_VLUXSEG2EI16V,match_opcode,INSN_DREF},
	{"vsuxseg2ei16.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSUXSEG2EI16V,MASK_VSUXSEG2EI16V,match_opcode,INSN_DREF},
	{"vluxseg3ei16.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLUXSEG3EI16V,MASK_VLUXSEG3EI16V,match_opcode,INSN_DREF},
	{"vsuxseg3ei16.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSUXSEG3EI16V,MASK_VSUXSEG3EI16V,match_opcode,INSN_DREF},
	{"vluxseg4ei16.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLUXSEG4EI16V,MASK_VLUXSEG4EI16V,match_opcode,INSN_DREF},
	{"vsuxseg4ei16.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSUXSEG4EI16V,MASK_VSUXSEG4EI16V,match_opcode,INSN_DREF},
	{"vluxseg5ei16.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLUXSEG5EI16V,MASK_VLUXSEG5EI16V,match_opcode,INSN_DREF},
	{"vsuxseg5ei16.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSUXSEG5EI16V,MASK_VSUXSEG5EI16V,match_opcode,INSN_DREF},
	{"vluxseg6ei16.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLUXSEG6EI16V,MASK_VLUXSEG6EI16V,match_opcode,INSN_DREF},
	{"vsuxseg6ei16.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSUXSEG6EI16V,MASK_VSUXSEG6EI16V,match_opcode,INSN_DREF},
	{"vluxseg7ei16.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLUXSEG7EI16V,MASK_VLUXSEG7EI16V,match_opcode,INSN_DREF},
	{"vsuxseg7ei16.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSUXSEG7EI16V,MASK_VSUXSEG7EI16V,match_opcode,INSN_DREF},
	{"vluxseg8ei16.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLUXSEG8EI16V,MASK_VLUXSEG8EI16V,match_opcode,INSN_DREF},
	{"vsuxseg8ei16.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSUXSEG8EI16V,MASK_VSUXSEG8EI16V,match_opcode,INSN_DREF},

	{"vluxseg2ei32.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLUXSEG2EI32V,MASK_VLUXSEG2EI32V,match_opcode,INSN_DREF},
	{"vsuxseg2ei32.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSUXSEG2EI32V,MASK_VSUXSEG2EI32V,match_opcode,INSN_DREF},
	{"vluxseg3ei32.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLUXSEG3EI32V,MASK_VLUXSEG3EI32V,match_opcode,INSN_DREF},
	{"vsuxseg3ei32.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSUXSEG3EI32V,MASK_VSUXSEG3EI32V,match_opcode,INSN_DREF},
	{"vluxseg4ei32.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLUXSEG4EI32V,MASK_VLUXSEG4EI32V,match_opcode,INSN_DREF},
	{"vsuxseg4ei32.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSUXSEG4EI32V,MASK_VSUXSEG4EI32V,match_opcode,INSN_DREF},
	{"vluxseg5ei32.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLUXSEG5EI32V,MASK_VLUXSEG5EI32V,match_opcode,INSN_DREF},
	{"vsuxseg5ei32.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSUXSEG5EI32V,MASK_VSUXSEG5EI32V,match_opcode,INSN_DREF},
	{"vluxseg6ei32.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLUXSEG6EI32V,MASK_VLUXSEG6EI32V,match_opcode,INSN_DREF},
	{"vsuxseg6ei32.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSUXSEG6EI32V,MASK_VSUXSEG6EI32V,match_opcode,INSN_DREF},
	{"vluxseg7ei32.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLUXSEG7EI32V,MASK_VLUXSEG7EI32V,match_opcode,INSN_DREF},
	{"vsuxseg7ei32.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSUXSEG7EI32V,MASK_VSUXSEG7EI32V,match_opcode,INSN_DREF},
	{"vluxseg8ei32.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLUXSEG8EI32V,MASK_VLUXSEG8EI32V,match_opcode,INSN_DREF},
	{"vsuxseg8ei32.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSUXSEG8EI32V,MASK_VSUXSEG8EI32V,match_opcode,INSN_DREF},

	{"vluxseg2ei64.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLUXSEG2EI64V,MASK_VLUXSEG2EI64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vsuxseg2ei64.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSUXSEG2EI64V,MASK_VSUXSEG2EI64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vluxseg3ei64.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLUXSEG3EI64V,MASK_VLUXSEG3EI64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vsuxseg3ei64.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSUXSEG3EI64V,MASK_VSUXSEG3EI64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vluxseg4ei64.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLUXSEG4EI64V,MASK_VLUXSEG4EI64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vsuxseg4ei64.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSUXSEG4EI64V,MASK_VSUXSEG4EI64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vluxseg5ei64.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLUXSEG5EI64V,MASK_VLUXSEG5EI64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vsuxseg5ei64.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSUXSEG5EI64V,MASK_VSUXSEG5EI64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vluxseg6ei64.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLUXSEG6EI64V,MASK_VLUXSEG6EI64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vsuxseg6ei64.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSUXSEG6EI64V,MASK_VSUXSEG6EI64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vluxseg7ei64.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLUXSEG7EI64V,MASK_VLUXSEG7EI64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vsuxseg7ei64.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSUXSEG7EI64V,MASK_VSUXSEG7EI64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vluxseg8ei64.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VLUXSEG8EI64V,MASK_VLUXSEG8EI64V,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vsuxseg8ei64.v",0,INSN_CLASS_V,"Vd,0(s),VtVm",MATCH_VSUXSEG8EI64V,MASK_VSUXSEG8EI64V,match_opcode,INSN_DREF|INSN_V_EEW64},

	{"vlseg2e8ff.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG2E8FFV,MASK_VLSEG2E8FFV,match_opcode,INSN_DREF},
	{"vlseg3e8ff.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG3E8FFV,MASK_VLSEG3E8FFV,match_opcode,INSN_DREF},
	{"vlseg4e8ff.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG4E8FFV,MASK_VLSEG4E8FFV,match_opcode,INSN_DREF},
	{"vlseg5e8ff.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG5E8FFV,MASK_VLSEG5E8FFV,match_opcode,INSN_DREF},
	{"vlseg6e8ff.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG6E8FFV,MASK_VLSEG6E8FFV,match_opcode,INSN_DREF},
	{"vlseg7e8ff.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG7E8FFV,MASK_VLSEG7E8FFV,match_opcode,INSN_DREF},
	{"vlseg8e8ff.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG8E8FFV,MASK_VLSEG8E8FFV,match_opcode,INSN_DREF},

	{"vlseg2e16ff.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG2E16FFV,MASK_VLSEG2E16FFV,match_opcode,INSN_DREF},
	{"vlseg3e16ff.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG3E16FFV,MASK_VLSEG3E16FFV,match_opcode,INSN_DREF},
	{"vlseg4e16ff.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG4E16FFV,MASK_VLSEG4E16FFV,match_opcode,INSN_DREF},
	{"vlseg5e16ff.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG5E16FFV,MASK_VLSEG5E16FFV,match_opcode,INSN_DREF},
	{"vlseg6e16ff.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG6E16FFV,MASK_VLSEG6E16FFV,match_opcode,INSN_DREF},
	{"vlseg7e16ff.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG7E16FFV,MASK_VLSEG7E16FFV,match_opcode,INSN_DREF},
	{"vlseg8e16ff.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG8E16FFV,MASK_VLSEG8E16FFV,match_opcode,INSN_DREF},

	{"vlseg2e32ff.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG2E32FFV,MASK_VLSEG2E32FFV,match_opcode,INSN_DREF},
	{"vlseg3e32ff.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG3E32FFV,MASK_VLSEG3E32FFV,match_opcode,INSN_DREF},
	{"vlseg4e32ff.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG4E32FFV,MASK_VLSEG4E32FFV,match_opcode,INSN_DREF},
	{"vlseg5e32ff.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG5E32FFV,MASK_VLSEG5E32FFV,match_opcode,INSN_DREF},
	{"vlseg6e32ff.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG6E32FFV,MASK_VLSEG6E32FFV,match_opcode,INSN_DREF},
	{"vlseg7e32ff.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG7E32FFV,MASK_VLSEG7E32FFV,match_opcode,INSN_DREF},
	{"vlseg8e32ff.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG8E32FFV,MASK_VLSEG8E32FFV,match_opcode,INSN_DREF},

	{"vlseg2e64ff.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG2E64FFV,MASK_VLSEG2E64FFV,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vlseg3e64ff.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG3E64FFV,MASK_VLSEG3E64FFV,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vlseg4e64ff.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG4E64FFV,MASK_VLSEG4E64FFV,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vlseg5e64ff.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG5E64FFV,MASK_VLSEG5E64FFV,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vlseg6e64ff.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG6E64FFV,MASK_VLSEG6E64FFV,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vlseg7e64ff.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG7E64FFV,MASK_VLSEG7E64FFV,match_opcode,INSN_DREF|INSN_V_EEW64},
	{"vlseg8e64ff.v",0,INSN_CLASS_V,"Vd,0(s)Vm",MATCH_VLSEG8E64FFV,MASK_VLSEG8E64FFV,match_opcode,INSN_DREF|INSN_V_EEW64},

	{"vl1r.v",0,INSN_CLASS_V,"Vd,0(s)",MATCH_VL1RE8V,MASK_VL1RE8V,match_opcode,INSN_DREF|INSN_ALIAS},
	{"vl1re8.v",0,INSN_CLASS_V,"Vd,0(s)",MATCH_VL1RE8V,MASK_VL1RE8V,match_opcode,INSN_DREF},
	{"vl1re16.v",0,INSN_CLASS_V,"Vd,0(s)",MATCH_VL1RE16V,MASK_VL1RE16V,match_opcode,INSN_DREF},
	{"vl1re32.v",0,INSN_CLASS_V,"Vd,0(s)",MATCH_VL1RE32V,MASK_VL1RE32V,match_opcode,INSN_DREF},
	{"vl1re64.v",0,INSN_CLASS_V,"Vd,0(s)",MATCH_VL1RE64V,MASK_VL1RE64V,match_opcode,INSN_DREF|INSN_V_EEW64},

	{"vl2r.v",0,INSN_CLASS_V,"Vd,0(s)",MATCH_VL2RE8V,MASK_VL2RE8V,match_opcode,INSN_DREF|INSN_ALIAS},
	{"vl2re8.v",0,INSN_CLASS_V,"Vd,0(s)",MATCH_VL2RE8V,MASK_VL2RE8V,match_opcode,INSN_DREF},
	{"vl2re16.v",0,INSN_CLASS_V,"Vd,0(s)",MATCH_VL2RE16V,MASK_VL2RE16V,match_opcode,INSN_DREF},
	{"vl2re32.v",0,INSN_CLASS_V,"Vd,0(s)",MATCH_VL2RE32V,MASK_VL2RE32V,match_opcode,INSN_DREF},
	{"vl2re64.v",0,INSN_CLASS_V,"Vd,0(s)",MATCH_VL2RE64V,MASK_VL2RE64V,match_opcode,INSN_DREF|INSN_V_EEW64},

	{"vl4r.v",0,INSN_CLASS_V,"Vd,0(s)",MATCH_VL4RE8V,MASK_VL4RE8V,match_opcode,INSN_DREF|INSN_ALIAS},
	{"vl4re8.v",0,INSN_CLASS_V,"Vd,0(s)",MATCH_VL4RE8V,MASK_VL4RE8V,match_opcode,INSN_DREF},
	{"vl4re16.v",0,INSN_CLASS_V,"Vd,0(s)",MATCH_VL4RE16V,MASK_VL4RE16V,match_opcode,INSN_DREF},
	{"vl4re32.v",0,INSN_CLASS_V,"Vd,0(s)",MATCH_VL4RE32V,MASK_VL4RE32V,match_opcode,INSN_DREF},
	{"vl4re64.v",0,INSN_CLASS_V,"Vd,0(s)",MATCH_VL4RE64V,MASK_VL4RE64V,match_opcode,INSN_DREF|INSN_V_EEW64},

	{"vl8r.v",0,INSN_CLASS_V,"Vd,0(s)",MATCH_VL8RE8V,MASK_VL8RE8V,match_opcode,INSN_DREF|INSN_ALIAS},
	{"vl8re8.v",0,INSN_CLASS_V,"Vd,0(s)",MATCH_VL8RE8V,MASK_VL8RE8V,match_opcode,INSN_DREF},
	{"vl8re16.v",0,INSN_CLASS_V,"Vd,0(s)",MATCH_VL8RE16V,MASK_VL8RE16V,match_opcode,INSN_DREF},
	{"vl8re32.v",0,INSN_CLASS_V,"Vd,0(s)",MATCH_VL8RE32V,MASK_VL8RE32V,match_opcode,INSN_DREF},
	{"vl8re64.v",0,INSN_CLASS_V,"Vd,0(s)",MATCH_VL8RE64V,MASK_VL8RE64V,match_opcode,INSN_DREF|INSN_V_EEW64},

	{"vs1r.v",0,INSN_CLASS_V,"Vd,0(s)",MATCH_VS1RV,MASK_VS1RV,match_opcode,INSN_DREF},
	{"vs2r.v",0,INSN_CLASS_V,"Vd,0(s)",MATCH_VS2RV,MASK_VS2RV,match_opcode,INSN_DREF},
	{"vs4r.v",0,INSN_CLASS_V,"Vd,0(s)",MATCH_VS4RV,MASK_VS4RV,match_opcode,INSN_DREF},
	{"vs8r.v",0,INSN_CLASS_V,"Vd,0(s)",MATCH_VS8RV,MASK_VS8RV,match_opcode,INSN_DREF},

	{"vneg.v",0,INSN_CLASS_V,"Vd,VtVm",MATCH_VRSUBVX,MASK_VRSUBVX|MASK_RS1,match_opcode,INSN_ALIAS},

	{"vadd.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VADDVV,MASK_VADDVV,match_opcode,0},
	{"vadd.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VADDVX,MASK_VADDVX,match_opcode,0},
	{"vadd.vi",0,INSN_CLASS_V,"Vd,Vt,ViVm",MATCH_VADDVI,MASK_VADDVI,match_opcode,0},
	{"vsub.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VSUBVV,MASK_VSUBVV,match_opcode,0},
	{"vsub.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VSUBVX,MASK_VSUBVX,match_opcode,0},
	{"vrsub.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VRSUBVX,MASK_VRSUBVX,match_opcode,0},
	{"vrsub.vi",0,INSN_CLASS_V,"Vd,Vt,ViVm",MATCH_VRSUBVI,MASK_VRSUBVI,match_opcode,0},

	{"vwcvt.x.x.v",0,INSN_CLASS_V,"Vd,VtVm",MATCH_VWCVTXXV,MASK_VWCVTXXV,match_opcode,INSN_ALIAS},
	{"vwcvtu.x.x.v",0,INSN_CLASS_V,"Vd,VtVm",MATCH_VWCVTUXXV,MASK_VWCVTUXXV,match_opcode,INSN_ALIAS},

	{"vwaddu.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VWADDUVV,MASK_VWADDUVV,match_opcode,0},
	{"vwaddu.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VWADDUVX,MASK_VWADDUVX,match_opcode,0},
	{"vwsubu.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VWSUBUVV,MASK_VWSUBUVV,match_opcode,0},
	{"vwsubu.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VWSUBUVX,MASK_VWSUBUVX,match_opcode,0},
	{"vwadd.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VWADDVV,MASK_VWADDVV,match_opcode,0},
	{"vwadd.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VWADDVX,MASK_VWADDVX,match_opcode,0},
	{"vwsub.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VWSUBVV,MASK_VWSUBVV,match_opcode,0},
	{"vwsub.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VWSUBVX,MASK_VWSUBVX,match_opcode,0},
	{"vwaddu.wv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VWADDUWV,MASK_VWADDUWV,match_opcode,0},
	{"vwaddu.wx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VWADDUWX,MASK_VWADDUWX,match_opcode,0},
	{"vwsubu.wv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VWSUBUWV,MASK_VWSUBUWV,match_opcode,0},
	{"vwsubu.wx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VWSUBUWX,MASK_VWSUBUWX,match_opcode,0},
	{"vwadd.wv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VWADDWV,MASK_VWADDWV,match_opcode,0},
	{"vwadd.wx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VWADDWX,MASK_VWADDWX,match_opcode,0},
	{"vwsub.wv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VWSUBWV,MASK_VWSUBWV,match_opcode,0},
	{"vwsub.wx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VWSUBWX,MASK_VWSUBWX,match_opcode,0},

	{"vzext.vf2",0,INSN_CLASS_V,"Vd,VtVm",MATCH_VZEXT_VF2,MASK_VZEXT_VF2,match_opcode,0},
	{"vsext.vf2",0,INSN_CLASS_V,"Vd,VtVm",MATCH_VSEXT_VF2,MASK_VSEXT_VF2,match_opcode,0},
	{"vzext.vf4",0,INSN_CLASS_V,"Vd,VtVm",MATCH_VZEXT_VF4,MASK_VZEXT_VF4,match_opcode,0},
	{"vsext.vf4",0,INSN_CLASS_V,"Vd,VtVm",MATCH_VSEXT_VF4,MASK_VSEXT_VF4,match_opcode,0},
	{"vzext.vf8",0,INSN_CLASS_V,"Vd,VtVm",MATCH_VZEXT_VF8,MASK_VZEXT_VF8,match_opcode,0},
	{"vsext.vf8",0,INSN_CLASS_V,"Vd,VtVm",MATCH_VSEXT_VF8,MASK_VSEXT_VF8,match_opcode,0},

	{"vadc.vvm",0,INSN_CLASS_V,"Vd,Vt,Vs,V0",MATCH_VADCVVM,MASK_VADCVVM,match_opcode,0},
	{"vadc.vxm",0,INSN_CLASS_V,"Vd,Vt,s,V0",MATCH_VADCVXM,MASK_VADCVXM,match_opcode,0},
	{"vadc.vim",0,INSN_CLASS_V,"Vd,Vt,Vi,V0",MATCH_VADCVIM,MASK_VADCVIM,match_opcode,0},
	{"vmadc.vvm",0,INSN_CLASS_V,"Vd,Vt,Vs,V0",MATCH_VMADCVVM,MASK_VMADCVVM,match_opcode,0},
	{"vmadc.vxm",0,INSN_CLASS_V,"Vd,Vt,s,V0",MATCH_VMADCVXM,MASK_VMADCVXM,match_opcode,0},
	{"vmadc.vim",0,INSN_CLASS_V,"Vd,Vt,Vi,V0",MATCH_VMADCVIM,MASK_VMADCVIM,match_opcode,0},
	{"vmadc.vv",0,INSN_CLASS_V,"Vd,Vt,Vs",MATCH_VMADCVV,MASK_VMADCVV,match_opcode,0},
	{"vmadc.vx",0,INSN_CLASS_V,"Vd,Vt,s",MATCH_VMADCVX,MASK_VMADCVX,match_opcode,0},
	{"vmadc.vi",0,INSN_CLASS_V,"Vd,Vt,Vi",MATCH_VMADCVI,MASK_VMADCVI,match_opcode,0},
	{"vsbc.vvm",0,INSN_CLASS_V,"Vd,Vt,Vs,V0",MATCH_VSBCVVM,MASK_VSBCVVM,match_opcode,0},
	{"vsbc.vxm",0,INSN_CLASS_V,"Vd,Vt,s,V0",MATCH_VSBCVXM,MASK_VSBCVXM,match_opcode,0},
	{"vmsbc.vvm",0,INSN_CLASS_V,"Vd,Vt,Vs,V0",MATCH_VMSBCVVM,MASK_VMSBCVVM,match_opcode,0},
	{"vmsbc.vxm",0,INSN_CLASS_V,"Vd,Vt,s,V0",MATCH_VMSBCVXM,MASK_VMSBCVXM,match_opcode,0},
	{"vmsbc.vv",0,INSN_CLASS_V,"Vd,Vt,Vs",MATCH_VMSBCVV,MASK_VMSBCVV,match_opcode,0},
	{"vmsbc.vx",0,INSN_CLASS_V,"Vd,Vt,s",MATCH_VMSBCVX,MASK_VMSBCVX,match_opcode,0},

	{"vnot.v",0,INSN_CLASS_V,"Vd,VtVm",MATCH_VNOTV,MASK_VNOTV,match_opcode,INSN_ALIAS},

	{"vand.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VANDVV,MASK_VANDVV,match_opcode,0},
	{"vand.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VANDVX,MASK_VANDVX,match_opcode,0},
	{"vand.vi",0,INSN_CLASS_V,"Vd,Vt,ViVm",MATCH_VANDVI,MASK_VANDVI,match_opcode,0},
	{"vor.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VORVV,MASK_VORVV,match_opcode,0},
	{"vor.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VORVX,MASK_VORVX,match_opcode,0},
	{"vor.vi",0,INSN_CLASS_V,"Vd,Vt,ViVm",MATCH_VORVI,MASK_VORVI,match_opcode,0},
	{"vxor.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VXORVV,MASK_VXORVV,match_opcode,0},
	{"vxor.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VXORVX,MASK_VXORVX,match_opcode,0},
	{"vxor.vi",0,INSN_CLASS_V,"Vd,Vt,ViVm",MATCH_VXORVI,MASK_VXORVI,match_opcode,0},

	{"vsll.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VSLLVV,MASK_VSLLVV,match_opcode,0},
	{"vsll.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VSLLVX,MASK_VSLLVX,match_opcode,0},
	{"vsll.vi",0,INSN_CLASS_V,"Vd,Vt,VjVm",MATCH_VSLLVI,MASK_VSLLVI,match_opcode,0},
	{"vsrl.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VSRLVV,MASK_VSRLVV,match_opcode,0},
	{"vsrl.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VSRLVX,MASK_VSRLVX,match_opcode,0},
	{"vsrl.vi",0,INSN_CLASS_V,"Vd,Vt,VjVm",MATCH_VSRLVI,MASK_VSRLVI,match_opcode,0},
	{"vsra.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VSRAVV,MASK_VSRAVV,match_opcode,0},
	{"vsra.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VSRAVX,MASK_VSRAVX,match_opcode,0},
	{"vsra.vi",0,INSN_CLASS_V,"Vd,Vt,VjVm",MATCH_VSRAVI,MASK_VSRAVI,match_opcode,0},

	{"vncvt.x.x.w",0,INSN_CLASS_V,"Vd,VtVm",MATCH_VNCVTXXW,MASK_VNCVTXXW,match_opcode,INSN_ALIAS},

	{"vnsrl.wv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VNSRLWV,MASK_VNSRLWV,match_opcode,0},
	{"vnsrl.wx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VNSRLWX,MASK_VNSRLWX,match_opcode,0},
	{"vnsrl.wi",0,INSN_CLASS_V,"Vd,Vt,VjVm",MATCH_VNSRLWI,MASK_VNSRLWI,match_opcode,0},
	{"vnsra.wv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VNSRAWV,MASK_VNSRAWV,match_opcode,0},
	{"vnsra.wx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VNSRAWX,MASK_VNSRAWX,match_opcode,0},
	{"vnsra.wi",0,INSN_CLASS_V,"Vd,Vt,VjVm",MATCH_VNSRAWI,MASK_VNSRAWI,match_opcode,0},

	{"vmseq.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VMSEQVV,MASK_VMSEQVV,match_opcode,0},
	{"vmseq.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VMSEQVX,MASK_VMSEQVX,match_opcode,0},
	{"vmseq.vi",0,INSN_CLASS_V,"Vd,Vt,ViVm",MATCH_VMSEQVI,MASK_VMSEQVI,match_opcode,0},
	{"vmsne.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VMSNEVV,MASK_VMSNEVV,match_opcode,0},
	{"vmsne.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VMSNEVX,MASK_VMSNEVX,match_opcode,0},
	{"vmsne.vi",0,INSN_CLASS_V,"Vd,Vt,ViVm",MATCH_VMSNEVI,MASK_VMSNEVI,match_opcode,0},
	{"vmsltu.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VMSLTUVV,MASK_VMSLTUVV,match_opcode,0},
	{"vmsltu.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VMSLTUVX,MASK_VMSLTUVX,match_opcode,0},
	{"vmslt.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VMSLTVV,MASK_VMSLTVV,match_opcode,0},
	{"vmslt.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VMSLTVX,MASK_VMSLTVX,match_opcode,0},
	{"vmsleu.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VMSLEUVV,MASK_VMSLEUVV,match_opcode,0},
	{"vmsleu.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VMSLEUVX,MASK_VMSLEUVX,match_opcode,0},
	{"vmsleu.vi",0,INSN_CLASS_V,"Vd,Vt,ViVm",MATCH_VMSLEUVI,MASK_VMSLEUVI,match_opcode,0},
	{"vmsle.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VMSLEVV,MASK_VMSLEVV,match_opcode,0},
	{"vmsle.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VMSLEVX,MASK_VMSLEVX,match_opcode,0},
	{"vmsle.vi",0,INSN_CLASS_V,"Vd,Vt,ViVm",MATCH_VMSLEVI,MASK_VMSLEVI,match_opcode,0},
	{"vmsgtu.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VMSGTUVX,MASK_VMSGTUVX,match_opcode,0},
	{"vmsgtu.vi",0,INSN_CLASS_V,"Vd,Vt,ViVm",MATCH_VMSGTUVI,MASK_VMSGTUVI,match_opcode,0},
	{"vmsgt.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VMSGTVX,MASK_VMSGTVX,match_opcode,0},
	{"vmsgt.vi",0,INSN_CLASS_V,"Vd,Vt,ViVm",MATCH_VMSGTVI,MASK_VMSGTVI,match_opcode,0},
	{"vmsgt.vv",0,INSN_CLASS_V,"Vd,Vs,VtVm",MATCH_VMSLTVV,MASK_VMSLTVV,match_opcode,INSN_ALIAS},
	{"vmsgtu.vv",0,INSN_CLASS_V,"Vd,Vs,VtVm",MATCH_VMSLTUVV,MASK_VMSLTUVV,match_opcode,INSN_ALIAS},
	{"vmsge.vv",0,INSN_CLASS_V,"Vd,Vs,VtVm",MATCH_VMSLEVV,MASK_VMSLEVV,match_opcode,INSN_ALIAS},
	{"vmsgeu.vv",0,INSN_CLASS_V,"Vd,Vs,VtVm",MATCH_VMSLEUVV,MASK_VMSLEUVV,match_opcode,INSN_ALIAS},
	{"vmslt.vi",0,INSN_CLASS_V,"Vd,Vt,VkVm",MATCH_VMSLEVI,MASK_VMSLEVI,match_opcode,INSN_ALIAS},
	{"vmsltu.vi",0,INSN_CLASS_V,"Vd,Vu,0Vm",MATCH_VMSNEVV,MASK_VMSNEVV,match_vs1_eq_vs2,INSN_ALIAS},
	{"vmsltu.vi",0,INSN_CLASS_V,"Vd,Vt,VkVm",MATCH_VMSLEUVI,MASK_VMSLEUVI,match_opcode,INSN_ALIAS},
	{"vmsge.vi",0,INSN_CLASS_V,"Vd,Vt,VkVm",MATCH_VMSGTVI,MASK_VMSGTVI,match_opcode,INSN_ALIAS},
	{"vmsgeu.vi",0,INSN_CLASS_V,"Vd,Vu,0Vm",MATCH_VMSEQVV,MASK_VMSEQVV,match_vs1_eq_vs2,INSN_ALIAS},
	{"vmsgeu.vi",0,INSN_CLASS_V,"Vd,Vt,VkVm",MATCH_VMSGTUVI,MASK_VMSGTUVI,match_opcode,INSN_ALIAS},

	{"vmsge.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",0,(int)M_VMSGE,match_opcode,INSN_MACRO},
	{"vmsge.vx",0,INSN_CLASS_V,"Vd,Vt,s,VM,VT",0,(int)M_VMSGE,match_opcode,INSN_MACRO},
	{"vmsgeu.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",0,(int)M_VMSGEU,match_opcode,INSN_MACRO},
	{"vmsgeu.vx",0,INSN_CLASS_V,"Vd,Vt,s,VM,VT",0,(int)M_VMSGEU,match_opcode,INSN_MACRO},

	{"vminu.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VMINUVV,MASK_VMINUVV,match_opcode,0},
	{"vminu.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VMINUVX,MASK_VMINUVX,match_opcode,0},
	{"vmin.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VMINVV,MASK_VMINVV,match_opcode,0},
	{"vmin.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VMINVX,MASK_VMINVX,match_opcode,0},
	{"vmaxu.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VMAXUVV,MASK_VMAXUVV,match_opcode,0},
	{"vmaxu.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VMAXUVX,MASK_VMAXUVX,match_opcode,0},
	{"vmax.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VMAXVV,MASK_VMAXVV,match_opcode,0},
	{"vmax.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VMAXVX,MASK_VMAXVX,match_opcode,0},

	{"vmul.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VMULVV,MASK_VMULVV,match_opcode,0},
	{"vmul.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VMULVX,MASK_VMULVX,match_opcode,0},
	{"vmulh.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VMULHVV,MASK_VMULHVV,match_opcode,0},
	{"vmulh.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VMULHVX,MASK_VMULHVX,match_opcode,0},
	{"vmulhu.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VMULHUVV,MASK_VMULHUVV,match_opcode,0},
	{"vmulhu.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VMULHUVX,MASK_VMULHUVX,match_opcode,0},
	{"vmulhsu.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VMULHSUVV,MASK_VMULHSUVV,match_opcode,0},
	{"vmulhsu.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VMULHSUVX,MASK_VMULHSUVX,match_opcode,0},

	{"vwmul.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VWMULVV,MASK_VWMULVV,match_opcode,0},
	{"vwmul.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VWMULVX,MASK_VWMULVX,match_opcode,0},
	{"vwmulu.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VWMULUVV,MASK_VWMULUVV,match_opcode,0},
	{"vwmulu.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VWMULUVX,MASK_VWMULUVX,match_opcode,0},
	{"vwmulsu.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VWMULSUVV,MASK_VWMULSUVV,match_opcode,0},
	{"vwmulsu.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VWMULSUVX,MASK_VWMULSUVX,match_opcode,0},

	{"vmacc.vv",0,INSN_CLASS_V,"Vd,Vs,VtVm",MATCH_VMACCVV,MASK_VMACCVV,match_opcode,0},
	{"vmacc.vx",0,INSN_CLASS_V,"Vd,s,VtVm",MATCH_VMACCVX,MASK_VMACCVX,match_opcode,0},
	{"vnmsac.vv",0,INSN_CLASS_V,"Vd,Vs,VtVm",MATCH_VNMSACVV,MASK_VNMSACVV,match_opcode,0},
	{"vnmsac.vx",0,INSN_CLASS_V,"Vd,s,VtVm",MATCH_VNMSACVX,MASK_VNMSACVX,match_opcode,0},
	{"vmadd.vv",0,INSN_CLASS_V,"Vd,Vs,VtVm",MATCH_VMADDVV,MASK_VMADDVV,match_opcode,0},
	{"vmadd.vx",0,INSN_CLASS_V,"Vd,s,VtVm",MATCH_VMADDVX,MASK_VMADDVX,match_opcode,0},
	{"vnmsub.vv",0,INSN_CLASS_V,"Vd,Vs,VtVm",MATCH_VNMSUBVV,MASK_VNMSUBVV,match_opcode,0},
	{"vnmsub.vx",0,INSN_CLASS_V,"Vd,s,VtVm",MATCH_VNMSUBVX,MASK_VNMSUBVX,match_opcode,0},

	{"vwmaccu.vv",0,INSN_CLASS_V,"Vd,Vs,VtVm",MATCH_VWMACCUVV,MASK_VWMACCUVV,match_opcode,0},
	{"vwmaccu.vx",0,INSN_CLASS_V,"Vd,s,VtVm",MATCH_VWMACCUVX,MASK_VWMACCUVX,match_opcode,0},
	{"vwmacc.vv",0,INSN_CLASS_V,"Vd,Vs,VtVm",MATCH_VWMACCVV,MASK_VWMACCVV,match_opcode,0},
	{"vwmacc.vx",0,INSN_CLASS_V,"Vd,s,VtVm",MATCH_VWMACCVX,MASK_VWMACCVX,match_opcode,0},
	{"vwmaccsu.vv",0,INSN_CLASS_V,"Vd,Vs,VtVm",MATCH_VWMACCSUVV,MASK_VWMACCSUVV,match_opcode,0},
	{"vwmaccsu.vx",0,INSN_CLASS_V,"Vd,s,VtVm",MATCH_VWMACCSUVX,MASK_VWMACCSUVX,match_opcode,0},
	{"vwmaccus.vx",0,INSN_CLASS_V,"Vd,s,VtVm",MATCH_VWMACCUSVX,MASK_VWMACCUSVX,match_opcode,0},

	{"vdivu.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VDIVUVV,MASK_VDIVUVV,match_opcode,0},
	{"vdivu.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VDIVUVX,MASK_VDIVUVX,match_opcode,0},
	{"vdiv.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VDIVVV,MASK_VDIVVV,match_opcode,0},
	{"vdiv.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VDIVVX,MASK_VDIVVX,match_opcode,0},
	{"vremu.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VREMUVV,MASK_VREMUVV,match_opcode,0},
	{"vremu.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VREMUVX,MASK_VREMUVX,match_opcode,0},
	{"vrem.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VREMVV,MASK_VREMVV,match_opcode,0},
	{"vrem.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VREMVX,MASK_VREMVX,match_opcode,0},

	{"vmerge.vvm",0,INSN_CLASS_V,"Vd,Vt,Vs,V0",MATCH_VMERGEVVM,MASK_VMERGEVVM,match_opcode,0},
	{"vmerge.vxm",0,INSN_CLASS_V,"Vd,Vt,s,V0",MATCH_VMERGEVXM,MASK_VMERGEVXM,match_opcode,0},
	{"vmerge.vim",0,INSN_CLASS_V,"Vd,Vt,Vi,V0",MATCH_VMERGEVIM,MASK_VMERGEVIM,match_opcode,0},

	{"vmv.v.v",0,INSN_CLASS_V,"Vd,Vs",MATCH_VMVVV,MASK_VMVVV,match_opcode,0},
	{"vmv.v.x",0,INSN_CLASS_V,"Vd,s",MATCH_VMVVX,MASK_VMVVX,match_opcode,0},
	{"vmv.v.i",0,INSN_CLASS_V,"Vd,Vi",MATCH_VMVVI,MASK_VMVVI,match_opcode,0},

	{"vsaddu.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VSADDUVV,MASK_VSADDUVV,match_opcode,0},
	{"vsaddu.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VSADDUVX,MASK_VSADDUVX,match_opcode,0},
	{"vsaddu.vi",0,INSN_CLASS_V,"Vd,Vt,ViVm",MATCH_VSADDUVI,MASK_VSADDUVI,match_opcode,0},
	{"vsadd.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VSADDVV,MASK_VSADDVV,match_opcode,0},
	{"vsadd.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VSADDVX,MASK_VSADDVX,match_opcode,0},
	{"vsadd.vi",0,INSN_CLASS_V,"Vd,Vt,ViVm",MATCH_VSADDVI,MASK_VSADDVI,match_opcode,0},
	{"vssubu.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VSSUBUVV,MASK_VSSUBUVV,match_opcode,0},
	{"vssubu.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VSSUBUVX,MASK_VSSUBUVX,match_opcode,0},
	{"vssub.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VSSUBVV,MASK_VSSUBVV,match_opcode,0},
	{"vssub.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VSSUBVX,MASK_VSSUBVX,match_opcode,0},

	{"vaaddu.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VAADDUVV,MASK_VAADDUVV,match_opcode,0},
	{"vaaddu.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VAADDUVX,MASK_VAADDUVX,match_opcode,0},
	{"vaadd.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VAADDVV,MASK_VAADDVV,match_opcode,0},
	{"vaadd.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VAADDVX,MASK_VAADDVX,match_opcode,0},
	{"vasubu.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VASUBUVV,MASK_VASUBUVV,match_opcode,0},
	{"vasubu.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VASUBUVX,MASK_VASUBUVX,match_opcode,0},
	{"vasub.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VASUBVV,MASK_VASUBVV,match_opcode,0},
	{"vasub.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VASUBVX,MASK_VASUBVX,match_opcode,0},

	{"vsmul.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VSMULVV,MASK_VSMULVV,match_opcode,0},
	{"vsmul.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VSMULVX,MASK_VSMULVX,match_opcode,0},

	{"vssrl.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VSSRLVV,MASK_VSSRLVV,match_opcode,0},
	{"vssrl.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VSSRLVX,MASK_VSSRLVX,match_opcode,0},
	{"vssrl.vi",0,INSN_CLASS_V,"Vd,Vt,VjVm",MATCH_VSSRLVI,MASK_VSSRLVI,match_opcode,0},
	{"vssra.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VSSRAVV,MASK_VSSRAVV,match_opcode,0},
	{"vssra.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VSSRAVX,MASK_VSSRAVX,match_opcode,0},
	{"vssra.vi",0,INSN_CLASS_V,"Vd,Vt,VjVm",MATCH_VSSRAVI,MASK_VSSRAVI,match_opcode,0},

	{"vnclipu.wv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VNCLIPUWV,MASK_VNCLIPUWV,match_opcode,0},
	{"vnclipu.wx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VNCLIPUWX,MASK_VNCLIPUWX,match_opcode,0},
	{"vnclipu.wi",0,INSN_CLASS_V,"Vd,Vt,VjVm",MATCH_VNCLIPUWI,MASK_VNCLIPUWI,match_opcode,0},
	{"vnclip.wv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VNCLIPWV,MASK_VNCLIPWV,match_opcode,0},
	{"vnclip.wx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VNCLIPWX,MASK_VNCLIPWX,match_opcode,0},
	{"vnclip.wi",0,INSN_CLASS_V,"Vd,Vt,VjVm",MATCH_VNCLIPWI,MASK_VNCLIPWI,match_opcode,0},

	{"vfadd.vv",0,INSN_CLASS_ZVEF,"Vd,Vt,VsVm",MATCH_VFADDVV,MASK_VFADDVV,match_opcode,0},
	{"vfadd.vf",0,INSN_CLASS_ZVEF,"Vd,Vt,SVm",MATCH_VFADDVF,MASK_VFADDVF,match_opcode,0},
	{"vfsub.vv",0,INSN_CLASS_ZVEF,"Vd,Vt,VsVm",MATCH_VFSUBVV,MASK_VFSUBVV,match_opcode,0},
	{"vfsub.vf",0,INSN_CLASS_ZVEF,"Vd,Vt,SVm",MATCH_VFSUBVF,MASK_VFSUBVF,match_opcode,0},
	{"vfrsub.vf",0,INSN_CLASS_ZVEF,"Vd,Vt,SVm",MATCH_VFRSUBVF,MASK_VFRSUBVF,match_opcode,0},

	{"vfwadd.vv",0,INSN_CLASS_ZVEF,"Vd,Vt,VsVm",MATCH_VFWADDVV,MASK_VFWADDVV,match_opcode,0},
	{"vfwadd.vf",0,INSN_CLASS_ZVEF,"Vd,Vt,SVm",MATCH_VFWADDVF,MASK_VFWADDVF,match_opcode,0},
	{"vfwsub.vv",0,INSN_CLASS_ZVEF,"Vd,Vt,VsVm",MATCH_VFWSUBVV,MASK_VFWSUBVV,match_opcode,0},
	{"vfwsub.vf",0,INSN_CLASS_ZVEF,"Vd,Vt,SVm",MATCH_VFWSUBVF,MASK_VFWSUBVF,match_opcode,0},
	{"vfwadd.wv",0,INSN_CLASS_ZVEF,"Vd,Vt,VsVm",MATCH_VFWADDWV,MASK_VFWADDWV,match_opcode,0},
	{"vfwadd.wf",0,INSN_CLASS_ZVEF,"Vd,Vt,SVm",MATCH_VFWADDWF,MASK_VFWADDWF,match_opcode,0},
	{"vfwsub.wv",0,INSN_CLASS_ZVEF,"Vd,Vt,VsVm",MATCH_VFWSUBWV,MASK_VFWSUBWV,match_opcode,0},
	{"vfwsub.wf",0,INSN_CLASS_ZVEF,"Vd,Vt,SVm",MATCH_VFWSUBWF,MASK_VFWSUBWF,match_opcode,0},

	{"vfmul.vv",0,INSN_CLASS_ZVEF,"Vd,Vt,VsVm",MATCH_VFMULVV,MASK_VFMULVV,match_opcode,0},
	{"vfmul.vf",0,INSN_CLASS_ZVEF,"Vd,Vt,SVm",MATCH_VFMULVF,MASK_VFMULVF,match_opcode,0},
	{"vfdiv.vv",0,INSN_CLASS_ZVEF,"Vd,Vt,VsVm",MATCH_VFDIVVV,MASK_VFDIVVV,match_opcode,0},
	{"vfdiv.vf",0,INSN_CLASS_ZVEF,"Vd,Vt,SVm",MATCH_VFDIVVF,MASK_VFDIVVF,match_opcode,0},
	{"vfrdiv.vf",0,INSN_CLASS_ZVEF,"Vd,Vt,SVm",MATCH_VFRDIVVF,MASK_VFRDIVVF,match_opcode,0},

	{"vfwmul.vv",0,INSN_CLASS_ZVEF,"Vd,Vt,VsVm",MATCH_VFWMULVV,MASK_VFWMULVV,match_opcode,0},
	{"vfwmul.vf",0,INSN_CLASS_ZVEF,"Vd,Vt,SVm",MATCH_VFWMULVF,MASK_VFWMULVF,match_opcode,0},

	{"vfmadd.vv",0,INSN_CLASS_ZVEF,"Vd,Vs,VtVm",MATCH_VFMADDVV,MASK_VFMADDVV,match_opcode,0},
	{"vfmadd.vf",0,INSN_CLASS_ZVEF,"Vd,S,VtVm",MATCH_VFMADDVF,MASK_VFMADDVF,match_opcode,0},
	{"vfnmadd.vv",0,INSN_CLASS_ZVEF,"Vd,Vs,VtVm",MATCH_VFNMADDVV,MASK_VFNMADDVV,match_opcode,0},
	{"vfnmadd.vf",0,INSN_CLASS_ZVEF,"Vd,S,VtVm",MATCH_VFNMADDVF,MASK_VFNMADDVF,match_opcode,0},
	{"vfmsub.vv",0,INSN_CLASS_ZVEF,"Vd,Vs,VtVm",MATCH_VFMSUBVV,MASK_VFMSUBVV,match_opcode,0},
	{"vfmsub.vf",0,INSN_CLASS_ZVEF,"Vd,S,VtVm",MATCH_VFMSUBVF,MASK_VFMSUBVF,match_opcode,0},
	{"vfnmsub.vv",0,INSN_CLASS_ZVEF,"Vd,Vs,VtVm",MATCH_VFNMSUBVV,MASK_VFNMSUBVV,match_opcode,0},
	{"vfnmsub.vf",0,INSN_CLASS_ZVEF,"Vd,S,VtVm",MATCH_VFNMSUBVF,MASK_VFNMSUBVF,match_opcode,0},
	{"vfmacc.vv",0,INSN_CLASS_ZVEF,"Vd,Vs,VtVm",MATCH_VFMACCVV,MASK_VFMACCVV,match_opcode,0},
	{"vfmacc.vf",0,INSN_CLASS_ZVEF,"Vd,S,VtVm",MATCH_VFMACCVF,MASK_VFMACCVF,match_opcode,0},
	{"vfnmacc.vv",0,INSN_CLASS_ZVEF,"Vd,Vs,VtVm",MATCH_VFNMACCVV,MASK_VFNMACCVV,match_opcode,0},
	{"vfnmacc.vf",0,INSN_CLASS_ZVEF,"Vd,S,VtVm",MATCH_VFNMACCVF,MASK_VFNMACCVF,match_opcode,0},
	{"vfmsac.vv",0,INSN_CLASS_ZVEF,"Vd,Vs,VtVm",MATCH_VFMSACVV,MASK_VFMSACVV,match_opcode,0},
	{"vfmsac.vf",0,INSN_CLASS_ZVEF,"Vd,S,VtVm",MATCH_VFMSACVF,MASK_VFMSACVF,match_opcode,0},
	{"vfnmsac.vv",0,INSN_CLASS_ZVEF,"Vd,Vs,VtVm",MATCH_VFNMSACVV,MASK_VFNMSACVV,match_opcode,0},
	{"vfnmsac.vf",0,INSN_CLASS_ZVEF,"Vd,S,VtVm",MATCH_VFNMSACVF,MASK_VFNMSACVF,match_opcode,0},

	{"vfwmacc.vv",0,INSN_CLASS_ZVEF,"Vd,Vs,VtVm",MATCH_VFWMACCVV,MASK_VFWMACCVV,match_opcode,0},
	{"vfwmacc.vf",0,INSN_CLASS_ZVEF,"Vd,S,VtVm",MATCH_VFWMACCVF,MASK_VFWMACCVF,match_opcode,0},
	{"vfwnmacc.vv",0,INSN_CLASS_ZVEF,"Vd,Vs,VtVm",MATCH_VFWNMACCVV,MASK_VFWNMACCVV,match_opcode,0},
	{"vfwnmacc.vf",0,INSN_CLASS_ZVEF,"Vd,S,VtVm",MATCH_VFWNMACCVF,MASK_VFWNMACCVF,match_opcode,0},
	{"vfwmsac.vv",0,INSN_CLASS_ZVEF,"Vd,Vs,VtVm",MATCH_VFWMSACVV,MASK_VFWMSACVV,match_opcode,0},
	{"vfwmsac.vf",0,INSN_CLASS_ZVEF,"Vd,S,VtVm",MATCH_VFWMSACVF,MASK_VFWMSACVF,match_opcode,0},
	{"vfwnmsac.vv",0,INSN_CLASS_ZVEF,"Vd,Vs,VtVm",MATCH_VFWNMSACVV,MASK_VFWNMSACVV,match_opcode,0},
	{"vfwnmsac.vf",0,INSN_CLASS_ZVEF,"Vd,S,VtVm",MATCH_VFWNMSACVF,MASK_VFWNMSACVF,match_opcode,0},

	{"vfsqrt.v",0,INSN_CLASS_ZVEF,"Vd,VtVm",MATCH_VFSQRTV,MASK_VFSQRTV,match_opcode,0},
	{"vfrsqrt7.v",0,INSN_CLASS_ZVEF,"Vd,VtVm",MATCH_VFRSQRT7V,MASK_VFRSQRT7V,match_opcode,0},
	{"vfrsqrte7.v",0,INSN_CLASS_ZVEF,"Vd,VtVm",MATCH_VFRSQRT7V,MASK_VFRSQRT7V,match_opcode,0},
	{"vfrec7.v",0,INSN_CLASS_ZVEF,"Vd,VtVm",MATCH_VFREC7V,MASK_VFREC7V,match_opcode,0},
	{"vfrece7.v",0,INSN_CLASS_ZVEF,"Vd,VtVm",MATCH_VFREC7V,MASK_VFREC7V,match_opcode,0},
	{"vfclass.v",0,INSN_CLASS_ZVEF,"Vd,VtVm",MATCH_VFCLASSV,MASK_VFCLASSV,match_opcode,0},

	{"vfmin.vv",0,INSN_CLASS_ZVEF,"Vd,Vt,VsVm",MATCH_VFMINVV,MASK_VFMINVV,match_opcode,0},
	{"vfmin.vf",0,INSN_CLASS_ZVEF,"Vd,Vt,SVm",MATCH_VFMINVF,MASK_VFMINVF,match_opcode,0},
	{"vfmax.vv",0,INSN_CLASS_ZVEF,"Vd,Vt,VsVm",MATCH_VFMAXVV,MASK_VFMAXVV,match_opcode,0},
	{"vfmax.vf",0,INSN_CLASS_ZVEF,"Vd,Vt,SVm",MATCH_VFMAXVF,MASK_VFMAXVF,match_opcode,0},

	{"vfneg.v",0,INSN_CLASS_ZVEF,"Vd,VuVm",MATCH_VFSGNJNVV,MASK_VFSGNJNVV,match_vs1_eq_vs2,INSN_ALIAS},
	{"vfabs.v",0,INSN_CLASS_ZVEF,"Vd,VuVm",MATCH_VFSGNJXVV,MASK_VFSGNJXVV,match_vs1_eq_vs2,INSN_ALIAS},

	{"vfsgnj.vv",0,INSN_CLASS_ZVEF,"Vd,Vt,VsVm",MATCH_VFSGNJVV,MASK_VFSGNJVV,match_opcode,0},
	{"vfsgnj.vf",0,INSN_CLASS_ZVEF,"Vd,Vt,SVm",MATCH_VFSGNJVF,MASK_VFSGNJVF,match_opcode,0},
	{"vfsgnjn.vv",0,INSN_CLASS_ZVEF,"Vd,Vt,VsVm",MATCH_VFSGNJNVV,MASK_VFSGNJNVV,match_opcode,0},
	{"vfsgnjn.vf",0,INSN_CLASS_ZVEF,"Vd,Vt,SVm",MATCH_VFSGNJNVF,MASK_VFSGNJNVF,match_opcode,0},
	{"vfsgnjx.vv",0,INSN_CLASS_ZVEF,"Vd,Vt,VsVm",MATCH_VFSGNJXVV,MASK_VFSGNJXVV,match_opcode,0},
	{"vfsgnjx.vf",0,INSN_CLASS_ZVEF,"Vd,Vt,SVm",MATCH_VFSGNJXVF,MASK_VFSGNJXVF,match_opcode,0},

	{"vmfeq.vv",0,INSN_CLASS_ZVEF,"Vd,Vt,VsVm",MATCH_VMFEQVV,MASK_VMFEQVV,match_opcode,0},
	{"vmfeq.vf",0,INSN_CLASS_ZVEF,"Vd,Vt,SVm",MATCH_VMFEQVF,MASK_VMFEQVF,match_opcode,0},
	{"vmfne.vv",0,INSN_CLASS_ZVEF,"Vd,Vt,VsVm",MATCH_VMFNEVV,MASK_VMFNEVV,match_opcode,0},
	{"vmfne.vf",0,INSN_CLASS_ZVEF,"Vd,Vt,SVm",MATCH_VMFNEVF,MASK_VMFNEVF,match_opcode,0},
	{"vmflt.vv",0,INSN_CLASS_ZVEF,"Vd,Vt,VsVm",MATCH_VMFLTVV,MASK_VMFLTVV,match_opcode,0},
	{"vmflt.vf",0,INSN_CLASS_ZVEF,"Vd,Vt,SVm",MATCH_VMFLTVF,MASK_VMFLTVF,match_opcode,0},
	{"vmfle.vv",0,INSN_CLASS_ZVEF,"Vd,Vt,VsVm",MATCH_VMFLEVV,MASK_VMFLEVV,match_opcode,0},
	{"vmfle.vf",0,INSN_CLASS_ZVEF,"Vd,Vt,SVm",MATCH_VMFLEVF,MASK_VMFLEVF,match_opcode,0},
	{"vmfgt.vf",0,INSN_CLASS_ZVEF,"Vd,Vt,SVm",MATCH_VMFGTVF,MASK_VMFGTVF,match_opcode,0},
	{"vmfge.vf",0,INSN_CLASS_ZVEF,"Vd,Vt,SVm",MATCH_VMFGEVF,MASK_VMFGEVF,match_opcode,0},

	/* These aliases are for assembly but not disassembly.  */
	{"vmfgt.vv",0,INSN_CLASS_ZVEF,"Vd,Vs,VtVm",MATCH_VMFLTVV,MASK_VMFLTVV,match_opcode,INSN_ALIAS},
	{"vmfge.vv",0,INSN_CLASS_ZVEF,"Vd,Vs,VtVm",MATCH_VMFLEVV,MASK_VMFLEVV,match_opcode,INSN_ALIAS},

	{"vfmerge.vfm",0,INSN_CLASS_ZVEF,"Vd,Vt,S,V0",MATCH_VFMERGEVFM,MASK_VFMERGEVFM,match_opcode,0},
	{"vfmv.v.f",0,INSN_CLASS_ZVEF,"Vd,S",MATCH_VFMVVF,MASK_VFMVVF,match_opcode,0},

	{"vfcvt.xu.f.v",0,INSN_CLASS_ZVEF,"Vd,VtVm",MATCH_VFCVTXUFV,MASK_VFCVTXUFV,match_opcode,0},
	{"vfcvt.x.f.v",0,INSN_CLASS_ZVEF,"Vd,VtVm",MATCH_VFCVTXFV,MASK_VFCVTXFV,match_opcode,0},
	{"vfcvt.rtz.xu.f.v",0,INSN_CLASS_ZVEF,"Vd,VtVm",MATCH_VFCVTRTZXUFV,MASK_VFCVTRTZXUFV,match_opcode,0},
	{"vfcvt.rtz.x.f.v",0,INSN_CLASS_ZVEF,"Vd,VtVm",MATCH_VFCVTRTZXFV,MASK_VFCVTRTZXFV,match_opcode,0},
	{"vfcvt.f.xu.v",0,INSN_CLASS_ZVEF,"Vd,VtVm",MATCH_VFCVTFXUV,MASK_VFCVTFXUV,match_opcode,0},
	{"vfcvt.f.x.v",0,INSN_CLASS_ZVEF,"Vd,VtVm",MATCH_VFCVTFXV,MASK_VFCVTFXV,match_opcode,0},

	{"vfwcvt.xu.f.v",0,INSN_CLASS_ZVEF,"Vd,VtVm",MATCH_VFWCVTXUFV,MASK_VFWCVTXUFV,match_opcode,0},
	{"vfwcvt.x.f.v",0,INSN_CLASS_ZVEF,"Vd,VtVm",MATCH_VFWCVTXFV,MASK_VFWCVTXFV,match_opcode,0},
	{"vfwcvt.rtz.xu.f.v",0,INSN_CLASS_ZVEF,"Vd,VtVm",MATCH_VFWCVTRTZXUFV,MASK_VFWCVTRTZXUFV,match_opcode,0},
	{"vfwcvt.rtz.x.f.v",0,INSN_CLASS_ZVEF,"Vd,VtVm",MATCH_VFWCVTRTZXFV,MASK_VFWCVTRTZXFV,match_opcode,0},
	{"vfwcvt.f.xu.v",0,INSN_CLASS_ZVEF,"Vd,VtVm",MATCH_VFWCVTFXUV,MASK_VFWCVTFXUV,match_opcode,0},
	{"vfwcvt.f.x.v",0,INSN_CLASS_ZVEF,"Vd,VtVm",MATCH_VFWCVTFXV,MASK_VFWCVTFXV,match_opcode,0},
	{"vfwcvt.f.f.v",0,INSN_CLASS_ZVEF,"Vd,VtVm",MATCH_VFWCVTFFV,MASK_VFWCVTFFV,match_opcode,0},

	{"vfncvt.xu.f.w",0,INSN_CLASS_ZVEF,"Vd,VtVm",MATCH_VFNCVTXUFW,MASK_VFNCVTXUFW,match_opcode,0},
	{"vfncvt.x.f.w",0,INSN_CLASS_ZVEF,"Vd,VtVm",MATCH_VFNCVTXFW,MASK_VFNCVTXFW,match_opcode,0},
	{"vfncvt.rtz.xu.f.w",0,INSN_CLASS_ZVEF,"Vd,VtVm",MATCH_VFNCVTRTZXUFW,MASK_VFNCVTRTZXUFW,match_opcode,0},
	{"vfncvt.rtz.x.f.w",0,INSN_CLASS_ZVEF,"Vd,VtVm",MATCH_VFNCVTRTZXFW,MASK_VFNCVTRTZXFW,match_opcode,0},
	{"vfncvt.f.xu.w",0,INSN_CLASS_ZVEF,"Vd,VtVm",MATCH_VFNCVTFXUW,MASK_VFNCVTFXUW,match_opcode,0},
	{"vfncvt.f.x.w",0,INSN_CLASS_ZVEF,"Vd,VtVm",MATCH_VFNCVTFXW,MASK_VFNCVTFXW,match_opcode,0},
	{"vfncvt.f.f.w",0,INSN_CLASS_ZVEF,"Vd,VtVm",MATCH_VFNCVTFFW,MASK_VFNCVTFFW,match_opcode,0},
	{"vfncvt.rod.f.f.w",0,INSN_CLASS_ZVEF,"Vd,VtVm",MATCH_VFNCVTRODFFW,MASK_VFNCVTRODFFW,match_opcode,0},

	{"vredsum.vs",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VREDSUMVS,MASK_VREDSUMVS,match_opcode,0},
	{"vredmaxu.vs",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VREDMAXUVS,MASK_VREDMAXUVS,match_opcode,0},
	{"vredmax.vs",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VREDMAXVS,MASK_VREDMAXVS,match_opcode,0},
	{"vredminu.vs",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VREDMINUVS,MASK_VREDMINUVS,match_opcode,0},
	{"vredmin.vs",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VREDMINVS,MASK_VREDMINVS,match_opcode,0},
	{"vredand.vs",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VREDANDVS,MASK_VREDANDVS,match_opcode,0},
	{"vredor.vs",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VREDORVS,MASK_VREDORVS,match_opcode,0},
	{"vredxor.vs",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VREDXORVS,MASK_VREDXORVS,match_opcode,0},

	{"vwredsumu.vs",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VWREDSUMUVS,MASK_VWREDSUMUVS,match_opcode,0},
	{"vwredsum.vs",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VWREDSUMVS,MASK_VWREDSUMVS,match_opcode,0},

	{"vfredosum.vs",0,INSN_CLASS_ZVEF,"Vd,Vt,VsVm",MATCH_VFREDOSUMVS,MASK_VFREDOSUMVS,match_opcode,0},
	{"vfredusum.vs",0,INSN_CLASS_ZVEF,"Vd,Vt,VsVm",MATCH_VFREDUSUMVS,MASK_VFREDUSUMVS,match_opcode,0},
	{"vfredsum.vs",0,INSN_CLASS_ZVEF,"Vd,Vt,VsVm",MATCH_VFREDUSUMVS,MASK_VFREDUSUMVS,match_opcode,INSN_ALIAS},
	{"vfredmax.vs",0,INSN_CLASS_ZVEF,"Vd,Vt,VsVm",MATCH_VFREDMAXVS,MASK_VFREDMAXVS,match_opcode,0},
	{"vfredmin.vs",0,INSN_CLASS_ZVEF,"Vd,Vt,VsVm",MATCH_VFREDMINVS,MASK_VFREDMINVS,match_opcode,0},

	{"vfwredosum.vs",0,INSN_CLASS_ZVEF,"Vd,Vt,VsVm",MATCH_VFWREDOSUMVS,MASK_VFWREDOSUMVS,match_opcode,0},
	{"vfwredusum.vs",0,INSN_CLASS_ZVEF,"Vd,Vt,VsVm",MATCH_VFWREDUSUMVS,MASK_VFWREDUSUMVS,match_opcode,0},
	{"vfwredsum.vs",0,INSN_CLASS_ZVEF,"Vd,Vt,VsVm",MATCH_VFWREDUSUMVS,MASK_VFWREDUSUMVS,match_opcode,INSN_ALIAS},

	{"vmmv.m",0,INSN_CLASS_V,"Vd,Vu",MATCH_VMANDMM,MASK_VMANDMM,match_vs1_eq_vs2,INSN_ALIAS},
	{"vmcpy.m",0,INSN_CLASS_V,"Vd,Vu",MATCH_VMANDMM,MASK_VMANDMM,match_vs1_eq_vs2,INSN_ALIAS},
	{"vmclr.m",0,INSN_CLASS_V,"Vv",MATCH_VMXORMM,MASK_VMXORMM,match_vd_eq_vs1_eq_vs2,INSN_ALIAS},
	{"vmset.m",0,INSN_CLASS_V,"Vv",MATCH_VMXNORMM,MASK_VMXNORMM,match_vd_eq_vs1_eq_vs2,INSN_ALIAS},
	{"vmnot.m",0,INSN_CLASS_V,"Vd,Vu",MATCH_VMNANDMM,MASK_VMNANDMM,match_vs1_eq_vs2,INSN_ALIAS},

	{"vmand.mm",0,INSN_CLASS_V,"Vd,Vt,Vs",MATCH_VMANDMM,MASK_VMANDMM,match_opcode,0},
	{"vmnand.mm",0,INSN_CLASS_V,"Vd,Vt,Vs",MATCH_VMNANDMM,MASK_VMNANDMM,match_opcode,0},
	{"vmandn.mm",0,INSN_CLASS_V,"Vd,Vt,Vs",MATCH_VMANDNMM,MASK_VMANDNMM,match_opcode,0},
	{"vmandnot.mm",0,INSN_CLASS_V,"Vd,Vt,Vs",MATCH_VMANDNMM,MASK_VMANDNMM,match_opcode,INSN_ALIAS},
	{"vmxor.mm",0,INSN_CLASS_V,"Vd,Vt,Vs",MATCH_VMXORMM,MASK_VMXORMM,match_opcode,0},
	{"vmor.mm",0,INSN_CLASS_V,"Vd,Vt,Vs",MATCH_VMORMM,MASK_VMORMM,match_opcode,0},
	{"vmnor.mm",0,INSN_CLASS_V,"Vd,Vt,Vs",MATCH_VMNORMM,MASK_VMNORMM,match_opcode,0},
	{"vmorn.mm",0,INSN_CLASS_V,"Vd,Vt,Vs",MATCH_VMORNMM,MASK_VMORNMM,match_opcode,0},
	{"vmornot.mm",0,INSN_CLASS_V,"Vd,Vt,Vs",MATCH_VMORNMM,MASK_VMORNMM,match_opcode,INSN_ALIAS},
	{"vmxnor.mm",0,INSN_CLASS_V,"Vd,Vt,Vs",MATCH_VMXNORMM,MASK_VMXNORMM,match_opcode,0},

	{"vcpop.m",0,INSN_CLASS_V,"d,VtVm",MATCH_VCPOPM,MASK_VCPOPM,match_opcode,0},
	{"vpopc.m",0,INSN_CLASS_V,"d,VtVm",MATCH_VCPOPM,MASK_VCPOPM,match_opcode,INSN_ALIAS},
	{"vfirst.m",0,INSN_CLASS_V,"d,VtVm",MATCH_VFIRSTM,MASK_VFIRSTM,match_opcode,0},
	{"vmsbf.m",0,INSN_CLASS_V,"Vd,VtVm",MATCH_VMSBFM,MASK_VMSBFM,match_opcode,0},
	{"vmsif.m",0,INSN_CLASS_V,"Vd,VtVm",MATCH_VMSIFM,MASK_VMSIFM,match_opcode,0},
	{"vmsof.m",0,INSN_CLASS_V,"Vd,VtVm",MATCH_VMSOFM,MASK_VMSOFM,match_opcode,0},
	{"viota.m",0,INSN_CLASS_V,"Vd,VtVm",MATCH_VIOTAM,MASK_VIOTAM,match_opcode,0},
	{"vid.v",0,INSN_CLASS_V,"VdVm",MATCH_VIDV,MASK_VIDV,match_opcode,0},

	{"vmv.x.s",0,INSN_CLASS_V,"d,Vt",MATCH_VMVXS,MASK_VMVXS,match_opcode,0},
	{"vmv.s.x",0,INSN_CLASS_V,"Vd,s",MATCH_VMVSX,MASK_VMVSX,match_opcode,0},

	{"vfmv.f.s",0,INSN_CLASS_ZVEF,"D,Vt",MATCH_VFMVFS,MASK_VFMVFS,match_opcode,0},
	{"vfmv.s.f",0,INSN_CLASS_ZVEF,"Vd,S",MATCH_VFMVSF,MASK_VFMVSF,match_opcode,0},

	{"vslideup.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VSLIDEUPVX,MASK_VSLIDEUPVX,match_opcode,0},
	{"vslideup.vi",0,INSN_CLASS_V,"Vd,Vt,VjVm",MATCH_VSLIDEUPVI,MASK_VSLIDEUPVI,match_opcode,0},
	{"vslidedown.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VSLIDEDOWNVX,MASK_VSLIDEDOWNVX,match_opcode,0},
	{"vslidedown.vi",0,INSN_CLASS_V,"Vd,Vt,VjVm",MATCH_VSLIDEDOWNVI,MASK_VSLIDEDOWNVI,match_opcode,0},

	{"vslide1up.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VSLIDE1UPVX,MASK_VSLIDE1UPVX,match_opcode,0},
	{"vslide1down.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VSLIDE1DOWNVX,MASK_VSLIDE1DOWNVX,match_opcode,0},
	{"vfslide1up.vf",0,INSN_CLASS_ZVEF,"Vd,Vt,SVm",MATCH_VFSLIDE1UPVF,MASK_VFSLIDE1UPVF,match_opcode,0},
	{"vfslide1down.vf",0,INSN_CLASS_ZVEF,"Vd,Vt,SVm",MATCH_VFSLIDE1DOWNVF,MASK_VFSLIDE1DOWNVF,match_opcode,0},

	{"vrgather.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VRGATHERVV,MASK_VRGATHERVV,match_opcode,0},
	{"vrgather.vx",0,INSN_CLASS_V,"Vd,Vt,sVm",MATCH_VRGATHERVX,MASK_VRGATHERVX,match_opcode,0},
	{"vrgather.vi",0,INSN_CLASS_V,"Vd,Vt,VjVm",MATCH_VRGATHERVI,MASK_VRGATHERVI,match_opcode,0},
	{"vrgatherei16.vv",0,INSN_CLASS_V,"Vd,Vt,VsVm",MATCH_VRGATHEREI16VV,MASK_VRGATHEREI16VV,match_opcode,0},

	{"vcompress.vm",0,INSN_CLASS_V,"Vd,Vt,Vs",MATCH_VCOMPRESSVM,MASK_VCOMPRESSVM,match_opcode,0},

	{"vmv1r.v",0,INSN_CLASS_V,"Vd,Vt",MATCH_VMV1RV,MASK_VMV1RV,match_opcode,0},
	{"vmv2r.v",0,INSN_CLASS_V,"Vd,Vt",MATCH_VMV2RV,MASK_VMV2RV,match_opcode,0},
	{"vmv4r.v",0,INSN_CLASS_V,"Vd,Vt",MATCH_VMV4RV,MASK_VMV4RV,match_opcode,0},
	{"vmv8r.v",0,INSN_CLASS_V,"Vd,Vt",MATCH_VMV8RV,MASK_VMV8RV,match_opcode,0},

	/* Supervisor instructions.  */
	{"csrr",0,INSN_CLASS_ZICSR,"d,E",MATCH_CSRRS,MASK_CSRRS|MASK_RS1,match_opcode,INSN_ALIAS},
	{"csrw",0,INSN_CLASS_ZICSR,"E,s",MATCH_CSRRW,MASK_CSRRW|MASK_RD,match_opcode,INSN_ALIAS},
	{"csrw",0,INSN_CLASS_ZICSR,"E,Z",MATCH_CSRRWI,MASK_CSRRWI|MASK_RD,match_opcode,INSN_ALIAS},
	{"csrwi",0,INSN_CLASS_ZICSR,"E,Z",MATCH_CSRRWI,MASK_CSRRWI|MASK_RD,match_opcode,INSN_ALIAS},
	{"csrs",0,INSN_CLASS_ZICSR,"E,s",MATCH_CSRRS,MASK_CSRRS|MASK_RD,match_opcode,INSN_ALIAS},
	{"csrs",0,INSN_CLASS_ZICSR,"E,Z",MATCH_CSRRSI,MASK_CSRRSI|MASK_RD,match_opcode,INSN_ALIAS},
	{"csrsi",0,INSN_CLASS_ZICSR,"E,Z",MATCH_CSRRSI,MASK_CSRRSI|MASK_RD,match_opcode,INSN_ALIAS},
	{"csrc",0,INSN_CLASS_ZICSR,"E,s",MATCH_CSRRC,MASK_CSRRC|MASK_RD,match_opcode,INSN_ALIAS},
	{"csrc",0,INSN_CLASS_ZICSR,"E,Z",MATCH_CSRRCI,MASK_CSRRCI|MASK_RD,match_opcode,INSN_ALIAS},
	{"csrci",0,INSN_CLASS_ZICSR,"E,Z",MATCH_CSRRCI,MASK_CSRRCI|MASK_RD,match_opcode,INSN_ALIAS},
	{"csrrw",0,INSN_CLASS_ZICSR,"d,E,s",MATCH_CSRRW,MASK_CSRRW,match_opcode,0},
	{"csrrw",0,INSN_CLASS_ZICSR,"d,E,Z",MATCH_CSRRWI,MASK_CSRRWI,match_opcode,INSN_ALIAS},
	{"csrrwi",0,INSN_CLASS_ZICSR,"d,E,Z",MATCH_CSRRWI,MASK_CSRRWI,match_opcode,0},
	{"csrrs",0,INSN_CLASS_ZICSR,"d,E,s",MATCH_CSRRS,MASK_CSRRS,match_opcode,0},
	{"csrrs",0,INSN_CLASS_ZICSR,"d,E,Z",MATCH_CSRRSI,MASK_CSRRSI,match_opcode,INSN_ALIAS},
	{"csrrsi",0,INSN_CLASS_ZICSR,"d,E,Z",MATCH_CSRRSI,MASK_CSRRSI,match_opcode,0},
	{"csrrc",0,INSN_CLASS_ZICSR,"d,E,s",MATCH_CSRRC,MASK_CSRRC,match_opcode,0},
	{"csrrc",0,INSN_CLASS_ZICSR,"d,E,Z",MATCH_CSRRCI,MASK_CSRRCI,match_opcode,INSN_ALIAS},
	{"csrrci",0,INSN_CLASS_ZICSR,"d,E,Z",MATCH_CSRRCI,MASK_CSRRCI,match_opcode,0},
	{"uret",0,INSN_CLASS_I,"",MATCH_URET,MASK_URET,match_opcode,0},
	{"sret",0,INSN_CLASS_I,"",MATCH_SRET,MASK_SRET,match_opcode,0},
	{"hret",0,INSN_CLASS_I,"",MATCH_HRET,MASK_HRET,match_opcode,0},
	{"mret",0,INSN_CLASS_I,"",MATCH_MRET,MASK_MRET,match_opcode,0},
	{"dret",0,INSN_CLASS_I,"",MATCH_DRET,MASK_DRET,match_opcode,0},
	{"sfence.vm",0,INSN_CLASS_I,"",MATCH_SFENCE_VM,MASK_SFENCE_VM|MASK_RS1,match_opcode,0},
	{"sfence.vm",0,INSN_CLASS_I,"s",MATCH_SFENCE_VM,MASK_SFENCE_VM,match_opcode,0},
	{"sfence.vma",0,INSN_CLASS_I,"",MATCH_SFENCE_VMA,MASK_SFENCE_VMA|MASK_RS1|MASK_RS2,match_opcode,INSN_ALIAS},
	{"sfence.vma",0,INSN_CLASS_I,"s",MATCH_SFENCE_VMA,MASK_SFENCE_VMA|MASK_RS2,match_opcode,INSN_ALIAS},
	{"sfence.vma",0,INSN_CLASS_I,"s,t",MATCH_SFENCE_VMA,MASK_SFENCE_VMA,match_opcode,0},
	{"wfi",0,INSN_CLASS_I,"",MATCH_WFI,MASK_WFI,match_opcode,0},

	/* Svinval instructions.  */
	{"sinval.vma",0,INSN_CLASS_SVINVAL,"s,t",MATCH_SINVAL_VMA,MASK_SINVAL_VMA,match_opcode,0},
	{"sfence.w.inval",0,INSN_CLASS_SVINVAL,"",MATCH_SFENCE_W_INVAL,MASK_SFENCE_W_INVAL,match_opcode,0},
	{"sfence.inval.ir",0,INSN_CLASS_SVINVAL,"",MATCH_SFENCE_INVAL_IR,MASK_SFENCE_INVAL_IR,match_opcode,0},
	{"hinval.vvma",0,INSN_CLASS_SVINVAL,"s,t",MATCH_HINVAL_VVMA,MASK_HINVAL_VVMA,match_opcode,0},
	{"hinval.gvma",0,INSN_CLASS_SVINVAL,"s,t",MATCH_HINVAL_GVMA,MASK_HINVAL_GVMA,match_opcode,0},

	/* Hypervisor instructions.  */
	{"hfence.vvma",0,INSN_CLASS_H,"",MATCH_HFENCE_VVMA,MASK_HFENCE_VVMA|MASK_RS1|MASK_RS2,match_opcode,INSN_ALIAS},
	{"hfence.vvma",0,INSN_CLASS_H,"s",MATCH_HFENCE_VVMA,MASK_HFENCE_VVMA|MASK_RS2,match_opcode,INSN_ALIAS},
	{"hfence.vvma",0,INSN_CLASS_H,"s,t",MATCH_HFENCE_VVMA,MASK_HFENCE_VVMA,match_opcode,0},
	{"hfence.gvma",0,INSN_CLASS_H,"",MATCH_HFENCE_GVMA,MASK_HFENCE_GVMA|MASK_RS1|MASK_RS2,match_opcode,INSN_ALIAS},
	{"hfence.gvma",0,INSN_CLASS_H,"s",MATCH_HFENCE_GVMA,MASK_HFENCE_GVMA|MASK_RS2,match_opcode,INSN_ALIAS},
	{"hfence.gvma",0,INSN_CLASS_H,"s,t",MATCH_HFENCE_GVMA,MASK_HFENCE_GVMA,match_opcode,0},
	{"hlv.b",0,INSN_CLASS_H,"d,0(s)",MATCH_HLV_B,MASK_HLV_B,match_opcode,INSN_DREF|INSN_1_BYTE},
	{"hlv.bu",0,INSN_CLASS_H,"d,0(s)",MATCH_HLV_BU,MASK_HLV_BU,match_opcode,INSN_DREF|INSN_1_BYTE},
	{"hlv.h",0,INSN_CLASS_H,"d,0(s)",MATCH_HLV_H,MASK_HLV_H,match_opcode,INSN_DREF|INSN_2_BYTE},
	{"hlv.hu",0,INSN_CLASS_H,"d,0(s)",MATCH_HLV_HU,MASK_HLV_HU,match_opcode,INSN_DREF|INSN_2_BYTE},
	{"hlvx.hu",0,INSN_CLASS_H,"d,0(s)",MATCH_HLVX_HU,MASK_HLVX_HU,match_opcode,INSN_DREF|INSN_2_BYTE},
	{"hlv.w",0,INSN_CLASS_H,"d,0(s)",MATCH_HLV_W,MASK_HLV_W,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"hlv.wu",64,INSN_CLASS_H,"d,0(s)",MATCH_HLV_WU,MASK_HLV_WU,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"hlvx.wu",0,INSN_CLASS_H,"d,0(s)",MATCH_HLVX_WU,MASK_HLVX_WU,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"hlv.d",64,INSN_CLASS_H,"d,0(s)",MATCH_HLV_D,MASK_HLV_D,match_opcode,INSN_DREF|INSN_8_BYTE},
	{"hsv.b",0,INSN_CLASS_H,"t,0(s)",MATCH_HSV_B,MASK_HSV_B,match_opcode,INSN_DREF|INSN_1_BYTE},
	{"hsv.h",0,INSN_CLASS_H,"t,0(s)",MATCH_HSV_H,MASK_HSV_H,match_opcode,INSN_DREF|INSN_2_BYTE},
	{"hsv.w",0,INSN_CLASS_H,"t,0(s)",MATCH_HSV_W,MASK_HSV_W,match_opcode,INSN_DREF|INSN_4_BYTE},
	{"hsv.d",64,INSN_CLASS_H,"t,0(s)",MATCH_HSV_D,MASK_HSV_D,match_opcode,INSN_DREF|INSN_8_BYTE},

	/* Vendor-specific (T-Head) XTheadBa instructions.  */
	{"th.addsl",0,INSN_CLASS_XTHEADBA,"d,s,t,Xu2@25",MATCH_TH_ADDSL,MASK_TH_ADDSL,match_opcode,0},

	/* Vendor-specific (T-Head) XTheadBb instructions.  */
	{"th.srri",0,INSN_CLASS_XTHEADBB,"d,s,Xu6@20",MATCH_TH_SRRI,MASK_TH_SRRI,match_opcode,0},
	{"th.srriw",64,INSN_CLASS_XTHEADBB,"d,s,Xu5@20",MATCH_TH_SRRIW,MASK_TH_SRRIW,match_opcode,0},
	{"th.ext",0,INSN_CLASS_XTHEADBB,"d,s,Xu6@26,Xu6@20",MATCH_TH_EXT,MASK_TH_EXT,match_opcode,0},
	{"th.extu",0,INSN_CLASS_XTHEADBB,"d,s,Xu6@26,Xu6@20",MATCH_TH_EXTU,MASK_TH_EXTU,match_opcode,0},
	{"th.ff0",0,INSN_CLASS_XTHEADBB,"d,s",MATCH_TH_FF0,MASK_TH_FF0,match_opcode,0},
	{"th.ff1",0,INSN_CLASS_XTHEADBB,"d,s",MATCH_TH_FF1,MASK_TH_FF1,match_opcode,0},
	{"th.rev",0,INSN_CLASS_XTHEADBB,"d,s",MATCH_TH_REV,MASK_TH_REV,match_opcode,0},
	{"th.revw",64,INSN_CLASS_XTHEADBB,"d,s",MATCH_TH_REVW,MASK_TH_REVW,match_opcode,0},
	{"th.tstnbz",0,INSN_CLASS_XTHEADBB,"d,s",MATCH_TH_TSTNBZ,MASK_TH_TSTNBZ,match_opcode,0},

	/* Vendor-specific (T-Head) XTheadBs instructions.  */
	{"th.tst",0,INSN_CLASS_XTHEADBS,"d,s,Xu6@20",MATCH_TH_TST,MASK_TH_TST,match_opcode,0},

	/* Vendor-specific (T-Head) XTheadCmo instructions.  */
	{"th.dcache.call",0,INSN_CLASS_XTHEADCMO,"",MATCH_TH_DCACHE_CALL,MASK_TH_DCACHE_CALL,match_opcode,0},
	{"th.dcache.ciall",0,INSN_CLASS_XTHEADCMO,"",MATCH_TH_DCACHE_CIALL,MASK_TH_DCACHE_CIALL,match_opcode,0},
	{"th.dcache.iall",0,INSN_CLASS_XTHEADCMO,"",MATCH_TH_DCACHE_IALL,MASK_TH_DCACHE_IALL,match_opcode,0},
	{"th.dcache.cpa",0,INSN_CLASS_XTHEADCMO,"s",MATCH_TH_DCACHE_CPA,MASK_TH_DCACHE_CPA,match_opcode,0},
	{"th.dcache.cipa",0,INSN_CLASS_XTHEADCMO,"s",MATCH_TH_DCACHE_CIPA,MASK_TH_DCACHE_CIPA,match_opcode,0},
	{"th.dcache.ipa",0,INSN_CLASS_XTHEADCMO,"s",MATCH_TH_DCACHE_IPA,MASK_TH_DCACHE_IPA,match_opcode,0},
	{"th.dcache.cva",0,INSN_CLASS_XTHEADCMO,"s",MATCH_TH_DCACHE_CVA,MASK_TH_DCACHE_CVA,match_opcode,0},
	{"th.dcache.civa",0,INSN_CLASS_XTHEADCMO,"s",MATCH_TH_DCACHE_CIVA,MASK_TH_DCACHE_CIVA,match_opcode,0},
	{"th.dcache.iva",0,INSN_CLASS_XTHEADCMO,"s",MATCH_TH_DCACHE_IVA,MASK_TH_DCACHE_IVA,match_opcode,0},
	{"th.dcache.csw",0,INSN_CLASS_XTHEADCMO,"s",MATCH_TH_DCACHE_CSW,MASK_TH_DCACHE_CSW,match_opcode,0},
	{"th.dcache.cisw",0,INSN_CLASS_XTHEADCMO,"s",MATCH_TH_DCACHE_CISW,MASK_TH_DCACHE_CISW,match_opcode,0},
	{"th.dcache.isw",0,INSN_CLASS_XTHEADCMO,"s",MATCH_TH_DCACHE_ISW,MASK_TH_DCACHE_ISW,match_opcode,0},
	{"th.dcache.cpal1",0,INSN_CLASS_XTHEADCMO,"s",MATCH_TH_DCACHE_CPAL1,MASK_TH_DCACHE_CPAL1,match_opcode,0},
	{"th.dcache.cval1",0,INSN_CLASS_XTHEADCMO,"s",MATCH_TH_DCACHE_CVAL1,MASK_TH_DCACHE_CVAL1,match_opcode,0},

	{"th.icache.iall",0,INSN_CLASS_XTHEADCMO,"",MATCH_TH_ICACHE_IALL,MASK_TH_ICACHE_IALL,match_opcode,0},
	{"th.icache.ialls",0,INSN_CLASS_XTHEADCMO,"",MATCH_TH_ICACHE_IALLS,MASK_TH_ICACHE_IALLS,match_opcode,0},
	{"th.icache.ipa",0,INSN_CLASS_XTHEADCMO,"s",MATCH_TH_ICACHE_IPA,MASK_TH_ICACHE_IPA,match_opcode,0},
	{"th.icache.iva",0,INSN_CLASS_XTHEADCMO,"s",MATCH_TH_ICACHE_IVA,MASK_TH_ICACHE_IVA,match_opcode,0},

	{"th.l2cache.call",0,INSN_CLASS_XTHEADCMO,"",MATCH_TH_L2CACHE_CALL,MASK_TH_L2CACHE_CALL,match_opcode,0},
	{"th.l2cache.ciall",0,INSN_CLASS_XTHEADCMO,"",MATCH_TH_L2CACHE_CIALL,MASK_TH_L2CACHE_CIALL,match_opcode,0},
	{"th.l2cache.iall",0,INSN_CLASS_XTHEADCMO,"",MATCH_TH_L2CACHE_IALL,MASK_TH_L2CACHE_IALL,match_opcode,0},

	/* Vendor-specific (T-Head) XTheadCondMov instructions.  */
	{"th.mveqz",0,INSN_CLASS_XTHEADCONDMOV,"d,s,t",MATCH_TH_MVEQZ,MASK_TH_MVEQZ,match_opcode,0},
	{"th.mvnez",0,INSN_CLASS_XTHEADCONDMOV,"d,s,t",MATCH_TH_MVNEZ,MASK_TH_MVNEZ,match_opcode,0},

	/* Vendor-specific (T-Head) XTheadFMemIdx instructions.  */
	{"th.flrd",0,INSN_CLASS_XTHEADFMEMIDX,"D,s,t,Xu2@25",MATCH_TH_FLRD,MASK_TH_FLRD,match_opcode,0},
	{"th.flrw",0,INSN_CLASS_XTHEADFMEMIDX,"D,s,t,Xu2@25",MATCH_TH_FLRW,MASK_TH_FLRW,match_opcode,0},
	{"th.flurd",0,INSN_CLASS_XTHEADFMEMIDX,"D,s,t,Xu2@25",MATCH_TH_FLURD,MASK_TH_FLURD,match_opcode,0},
	{"th.flurw",0,INSN_CLASS_XTHEADFMEMIDX,"D,s,t,Xu2@25",MATCH_TH_FLURW,MASK_TH_FLURW,match_opcode,0},
	{"th.fsrd",0,INSN_CLASS_XTHEADFMEMIDX,"D,s,t,Xu2@25",MATCH_TH_FSRD,MASK_TH_FSRD,match_opcode,0},
	{"th.fsrw",0,INSN_CLASS_XTHEADFMEMIDX,"D,s,t,Xu2@25",MATCH_TH_FSRW,MASK_TH_FSRW,match_opcode,0},
	{"th.fsurd",0,INSN_CLASS_XTHEADFMEMIDX,"D,s,t,Xu2@25",MATCH_TH_FSURD,MASK_TH_FSURD,match_opcode,0},
	{"th.fsurw",0,INSN_CLASS_XTHEADFMEMIDX,"D,s,t,Xu2@25",MATCH_TH_FSURW,MASK_TH_FSURW,match_opcode,0},

	/* Vendor-specific (T-Head) XTheadFmv instructions.  */
	{"th.fmv.hw.x",32,INSN_CLASS_XTHEADFMV,"d,S",MATCH_TH_FMV_HW_X,MASK_TH_FMV_HW_X,match_opcode,0},
	{"th.fmv.x.hw",32,INSN_CLASS_XTHEADFMV,"d,S",MATCH_TH_FMV_X_HW,MASK_TH_FMV_X_HW,match_opcode,0},

	/* Vendor-specific (T-Head) XTheadInt instructions.  */
	{"th.ipop",0,INSN_CLASS_XTHEADINT,"",MATCH_TH_IPOP,MASK_TH_IPOP,match_opcode,0},
	{"th.ipush",0,INSN_CLASS_XTHEADINT,"",MATCH_TH_IPUSH,MASK_TH_IPUSH,match_opcode,0},

	/* Vendor-specific (T-Head) XTheadMemIdx instructions.  */
	{"th.ldia",64,INSN_CLASS_XTHEADMEMIDX,"d,(s),Xs5@20,Xu2@25",MATCH_TH_LDIA,MASK_TH_LDIA,match_th_load_inc,0},
	{"th.ldib",64,INSN_CLASS_XTHEADMEMIDX,"d,(s),Xs5@20,Xu2@25",MATCH_TH_LDIB,MASK_TH_LDIB,match_th_load_inc,0},
	{"th.lwia",0,INSN_CLASS_XTHEADMEMIDX,"d,(s),Xs5@20,Xu2@25",MATCH_TH_LWIA,MASK_TH_LWIA,match_th_load_inc,0},
	{"th.lwib",0,INSN_CLASS_XTHEADMEMIDX,"d,(s),Xs5@20,Xu2@25",MATCH_TH_LWIB,MASK_TH_LWIB,match_th_load_inc,0},
	{"th.lwuia",64,INSN_CLASS_XTHEADMEMIDX,"d,(s),Xs5@20,Xu2@25",MATCH_TH_LWUIA,MASK_TH_LWUIA,match_th_load_inc,0},
	{"th.lwuib",64,INSN_CLASS_XTHEADMEMIDX,"d,(s),Xs5@20,Xu2@25",MATCH_TH_LWUIB,MASK_TH_LWUIB,match_th_load_inc,0},
	{"th.lhia",0,INSN_CLASS_XTHEADMEMIDX,"d,(s),Xs5@20,Xu2@25",MATCH_TH_LHIA,MASK_TH_LHIA,match_th_load_inc,0},
	{"th.lhib",0,INSN_CLASS_XTHEADMEMIDX,"d,(s),Xs5@20,Xu2@25",MATCH_TH_LHIB,MASK_TH_LHIB,match_th_load_inc,0},
	{"th.lhuia",0,INSN_CLASS_XTHEADMEMIDX,"d,(s),Xs5@20,Xu2@25",MATCH_TH_LHUIA,MASK_TH_LHUIA,match_th_load_inc,0},
	{"th.lhuib",0,INSN_CLASS_XTHEADMEMIDX,"d,(s),Xs5@20,Xu2@25",MATCH_TH_LHUIB,MASK_TH_LHUIB,match_th_load_inc,0},
	{"th.lbia",0,INSN_CLASS_XTHEADMEMIDX,"d,(s),Xs5@20,Xu2@25",MATCH_TH_LBIA,MASK_TH_LBIA,match_th_load_inc,0},
	{"th.lbib",0,INSN_CLASS_XTHEADMEMIDX,"d,(s),Xs5@20,Xu2@25",MATCH_TH_LBIB,MASK_TH_LBIB,match_th_load_inc,0},
	{"th.lbuia",0,INSN_CLASS_XTHEADMEMIDX,"d,(s),Xs5@20,Xu2@25",MATCH_TH_LBUIA,MASK_TH_LBUIA,match_th_load_inc,0},
	{"th.lbuib",0,INSN_CLASS_XTHEADMEMIDX,"d,(s),Xs5@20,Xu2@25",MATCH_TH_LBUIB,MASK_TH_LBUIB,match_th_load_inc,0},
	{"th.sdia",64,INSN_CLASS_XTHEADMEMIDX,"d,(s),Xs5@20,Xu2@25",MATCH_TH_SDIA,MASK_TH_SDIA,match_opcode,0},
	{"th.sdib",64,INSN_CLASS_XTHEADMEMIDX,"d,(s),Xs5@20,Xu2@25",MATCH_TH_SDIB,MASK_TH_SDIB,match_opcode,0},
	{"th.swia",0,INSN_CLASS_XTHEADMEMIDX,"d,(s),Xs5@20,Xu2@25",MATCH_TH_SWIA,MASK_TH_SWIA,match_opcode,0},
	{"th.swib",0,INSN_CLASS_XTHEADMEMIDX,"d,(s),Xs5@20,Xu2@25",MATCH_TH_SWIB,MASK_TH_SWIB,match_opcode,0},
	{"th.shia",0,INSN_CLASS_XTHEADMEMIDX,"d,(s),Xs5@20,Xu2@25",MATCH_TH_SHIA,MASK_TH_SHIA,match_opcode,0},
	{"th.shib",0,INSN_CLASS_XTHEADMEMIDX,"d,(s),Xs5@20,Xu2@25",MATCH_TH_SHIB,MASK_TH_SHIB,match_opcode,0},
	{"th.sbia",0,INSN_CLASS_XTHEADMEMIDX,"d,(s),Xs5@20,Xu2@25",MATCH_TH_SBIA,MASK_TH_SBIA,match_opcode,0},
	{"th.sbib",0,INSN_CLASS_XTHEADMEMIDX,"d,(s),Xs5@20,Xu2@25",MATCH_TH_SBIB,MASK_TH_SBIB,match_opcode,0},

	{"th.lrd",64,INSN_CLASS_XTHEADMEMIDX,"d,s,t,Xu2@25",MATCH_TH_LRD,MASK_TH_LRD,match_opcode,0},
	{"th.lrw",0,INSN_CLASS_XTHEADMEMIDX,"d,s,t,Xu2@25",MATCH_TH_LRW,MASK_TH_LRW,match_opcode,0},
	{"th.lrwu",64,INSN_CLASS_XTHEADMEMIDX,"d,s,t,Xu2@25",MATCH_TH_LRWU,MASK_TH_LRWU,match_opcode,0},
	{"th.lrh",0,INSN_CLASS_XTHEADMEMIDX,"d,s,t,Xu2@25",MATCH_TH_LRH,MASK_TH_LRH,match_opcode,0},
	{"th.lrhu",0,INSN_CLASS_XTHEADMEMIDX,"d,s,t,Xu2@25",MATCH_TH_LRHU,MASK_TH_LRHU,match_opcode,0},
	{"th.lrb",0,INSN_CLASS_XTHEADMEMIDX,"d,s,t,Xu2@25",MATCH_TH_LRB,MASK_TH_LRB,match_opcode,0},
	{"th.lrbu",0,INSN_CLASS_XTHEADMEMIDX,"d,s,t,Xu2@25",MATCH_TH_LRBU,MASK_TH_LRBU,match_opcode,0},
	{"th.srd",64,INSN_CLASS_XTHEADMEMIDX,"d,s,t,Xu2@25",MATCH_TH_SRD,MASK_TH_SRD,match_opcode,0},
	{"th.srw",0,INSN_CLASS_XTHEADMEMIDX,"d,s,t,Xu2@25",MATCH_TH_SRW,MASK_TH_SRW,match_opcode,0},
	{"th.srh",0,INSN_CLASS_XTHEADMEMIDX,"d,s,t,Xu2@25",MATCH_TH_SRH,MASK_TH_SRH,match_opcode,0},
	{"th.srb",0,INSN_CLASS_XTHEADMEMIDX,"d,s,t,Xu2@25",MATCH_TH_SRB,MASK_TH_SRB,match_opcode,0},

	{"th.lurd",64,INSN_CLASS_XTHEADMEMIDX,"d,s,t,Xu2@25",MATCH_TH_LURD,MASK_TH_LURD,match_opcode,0},
	{"th.lurw",0,INSN_CLASS_XTHEADMEMIDX,"d,s,t,Xu2@25",MATCH_TH_LURW,MASK_TH_LURW,match_opcode,0},
	{"th.lurwu",64,INSN_CLASS_XTHEADMEMIDX,"d,s,t,Xu2@25",MATCH_TH_LURWU,MASK_TH_LURWU,match_opcode,0},
	{"th.lurh",0,INSN_CLASS_XTHEADMEMIDX,"d,s,t,Xu2@25",MATCH_TH_LURH,MASK_TH_LURH,match_opcode,0},
	{"th.lurhu",0,INSN_CLASS_XTHEADMEMIDX,"d,s,t,Xu2@25",MATCH_TH_LURHU,MASK_TH_LURHU,match_opcode,0},
	{"th.lurb",0,INSN_CLASS_XTHEADMEMIDX,"d,s,t,Xu2@25",MATCH_TH_LURB,MASK_TH_LURB,match_opcode,0},
	{"th.lurbu",0,INSN_CLASS_XTHEADMEMIDX,"d,s,t,Xu2@25",MATCH_TH_LURBU,MASK_TH_LURBU,match_opcode,0},
	{"th.surd",64,INSN_CLASS_XTHEADMEMIDX,"d,s,t,Xu2@25",MATCH_TH_SURD,MASK_TH_SURD,match_opcode,0},
	{"th.surw",0,INSN_CLASS_XTHEADMEMIDX,"d,s,t,Xu2@25",MATCH_TH_SURW,MASK_TH_SURW,match_opcode,0},
	{"th.surh",0,INSN_CLASS_XTHEADMEMIDX,"d,s,t,Xu2@25",MATCH_TH_SURH,MASK_TH_SURH,match_opcode,0},
	{"th.surb",0,INSN_CLASS_XTHEADMEMIDX,"d,s,t,Xu2@25",MATCH_TH_SURB,MASK_TH_SURB,match_opcode,0},

	/* Vendor-specific (T-Head) XTheadMemPair instructions.  */
	{"th.ldd",64,INSN_CLASS_XTHEADMEMPAIR,"d,t,(s),Xu2@25,Xl4",MATCH_TH_LDD,MASK_TH_LDD,match_th_load_pair,0},
	{"th.lwd",0,INSN_CLASS_XTHEADMEMPAIR,"d,t,(s),Xu2@25,Xl3",MATCH_TH_LWD,MASK_TH_LWD,match_th_load_pair,0},
	{"th.lwud",0,INSN_CLASS_XTHEADMEMPAIR,"d,t,(s),Xu2@25,Xl3",MATCH_TH_LWUD,MASK_TH_LWUD,match_th_load_pair,0},
	{"th.sdd",64,INSN_CLASS_XTHEADMEMPAIR,"d,t,(s),Xu2@25,Xl4",MATCH_TH_SDD,MASK_TH_SDD,match_opcode,0},
	{"th.swd",0,INSN_CLASS_XTHEADMEMPAIR,"d,t,(s),Xu2@25,Xl3",MATCH_TH_SWD,MASK_TH_SWD,match_opcode,0},

	/* Vendor-specific (T-Head) XTheadMac instructions.  */
	{"th.mula",0,INSN_CLASS_XTHEADMAC,"d,s,t",MATCH_TH_MULA,MASK_TH_MULA,match_opcode,0},
	{"th.mulah",0,INSN_CLASS_XTHEADMAC,"d,s,t",MATCH_TH_MULAH,MASK_TH_MULAH,match_opcode,0},
	{"th.mulaw",64,INSN_CLASS_XTHEADMAC,"d,s,t",MATCH_TH_MULAW,MASK_TH_MULAW,match_opcode,0},
	{"th.muls",0,INSN_CLASS_XTHEADMAC,"d,s,t",MATCH_TH_MULS,MASK_TH_MULS,match_opcode,0},
	{"th.mulsh",0,INSN_CLASS_XTHEADMAC,"d,s,t",MATCH_TH_MULSH,MASK_TH_MULSH,match_opcode,0},
	{"th.mulsw",64,INSN_CLASS_XTHEADMAC,"d,s,t",MATCH_TH_MULSW,MASK_TH_MULSW,match_opcode,0},

	/* Vendor-specific (T-Head) XTheadSync instructions.  */
	{"th.sfence.vmas",0,INSN_CLASS_XTHEADSYNC,"s,t",MATCH_TH_SFENCE_VMAS,MASK_TH_SFENCE_VMAS,match_opcode,0},
	{"th.sync",0,INSN_CLASS_XTHEADSYNC,"",MATCH_TH_SYNC,MASK_TH_SYNC,match_opcode,0},
	{"th.sync.i",0,INSN_CLASS_XTHEADSYNC,"",MATCH_TH_SYNC_I,MASK_TH_SYNC_I,match_opcode,0},
	{"th.sync.is",0,INSN_CLASS_XTHEADSYNC,"",MATCH_TH_SYNC_IS,MASK_TH_SYNC_IS,match_opcode,0},
	{"th.sync.s",0,INSN_CLASS_XTHEADSYNC,"",MATCH_TH_SYNC_S,MASK_TH_SYNC_S,match_opcode,0},

	/* Vendor-specific (Ventana Microsystems) XVentanaCondOps instructions */
	{"vt.maskc",0,INSN_CLASS_XVENTANACONDOPS,"d,s,t",MATCH_VT_MASKC,MASK_VT_MASKC,match_opcode,0},
	{"vt.maskcn",0,INSN_CLASS_XVENTANACONDOPS,"d,s,t",MATCH_VT_MASKCN,MASK_VT_MASKCN,match_opcode,0},

	/* Terminate the list.  */
	{0,0,INSN_CLASS_NONE,0,0,0,0,0}
};

/* Instruction format for .insn directive.  */
static const struct riscv_opcode riscv_insn_types[] = {
	/* name,xlen,isa,operands,match,mask,match_func,pinfo.  */
	{"r",0,INSN_CLASS_I,"O4,F3,F7,d,s,t",0,0,match_opcode,0},
	{"r",0,INSN_CLASS_F,"O4,F3,F7,D,s,t",0,0,match_opcode,0},
	{"r",0,INSN_CLASS_F,"O4,F3,F7,d,S,t",0,0,match_opcode,0},
	{"r",0,INSN_CLASS_F,"O4,F3,F7,D,S,t",0,0,match_opcode,0},
	{"r",0,INSN_CLASS_F,"O4,F3,F7,d,s,T",0,0,match_opcode,0},
	{"r",0,INSN_CLASS_F,"O4,F3,F7,D,s,T",0,0,match_opcode,0},
	{"r",0,INSN_CLASS_F,"O4,F3,F7,d,S,T",0,0,match_opcode,0},
	{"r",0,INSN_CLASS_F,"O4,F3,F7,D,S,T",0,0,match_opcode,0},
	{"r",0,INSN_CLASS_I,"O4,F3,F2,d,s,t,r",0,0,match_opcode,0},
	{"r",0,INSN_CLASS_F,"O4,F3,F2,D,s,t,r",0,0,match_opcode,0},
	{"r",0,INSN_CLASS_F,"O4,F3,F2,d,S,t,r",0,0,match_opcode,0},
	{"r",0,INSN_CLASS_F,"O4,F3,F2,D,S,t,r",0,0,match_opcode,0},
	{"r",0,INSN_CLASS_F,"O4,F3,F2,d,s,T,r",0,0,match_opcode,0},
	{"r",0,INSN_CLASS_F,"O4,F3,F2,D,s,T,r",0,0,match_opcode,0},
	{"r",0,INSN_CLASS_F,"O4,F3,F2,d,S,T,r",0,0,match_opcode,0},
	{"r",0,INSN_CLASS_F,"O4,F3,F2,D,S,T,r",0,0,match_opcode,0},
	{"r",0,INSN_CLASS_F,"O4,F3,F2,d,s,t,R",0,0,match_opcode,0},
	{"r",0,INSN_CLASS_F,"O4,F3,F2,D,s,t,R",0,0,match_opcode,0},
	{"r",0,INSN_CLASS_F,"O4,F3,F2,d,S,t,R",0,0,match_opcode,0},
	{"r",0,INSN_CLASS_F,"O4,F3,F2,D,S,t,R",0,0,match_opcode,0},
	{"r",0,INSN_CLASS_F,"O4,F3,F2,d,s,T,R",0,0,match_opcode,0},
	{"r",0,INSN_CLASS_F,"O4,F3,F2,D,s,T,R",0,0,match_opcode,0},
	{"r",0,INSN_CLASS_F,"O4,F3,F2,d,S,T,R",0,0,match_opcode,0},
	{"r",0,INSN_CLASS_F,"O4,F3,F2,D,S,T,R",0,0,match_opcode,0},

	{"r4",0,INSN_CLASS_I,"O4,F3,F2,d,s,t,r",0,0,match_opcode,0},
	{"r4",0,INSN_CLASS_F,"O4,F3,F2,D,s,t,r",0,0,match_opcode,0},
	{"r4",0,INSN_CLASS_F,"O4,F3,F2,d,S,t,r",0,0,match_opcode,0},
	{"r4",0,INSN_CLASS_F,"O4,F3,F2,D,S,t,r",0,0,match_opcode,0},
	{"r4",0,INSN_CLASS_F,"O4,F3,F2,d,s,T,r",0,0,match_opcode,0},
	{"r4",0,INSN_CLASS_F,"O4,F3,F2,D,s,T,r",0,0,match_opcode,0},
	{"r4",0,INSN_CLASS_F,"O4,F3,F2,d,S,T,r",0,0,match_opcode,0},
	{"r4",0,INSN_CLASS_F,"O4,F3,F2,D,S,T,r",0,0,match_opcode,0},
	{"r4",0,INSN_CLASS_F,"O4,F3,F2,d,s,t,R",0,0,match_opcode,0},
	{"r4",0,INSN_CLASS_F,"O4,F3,F2,D,s,t,R",0,0,match_opcode,0},
	{"r4",0,INSN_CLASS_F,"O4,F3,F2,d,S,t,R",0,0,match_opcode,0},
	{"r4",0,INSN_CLASS_F,"O4,F3,F2,D,S,t,R",0,0,match_opcode,0},
	{"r4",0,INSN_CLASS_F,"O4,F3,F2,d,s,T,R",0,0,match_opcode,0},
	{"r4",0,INSN_CLASS_F,"O4,F3,F2,D,s,T,R",0,0,match_opcode,0},
	{"r4",0,INSN_CLASS_F,"O4,F3,F2,d,S,T,R",0,0,match_opcode,0},
	{"r4",0,INSN_CLASS_F,"O4,F3,F2,D,S,T,R",0,0,match_opcode,0},

	{"i",0,INSN_CLASS_I,"O4,F3,d,s,j",0,0,match_opcode,0},
	{"i",0,INSN_CLASS_F,"O4,F3,D,s,j",0,0,match_opcode,0},
	{"i",0,INSN_CLASS_F,"O4,F3,d,S,j",0,0,match_opcode,0},
	{"i",0,INSN_CLASS_F,"O4,F3,D,S,j",0,0,match_opcode,0},
	{"i",0,INSN_CLASS_I,"O4,F3,d,o(s)",0,0,match_opcode,0},
	{"i",0,INSN_CLASS_F,"O4,F3,D,o(s)",0,0,match_opcode,0},

	{"s",0,INSN_CLASS_I,"O4,F3,t,q(s)",0,0,match_opcode,0},
	{"s",0,INSN_CLASS_F,"O4,F3,T,q(s)",0,0,match_opcode,0},

	{"sb",0,INSN_CLASS_I,"O4,F3,s,t,p",0,0,match_opcode,0},
	{"sb",0,INSN_CLASS_F,"O4,F3,S,t,p",0,0,match_opcode,0},
	{"sb",0,INSN_CLASS_F,"O4,F3,s,T,p",0,0,match_opcode,0},
	{"sb",0,INSN_CLASS_F,"O4,F3,S,T,p",0,0,match_opcode,0},
	{"b",0,INSN_CLASS_I,"O4,F3,s,t,p",0,0,match_opcode,0},
	{"b",0,INSN_CLASS_F,"O4,F3,S,t,p",0,0,match_opcode,0},
	{"b",0,INSN_CLASS_F,"O4,F3,s,T,p",0,0,match_opcode,0},
	{"b",0,INSN_CLASS_F,"O4,F3,S,T,p",0,0,match_opcode,0},

	{"u",0,INSN_CLASS_I,"O4,d,u",0,0,match_opcode,0},
	{"u",0,INSN_CLASS_F,"O4,D,u",0,0,match_opcode,0},

	{"uj",0,INSN_CLASS_I,"O4,d,a",0,0,match_opcode,0},
	{"uj",0,INSN_CLASS_F,"O4,D,a",0,0,match_opcode,0},
	{"j",0,INSN_CLASS_I,"O4,d,a",0,0,match_opcode,0},
	{"j",0,INSN_CLASS_F,"O4,D,a",0,0,match_opcode,0},

	{"cr",0,INSN_CLASS_C,"O2,CF4,d,CV",0,0,match_opcode,0},
	{"cr",0,INSN_CLASS_F_AND_C,"O2,CF4,D,CV",0,0,match_opcode,0},
	{"cr",0,INSN_CLASS_F_AND_C,"O2,CF4,d,CT",0,0,match_opcode,0},
	{"cr",0,INSN_CLASS_F_AND_C,"O2,CF4,D,CT",0,0,match_opcode,0},

	{"ci",0,INSN_CLASS_C,"O2,CF3,d,Co",0,0,match_opcode,0},
	{"ci",0,INSN_CLASS_F_AND_C,"O2,CF3,D,Co",0,0,match_opcode,0},

	{"ciw",0,INSN_CLASS_C,"O2,CF3,Ct,C8",0,0,match_opcode,0},
	{"ciw",0,INSN_CLASS_F_AND_C,"O2,CF3,CD,C8",0,0,match_opcode,0},

	{"css",0,INSN_CLASS_C,"O2,CF3,CV,C6",0,0,match_opcode,0},
	{"css",0,INSN_CLASS_F_AND_C,"O2,CF3,CT,C6",0,0,match_opcode,0},

	{"cl",0,INSN_CLASS_C,"O2,CF3,Ct,C5(Cs)",0,0,match_opcode,0},
	{"cl",0,INSN_CLASS_F_AND_C,"O2,CF3,CD,C5(Cs)",0,0,match_opcode,0},
	{"cl",0,INSN_CLASS_F_AND_C,"O2,CF3,Ct,C5(CS)",0,0,match_opcode,0},
	{"cl",0,INSN_CLASS_F_AND_C,"O2,CF3,CD,C5(CS)",0,0,match_opcode,0},

	{"cs",0,INSN_CLASS_C,"O2,CF3,Ct,C5(Cs)",0,0,match_opcode,0},
	{"cs",0,INSN_CLASS_F_AND_C,"O2,CF3,CD,C5(Cs)",0,0,match_opcode,0},
	{"cs",0,INSN_CLASS_F_AND_C,"O2,CF3,Ct,C5(CS)",0,0,match_opcode,0},
	{"cs",0,INSN_CLASS_F_AND_C,"O2,CF3,CD,C5(CS)",0,0,match_opcode,0},

	{"ca",0,INSN_CLASS_C,"O2,CF6,CF2,Cs,Ct",0,0,match_opcode,0},
	{"ca",0,INSN_CLASS_F_AND_C,"O2,CF6,CF2,CS,Ct",0,0,match_opcode,0},
	{"ca",0,INSN_CLASS_F_AND_C,"O2,CF6,CF2,Cs,CD",0,0,match_opcode,0},
	{"ca",0,INSN_CLASS_F_AND_C,"O2,CF6,CF2,CS,CD",0,0,match_opcode,0},

	{"cb",0,INSN_CLASS_C,"O2,CF3,Cs,Cp",0,0,match_opcode,0},
	{"cb",0,INSN_CLASS_F_AND_C,"O2,CF3,CS,Cp",0,0,match_opcode,0},

	{"cj",0,INSN_CLASS_C,"O2,CF3,Ca",0,0,match_opcode,0},

	/* Terminate the list.  */
	{0,0,INSN_CLASS_NONE,0,0,0,0,0}
};
/* ============================================================**** obj-elf.c */
/* ELF object file format */
static void	obj_elf_size(int);
static void	obj_elf_type(int);
static void	obj_elf_weak(int);
static void	obj_elf_visibility(int);
static void	obj_elf_symver(int);
static void	obj_elf_subsection(int);
static void	obj_elf_popsection(int);
static void	obj_elf_gnu_attribute(int);
static void	obj_elf_tls_common(int);
static void	obj_elf_struct(int);


#undef NO_RELOC
static asection *elf_com_section_ptr;

static int	elf_s_get_other(symbolS * sym)
{
	return elf_symbol(symbol_get_bfdsym(sym))->internal_elf_sym.st_other;
}

static void	elf_file_symbol(const char *s)
{				/* config/obj-elf.c:247 */
	asymbol        *bsym;
	symbolS        *sym = symbol_new(s,absolute_section,&zero_address_frag,0);
	size_t		name_length = strlen(s);

	if (name_length > strlen(S_GET_NAME(sym))) {
		obstack_grow(&notes,s,name_length + 1);
		S_SET_NAME(sym,(const char *)obstack_finish(&notes));
	} else
		strcpy((char *)S_GET_NAME(sym),s);

	symbol_get_bfdsym(sym)->flags |= BSF_FILE;

	if (symbol_rootP != sym
	    && ((bsym = symbol_get_bfdsym(symbol_rootP)) == NULL
		|| (bsym->flags & BSF_FILE) == 0)) {
		symbol_remove(sym,&symbol_rootP,&symbol_lastP);
		symbol_insert(sym,symbol_rootP,&symbol_rootP,&symbol_lastP);
	}
}

/* Called from read.c:s_comm after we've parsed .comm symbol,size. Parse a
 * possible alignment value.  */
static symbolS *elf_common_parse(int ignore ATTRIBUTE_UNUSED,symbolS * symbolP,addressT size)
{				/* config/obj-elf.c:284 */
	addressT	align = 0;
	int		is_local = symbol_get_obj(symbolP)->local;

	if (*input_line_pointer == ',') {
		char           *save = input_line_pointer;

		input_line_pointer++;
		SKIP_WHITESPACE();

		if (*input_line_pointer == '"') {
			/* For sparc.  Accept .common symbol,length,"bss"  */
			input_line_pointer++;
			/* Some use the dot,some don't.  */
			if (*input_line_pointer == '.')
				input_line_pointer++;
			/* Some say data,some say bss.  */
			if (startswith(input_line_pointer,"bss\""))
				input_line_pointer += 4;
			else
				if (startswith(input_line_pointer,"data\""))
					input_line_pointer += 5;
				else {
					char           *p = input_line_pointer;
					char		c;

					while (*--p != '"');
					while (!is_end_of_line[(unsigned char)*input_line_pointer])
						if (*input_line_pointer++ == '"')
							break;
					c = *input_line_pointer;
					*input_line_pointer = '\0';
					as_bad(("bad .common segment %s"),p);
					*input_line_pointer = c;
					ignore_rest_of_line();
					return NULL;
				}
			/* ??? Don't ask me why these are always global.  */
			is_local = 0;
		} else {
			input_line_pointer = save;
			align = parse_align(is_local);
			if (align == (addressT) - 1)
				return NULL;
		}
	}
	if (is_local) {
		bss_alloc(symbolP,size,align);
		S_CLEAR_EXTERNAL(symbolP);
	} else {
		S_SET_VALUE(symbolP,size);
		S_SET_ALIGN(symbolP,align);
		S_SET_EXTERNAL(symbolP);
		S_SET_SEGMENT(symbolP,elf_com_section_ptr);
	}

	symbol_get_bfdsym(symbolP)->flags |= BSF_OBJECT;

	return symbolP;
}

static void	obj_elf_common(int is_common ATTRIBUTE_UNUSED)
{
	s_comm_internal(0,elf_common_parse);
}

static void	obj_elf_tls_common(int ignore ATTRIBUTE_UNUSED)
{
	symbolS        *symbolP = s_comm_internal(0,elf_common_parse);

	if (symbolP)
		symbol_get_bfdsym(symbolP)->flags |= BSF_THREAD_LOCAL;
}

static void	obj_elf_lcomm(int ignore ATTRIBUTE_UNUSED)
{
	symbolS        *symbolP = s_comm_internal(0,s_lcomm_internal);

	if (symbolP)
		symbol_get_bfdsym(symbolP)->flags |= BSF_OBJECT;
}

static symbolS *get_sym_from_input_line_and_check(void)
{
	char           *name;
	char		c;
	symbolS        *sym;

	c = get_symbol_name(&name);
	sym = symbol_find_or_make(name);
	*input_line_pointer = c;
	SKIP_WHITESPACE_AFTER_NAME();

	/* There is no symbol name if input_line_pointer has not moved.  */
	if (name == input_line_pointer)
		as_bad(("Missing symbol name in directive"));
	return sym;
}

static void	obj_elf_local(int ignore ATTRIBUTE_UNUSED)
{
	int		c;
	symbolS        *symbolP;

	do {
		symbolP = get_sym_from_input_line_and_check();
		c = *input_line_pointer;
		S_CLEAR_EXTERNAL(symbolP);
		symbol_get_obj(symbolP)->local = 1;
		if (c == ',') {
			input_line_pointer++;
			SKIP_WHITESPACE();
			if (*input_line_pointer == '\n')
				c = '\n';
		}
	}
	while (c == ',');
	demand_empty_rest_of_line();
}

static void	obj_elf_weak(int ignore ATTRIBUTE_UNUSED)
{
	int		c;
	symbolS        *symbolP;

	do {
		symbolP = get_sym_from_input_line_and_check();
		c = *input_line_pointer;
		S_SET_WEAK(symbolP);
		if (c == ',') {
			input_line_pointer++;
			SKIP_WHITESPACE();
			if (*input_line_pointer == '\n')
				c = '\n';
		}
	}
	while (c == ',');
	demand_empty_rest_of_line();
}

static void	obj_elf_visibility(int visibility)
{
	int		c;
	symbolS        *symbolP;
	asymbol        *bfdsym;
	elf_symbol_type *elfsym;

	do {
		symbolP = get_sym_from_input_line_and_check();

		bfdsym = symbol_get_bfdsym(symbolP);
		elfsym = elf_symbol_from(bfdsym);

		gas_assert(elfsym);

		elfsym->internal_elf_sym.st_other &= ~3;
		elfsym->internal_elf_sym.st_other |= visibility;

		c = *input_line_pointer;
		if (c == ',') {
			input_line_pointer++;

			SKIP_WHITESPACE();

			if (*input_line_pointer == '\n')
				c = '\n';
		}
	} while (c == ',');

	demand_empty_rest_of_line();
}

static segT	previous_section;
static int	previous_subsection;

struct section_stack {
	struct section_stack *next;
	segT		seg      ,prev_seg;
	int		subseg    ,prev_subseg;
};

static struct section_stack *section_stack;

/* ELF section flags for unique sections.  */
#define SEC_ASSEMBLER_SHF_MASK SHF_GNU_RETAIN

/* Return TRUE iff SEC matches the section info INF.  */
static bool	get_section_by_match(bfd * abfd ATTRIBUTE_UNUSED,asection * sec,void *inf)
{
	struct elf_section_match *match = (struct elf_section_match *)inf;
	const char     *gname = match->group_name;
	const char     *group_name = elf_group_name(sec);
	const char     *linked_to_symbol_name
	= sec->map_head.linked_to_symbol_name;
	unsigned int	sh_info = elf_section_data(sec)->this_hdr.sh_info;
	bfd_vma		sh_flags = (elf_section_data(sec)->this_hdr.sh_flags
			     & SEC_ASSEMBLER_SHF_MASK);

	return (sh_info == match->sh_info
		&& sh_flags == match->sh_flags
		&& ((sec->flags & SEC_ASSEMBLER_SECTION_ID)
		    == (match->flags & SEC_ASSEMBLER_SECTION_ID))
		&& sec->section_id == match->section_id
		&& (group_name == gname
		    || (group_name != NULL
			&& gname != NULL
			&& strcmp(group_name,gname) == 0))
		&& (linked_to_symbol_name == match->linked_to_symbol_name
		    || (linked_to_symbol_name != NULL
			&& match->linked_to_symbol_name != NULL
			&& strcmp(linked_to_symbol_name,
				  match->linked_to_symbol_name) == 0)));
}

/* Handle the .section pseudo-op.  This code supports two different syntaxes.
 * 
 * The first is found on Solaris,and looks like .section
 * ".sec1",#alloc,#execinstr,#write Here the names after '#' are the SHF_*
 * flags to turn on for the section.  I'm not sure how it determines the SHT_*
 * type (BFD doesn't really give us control over the type,anyhow).
 * 
 * The second format is found on UnixWare,and probably most SVR4 machines,and
 * looks like .section .sec1,"a",@progbits The quoted string may contain any
 * combination of a,w,x,and represents the SHF_* flags to turn on for the
 * section.  The string beginning with '@' can be progbits or nobits.  There
 * should be other possibilities,but I don't know what they are.  In any case,
 * BFD doesn't really let us set the section type.  */
static void	obj_elf_change_section(const char *name,
				   		unsigned	int	type,
				   		bfd_vma	attr ,
				   		int		entsize ,
			      		struct	elf_section_match *match_p,
				   		int		linkonce,
				   		int		push)
{
	asection       *old_sec;
	segT		sec;
	uint32_t	flags;
	const struct bfd_elf_special_section *ssect;

	if (match_p == NULL) {
		static struct elf_section_match unused_match;
		match_p = &unused_match;
	}

	/* Switch to the section,creating it if necessary.  */
	if (push) {
		struct section_stack *elt;
		elt = XNEW(struct section_stack);
		elt->next = section_stack;
		elt->seg = now_seg;
		elt->prev_seg = previous_section;
		elt->subseg = now_subseg;
		elt->prev_subseg = previous_subsection;
		section_stack = elt;
	}
	obj_elf_section_change_hook();

	old_sec = bfd_get_section_by_name_if(stdoutput,name,get_section_by_match,
					     (void *)match_p);
	if (old_sec) {
		sec = old_sec;
		subseg_set(sec,0);
	} else
		sec = subseg_force_new(name,0);

	ssect = get_sec_type_attr(stdoutput,sec);

	if (ssect != NULL) {
		bool		override = false;

		if (type == SHT_NULL)
			type = ssect->type;
		else
			if (type != ssect->type) {
				if (old_sec == NULL
				/*
				 * Some older versions of gcc will emit
				 * 
				 * .section .init_array,"aw",@progbits
				 * 
				 * for __attribute__ ((section (".init_array"))).
				 * "@progbits" is incorrect.  Also for x86-64
				 * large bss sections,some older versions of
				 * gcc will emit
				 * 
				 * .section .lbss,"aw",@progbits
				 * 
				 * "@progbits" is incorrect.
				 */
#ifdef TC_I386
				    && (bed->s->arch_size != 64
					|| !(ssect->attr & SHF_X86_64_LARGE))
#endif
				    && ssect->type != SHT_INIT_ARRAY
				    && ssect->type != SHT_FINI_ARRAY
				    && ssect->type != SHT_PREINIT_ARRAY) {
					/*
					 * We allow to specify any type for a
					 * .note section.
					 */
					if (ssect->type != SHT_NOTE
					/*
					 * Processor and application defined
					 * types are allowed too.
					 */
					    && type < SHT_LOPROC)
						as_warn(("setting incorrect section type for %s"),
							name);
				} else {
					as_warn(("ignoring incorrect section type for %s"),
						name);
					type = ssect->type;
				}
			}
		if (old_sec == NULL && ((attr & ~(SHF_LINK_ORDER
						 |SHF_MASKOS
						 |SHF_MASKPROC))
					& ~ssect->attr) != 0) {
			/* Strip SHF_GNU_RETAIN.  */
			bfd_vma		generic_attr = attr;
			if (elf_tdata(stdoutput)->has_gnu_osabi)
				generic_attr &= ~SHF_GNU_RETAIN;

			/*
			 * As a GNU extension,we permit a .note section to be
			 * allocatable.  If the linker sees an allocatable
			 * .note section,it will create a PT_NOTE segment in
			 * the output file.  We also allow "x" for
			 * .note.GNU-stack.
			 */
			if (ssect->type == SHT_NOTE
			    && (generic_attr == SHF_ALLOC
				|| generic_attr == SHF_EXECINSTR));
			/*
			 * Allow different SHF_MERGE and SHF_STRINGS if we have
			 * something like .rodata.str.
			 */
			else
				if (ssect->suffix_length == -2
				    && name[ssect->prefix_length] == '.'
				    && (generic_attr
					& ~ssect->attr
					& ~SHF_MERGE
					& ~SHF_STRINGS) == 0);
			/* .interp,.strtab and .symtab can have SHF_ALLOC.  */
				else
					if (generic_attr == SHF_ALLOC
					    && (strcmp(name,".interp") == 0
						|| strcmp(name,".strtab") == 0
					     || strcmp(name,".symtab") == 0))
						override = true;
			/* .note.GNU-stack can have SHF_EXECINSTR.  */
					else
						if (generic_attr == SHF_EXECINSTR
						    && strcmp(name,".note.GNU-stack") == 0)
							override = true;
#ifdef TC_ALPHA
			/* A section on Alpha may have SHF_ALPHA_GPREL.  */
						else
							if ((generic_attr & ~ssect->attr) == SHF_ALPHA_GPREL)
								override = true;
#endif
#ifdef TC_RX
							else
								if (generic_attr == (SHF_EXECINSTR|SHF_WRITE|SHF_ALLOC)
								    && (ssect->type == SHT_INIT_ARRAY
									|| ssect->type == SHT_FINI_ARRAY
									|| ssect->type == SHT_PREINIT_ARRAY))
									/*
									 * RX
									 * init/
									 * fini
									 * array
									 * s
									 * can
									 * and
									 * shoul
									 * d
									 * have
									 * the
									 * "awx"
									 * 
									 * attri
									 * butes
									 * 
									 * set.
									 */
									;
#endif
								else {
									if (match_p->group_name == NULL)
										as_warn(("setting incorrect section attributes for %s"),
											name);
									override = true;
								}
		}
		if (!override && old_sec == NULL)
			attr |= ssect->attr;
	}
	/* Convert ELF type and flags to BFD flags.  */
	flags = (SEC_RELOC
		|((attr & SHF_WRITE) ? 0 : SEC_READONLY)
		|((attr & SHF_ALLOC) ? SEC_ALLOC : 0)
		|(((attr & SHF_ALLOC) && type != SHT_NOBITS) ? SEC_LOAD : 0)
		|((attr & SHF_EXECINSTR) ? SEC_CODE : 0)
		|((attr & SHF_MERGE) ? SEC_MERGE : 0)
		|((attr & SHF_STRINGS) ? SEC_STRINGS : 0)
		|((attr & SHF_EXCLUDE) ? SEC_EXCLUDE : 0)
		|((attr & SHF_TLS) ? SEC_THREAD_LOCAL : 0));

	if (linkonce)
		flags |= SEC_LINK_ONCE|SEC_LINK_DUPLICATES_DISCARD;

	/* PR 28054: Set the SEC_ELF_OCTETS flag for debugging sections. Based
	 * on the code in bfd/elf.c:_bfd_elf_make_section_from_shdr().
	 * 
	 * FIXME: We do not set the SEC_DEBUGGING flag because that causes
	 * problems for the FT32 and MSP430 targets.  Investigate and fix.  */
	if ((flags & SEC_ALLOC) == 0 && name[0] == '.') {
		if (startswith(name,".debug")
		    || startswith(name,".zdebug")
		    || startswith(name,".gnu.debuglto_.debug_")
		    || startswith(name,".gnu.linkonce.wi.")
		    || startswith(name,GNU_BUILD_ATTRS_SECTION_NAME)
		    || startswith(name,".note.gnu"))
			flags |= SEC_ELF_OCTETS;
	}
	if (old_sec == NULL) {
		symbolS        *secsym;

		if (type == SHT_NULL)
			type = elf_get_default_section_type(flags);
		elf_section_type(sec) = type;
		elf_section_flags(sec) = attr;
		elf_section_data(sec)->this_hdr.sh_info = match_p->sh_info;

		/* Prevent SEC_HAS_CONTENTS from being inadvertently set.  */
		if (type == SHT_NOBITS)
			seg_info(sec)->bss = 1;

		/* Set the section ID and flags.  */
		sec->section_id = match_p->section_id;
		flags |= match_p->flags;

		/* Set the linked-to symbol name.  */
		sec->map_head.linked_to_symbol_name
			= match_p->linked_to_symbol_name;

		sec->flags = flags;
		if (flags & SEC_MERGE)
			sec->entsize = entsize;
		elf_group_name(sec) = match_p->group_name;

		/* Add a symbol for this section to the symbol table.  */
		secsym = symbol_find(name);
		if (secsym != NULL) {
			/*
			 * We could be repurposing an undefined symbol here:
			 * make sure we reset sy_value to look like other
			 * section symbols in order to avoid trying to
			 * incorrectly resolve this section symbol later on.
			 */
			static const expressionS exp = {.X_op = O_constant};
			symbol_set_value_expression(secsym,&exp);
			symbol_set_bfdsym(secsym,sec->symbol);
		} else
			symbol_table_insert(section_symbol(sec));
	} else {
		if (type != SHT_NULL && (unsigned)type != elf_section_type(old_sec)) {
			if (ssect != NULL)
				/*
				 * This is a special section with known type.
				 * User assembly might get the section type
				 * wrong; Even high profile projects like glibc
				 * have done so in the past. So don't error in
				 * this case.
				 */
				as_warn(("ignoring changed section type for %s"),name);
			else
				/*
				 * Do error when assembly isn't
				 * self-consistent.
				 */
				as_bad(("changed section type for %s"),name);
		}
		if (attr != 0) {
			/*
			 * If section attributes are specified the second time
			 * we see a particular section,then check that they
			 * are the same as we saw the first time.
			 */
			if (((old_sec->flags ^ flags)
			     & (SEC_ALLOC|SEC_LOAD|SEC_READONLY|SEC_CODE
				| SEC_EXCLUDE|SEC_SORT_ENTRIES|SEC_MERGE|SEC_STRINGS
				| SEC_LINK_ONCE|SEC_LINK_DUPLICATES_DISCARD
				| SEC_THREAD_LOCAL))) {
				if (ssect != NULL)
					as_warn(("ignoring changed section attributes for %s"),name);
				else
					as_bad(("changed section attributes for %s"),name);
			} else
				/*
				 * FIXME: Maybe we should consider removing a
				 * previously set processor or application
				 * specific attribute as suspicious?
				 */
				elf_section_flags(sec) = attr;

			if ((flags & SEC_MERGE) && old_sec->entsize != (unsigned)entsize)
				as_bad(("changed section entity size for %s"),name);
		}
	}
}

static bfd_vma	obj_elf_parse_section_letters(char *str,size_t len,
			      		bool *	is_clone,bfd_vma * gnu_attr)
{
	bfd_vma		attr = 0;
	*is_clone = false;

	while (len > 0) {
		switch (*str) {
		case 'a':
			attr |= SHF_ALLOC;
			/* Compatibility.  */
			if (len > 1 && str[1] == 'm') {
				attr |= SHF_MERGE;
				str++,len--;
				if (len > 1 && str[1] == 's') {
					attr |= SHF_STRINGS;
					str++,len--;
				}
			}
			break;
		case 'e': attr |= SHF_EXCLUDE; break;
		case 'o': attr |= SHF_LINK_ORDER; break;
		case 'w': attr |= SHF_WRITE; break;
		case 'x': attr |= SHF_EXECINSTR; break;
		case 'M': attr |= SHF_MERGE; break;
		case 'S': attr |= SHF_STRINGS; break;
		case 'G': attr |= SHF_GROUP; break;
		case 'T': attr |= SHF_TLS; break;
		case 'd': *gnu_attr |= SHF_GNU_MBIND; break;
		case 'R': *gnu_attr |= SHF_GNU_RETAIN; break;
		case '?': *is_clone = true; break;
		default:
			{
				const char     *bad_msg = ("unrecognized .section attribute:"
					 " want a,e,o,w,x,M,S,G,T or number");
#ifdef md_elf_section_letter
				bfd_vma		md_attr = md_elf_section_letter(*str,&bad_msg);
				if (md_attr != (bfd_vma) - 1)
					attr |= md_attr;
				else
#endif
					if (ISDIGIT(*str)) {
						char           *end;
						bfd_vma		numeric_flags = strtoul(str,&end,0);

						attr |= numeric_flags;

						{
						/* Add flags in the SHF_MASKOS range to gnu_attr for OSABIs
						 * that support those flags. Also adding the flags for
						 * ELFOSABI_{NONE,STANDALONE} allows them to be validated later
						 * in obj_elf_section. We can't just always set these bits in
						 * gnu_attr for all OSABIs,since Binutils does not recognize all
						 * SHF_MASKOS bits for non-GNU OSABIs.
						 * It's therefore possible that numeric flags are being used to set
						 * bits in the SHF_MASKOS range for those targets,and
						 * we don't want assembly to fail in those situations.  */
							*gnu_attr |= (numeric_flags & SHF_MASKOS);
						}

						/* Update str and len,allowing for the fact that we will
						 * execute str++ and len-- below.  */
						end--;
						len -= (end - str);
						str = end;
					} else
						as_fatal("%s",bad_msg);
			}
			break;
		}
		str++,len--;
	}

	return attr;
}

static int	obj_elf_section_type(char *str,size_t len,bool warn)
{
	if (len == 8 && startswith(str,"progbits")) return SHT_PROGBITS;
	if (len == 6 && startswith(str,"nobits")) return SHT_NOBITS;
	if (len == 4 && startswith(str,"note")) return SHT_NOTE;
	if (len == 10 && startswith(str,"init_array")) return SHT_INIT_ARRAY;
	if (len == 10 && startswith(str,"fini_array")) return SHT_FINI_ARRAY;
	if (len == 13 && startswith(str,"preinit_array")) return SHT_PREINIT_ARRAY;

	if (ISDIGIT(*str)) {
		char           *end;
		int		type = strtoul(str,&end,0);

		if (warn && (size_t) (end - str) != len)
			as_warn("extraneous characters at end of numeric section type");

		return type;
	}
	if (warn)
		as_warn("unrecognized section type");
	return 0;
}

/* Get name of section.  */
static const char *obj_elf_section_name(void)
{
	char           *name;

	SKIP_WHITESPACE();
	if (*input_line_pointer == '"') {
		int		dummy;

		name = demand_copy_C_string(&dummy);
		if (name == NULL) {
			ignore_rest_of_line();
			return NULL;
		}
	} else {
		char           *end = input_line_pointer;

		while (0 == strchr("\n\t,; ",*end))
			end++;
		if (end == input_line_pointer) {
			as_bad("missing name");
			ignore_rest_of_line();
			return NULL;
		}
		obstack_grow0(&notes,input_line_pointer,end - input_line_pointer);
		name = obstack_base(&notes);

		while (flag_sectname_subst) {
			char           *subst = strchr(name,'%');
			if (subst && subst[1] == 'S') {
				size_t		head = subst - name;
				size_t		tail = strlen(subst + 2) + 1;
				size_t		slen = strlen(now_seg->name);

				if (slen > 2) {
					obstack_blank(&notes,slen - 2);
					name = obstack_base(&notes);
				}
				memmove(name + head + slen,name + head + 2,tail);
				memcpy(name + head,now_seg->name,slen);
			} else
				break;
		}

		obstack_finish(&notes);

		input_line_pointer = end;
	}
	SKIP_WHITESPACE();
	return name;
}

static void	obj_elf_attach_to_group(int dummy ATTRIBUTE_UNUSED)
{
	const char     *gname = obj_elf_section_name();

	if (gname == NULL) {
		as_warn("group name not parseable");
		return;
	}
	if (elf_group_name(now_seg)) {
		as_warn("section %s already has a group (%s)",
			bfd_section_name(now_seg),elf_group_name(now_seg));
		return;
	}
	elf_group_name(now_seg) = gname;
	elf_section_flags(now_seg) |= SHF_GROUP;
}

/* gas/config/obj-elf.c:1101 */
static void	obj_elf_section(int push)
{
	const char     *name;
	char           *beg;
	int		type      ,dummy;
	bfd_vma		attr;
	bfd_vma		gnu_attr;
	int		entsize;
	int		linkonce;
	subsegT		new_subsection = -1;
	struct elf_section_match match;
	unsigned long	linked_to_section_index = -1UL;

	name = obj_elf_section_name();
	if (name == NULL)
		return;

	memset(&match,0,sizeof(match));

	symbolS        *sym;
	if ((sym = symbol_find(name)) != NULL
	    && !symbol_section_p(sym)
	    && S_IS_DEFINED(sym)
	    && !S_IS_VOLATILE(sym)
	    && !S_CAN_BE_REDEFINED(sym)) {
		as_bad("section name '%s' already defined as another symbol",name);
		ignore_rest_of_line();
		return;
	}
	type = SHT_NULL;
	attr = 0;
	gnu_attr = 0;
	entsize = 0;
	linkonce = 0;

	if (*input_line_pointer == ',') {
		/* Skip the comma.  */
		++input_line_pointer;
		SKIP_WHITESPACE();

		if (push && ISDIGIT(*input_line_pointer)) {
			/* .pushsection has an optional subsection.  */
			new_subsection = (subsegT) get_absolute_expression();

			SKIP_WHITESPACE();

			/* Stop if we don't see a comma.  */
			if (*input_line_pointer != ',')
				goto done;

			/* Skip the comma.  */
			++input_line_pointer;
			SKIP_WHITESPACE();
		}
		if (*input_line_pointer == '"') {
			bool		is_clone;

			beg = demand_copy_C_string(&dummy);
			if (beg == NULL) {
				ignore_rest_of_line();
				return;
			}
			attr |= obj_elf_parse_section_letters(beg,strlen(beg),
							&is_clone,&gnu_attr);

			SKIP_WHITESPACE();
			if (*input_line_pointer == ',') {
				char		c;
				char           *save = input_line_pointer;

				++input_line_pointer;
				SKIP_WHITESPACE();
				c = *input_line_pointer;
				if (c == '"') {
					beg = demand_copy_C_string(&dummy);
					if (beg == NULL) {
						ignore_rest_of_line();
						return;
					}
					type = obj_elf_section_type(beg,strlen(beg),true);
				} else
					if (c == '@' || c == '%') {
						++input_line_pointer;

						if (ISDIGIT(*input_line_pointer))
							type = strtoul(input_line_pointer,&input_line_pointer,0);
						else {
							c = get_symbol_name(&beg);
							(void)restore_line_pointer(c);
							type = obj_elf_section_type(beg,
										    input_line_pointer - beg,
									true);
						}
					} else
						input_line_pointer = save;
			}
			SKIP_WHITESPACE();
			if ((attr & SHF_MERGE) != 0 && *input_line_pointer == ',') {
				++input_line_pointer;
				SKIP_WHITESPACE();
				entsize = get_absolute_expression();
				SKIP_WHITESPACE();
				if (entsize < 0) {
					as_warn(("invalid merge entity size"));
					attr &= ~SHF_MERGE;
					entsize = 0;
				}
			} else
				if ((attr & SHF_MERGE) != 0) {
					as_warn(("entity size for SHF_MERGE not specified"));
					attr &= ~SHF_MERGE;
				}
			if ((attr & SHF_LINK_ORDER) != 0 && *input_line_pointer == ',') {
				++input_line_pointer;
				SKIP_WHITESPACE();
				/* Check for a numeric section index,rather than a symbol name. */
				if (ISDIGIT(*input_line_pointer)) {
					linked_to_section_index = strtoul(input_line_pointer,&input_line_pointer,0);
				} else {
					char		c;
					unsigned int	length;

					c = get_symbol_name(&beg);
					(void)restore_line_pointer(c);
					length = input_line_pointer - beg;
					if (length)
						match.linked_to_symbol_name = xmemdup0(beg,length);
				}
			}
			if ((attr & SHF_GROUP) != 0 && is_clone) {
				as_warn(("? section flag ignored with G present"));
				is_clone = false;
			}
			if ((attr & SHF_GROUP) != 0 && *input_line_pointer == ',') {
				++input_line_pointer;
				match.group_name = obj_elf_section_name();
				if (match.group_name == NULL)
					attr &= ~SHF_GROUP;
				else
					if (*input_line_pointer == ',') {
						++input_line_pointer;
						SKIP_WHITESPACE();
						if (startswith(input_line_pointer,"comdat")) {
							input_line_pointer += 6;
							linkonce = 1;
						}
					} else
						if (startswith(name,".gnu.linkonce"))
							linkonce = 1;
			} else
				if ((attr & SHF_GROUP) != 0) {
					as_warn(("group name for SHF_GROUP not specified"));
					attr &= ~SHF_GROUP;
				}
			if (is_clone) {
				const char     *now_group = elf_group_name(now_seg);
				if (now_group != NULL) {
					match.group_name = now_group;
					linkonce = (now_seg->flags & SEC_LINK_ONCE) != 0;
				}
			}
			if ((gnu_attr & SHF_GNU_MBIND) != 0 && *input_line_pointer == ',') {
				char           *save = input_line_pointer;
				++input_line_pointer;
				SKIP_WHITESPACE();
				if (ISDIGIT(*input_line_pointer)) {
					char           *t = input_line_pointer;
					match.sh_info = strtoul(input_line_pointer,
						      &input_line_pointer,0);
					if (match.sh_info == (unsigned int)-1) {
						as_warn(("unsupported mbind section info: %s"),t);
						match.sh_info = 0;
					}
				} else
					input_line_pointer = save;
			}
			if ((gnu_attr & SHF_GNU_RETAIN) != 0)
				match.sh_flags |= SHF_GNU_RETAIN;

			if (*input_line_pointer == ',') {
				char           *save = input_line_pointer;

				++input_line_pointer;
				SKIP_WHITESPACE();
				if (startswith(input_line_pointer,"unique")) {
					input_line_pointer += 6;
					SKIP_WHITESPACE();
					if (*input_line_pointer == ',') {
						++input_line_pointer;
						SKIP_WHITESPACE();
						if (ISDIGIT(*input_line_pointer)) {
							bfd_vma		id;
							bool		overflow;
							char           *t = input_line_pointer;
							if (sizeof(bfd_vma) <= sizeof(unsigned long)) {
								errno = 0;
								id = strtoul(input_line_pointer,
									     &input_line_pointer,0);
								overflow = (id == (unsigned long)-1
									    && errno == ERANGE);
							} else {
								id = strtoull(input_line_pointer,&input_line_pointer,0);
								overflow = id == ~(bfd_vma) 0;
							}
							if (overflow || id > (unsigned int)-1) {
								char           *linefeed,
										saved_char = 0;
								if ((linefeed = strchr(t,'\n')) != NULL) {
									saved_char = *linefeed;
									*linefeed = '\0';
								}
								as_bad(("unsupported section id: %s"),t);
								if (saved_char)
									*linefeed = saved_char;
							} else {
								match.section_id = id;
								match.flags |= SEC_ASSEMBLER_SECTION_ID;
							}
						}
					}
				} else
					input_line_pointer = save;
			}
		}
	}
done:
	demand_empty_rest_of_line();

	if ((gnu_attr & (SHF_GNU_MBIND|SHF_GNU_RETAIN)) != 0) {
		bool		mbind_p = (gnu_attr & SHF_GNU_MBIND) != 0;

		if (mbind_p && (attr & SHF_ALLOC) == 0)
			as_bad(("SHF_ALLOC isn't set for GNU_MBIND section: %s"),name);

		if (mbind_p)
			elf_tdata(stdoutput)->has_gnu_osabi |= elf_gnu_osabi_mbind;
		if ((gnu_attr & SHF_GNU_RETAIN) != 0)
			elf_tdata(stdoutput)->has_gnu_osabi |= elf_gnu_osabi_retain;

		attr |= gnu_attr;
	}
	obj_elf_change_section(name,type,attr,entsize,&match,linkonce,
			       push);

	if (linked_to_section_index != -1UL) {
		elf_section_flags(now_seg) |= SHF_LINK_ORDER;
		elf_section_data(now_seg)->this_hdr.sh_link = linked_to_section_index;
		/* FIXME: Should we perform some sanity checking on the section
		 * index ?  */
	}
	if (push && new_subsection != -1)
		subseg_set(now_seg,new_subsection);
}

/* Change to the .bss section.  */
static void	obj_elf_bss(int i ATTRIBUTE_UNUSED)
{
	int		temp;

	obj_elf_section_change_hook();
	temp = get_absolute_expression();
	subseg_set(bss_section,(subsegT) temp);
	demand_empty_rest_of_line();

}

/* Change to the .data section.  */
static void	obj_elf_data(int i)
{
	obj_elf_section_change_hook();

	s_data(i);
}

/* Change to the .text section.  */
static void	obj_elf_text(int i)
{
	obj_elf_section_change_hook();
	s_text(i);
}

/* Change to the *ABS* section.  */
static void	obj_elf_struct(int i)
{
	obj_elf_section_change_hook();
	s_struct(i);
}

static void	obj_elf_subsection(int ignore ATTRIBUTE_UNUSED)
{
	int		temp;

	obj_elf_section_change_hook();

	temp = get_absolute_expression();
	subseg_set(now_seg,(subsegT) temp);
	demand_empty_rest_of_line();
}

/* This can be called from the processor backends if they change sections. */
static void	obj_elf_section_change_hook(void)
{
	previous_section = now_seg;
	previous_subsection = now_subseg;
}

static void	obj_elf_previous(int ignore ATTRIBUTE_UNUSED)
{
	segT		new_section;
	int		new_subsection;

	if (previous_section == 0) {
		as_warn(".previous without corresponding .section; ignored");
		return;
	}
	new_section = previous_section;
	new_subsection = previous_subsection;
	obj_elf_section_change_hook();

	subseg_set(new_section,new_subsection);
}

static void	obj_elf_popsection(int xxx ATTRIBUTE_UNUSED)
{
	struct section_stack *top = section_stack;

	if (top == NULL) {
		as_warn(".popsection without corresponding .pushsection; ignored");
		return;
	}

	section_stack = top->next;
	previous_section = top->prev_seg;
	previous_subsection = top->prev_subseg;
	subseg_set(top->seg,top->subseg);
	free(top);
}

static void	obj_elf_line(int ignore ATTRIBUTE_UNUSED)
{
	/* Assume delimiter is part of expression.  BSD4.2 as fails with
	 * delightful bug,so we are not being incompatible here.  */
	new_logical_line(NULL,get_absolute_expression());
	demand_empty_rest_of_line();
}

static struct elf_versioned_name_list *
		obj_elf_find_and_add_versioned_name(const char *version_name,
				    		const		char  *sym_name,
				      		const		char  *ver,
				      		struct	elf_obj_sy *sy_obj)
{
	struct elf_versioned_name_list *versioned_name;
	const char     *p;

	for (p = ver + 1; *p == ELF_VER_CHR; p++);

	versioned_name = sy_obj->versioned_name;

	switch (p - ver) {
	case 1: case 2: break;
	case 3:
		if (sy_obj->rename) {
			if (strcmp(versioned_name->name,version_name) == 0)
				return versioned_name;
			else {
				as_bad(("only one version name with `@@@' is allowed "
					"for symbol `%s'"),sym_name);
				return NULL;
			}
		}
		sy_obj->rename = true;
		break;
	default:
		as_bad(("invalid version name '%s' for symbol `%s'"),
		       version_name,sym_name);
		return NULL;
	}

	for (; versioned_name != NULL; versioned_name = versioned_name->next)
		if (strcmp(versioned_name->name,version_name) == 0)
			return versioned_name;

	/* Add this versioned name to the head of the list, */
	versioned_name = (struct elf_versioned_name_list *)
		xmalloc(sizeof(*versioned_name));
	versioned_name->name = strdup(version_name);
	versioned_name->next = sy_obj->versioned_name;
	sy_obj->versioned_name = versioned_name;

	return versioned_name;
}

/* This handles the .symver pseudo-op,which is used to specify a symbol
 * version.  The syntax is ``.symver NAME,SYMVERNAME''. SYMVERNAME may contain
 * ELF_VER_CHR ('@') characters.  This pseudo-op causes the assembler to emit a
 * symbol named SYMVERNAME with the same value as the symbol NAME.
 */
static void	obj_elf_symver(int ignore ATTRIBUTE_UNUSED)
{
	char           *name;
	const char     *sym_name;
	char		c;
	char		old_lexat;
	symbolS        *sym;
	struct elf_obj_sy *sy_obj;
	char           *p;

	sym = get_sym_from_input_line_and_check();

	if (*input_line_pointer != ',') {
		as_bad("expected comma after name in .symver");
		ignore_rest_of_line();
		return;
	}
	++input_line_pointer;
	SKIP_WHITESPACE();

	/* Temporarily include '@' in symbol names.  */
	old_lexat = lex_type[(unsigned char)'@'];
	lex_type[(unsigned char)'@'] |= LEX_NAME;
	c = get_symbol_name(&name);
	lex_type[(unsigned char)'@'] = old_lexat;
	sym_name = S_GET_NAME(sym);

	if (S_IS_COMMON(sym)) {
		as_bad(("`%s' can't be versioned to common symbol '%s'"),
		       name,sym_name);
		ignore_rest_of_line();
		return;
	}
	p = strchr(name,ELF_VER_CHR);
	if (p == NULL) {
		as_bad(("missing version name in `%s' for symbol `%s'"),
		       name,sym_name);
		ignore_rest_of_line();
		return;
	}
	sy_obj = symbol_get_obj(sym);
	if (obj_elf_find_and_add_versioned_name(name,sym_name,
						p,sy_obj) == NULL) {
		sy_obj->bad_version = true;
		ignore_rest_of_line();
		return;
	}
	(void)restore_line_pointer(c);

	if (*input_line_pointer == ',') {
		char           *save = input_line_pointer;

		++input_line_pointer;
		SKIP_WHITESPACE();
		if (startswith(input_line_pointer,"local")) {
			input_line_pointer += 5;
			sy_obj->visibility = visibility_local;
		} else
			if (startswith(input_line_pointer,"hidden")) {
				input_line_pointer += 6;
				sy_obj->visibility = visibility_hidden;
			} else
				if (startswith(input_line_pointer,"remove")) {
					input_line_pointer += 6;
					sy_obj->visibility = visibility_remove;
				} else
					input_line_pointer = save;
	}
	demand_empty_rest_of_line();
}

/* This handles the .vtable_inherit pseudo-op,which is used to indicate to the
 * linker the hierarchy in which a particular table resides.  The syntax is
 * ".vtable_inherit CHILDNAME,PARENTNAME".  */
struct fix     *obj_elf_get_vtable_inherit(void)
{
	char           *cname,*pname;
	symbolS        *csym,*psym;
	char		c        ,bad = 0;

	if (*input_line_pointer == '#')
		++input_line_pointer;

	c = get_symbol_name(&cname);
	csym = symbol_find(cname);

	/* GCFIXME: should check that we don't have two .vtable_inherits for
	 * the same child symbol.  Also,we can currently only do this if the
	 * child symbol is already exists and is placed in a fragment.  */
	if (csym == NULL || symbol_get_frag(csym) == NULL) {
		as_bad("expected `%s' to have already been set for .vtable_inherit",
				cname);
		bad = 1;
	}
	*input_line_pointer = c;

	SKIP_WHITESPACE_AFTER_NAME();
	if (*input_line_pointer != ',') {
		as_bad("expected comma after name in .vtable_inherit");
		ignore_rest_of_line();
		return NULL;
	}
	++input_line_pointer;
	SKIP_WHITESPACE();

	if (*input_line_pointer == '#')
		++input_line_pointer;

	if (input_line_pointer[0] == '0'
	    && (input_line_pointer[1] == '\0'
		|| ISSPACE(input_line_pointer[1]))) {
		psym = section_symbol(absolute_section);
		++input_line_pointer;
	} else {
		c = get_symbol_name(&pname);
		psym = symbol_find_or_make(pname);
		restore_line_pointer(c);
	}

	demand_empty_rest_of_line();

	if (bad)
		return NULL;

	gas_assert(symbol_get_value_expression(csym)->X_op == O_constant);
	return fix_new(symbol_get_frag(csym),
		       symbol_get_value_expression(csym)->X_add_number,
		       0,psym,0,0,BFD_RELOC_VTABLE_INHERIT);
}

/* This is a version of obj_elf_get_vtable_inherit() that is suitable for use
 * in struct _pseudo_type tables.  */
static void	obj_elf_vtable_inherit(int ignore ATTRIBUTE_UNUSED)
{
	(void)obj_elf_get_vtable_inherit();
}

/* This handles the .vtable_entry pseudo-op,which is used to indicate to the
 * linker that a vtable slot was used.  The syntax is ".vtable_entry tablename,
 * offset".  */
static struct fix *obj_elf_get_vtable_entry(void)
{
	symbolS        *sym;
	offsetT		offset;

	if (*input_line_pointer == '#')
		++input_line_pointer;

	sym = get_sym_from_input_line_and_check();
	if (*input_line_pointer != ',') {
		as_bad(("expected comma after name in .vtable_entry"));
		ignore_rest_of_line();
		return NULL;
	}
	++input_line_pointer;
	if (*input_line_pointer == '#')
		++input_line_pointer;

	offset = get_absolute_expression();

	demand_empty_rest_of_line();

	return fix_new(frag_now,frag_now_fix(),0,sym,offset,0,
		       BFD_RELOC_VTABLE_ENTRY);
}

/* This is a version of obj_elf_get_vtable_entry() that is suitable for use in
 * struct _pseudo_type tables.  */
static void	obj_elf_vtable_entry(int ignore ATTRIBUTE_UNUSED)
{
	(void)obj_elf_get_vtable_entry();
}

#define skip_whitespace(str)  do { if (*(str) == ' ') ++(str); } while (0)

static inline int skip_past_char(char **str,char c)
{
	if (**str == c) {
		(*str)++;
		return 0;
	} else
		return -1;
}
#define skip_past_comma(str) skip_past_char (str,',')
/* A list of attributes that have been explicitly set by the assembly code.
 * VENDOR is the vendor id,BASE is the tag shifted right by the number of bits
 * in MASK,and bit N of MASK is set if tag BASE+N has been set.  */
struct recorded_attribute_info {
	struct recorded_attribute_info *next;
	int		vendor;
	unsigned int	base;
	unsigned long	mask;
};
static struct recorded_attribute_info *recorded_attributes;

/* Record that we have seen an explicit specification of attribute TAG for
 * vendor VENDOR.  */
static void	record_attribute(int vendor,unsigned int tag)
{
	unsigned int	base;
	unsigned long	mask;
	struct recorded_attribute_info *rai;

	base = tag / (8 * sizeof(rai->mask));
	mask = 1UL << (tag % (8 * sizeof(rai->mask)));
	for (rai = recorded_attributes; rai; rai = rai->next)
		if (rai->vendor == vendor && rai->base == base) {
			rai->mask |= mask;
			return;
		}
	rai = XNEW(struct recorded_attribute_info);
	rai->next = recorded_attributes;
	rai->vendor = vendor;
	rai->base = base;
	rai->mask = mask;
	recorded_attributes = rai;
}

/* Allocate/find an object attribute.  */
static obj_attribute *elf_new_obj_attr(bfd * abfd,int vendor,unsigned tag)
{
	obj_attribute  *attr;
	obj_attribute_list *list;
	obj_attribute_list *p;
	obj_attribute_list **lastp;


	if (tag < NUM_KNOWN_OBJ_ATTRIBUTES) {
		/* Known tags are preallocated.  */
		attr = &elf_known_obj_attributes(abfd)[vendor][tag];
	} else {
		/* Create a new tag.  */
		list = (obj_attribute_list *)
			bfd_alloc(abfd,sizeof(obj_attribute_list));
		memset(list,0,sizeof(obj_attribute_list));
		list->tag = tag;
		/* Keep the tag list in order.  */
		lastp = &elf_other_obj_attributes(abfd)[vendor];
		for (p = *lastp; p; p = p->next) {
			if (tag < p->tag)
				break;
			lastp = &p->next;
		}
		list->next = *lastp;
		*lastp = list;
		attr = &list->attr;
	}

	return attr;
}
static char    *elf_attr_strdup(bfd * abfd ATTRIBUTE_UNUSED,const char *s,const char *end)
{
	char           *p;
	size_t		len;

	if (end)
		len = strnlen(s,end - s);
	else
		len = strlen(s);

	p = (char *)malloc(len + 1);
	if (p != NULL) {
		memcpy(p,s,len);
		p[len] = 0;
	}
	return p;
}
/* Add a string object attribute.  */
static void	bfd_elf_add_obj_attr_string(bfd * abfd,int vendor,unsigned int tag,
		    		const		char  *s,const char *end)
{
	obj_attribute  *attr;

	attr = elf_new_obj_attr(abfd,vendor,tag);
	attr->type = _bfd_elf_obj_attrs_arg_type(abfd,vendor,tag);
	attr->s = elf_attr_strdup(abfd,s,end);
}
/* Add an integer object attribute.  */
static void	bfd_elf_add_obj_attr_int(bfd * abfd,int vendor,unsigned tag,unsigned i)
{
	obj_attribute  *attr;

	attr = elf_new_obj_attr(abfd,vendor,tag);
	attr->type = _bfd_elf_obj_attrs_arg_type(abfd,vendor,tag);
	attr->i = i;
}
/* * Determine whether a GNU object attribute tag takes an integer,a string or
 * both.  */
static int	gnu_obj_attrs_arg_type(unsigned int tag)
{
	/* Except for Tag_compatibility,for GNU attributes we follow the same
	 * rule ARM ones > 32 follow: odd-numbered tags take strings and
	 * even-numbered tags take integers.  In addition,tag & 2 is nonzero
	 * for architecture-independent tags and zero for
	 * architecture-dependent ones.  */
	if (tag == Tag_compatibility)
		return 3;
	else
		return (tag & 1) != 0 ? 2 : 1;
}
/* Determine whether an object attribute tag takes an integer,a string or
 * both.  */
static int	riscv_elf_obj_attrs_arg_type(int tag)
{
	return (tag & 1) != 0 ? ATTR_TYPE_FLAG_STR_VAL : ATTR_TYPE_FLAG_INT_VAL;
}

/* Determine what arguments an attribute tag takes.  */
static int	_bfd_elf_obj_attrs_arg_type(bfd * abfd ATTRIBUTE_UNUSED,
			  		int		vendor  ,unsigned int tag)
{
	switch (vendor) {
	case OBJ_ATTR_PROC:
		return riscv_elf_obj_attrs_arg_type(tag);
		break;
	case OBJ_ATTR_GNU:
		return gnu_obj_attrs_arg_type(tag);
		break;
	default:
		abort();
	}
}
/* Parse an attribute directive for VENDOR. Returns the attribute number read,
 * or zero on error.  */
static int	obj_elf_vendor_attribute(int vendor)
{
	expressionS	exp;
	int		type;
	int		tag;
	unsigned int	i = 0;
	char           *s = NULL;

	/* Read the first number or name.  */
	skip_whitespace(input_line_pointer);
	s = input_line_pointer;
	if (ISDIGIT(*input_line_pointer)) {
		expression(&exp);
		if (exp.X_op != O_constant)
			goto bad;
		tag = exp.X_add_number;
	} else {
		char           *name;

		/* A name may contain '_',but no other punctuation.  */
		for (; ISALNUM(*input_line_pointer) || *input_line_pointer == '_';
		     ++input_line_pointer)
			i++;
		if (i == 0)
			goto bad;

		name = xmemdup0(s,i);

#ifndef CONVERT_SYMBOLIC_ATTRIBUTE
#define CONVERT_SYMBOLIC_ATTRIBUTE(a) -1
#endif

		tag = CONVERT_SYMBOLIC_ATTRIBUTE(name);
		if (tag == -1) {
			as_bad(("Attribute name not recognised: %s"),name);
			ignore_rest_of_line();
			free(name);
			return 0;
		}
		free(name);
	}

	type = _bfd_elf_obj_attrs_arg_type(stdoutput,vendor,tag);

	if (skip_past_comma(&input_line_pointer) == -1)
		goto bad;
	if (type & 1) {
		expression(&exp);
		if (exp.X_op != O_constant) {
			as_bad(("expected numeric constant"));
			ignore_rest_of_line();
			return 0;
		}
		i = exp.X_add_number;
	}
	if ((type & 3) == 3
	    && skip_past_comma(&input_line_pointer) == -1) {
		as_bad(("expected comma"));
		ignore_rest_of_line();
		return 0;
	}
	if (type & 2) {
		int		len;

		skip_whitespace(input_line_pointer);
		if (*input_line_pointer != '"')
			goto bad_string;
		s = demand_copy_C_string(&len);
	}
	record_attribute(vendor,tag);
	switch (type & 3) {
	case 3:
		bfd_elf_add_obj_attr_int_string(stdoutput,vendor,tag,i,s);
		break;
	case 2:
		bfd_elf_add_obj_attr_string(stdoutput,vendor,tag,s,NULL);
		break;
	case 1:
		bfd_elf_add_obj_attr_int(stdoutput,vendor,tag,i);
		break;
	default:
		abort();
	}

	demand_empty_rest_of_line();
	return tag;
bad_string:
	as_bad(("bad string constant"));
	ignore_rest_of_line();
	return 0;
bad:
	as_bad(("expected <tag> ,<value>"));
	ignore_rest_of_line();
	return 0;
}

/* Parse a .gnu_attribute directive.  */
static void	obj_elf_gnu_attribute(int ignored ATTRIBUTE_UNUSED)
{
	obj_elf_vendor_attribute(OBJ_ATTR_GNU);
}

static void	elf_obj_read_begin_hook(void)
{
}

static void	elf_obj_symbol_new_hook(symbolS * symbolP)
{
	struct elf_obj_sy *sy_obj;

	sy_obj = symbol_get_obj(symbolP);
	sy_obj->size = NULL;
	sy_obj->versioned_name = NULL;

}

/* Deduplicate size expressions.  We might get into trouble with multiple
 * freeing or use after free if we leave them pointing to the same expressionS.  */
static void	elf_obj_symbol_clone_hook(symbolS * newsym,symbolS * orgsym ATTRIBUTE_UNUSED)
{
	struct elf_obj_sy *newelf = symbol_get_obj(newsym);
	if (newelf->size) {
		expressionS    *exp = XNEW(expressionS);
		*exp = *newelf->size;
		newelf->size = exp;
	}
}

static void	obj_elf_version(int ignore ATTRIBUTE_UNUSED)
{
	char           *name;
	unsigned int	c;
	char           *p;
	asection       *seg = now_seg;
	subsegT		subseg = now_subseg;
	Elf_Internal_Note i_note;
	Elf_External_Note e_note;
	asection       *note_secp = NULL;

	SKIP_WHITESPACE();
	if (*input_line_pointer == '\"') {
		unsigned int	len;

		++input_line_pointer;	/* -> 1st char of string.  */
		name = input_line_pointer;

		while (is_a_char(c = next_char_of_string()));
		c = *input_line_pointer;
		*input_line_pointer = '\0';
		*(input_line_pointer - 1) = '\0';
		*input_line_pointer = c;

		/* Create the .note section.  */
		note_secp = subseg_new(".note",0);
		note_secp->flags = SEC_HAS_CONTENTS|SEC_READONLY;
		record_alignment(note_secp,2);

		/* Process the version string.  */
		len = strlen(name) + 1;

		/*
		 * PR 3456: Although the name field is padded out to an 4-byte
		 * boundary,the namesz field should not be adjusted.
		 */
		i_note.namesz = len;
		i_note.descsz = 0;	/* No description.  */
		i_note.type = NT_VERSION;
		p = frag_more(sizeof(e_note.namesz));
		md_number_to_chars(p,i_note.namesz,sizeof(e_note.namesz));
		p = frag_more(sizeof(e_note.descsz));
		md_number_to_chars(p,i_note.descsz,sizeof(e_note.descsz));
		p = frag_more(sizeof(e_note.type));
		md_number_to_chars(p,i_note.type,sizeof(e_note.type));
		p = frag_more(len);
		memcpy(p,name,len);

		frag_align(2,0,0);

		subseg_set(seg,subseg);
	} else
		as_bad(("expected quoted string"));

	demand_empty_rest_of_line();
}

static void	obj_elf_size(int ignore ATTRIBUTE_UNUSED)
{
	char           *name;
	char		c = get_symbol_name(&name);
	char           *p;
	expressionS	exp;
	symbolS        *sym;

	p = input_line_pointer;
	*p = c;
	SKIP_WHITESPACE_AFTER_NAME();
	if (*input_line_pointer != ',') {
		*p = 0;
		as_bad(("expected comma after name `%s' in .size directive"),name);
		*p = c;
		ignore_rest_of_line();
		return;
	}
	input_line_pointer++;
	expression(&exp);
	if (exp.X_op == O_absent) {
		as_bad(("missing expression in .size directive"));
		exp.X_op = O_constant;
		exp.X_add_number = 0;
	}
	*p = 0;
	sym = symbol_find_or_make(name);
	*p = c;
	if (exp.X_op == O_constant) {
		S_SET_SIZE(sym,exp.X_add_number);
		xfree(symbol_get_obj(sym)->size);
		symbol_get_obj(sym)->size = NULL;
	} else {
		symbol_get_obj(sym)->size = XNEW(expressionS);
		*symbol_get_obj(sym)->size = exp;
	}
	demand_empty_rest_of_line();
}

/* Handle the ELF .type pseudo-op.  This sets the type of a symbol. There are
 * six syntaxes:
 * 
 * The first (used on Solaris) is .type SYM,#function The second (used on
 * UnixWare) is .type SYM,@function The third (reportedly to be used on Irix
 * 6.0) is .type SYM STT_FUNC The fourth (used on NetBSD/Arm and Linux/ARM) is
 * .type SYM,%function The fifth (used on SVR4/860) is .type SYM,"function" The
 * sixth (emitted by recent SunPRO under Solaris) is .type SYM,[0-9] where the
 * integer is the STT_* value.  */
static char    *obj_elf_type_name(char *cp)
{
	char           *p;

	p = input_line_pointer;
	if (*input_line_pointer >= '0'
	    && *input_line_pointer <= '9') {
		while (*input_line_pointer >= '0'
		       && *input_line_pointer <= '9')
			++input_line_pointer;
		*cp = *input_line_pointer;
		*input_line_pointer = '\0';
	} else
		*cp = get_symbol_name(&p);

	return p;
}

static void	obj_elf_type(int ignore ATTRIBUTE_UNUSED)
{
	char		c;
	int		type;
	const char     *type_name;
	symbolS        *sym;
	elf_symbol_type *elfsym;

	sym = get_sym_from_input_line_and_check();
	c = *input_line_pointer;
	elfsym = (elf_symbol_type *) symbol_get_bfdsym(sym);

	if (*input_line_pointer == ',')
		++input_line_pointer;

	SKIP_WHITESPACE();
	if (*input_line_pointer == '#'
	    || *input_line_pointer == '@'
	    || *input_line_pointer == '"'
	    || *input_line_pointer == '%')
		++input_line_pointer;

	type_name = obj_elf_type_name(&c);

	type = 0;
	if (strcmp(type_name,"function") == 0
	    || strcmp(type_name,"2") == 0
	    || strcmp(type_name,"STT_FUNC") == 0)
		type = BSF_FUNCTION;
	else
		if (strcmp(type_name,"object") == 0
		    || strcmp(type_name,"1") == 0
		    || strcmp(type_name,"STT_OBJECT") == 0)
			type = BSF_OBJECT;
		else
			if (strcmp(type_name,"tls_object") == 0
			    || strcmp(type_name,"6") == 0
			    || strcmp(type_name,"STT_TLS") == 0)
				type = BSF_OBJECT|BSF_THREAD_LOCAL;
			else
				if (strcmp(type_name,"notype") == 0
				    || strcmp(type_name,"0") == 0
				    || strcmp(type_name,"STT_NOTYPE") == 0);
				else
					if (strcmp(type_name,"common") == 0
					    || strcmp(type_name,"5") == 0
					    || strcmp(type_name,"STT_COMMON") == 0) {
						type = BSF_OBJECT;

						if (!S_IS_COMMON(sym)) {
							if (S_IS_VOLATILE(sym)) {
								sym = symbol_clone(sym,1);
								S_SET_SEGMENT(sym,bfd_com_section_ptr);
								S_SET_VALUE(sym,0);
								S_SET_EXTERNAL(sym);
								symbol_set_frag(sym,&zero_address_frag);
								S_CLEAR_VOLATILE(sym);
							}
							else
								if (S_IS_DEFINED(sym) || symbol_equated_p(sym))
									as_bad(("symbol '%s' is already defined"),S_GET_NAME(sym));
								else {
									/* FIXME:Is it safe to just change the section ? */
									S_SET_SEGMENT(sym,bfd_com_section_ptr);
									S_SET_VALUE(sym,0);
									S_SET_EXTERNAL(sym);
								}
						}
					} else
						if (strcmp(type_name,"gnu_indirect_function") == 0
						|| strcmp(type_name,"10") == 0
						    || strcmp(type_name,"STT_GNU_IFUNC") == 0) {
							elf_tdata(stdoutput)->has_gnu_osabi |= elf_gnu_osabi_ifunc;
							type = BSF_FUNCTION|BSF_GNU_INDIRECT_FUNCTION;
						} else
							if (strcmp(type_name,"gnu_unique_object") == 0) {
								elf_tdata(stdoutput)->has_gnu_osabi |= elf_gnu_osabi_unique;
								type = BSF_OBJECT|BSF_GNU_UNIQUE;
							}
							else as_bad(("unrecognized symbol type \"%s\""),type_name);

	*input_line_pointer = c;

	if (*input_line_pointer == '"')
		++input_line_pointer;

	{
		uint32_t	mask = BSF_FUNCTION|BSF_OBJECT;

		if (type != BSF_FUNCTION)
			mask |= BSF_GNU_INDIRECT_FUNCTION;
		if (type != BSF_OBJECT) {
			mask |= BSF_GNU_UNIQUE|BSF_THREAD_LOCAL;

			if (S_IS_COMMON(sym)) {
				as_bad(("cannot change type of common symbol '%s'"),
				       S_GET_NAME(sym));
				mask = type = 0;
			}
		}
		/* Don't warn when changing to STT_NOTYPE.  */
		if (type) {
			uint32_t	new = (elfsym->symbol.flags & ~mask)|type;

			if (new != (elfsym->symbol.flags|type))
				as_warn(("symbol '%s' already has its type set"),S_GET_NAME(sym));
			elfsym->symbol.flags = new;
		} else
			elfsym->symbol.flags &= ~mask;
	}
	demand_empty_rest_of_line();
}

static segT	comment_section;

static void	obj_elf_ident(int ignore ATTRIBUTE_UNUSED)
{
	segT		old_section = now_seg;
	int		old_subsection = now_subseg;

	if (!comment_section) {
		char           *p;
		comment_section = subseg_new(".comment",0);
		comment_section->flags = (SEC_READONLY|SEC_HAS_CONTENTS
					 |SEC_MERGE|SEC_STRINGS);
		comment_section->entsize = 1;
		p = frag_more(1);
		*p = 0;
	} else
		subseg_set(comment_section,0);
	stringer(8 + 1);
	subseg_set(old_section,old_subsection);
}

// #ifdef INIT_STAB_SECTION Always defined: in asm.H
/* The first entry in a .stabs section is special.  */
static void	obj_elf_init_stab_section(segT seg)
{
	char           *file;
	char           *p;
	char           *stabstr_name;
	unsigned int	stroff;

	/*
	 * Force the section to align to a longword boundary.  Without this,
	 * UnixWare ar crashes.
	 */
	bfd_set_section_alignment(seg,2);

	/* Make space for this first symbol.  */
	p = frag_more(12);
	/* Zero it out.  */
	memset(p,0,12);
	file = remap_debug_filename(as_where(NULL));
	stabstr_name = concat(segment_name(seg),"str",(char *)NULL);
	stroff = get_stab_string_offset(file,stabstr_name,true);
	know(stroff == 1 || (stroff == 0 && file[0] == '\0'));
	md_number_to_chars(p,stroff,4);
	seg_info(seg)->stabu.p = p;
	free(file);
}
//#endif INIT_STAB_SECTION

/* Fill in the counts in the first entry in a .stabs section.  */
static void	adjust_stab_sections(asection * sec,void *xxx ATTRIBUTE_UNUSED)
{
	char           *name;
	asection       *strsec;
	char           *p;
	int		strsz     ,nsyms;

	if (!startswith(sec->name,".stab"))
		return;
	if (!strcmp("str",sec->name + strlen(sec->name) - 3))
		return;

	name = concat(sec->name,"str",NULL);
	strsec = bfd_get_section_by_name(stdoutput,name);
	if (strsec)
		strsz = bfd_section_size(strsec);
	else
		strsz = 0;
	nsyms = bfd_section_size(sec) / 12 - 1;

	p = seg_info(sec)->stabu.p;
	gas_assert(p != 0);

	bfd_putl16(nsyms,p + 6);
	bfd_putl32(strsz,p + 8);
	free(name);
}


static void	elf_frob_symbol(symbolS * symp,int *puntp)
{
	struct elf_obj_sy *sy_obj;
	expressionS    *size;
	struct elf_versioned_name_list *versioned_name;

	sy_obj = symbol_get_obj(symp);

	size = sy_obj->size;
	if (size != NULL) {
		if (resolve_expression(size)
		    && size->X_op == O_constant)
			S_SET_SIZE(symp,size->X_add_number);
		else {
			if (!flag_allow_nonconst_size)
				as_bad((".size expression for %s "
					"does not evaluate to a constant"),S_GET_NAME(symp));
			else
				as_warn((".size expression for %s "
					 "does not evaluate to a constant"),S_GET_NAME(symp));
		}
		free(sy_obj->size);
		sy_obj->size = NULL;
	}
	versioned_name = sy_obj->versioned_name;
	if (versioned_name) {
		/* This symbol was given a new name with the .symver directive.
		 * If this is an external reference,just rename the symbol to
		 * include the version string.  This will make the relocs be
		 * against the correct versioned symbol. */

		/* We will have already reported an version error.  */
		if (sy_obj->bad_version)
			*puntp = true;
		/* elf_frob_file_before_adjust only allows one version symbol
		 * for renamed symbol.  */
		else
			if (sy_obj->rename)
				S_SET_NAME(symp,versioned_name->name);
			else
				if (S_IS_COMMON(symp)) {
					as_bad(("`%s' can't be versioned to common symbol '%s'"),
					       versioned_name->name,S_GET_NAME(symp));
					*puntp = true;
				} else {
					asymbol        *bfdsym;
					elf_symbol_type *elfsym;

					/* This is a definition.  Add an alias for each version. FIXME: Using an
					 * alias will permit the debugging information to refer to the right
					 * symbol. However,it's not clear* whether it is the best approach.  */

					/* FIXME: Creating a new symbol here is * risky.  We're in the final 
					 * loop over the symbol table.  We can get away with it only 
					 * because the symbol goes to the end of the list,where the
					 * loop will still see it.  It would probably be better to do this in
					 * obj_frob_file_before_adjust.  */
					for (; versioned_name != NULL;
					     versioned_name = versioned_name->next) {
						symbolS        *symp2 = symbol_find_or_make(versioned_name->name);

						S_SET_SEGMENT(symp2,S_GET_SEGMENT(symp));

						/*
						 * Subtracting out the frag address here is a hack
						 * because we are in the middle of the final loop.  */
						S_SET_VALUE(symp2,
							    (S_GET_VALUE(symp)
							     - (symbol_get_frag(symp)->fr_address
							 / OCTETS_PER_BYTE)));

						symbol_set_frag(symp2,symbol_get_frag(symp));

						/*
						 * This will copy over the size
						 * information.
						 */
						copy_symbol_attributes(symp2,symp);

						S_SET_OTHER(symp2,S_GET_OTHER(symp));

						if (S_IS_WEAK(symp))
							S_SET_WEAK(symp2);

						if (S_IS_EXTERNAL(symp))
							S_SET_EXTERNAL(symp2);
					}

					switch (sy_obj->visibility) {
					case visibility_unchanged:
						break;
					case visibility_hidden:
						bfdsym = symbol_get_bfdsym(symp);
						elfsym = elf_symbol_from(bfdsym);
						elfsym->internal_elf_sym.st_other &= ~3;
						elfsym->internal_elf_sym.st_other |= STV_HIDDEN;
						break;
					case visibility_remove:
						/* Don't remove the symbol if it is used in relocation.
						 * Instead,mark it as to be removed and issue an error
						 * if the symbol has more than one versioned name.  */
						if (symbol_used_in_reloc_p(symp)) {
							if (sy_obj->versioned_name->next != NULL)
								as_bad(("symbol '%s' with multiple versions cannot be used in relocation"),
								       S_GET_NAME(symp));
							symbol_mark_removed(symp);
						} else
							symbol_remove(symp,&symbol_rootP,&symbol_lastP);
						break;
					case visibility_local:
						S_CLEAR_EXTERNAL(symp);
						break;
					}
				}
	}
	/* Double check weak symbols.  */
	if (S_IS_WEAK(symp)) {
		if (S_IS_COMMON(symp))
			as_bad(("symbol `%s' can not be both weak and common"),
			       S_GET_NAME(symp));
	}
}

/* Fix up SYMPP which has been marked to be removed by .symver.  */
static void	elf_fixup_removed_symbol(symbolS ** sympp)
{
	symbolS        *symp = *sympp;
	struct elf_obj_sy *sy_obj = symbol_get_obj(symp);

	/* Replace the removed symbol with the versioned symbol.  */
	symp = symbol_find(sy_obj->versioned_name->name);
	*sympp = symp;
}

struct group_list {
	asection      **head;	/* Section lists.  */
	unsigned int	num_group;	/* Number of lists.  */
	htab_t		indexes;/* Maps group name to index in head array.  */
};

static struct group_list groups;
/* Called via map_over_sections.  If SEC is a member of a group,add it to a
 * list of sections belonging to the group.  INF is a pointer to a struct
 * group_list,which is where we store the head of each list.  If its
 * link_to_symbol_name isn't NULL,set up its linked-to section.  */
static void	build_additional_section_info(asection * sec,void *inf)
{
	struct group_list *list = (struct group_list *)inf;
	const char     *group_name = elf_group_name(sec);
	unsigned int	i;
	unsigned int   *elem_idx;
	unsigned int   *idx_ptr;

	if (sec->map_head.linked_to_symbol_name) {
		symbolS        *linked_to_sym;
		linked_to_sym = symbol_find(sec->map_head.linked_to_symbol_name);
		if (!linked_to_sym || !S_IS_DEFINED(linked_to_sym))
			as_bad(("undefined linked-to symbol `%s' on section `%s'"),
			       sec->map_head.linked_to_symbol_name,
			       bfd_section_name(sec));
		else
			elf_linked_to_section(sec) = S_GET_SEGMENT(linked_to_sym);
	}
	if (group_name == NULL)
		return;

	/* If this group already has a list,add the section to the head of the list. */
	elem_idx = (unsigned int *)str_hash_find(list->indexes,group_name);
	if (elem_idx != NULL) {
		elf_next_in_group(sec) = list->head[*elem_idx];
		list->head[*elem_idx] = sec;
		return;
	}
	/* New group. Make the arrays bigger in chunks to minimize calls to realloc. */
	i = list->num_group;
	if ((i & 127) == 0) {
		unsigned int	newsize = i + 128;
		list->head = XRESIZEVEC(asection *,list->head,newsize);
	}
	list->head[i] = sec;
	list->num_group += 1;

	/* Add index to hash.  */
	idx_ptr = XNEW(unsigned int);
	*idx_ptr = i;
	str_hash_insert(list->indexes,group_name,idx_ptr,0);
}

static void	free_section_idx(void *ent)
{
	string_tuple_t *tuple = ent;
	free((char *)tuple->value);
}

/* Create symbols for group signature.  */
static void	elf_adjust_symtab(void)
{
	unsigned int	i;

	/* Go find section groups.  */
	groups.num_group = 0;
	groups.head = NULL;
	groups.indexes = htab_create_alloc(16,hash_string_tuple,eq_string_tuple,
					free_section_idx,notes_calloc,NULL);
	map_over_sections(build_additional_section_info, &groups);

	/* Make the SHT_GROUP sections that describe each section group.  We
	 * can't set up the section contents here yet,because elf section
	 * indices have yet to be calculated.  elf.c:set_group_contents does
	 * the rest of the work.  */
	for (i = 0; i < groups.num_group; i++) {
		const char     *group_name = elf_group_name(groups.head[i]);
		const char     *sec_name;
		asection       *s;
		uint32_t	flags;
		struct symbol  *sy;

		flags = SEC_READONLY|SEC_HAS_CONTENTS|SEC_IN_MEMORY|SEC_GROUP;
		for (s = groups.head[i]; s != NULL; s = elf_next_in_group(s))
			if ((s->flags ^ flags) & SEC_LINK_ONCE) {
				flags |= SEC_LINK_ONCE|SEC_LINK_DUPLICATES_DISCARD;
				if (s != groups.head[i]) {
					as_warn(("assuming all members of group `%s' are COMDAT"),
						group_name);
					break;
				}
			}
		sec_name = ".group";
		s->flags = flags;
		s = subseg_force_new(sec_name,0);
		if (s == NULL
		    || !bfd_set_section_alignment(s,2)) {
			as_fatal(("can't create group: %s"),
				 bfd_errmsg(bfd_get_error()));
		}
		elf_section_type(s) = SHT_GROUP;

		/* Pass a pointer to the first section in this group.  */
		elf_next_in_group(s) = groups.head[i];
		elf_sec_group(groups.head[i]) = s;
		/*
		 * Make sure that the signature symbol for the group has the
		 * name of the group.
		 */
		sy = symbol_find_exact(group_name);
		if (!sy || !symbol_on_chain(sy,symbol_rootP,symbol_lastP)) {
			/* Create the symbol now.  */
			sy = symbol_new(group_name,now_seg,frag_now,0);
			symbol_get_obj(sy)->local = 1;
			symbol_table_insert(sy);
		}
		elf_group_id(s) = symbol_get_bfdsym(sy);
		/*
		 * Mark the group signature symbol as used so that it will be
		 * included in the symbol table.
		 */
		symbol_mark_used_in_reloc(sy);
	}
}

/* gas/config/obj-elf.c:2892 */
static void	elf_frob_file(void)
{
	map_over_sections(adjust_stab_sections,NULL);
	riscv_elf_final_processing();
}

/* It removes any unneeded versioned symbols from the symbol table.  */
static void	elf_frob_file_before_adjust(void)
{				/* gas/configobj-elf.c: 2902 */
	if (symbol_rootP) {
		symbolS        *symp;

		for (symp = symbol_rootP; symp; symp = symbol_next(symp)) {
			struct elf_obj_sy *sy_obj = symbol_get_obj(symp);
			int		is_defined = !!S_IS_DEFINED(symp);

			if (sy_obj->versioned_name) {
				char           *p = strchr(sy_obj->versioned_name->name,
							   ELF_VER_CHR);

				if (sy_obj->rename) {
					/* The @@@ syntax is a special case. If the symbol is not
					 * defined,2 `@'s * will be removed from the versioned_name. 
					 * Otherwise,1 `@' * will be removed.  */
					size_t		l = strlen(&p[3]) + 1;
					memmove(&p[1 + is_defined],&p[3],l);
				}
				if (!is_defined) {
					/* Verify that the name isn't using the @@ syntax--this is 
					 * reserved for * definitions of the default version
					 * to link against.  */
					if (!sy_obj->rename && p[1] == ELF_VER_CHR) {
						as_bad(("invalid attempt to declare external "
							"version name as default in symbol `%s'"),
						sy_obj->versioned_name->name);
						return;
					}
					/* Only one version symbol is allowed
					 * for undefined symbol.  */
					if (sy_obj->versioned_name->next) {
						as_bad(("multiple versions [`%s'|`%s'] for "
							"symbol `%s'"),
						 sy_obj->versioned_name->name,
						       sy_obj->versioned_name->next->name,
						       S_GET_NAME(symp));
						return;
					}
					sy_obj->rename = true;
				}
			}
			/* If there was .symver or .weak,but symbol was
			 * neither defined nor used anywhere,remove it.  */
			if (!is_defined
			    && (sy_obj->versioned_name || S_IS_WEAK(symp))
			    && symbol_used_p(symp) == 0
			    && symbol_used_in_reloc_p(symp) == 0)
				symbol_remove(symp,&symbol_rootP,&symbol_lastP);
		}
	}
}

/* It is required that we let write_relocs have the opportunity to optimize
 * away fixups before output has begun,since it is possible to eliminate all
 * fixups for a section and thus we never should have generated the relocation
 * section.  */
static void	elf_frob_file_after_relocs(void)
{
	unsigned int	i;

	/* Set SHT_GROUP section size.  */
	for (i = 0; i < groups.num_group; i++) {
		asection       *s,*head,*group;
		size_t		size;

		head = groups.head[i];
		size = 4;
		for (s = head; s != NULL; s = elf_next_in_group(s))
			size += (s->flags & SEC_RELOC) != 0 ? 8 : 4;

		group = elf_sec_group(head);
		subseg_set(group,0);
		set_section_size(group,size);
		group->contents = (unsigned char *)frag_more(size);
		frag_now->fr_fix = frag_now_fix_octets();
		frag_wane(frag_now);
	}
}

/* This is called when the assembler starts.  */
static void	elf_begin(void)
{
	asection       *s;

	/* Add symbols for the known sections to the symbol table.  */
	s = bfd_get_section_by_name(stdoutput,TEXT_SECTION_NAME);
	symbol_table_insert(section_symbol(s));
	s = bfd_get_section_by_name(stdoutput,DATA_SECTION_NAME);
	symbol_table_insert(section_symbol(s));
	s = bfd_get_section_by_name(stdoutput,BSS_SECTION_NAME);
	symbol_table_insert(section_symbol(s));
	elf_com_section_ptr = bfd_com_section_ptr;
	previous_section = NULL;
	previous_subsection = 0;
	comment_section = NULL;
	memset(&groups,0,sizeof(groups));
}

static void	elf_end(void)
{
	while (section_stack) {
		struct section_stack *top = section_stack;
		section_stack = top->next;
		free(top);
	}
	while (recorded_attributes) {
		struct recorded_attribute_info *rai = recorded_attributes;
		recorded_attributes = rai->next;
		free(rai);
	}
	if (groups.indexes) {
		htab_delete(groups.indexes);
		free(groups.head);
	}
}
/* ============================================================**** atof-ieee.c */
/* atof_ieee.c - turn a Flonum into an IEEE floating point number */

/* Flonums returned here.  */
extern FLONUM_TYPE generic_floating_point_number;
/* Precision in LittleNums.  */
/* Don't count the gap in the m68k extended precision format.  */
#define MAX_PRECISION  5
#define H_PRECISION    1
#define B_PRECISION    1	/* Not strictly IEEE,but handled here anyway.  */
#define F_PRECISION    2
#define D_PRECISION    4
#define X_PRECISION    5
#ifndef X_PRECISION_PAD
#define X_PRECISION_PAD 0
#endif
#define P_PRECISION    5
#ifndef P_PRECISION_PAD
#define P_PRECISION_PAD X_PRECISION_PAD
#endif

/* Length in LittleNums of guard bits.  */
#define GUARD          2

#ifndef TC_LARGEST_EXPONENT_IS_NORMAL
#define TC_LARGEST_EXPONENT_IS_NORMAL(PRECISION) 0
#endif

static const unsigned long mask[] =
{
	0x00000000,0x00000001,0x00000003,0x00000007,0x0000000f,0x0000001f,
	0x0000003f,0x0000007f,0x000000ff,0x000001ff,0x000003ff,0x000007ff,
	0x00000fff,0x00001fff,0x00003fff,0x00007fff,0x0000ffff,0x0001ffff,
	0x0003ffff,0x0007ffff,0x000fffff,0x001fffff,0x003fffff,0x007fffff,
	0x00ffffff,0x01ffffff,0x03ffffff,0x07ffffff,0x0fffffff,0x1fffffff,
0x3fffffff,0x7fffffff,0xffffffff,};
static int	bits_left_in_littlenum;
static int	littlenums_left;
static LITTLENUM_TYPE *littlenum_pointer;

static int	next_bits(int number_of_bits)
{
	int		return_value;

	if (!littlenums_left)
		return 0;

	if (number_of_bits >= bits_left_in_littlenum) {
		return_value = mask[bits_left_in_littlenum] & *littlenum_pointer;
		number_of_bits -= bits_left_in_littlenum;
		return_value <<= number_of_bits;

		if (--littlenums_left) {
			bits_left_in_littlenum = LITTLENUM_NUMBER_OF_BITS - number_of_bits;
			--littlenum_pointer;
			return_value |=
				(*littlenum_pointer >> bits_left_in_littlenum)
				& mask[number_of_bits];
		}
	} else {
		bits_left_in_littlenum -= number_of_bits;
		return_value =
			mask[number_of_bits] & (*littlenum_pointer >> bits_left_in_littlenum);
	}
	return return_value;
}

/* Num had better be less than LITTLENUM_NUMBER_OF_BITS.  */

static void	unget_bits(int num)
{
	if (!littlenums_left) {
		++littlenum_pointer;
		++littlenums_left;
		bits_left_in_littlenum = num;
	} else
		if (bits_left_in_littlenum + num > LITTLENUM_NUMBER_OF_BITS) {
			bits_left_in_littlenum =
				num - (LITTLENUM_NUMBER_OF_BITS - bits_left_in_littlenum);
			++littlenum_pointer;
			++littlenums_left;
		} else
			bits_left_in_littlenum += num;
}

static void	make_invalid_floating_point_number(LITTLENUM_TYPE * words)
{
	as_bad("cannot create floating-point number");
	/* Zero the leftmost bit.  */
	words[0] = (LITTLENUM_TYPE) ((unsigned)-1) >> 1;
	words[1] = (LITTLENUM_TYPE) - 1;
	words[2] = (LITTLENUM_TYPE) - 1;
	words[3] = (LITTLENUM_TYPE) - 1;
	words[4] = (LITTLENUM_TYPE) - 1;
	words[5] = (LITTLENUM_TYPE) - 1;
}

/* Build a floating point constant at str into a IEEE floating point number.
 * This function does the same thing as atof_ieee however it allows more
 * control over the exact format,i.e. explicitly specifying the precision and
 * number of exponent bits instead of relying on this infomation being deduced
 * from a given type.
 * 
 * If generic_float_info is not NULL then it will be set to contain generic
 * infomation about the parsed floating point number.
 * 
 * Returns pointer past text consumed.  */
static char    *atof_ieee_detail(char *str,
				 		int		precision,
				 		int		exponent_bits,
				 		LITTLENUM_TYPE * words,
			    		FLONUM_TYPE *	generic_float_info)
{
	/* Extra bits for zeroed low-order bits. The 1st MAX_PRECISION are
	 * zeroed,the last contain flonum bits.  */
	static LITTLENUM_TYPE bits[MAX_PRECISION + MAX_PRECISION + GUARD];
	char           *return_value;

	/* Number of 16-bit words in the format.  */
	FLONUM_TYPE	save_gen_flonum;

	/* We have to save the generic_floating_point_number because it
	 * contains storage allocation about the array of LITTLENUMs where the
	 * value is actually stored.  We will allocate our own array of
	 * littlenums below,but have to restore the global one on exit.  */
	save_gen_flonum = generic_floating_point_number;

	return_value = str;
	generic_floating_point_number.low = bits + MAX_PRECISION;
	generic_floating_point_number.high = NULL;
	generic_floating_point_number.leader = NULL;
	generic_floating_point_number.exponent = 0;
	generic_floating_point_number.sign = '\0';

	/* Use more LittleNums than seems necessary: the highest flonum may
	 * have 15 leading 0 bits,so could be useless.  */

	memset(bits,'\0',sizeof(LITTLENUM_TYPE) * MAX_PRECISION);

	generic_floating_point_number.high
		= generic_floating_point_number.low + precision - 1 + GUARD;

	if (atof_generic(&return_value,".",EXP_CHARS,
			 &generic_floating_point_number)) {
		make_invalid_floating_point_number(words);
		return NULL;
	}
	if (generic_float_info)
		*generic_float_info = generic_floating_point_number;

	gen_to_words(words,precision,exponent_bits);

	/* Restore the generic_floating_point_number's storage alloc (and
	 * everything else).  */
	generic_floating_point_number = save_gen_flonum;

	return return_value;
}

/* Warning: This returns 16-bit LITTLENUMs.  It is up to the caller to figure
 * out any alignment problems and to conspire for the bytes/word to be emitted
 * in the right order.  Bigendians beware!  */

/* Note that atof-ieee always has X and P precisions enabled.  it is up to
 * md_atof to filter them out if the target machine does not support them.  */

/* Returns pointer past text consumed.  */
static char    *atof_ieee(char *str,	/* Text to convert to binary.  */
			  		int		what_kind,	/* 'd','f','x','p'.  */
			  		LITTLENUM_TYPE * words)
{				/* Build the binary here.  */
	int		precision;
	long		exponent_bits;

	switch (what_kind) {
	case 'h': case 'H':
		precision = H_PRECISION;
		exponent_bits = 5;
		break;

	case 'b': case 'B':
		precision = B_PRECISION;
		exponent_bits = 8;
		break;

	case 'f': case 'F': case 's': case 'S':
		precision = F_PRECISION;
		exponent_bits = 8;
		break;

	case 'd': case 'D': case 'r': case 'R':
		precision = D_PRECISION;
		exponent_bits = 11;
		break;

	case 'x': case 'X': case 'e': case 'E':
		precision = X_PRECISION;
		exponent_bits = 15;
		break;

	case 'p': case 'P':
		precision = P_PRECISION;
		exponent_bits = -1;
		break;

	default:
		make_invalid_floating_point_number(words);
		return (NULL);
	}

	return atof_ieee_detail(str,precision,exponent_bits,words,NULL);
}

/* Turn generic_floating_point_number into a real float/double/extended.  */
/* gas/config/atof-ieee.c:308 */
static int	gen_to_words(LITTLENUM_TYPE * words,int precision,long exponent_bits)
{
	int		return_value = 0;

	long		exponent_1;
	long		exponent_2;
	long		exponent_3;
	long		exponent_4;
	int		exponent_skippage;
	LITTLENUM_TYPE	word1;
	LITTLENUM_TYPE *lp;
	LITTLENUM_TYPE *words_end;

	words_end = words + precision;

	if (generic_floating_point_number.low > generic_floating_point_number.leader) {
		/* 0.0e0 seen.  */
		if (generic_floating_point_number.sign == '+')
			words[0] = 0x0000;
		else
			words[0] = 0x8000;
		memset(&words[1],'\0',
		       (words_end - words - 1) * sizeof(LITTLENUM_TYPE));
		return return_value;
	}
	switch (generic_floating_point_number.sign) {
		/* NaN:  Do the right thing.  */
	case 0: case 'Q': case 'q': case 'S': case 's':
		if (TC_LARGEST_EXPONENT_IS_NORMAL(precision))
			as_warn(("NaNs are not supported by this target"));

		if (precision == H_PRECISION) {
			if (TOUPPER(generic_floating_point_number.sign) != 'S')
				words[0] = 0x7fff;
			else
				words[0] = exponent_bits == 5 ? 0x7dff : 0x7fbf;
		} else
			if (precision == F_PRECISION) {
				words[0] = TOUPPER(generic_floating_point_number.sign) == 'S'
					? 0x7fbf : 0x7fff;
				words[1] = 0xffff;
			} else
				if (precision == X_PRECISION) {
					abort();
				} else {
					words[0] = TOUPPER(generic_floating_point_number.sign) == 'S'
						? 0x7ff7 : 0x7fff;
					words[1] = 0xffff;
					words[2] = 0xffff;
					words[3] = 0xffff;
				}

		if (ISLOWER(generic_floating_point_number.sign))
			words[0] |= 0x8000;

		return return_value;

	case 'P': case 'N':
		if (TC_LARGEST_EXPONENT_IS_NORMAL(precision))
			as_warn(("Infinities are not supported by this target"));

		/* +INF:  Do the right thing.  */
		if (precision == H_PRECISION /* also B_PRECISION */ ) {
			words[0] = exponent_bits == 5 ? 0x7c00 : 0x7f80;
		} else
			if (precision == F_PRECISION) {
				words[0] = 0x7f80;
				words[1] = 0;
			} else
				if (precision == X_PRECISION) {
					abort();
				} else {
					words[0] = 0x7ff0;
					words[1] = 0;
					words[2] = 0;
					words[3] = 0;
				}

		if (generic_floating_point_number.sign == 'N')
			words[0] |= 0x8000;

		return return_value;
	}

	/* The floating point formats we support have: Bit 15 is sign bit. Bits
	 * 14:n are excess-whatever exponent. Bits n-1:0 (if any) are most
	 * significant bits of fraction. Bits 15:0 of the next word(s) are the
	 * next most significant bits.
	 * 
	 * So we need: number of bits of exponent,number of bits of mantissa.  */
	bits_left_in_littlenum = LITTLENUM_NUMBER_OF_BITS;
	littlenum_pointer = generic_floating_point_number.leader;
	littlenums_left = (1
			   + generic_floating_point_number.leader
			   - generic_floating_point_number.low);

	/* Seek (and forget) 1st significant bit.  */
	for (exponent_skippage = 0; !next_bits(1); ++exponent_skippage);
	exponent_1 = (generic_floating_point_number.exponent
		      + generic_floating_point_number.leader
		      + 1
		      - generic_floating_point_number.low);

	/* Radix LITTLENUM_RADIX,point just higher than
	 * generic_floating_point_number.leader.  */
	exponent_2 = exponent_1 * LITTLENUM_NUMBER_OF_BITS;

	/* Radix 2.  */
	exponent_3 = exponent_2 - exponent_skippage;

	/* Forget leading zeros,forget 1st bit.  */
	exponent_4 = exponent_3 + ((1 << (exponent_bits - 1)) - 2);

	/* Offset exponent.  */
	lp = words;

	/* Word 1.  Sign,exponent and perhaps high bits.  */
	word1 = ((generic_floating_point_number.sign == '+')
		 ? 0
		 : (1 << (LITTLENUM_NUMBER_OF_BITS - 1)));

	/* Assume 2's complement integers.  */
	if (exponent_4 <= 0) {
		int		prec_bits;
		int		num_bits;

		unget_bits(1);
		num_bits = -exponent_4;
		prec_bits =
			LITTLENUM_NUMBER_OF_BITS * precision - (exponent_bits + 1 + num_bits);

		if (num_bits >= LITTLENUM_NUMBER_OF_BITS - exponent_bits) {
			/* Bigger than one littlenum.  */
			num_bits -= (LITTLENUM_NUMBER_OF_BITS - 1) - exponent_bits;
			*lp++ = word1;
			if (num_bits + exponent_bits + 1
			    > precision * LITTLENUM_NUMBER_OF_BITS) {
				/* Exponent overflow.  */
				make_invalid_floating_point_number(words);
				return return_value;
			}
			while (num_bits >= LITTLENUM_NUMBER_OF_BITS) {
				num_bits -= LITTLENUM_NUMBER_OF_BITS;
				*lp++ = 0;
			}
			if (num_bits)
				*lp++ = next_bits(LITTLENUM_NUMBER_OF_BITS - (num_bits));
		} else {
			if (precision == X_PRECISION && exponent_bits == 15) {
				*lp++ = word1;
				*lp++ = next_bits(LITTLENUM_NUMBER_OF_BITS - num_bits);
			} else {
				word1 |= next_bits((LITTLENUM_NUMBER_OF_BITS - 1)
						- (exponent_bits + num_bits));
				*lp++ = word1;
			}
		}
		while (lp < words_end)
			*lp++ = next_bits(LITTLENUM_NUMBER_OF_BITS);

		/* Round the mantissa up,but don't change the number.  */
		if (next_bits(1)) {
			--lp;
			if (prec_bits >= LITTLENUM_NUMBER_OF_BITS) {
				int		n = 0;
				int		tmp_bits;

				n = 0;
				tmp_bits = prec_bits;
				while (tmp_bits > LITTLENUM_NUMBER_OF_BITS) {
					if (lp[n] != (LITTLENUM_TYPE) - 1)
						break;
					--n;
					tmp_bits -= LITTLENUM_NUMBER_OF_BITS;
				}
				if (tmp_bits > LITTLENUM_NUMBER_OF_BITS
				 || (lp[n] & mask[tmp_bits]) != mask[tmp_bits]
				    || (prec_bits != (precision * LITTLENUM_NUMBER_OF_BITS
						      - exponent_bits - 1))) {
					unsigned long	carry;

					for (carry = 1; carry && (lp >= words); lp--) {
						carry = *lp + carry;
						*lp = carry;
						carry >>= LITTLENUM_NUMBER_OF_BITS;
					}
				} else {
					/*
					 * This is an overflow of the denormal
					 * numbers.  We need to forget what we
					 * have produced,and instead generate
					 * the smallest normalized number.
					 */
					lp = words;
					word1 = ((generic_floating_point_number.sign == '+')
						 ? 0
						 : (1 << (LITTLENUM_NUMBER_OF_BITS - 1)));
					word1 |= (1
					    << ((LITTLENUM_NUMBER_OF_BITS - 1)
						- exponent_bits));
					*lp++ = word1;
					while (lp < words_end)
						*lp++ = 0;
				}
			} else
				*lp += 1;
		}
		return return_value;
	} else
		if ((unsigned long)exponent_4 > mask[exponent_bits]
		    || (!TC_LARGEST_EXPONENT_IS_NORMAL(precision)
			&& (unsigned long)exponent_4 == mask[exponent_bits])) {
			/* Exponent overflow.  Lose immediately.  */

			/*
			 * We leave return_value alone: admit we read the
			 * number,but return a floating exception because we
			 * can't encode the number.
			 */
			make_invalid_floating_point_number(words);
			return return_value;
		} else {
			word1 |= (exponent_4 << ((LITTLENUM_NUMBER_OF_BITS - 1) - exponent_bits))
				| next_bits((LITTLENUM_NUMBER_OF_BITS - 1) - exponent_bits);
		}

	*lp++ = word1;

	/*
	 * X_PRECISION is special: on the 68k,it has 16 bits of zero in the
	 * middle.  Either way,it is then followed by a 1 bit.
	 */
	if (exponent_bits == 15 && precision == X_PRECISION) {
		*lp++ = (1 << (LITTLENUM_NUMBER_OF_BITS - 1)
			|next_bits(LITTLENUM_NUMBER_OF_BITS - 1));
	}
	/* The rest of the words are just mantissa bits.  */
	while (lp < words_end)
		*lp++ = next_bits(LITTLENUM_NUMBER_OF_BITS);

	if (next_bits(1)) {
		unsigned long	carry;
		/* Since the NEXT bit is a 1,round UP the mantissa. The
		 * cunning design of these hidden-1 floats permits us to let
		 * the mantissa overflow into the exponent,and it 'does the
		 * right thing'. However,we lose if the highest-order bit of
		 * the lowest-order word flips. Is that clear?  */

		/* #if (sizeof(carry)) < ((sizeof(bits[0]) * BITS_PER_CHAR) +
		 * 2) Please allow at least 1 more bit in carry than is in a
		 * LITTLENUM. We need that extra bit to hold a carry during a
		 * LITTLENUM carry propagation. Another extra bit (kept 0) will
		 * assure us that we don't get a sticky sign bit after shifting
		 * right,and that permits us to propagate the carry without
		 * any masking of bits. #endif */
		for (carry = 1,lp--; carry; lp--) {
			carry = *lp + carry;
			*lp = carry;
			carry >>= LITTLENUM_NUMBER_OF_BITS;
			if (lp == words)
				break;
		}
		if (precision == X_PRECISION && exponent_bits == 15) {
			/* Extended precision numbers have an explicit integer
			 * bit that we may have to restore.  */
			if (lp == words) {
				/* Put back the integer bit.  */
				lp[1] |= 1 << (LITTLENUM_NUMBER_OF_BITS - 1);
			}
		}
		if ((word1 ^ *words) & (1 << (LITTLENUM_NUMBER_OF_BITS - 1))) {
			/* We leave return_value alone: admit we read the
			 * number,but return a floating exception because we
			 * can't encode the number.  */
			*words &= ~(1 << (LITTLENUM_NUMBER_OF_BITS - 1));
		}
	}
	return return_value;
}

/* This is a utility function called from various tc-*.c files.  It is here in
 * order to reduce code duplication.
 * 
 * Turn a string at input_line_pointer into a floating point constant of type TYPE
 * (a character found in the FLT_CHARS macro),and store it as LITTLENUMS in
 * the bytes buffer LITP.  The number of chars emitted is stored in *SIZEP.
 * BIG_WORDIAN is TRUE if the littlenums should be emitted most significant
 * littlenum first.
 * 
 * An error message is returned,or a NULL pointer if everything went OK.  */
static const char *ieee_md_atof(int type,
						char         *litP,
						int          *sizeP,
						bool		big_wordian)
{
	LITTLENUM_TYPE	words[MAX_LITTLENUMS];
	LITTLENUM_TYPE *wordP;
	char           *t;
	int		prec = 0,	pad = 0;

	if (strchr(FLT_CHARS,type) != NULL) {
		switch (type) {
		case 'H': case 'h':
			prec = H_PRECISION;
			break;

		case 'B': case 'b':
			prec = B_PRECISION;
			break;

		case 'f': case 'F': case 's': case 'S':
			prec = F_PRECISION;
			break;

		case 'd': case 'D': case 'r': case 'R':
			prec = D_PRECISION;
			break;

		case 't': case 'T':
			prec = X_PRECISION;
			pad = X_PRECISION_PAD;
			type = 'x';	/* This is what atof_ieee()
					 * understands.  */
			break;

		case 'x': case 'X': case 'p': case 'P':
			prec = P_PRECISION;
			pad = P_PRECISION_PAD;
			break;

		default:
			break;
		}
	}
	/* The 'f' and 'd' types are always recognised,even if the target has
	 * not put them into the FLT_CHARS macro.  This is because the 'f' type
	 * can come from the .dc.s,.dcb.s,.float or .single pseudo-ops and
	 * the 'd' type from the .dc.d,.dbc.d or .double pseudo-ops.
	 * 
	 * The 'x' type is not implicitly recognised however,even though it can
	 * be generated by the .dc.x and .dbc.x pseudo-ops because not all
	 * targets can support floating point values that big.  ie the target
	 * has to explicitly allow them by putting them into FLT_CHARS.  */
	else
		if (type == 'f')
			prec = F_PRECISION;
		else
			if (type == 'd')
				prec = D_PRECISION;

	if (prec == 0) {
		*sizeP = 0;
		return ("Unrecognized or unsupported floating point constant");
	}
	gas_assert(prec <= MAX_LITTLENUMS);

	t = atof_ieee(input_line_pointer,type,words);
	if (t)
		input_line_pointer = t;

	*sizeP = (prec + pad) * sizeof(LITTLENUM_TYPE);

	if (big_wordian) {
		for (wordP = words; prec--;) {
			md_number_to_chars(litP,(valueT) (*wordP++),sizeof(LITTLENUM_TYPE));
			litP += sizeof(LITTLENUM_TYPE);
		}
	} else {
		for (wordP = words + prec; prec--;) {
			md_number_to_chars(litP,(valueT) (*--wordP),sizeof(LITTLENUM_TYPE));
			litP += sizeof(LITTLENUM_TYPE);
		}
	}

	memset(litP,0,pad * sizeof(LITTLENUM_TYPE));
	litP += pad * sizeof(LITTLENUM_TYPE);

	return NULL;
}
/* ============================================================**** hashtab.c */
/* An expandable hash tables datatype.  This package implements basic hash
 * table functionality.  It is possible to search for an entry,create an entry
 * and destroy an entry.
 * 
 * Elements in the table are generic pointers.
 * 
 * The size of the table is not fixed; if the occupancy of the table grows too
 * high the hash table will be expanded.
 * 
 * The abstract data implementation is based on generalized Algorithm D from
 * Knuth's book "The art of computer programming".  Hash table is expanded by
 * creation of new hash table and transferring elements from the old table to
 * the new table.  */

static unsigned int higher_prime_index(unsigned long);
static hashval_t htab_mod_1(hashval_t,hashval_t,hashval_t,int);
static hashval_t htab_mod(hashval_t,htab_t);
static hashval_t htab_mod_m2(hashval_t,htab_t);
static int	htab_expand(htab_t);
static void   **find_empty_slot_for_expand(htab_t,hashval_t);

/* Table of primes and multiplicative inverses. Note that these are not
 * minimally reduced inverses.  Unlike when generating code to divide by a
 * constant,we want to be able to use the same algorithm all the time.  All of
 * these inverses (are implied to) have bit 32 set.
 * 
 * For the record,here's the function that computed the table; it's a vastly
 * simplified version of the function of the same name from gcc.  */

struct prime_ent {
	hashval_t	prime;
	hashval_t	inv;
	hashval_t	inv_m2;	/* inverse of prime-2 */
	hashval_t	shift;
};

static struct prime_ent const prime_tab[] = {
	{7,0x24924925,0x9999999b,2},
	{13,0x3b13b13c,0x745d1747,3},
	{31,0x08421085,0x1a7b9612,4},
	{61,0x0c9714fc,0x15b1e5f8,5},
	{127,0x02040811,0x0624dd30,6},
	{251,0x05197f7e,0x073260a5,7},
	{509,0x01824366,0x02864fc8,8},
	{1021,0x00c0906d,0x014191f7,9},
	{2039,0x0121456f,0x0161e69e,10},
	{4093,0x00300902,0x00501908,11},
	{8191,0x00080041,0x00180241,12},
	{16381,0x000c0091,0x00140191,13},
	{32749,0x002605a5,0x002a06e6,14},
	{65521,0x000f00e2,0x00110122,15},
	{131071,0x00008001,0x00018003,16},
	{262139,0x00014002,0x0001c004,17},
	{524287,0x00002001,0x00006001,18},
	{1048573,0x00003001,0x00005001,19},
	{2097143,0x00004801,0x00005801,20},
	{4194301,0x00000c01,0x00001401,21},
	{8388593,0x00001e01,0x00002201,22},
	{16777213,0x00000301,0x00000501,23},
	{33554393,0x00001381,0x00001481,24},
	{67108859,0x00000141,0x000001c1,25},
	{134217689,0x000004e1,0x00000521,26},
	{268435399,0x00000391,0x000003b1,27},
	{536870909,0x00000019,0x00000029,28},
	{1073741789,0x0000008d,0x00000095,29},
	{2147483647,0x00000003,0x00000007,30},
	/* Avoid "decimal constant so large it is unsigned" for 4294967291.  */
	{0xfffffffb,0x00000006,0x00000008,31}
};

/* The following function returns an index into the above table of the nearest
 * prime number which is greater than N,and near a power of two.  */
static unsigned int higher_prime_index(unsigned long n)
{
	unsigned int	low = 0;
	unsigned int	high = sizeof(prime_tab) / sizeof(prime_tab[0]);

	while (low != high) {
		unsigned int	mid = low + (high - low) / 2;
		if (n > prime_tab[mid].prime)
			low = mid + 1;
		else
			high = mid;
	}

	/* If we've run out of primes,abort.  */
	if (n > prime_tab[low].prime) {
		fprintf(stderr,"Cannot find prime bigger than %lu\n",n);
		exit(1);
	}
	return low;
}

/* The parens around the function names in the next two definitions are
 * essential in order to prevent macro expansions of the name. The bodies,
 * however,are expanded as expected,so they are not recursive definitions.  */

/* Return the current size of given hash table.  */
#define htab_size(htab)  ((htab)->size)
static		size_t  (htab_size) (htab_t htab)
{
	return htab_size(htab);
}

/* Return the current number of elements in given hash table. */
#define htab_elements(htab)  ((htab)->n_elements - (htab)->n_deleted)
/* Return X % Y.  */
static inline	hashval_t htab_mod_1(hashval_t x,hashval_t y,
				hashval_t inv ATTRIBUTE_UNUSED,
		 		int		shift	ATTRIBUTE_UNUSED)
{
	/* The multiplicative inverses computed above are for 32-bit types,and
	 * requires that we be able to compute a highpart multiply.  */
	/* Otherwise just use the native division routines.  */
	return x % y;
}

/* Compute the primary hash for HASH given HTAB's current size.  */
static inline hashval_t htab_mod(hashval_t hash,htab_t htab)
{
	const struct prime_ent *p = &prime_tab[htab->size_prime_index];
	return htab_mod_1(hash,p->prime,p->inv,p->shift);
}

/* Compute the secondary hash for HASH given HTAB's current size.  */
static inline hashval_t htab_mod_m2(hashval_t hash,htab_t htab)
{
	const struct prime_ent *p = &prime_tab[htab->size_prime_index];
	return 1 + htab_mod_1(hash,p->prime - 2,p->inv_m2,p->shift);
}

/* This function creates table with length slightly longer than given source
 * length.  Created hash table is initiated as empty (all the hash table
 * entries are HTAB_EMPTY_ENTRY).  The function returns the created hash table,
 * or NULL if memory allocation fails.  */
static htab_t	htab_create_alloc(size_t size,htab_hash hash_f,htab_eq eq_f,
  		htab_del	del_f,htab_alloc alloc_f,htab_free free_f)
{
	return htab_create_typed_alloc(size,hash_f,eq_f,del_f,alloc_f,alloc_f,
				       free_f);
}

/* This function creates a hash table that uses two different allocators
 * alloc_tab_f and alloc_f to use for allocating the table itself
 * and its entries respectively.  This is useful when variables of different
 * types need to be allocated with different allocators.
 * 
 * The created hash table is slightly larger than @var{size} and it is initially
 * empty (all the hash table entries are HTAB_EMPTY_ENTRY). The function
 * returns the created hash table,or NULL if memory allocation fails.  */
static htab_t	htab_create_typed_alloc(size_t size,htab_hash hash_f,htab_eq eq_f,
		      		htab_del	del_f,htab_alloc alloc_tab_f,
			  		htab_alloc	alloc_f,htab_free free_f)
{
	htab_t		result;
	unsigned int	size_prime_index;

	size_prime_index = higher_prime_index(size);
	size = prime_tab[size_prime_index].prime;

	result = (htab_t) (*alloc_tab_f) (1,sizeof(struct htab));
	if (result == NULL)
		return NULL;
	result->entries = (void **)(*alloc_f) (size,sizeof(void *));
	if (result->entries == NULL) {
		if (free_f != NULL)
			(*free_f) (result);
		return NULL;
	}
	result->size = size;
	result->size_prime_index = size_prime_index;
	result->hash_f = hash_f;
	result->eq_f = eq_f;
	result->del_f = del_f;
	result->alloc_f = alloc_f;
	result->free_f = free_f;
	return result;
}


/* These functions exist solely for backward compatibility.  */
#undef htab_create
/* This function frees all memory allocated for given hash table. Naturally the
 * hash table must already exist.  */
static void	htab_delete(htab_t htab)
{
	size_t		size = htab_size(htab);
	void          **entries = htab->entries;
	int		i;

	if (htab->del_f)
		for (i = size - 1; i >= 0; i--)
			if (entries[i] != HTAB_EMPTY_ENTRY && entries[i] != HTAB_DELETED_ENTRY)
				(*htab->del_f) (entries[i]);

	if (htab->free_f != NULL) {
		(*htab->free_f) (entries);
		(*htab->free_f) (htab);
	} else
		if (htab->free_with_arg_f != NULL) {
			(*htab->free_with_arg_f) (htab->alloc_arg,entries);
			(*htab->free_with_arg_f) (htab->alloc_arg,htab);
		}
}

/* Similar to htab_find_slot,but without several unwanted side effects: - Does
 * not call htab->eq_f when it finds an existing entry. - Does not change the
 * count of elements/searches/collisions in the hash table. This function also
 * assumes there are no deleted entries in the table. HASH is the hash value
 * for the element to be inserted.  */
static void   **find_empty_slot_for_expand(htab_t htab,hashval_t hash)
{
	hashval_t	index = htab_mod(hash,htab);
	size_t		size = htab_size(htab);
	void          **slot = htab->entries + index;
	hashval_t	hash2;

	if (*slot == HTAB_EMPTY_ENTRY)
		return slot;
	else
		if (*slot == HTAB_DELETED_ENTRY)
			abort();

	hash2 = htab_mod_m2(hash,htab);
	for (;;) {
		index += hash2;
		if (index >= size)
			index -= size;

		slot = htab->entries + index;
		if (*slot == HTAB_EMPTY_ENTRY)
			return slot;
		else
			if (*slot == HTAB_DELETED_ENTRY)
				abort();
	}
}

/* The following function changes size of memory allocated for the entries and
 * repeatedly inserts the table elements.  The occupancy of the table after the
 * call will be about 50%.  Naturally the hash table must already exist.
 * Remember also that the place of the table entries is changed.  If memory
 * allocation failures are allowed,this function will return zero,indicating
 * that the table could not be expanded.  If all goes well,it will return a
 * non-zero value.  */
static int	htab_expand(htab_t htab)
{
	void          **oentries;
	void          **olimit;
	void          **p;
	void          **nentries;
	size_t		nsize  ,osize,elts;
	unsigned int	oindex,nindex;

	oentries = htab->entries;
	oindex = htab->size_prime_index;
	osize = htab->size;
	olimit = oentries + osize;
	elts = htab_elements(htab);

	/* Resize only when table after removal of unused elements is either
	 * too full or too empty. */
	if (elts * 2 > osize || (elts * 8 < osize && osize > 32)) {
		nindex = higher_prime_index(elts * 2);
		nsize = prime_tab[nindex].prime;
	} else {
		nindex = oindex;
		nsize = osize;
	}

	if (htab->alloc_with_arg_f != NULL)
		nentries = (void **)(*htab->alloc_with_arg_f) (htab->alloc_arg,nsize,
							       sizeof(void *));
	else
		nentries = (void **)(*htab->alloc_f) (nsize,sizeof(void *));
	if (nentries == NULL)
		return 0;
	htab->entries = nentries;
	htab->size = nsize;
	htab->size_prime_index = nindex;
	htab->n_elements -= htab->n_deleted;
	htab->n_deleted = 0;

	p = oentries;
	do {
		void           *x = *p;

		if (x != HTAB_EMPTY_ENTRY && x != HTAB_DELETED_ENTRY) {
			void          **q = find_empty_slot_for_expand(htab,(*htab->hash_f) (x));

			*q = x;
		}
		p++;
	}
	while (p < olimit);

	if (htab->free_f != NULL)
		(*htab->free_f) (oentries);
	else
		if (htab->free_with_arg_f != NULL)
			(*htab->free_with_arg_f) (htab->alloc_arg,oentries);
	return 1;
}

/* This function searches for a hash table entry equal to the given element.
 * It cannot be used to insert or delete an element.  */
static void    *htab_find_with_hash(htab_t htab,const void *element,hashval_t hash)
{
	hashval_t	index,hash2;
	size_t		size;
	void           *entry;

	htab->searches++;
	size = htab_size(htab);
	index = htab_mod(hash,htab);

	entry = htab->entries[index];
	if (entry == HTAB_EMPTY_ENTRY
	    || (entry != HTAB_DELETED_ENTRY && (*htab->eq_f) (entry,element)))
		return entry;

	hash2 = htab_mod_m2(hash,htab);
	for (;;) {
		htab->collisions++;
		index += hash2;
		if (index >= size)
			index -= size;

		entry = htab->entries[index];
		if (entry == HTAB_EMPTY_ENTRY
		    || (entry != HTAB_DELETED_ENTRY && (*htab->eq_f) (entry,element)))
			return entry;
	}
}

/* Like htab_find_slot_with_hash,but compute the hash value from the element. */
static void    *htab_find(htab_t htab,const void *element)
{
	return htab_find_with_hash(htab,element,(*htab->hash_f) (element));
}

/* This function searches for a hash table slot containing an entry equal to
 * the given element.  To delete an entry,call this with insert=NO_INSERT,
 * then call htab_clear_slot on the slot returned (possibly after doing some
 * checks).  To insert an entry,call this with insert=INSERT,then write the
 * value you want into the returned slot.  When inserting an entry,NULL may be
 * returned if memory allocation fails. */

static void   **htab_find_slot_with_hash(htab_t htab,const void *element,
	       		hashval_t	hash,enum insert_option insert)
{
	void          **first_deleted_slot;
	hashval_t	index,hash2;
	size_t		size;
	void           *entry;

	size = htab_size(htab);
	if (insert == INSERT && size * 3 <= htab->n_elements * 4) {
		if (htab_expand(htab) == 0)
			return NULL;
		size = htab_size(htab);
	}
	index = htab_mod(hash,htab);

	htab->searches++;
	first_deleted_slot = NULL;

	entry = htab->entries[index];
	if (entry == HTAB_EMPTY_ENTRY)
		goto empty_entry;
	else
		if (entry == HTAB_DELETED_ENTRY)
			first_deleted_slot = &htab->entries[index];
		else
			if ((*htab->eq_f) (entry,element))
				return &htab->entries[index];

	hash2 = htab_mod_m2(hash,htab);
	for (;;) {
		htab->collisions++;
		index += hash2;
		if (index >= size)
			index -= size;

		entry = htab->entries[index];
		if (entry == HTAB_EMPTY_ENTRY)
			goto empty_entry;
		else
			if (entry == HTAB_DELETED_ENTRY) {
				if (!first_deleted_slot)
					first_deleted_slot = &htab->entries[index];
			} else
				if ((*htab->eq_f) (entry,element))
					return &htab->entries[index];
	}

empty_entry:
	if (insert == NO_INSERT)
		return NULL;

	if (first_deleted_slot) {
		htab->n_deleted--;
		*first_deleted_slot = HTAB_EMPTY_ENTRY;
		return first_deleted_slot;
	}
	htab->n_elements++;
	return &htab->entries[index];
}

/* Like htab_find_slot_with_hash,but compute the hash value from the element.*/
static void   **htab_find_slot(htab_t htab,const void *element,enum insert_option insert)
{
	return htab_find_slot_with_hash(htab,element,(*htab->hash_f) (element),
					insert);
}

/* This function deletes an element with the given value from hash table (the
 * hash is computed from the element).  If there is no matching element in the
 * hash table,this function does nothing.  hashtab.c:714 */
static void	htab_remove_elt(htab_t htab,const void *element)
{
	htab_remove_elt_with_hash(htab,element,(*htab->hash_f) (element));
}


/* This function deletes an element with the given value from hash table.  If
 * there is no matching element in the hash table,this function does nothing.*/
static void	htab_remove_elt_with_hash(htab_t htab,const void *element,hashval_t hash)
{
	void          **slot;

	slot = htab_find_slot_with_hash(htab,element,hash,NO_INSERT);
	if (slot == NULL)
		return;

	if (htab->del_f)
		(*htab->del_f) (*slot);

	*slot = HTAB_DELETED_ENTRY;
	htab->n_deleted++;
}

/* Hash P as a null-terminated string.
 * 
 * Copied from gcc/hashtable.c.  Zack had the following to say with respect to
 * applicability,though note that unlike hashtable.c,this hash table
 * implementation re-hashes rather than chain buckets.
 * 
 * http://gcc.gnu.org/ml/gcc-patches/2001-08/msg01021.html From: Zack Weinberg
 * <zackw@panix.com> Date: Fri,17 Aug 2001 02:15:56 -0400
 * 
 * I got it by extracting all the identifiers from all the source code I had lying
 * around in mid-1999,and testing many recurrences of the form "H_n = H_{n-1} *
 * K + c_n * L + M" where K,L,M were either prime numbers or the appropriate
 * identity.  This was the best one. I don't remember exactly what constituted
 * "best",except I was looking at bucket-length distributions mostly.
 * 
 * So it should be very good at hashing identifiers,but might not be as good at
 * arbitrary strings.
 * 
 * I'll add that it thoroughly trounces the hash functions recommended for this
 * use at http://burtleburtle.net/bob/hash/index.html,both on speed and bucket
 * distribution.  I haven't tried it against the function they just started
 * using for Perl's hashes. */

static hashval_t htab_hash_string(const void *p)
{
	const unsigned char *str = (const unsigned char *)p;
	hashval_t	r = 0;
	unsigned char	c;

	while ((c = *str++) != 0)
		r = r * 67 + c - 113;

	return r;
}

/* =======================================================*** objalloc.c */
/* objalloc.c -- routines to allocate memory for objects */

/*
 * These routines allocate space for an object.  Freeing allocated space may or
 * may not free all more recently allocated space.
 * 
 * We handle large and small allocation requests differently.  If we don't have
 * enough space in the current block,and the allocation request is for more
 * than 512 bytes,we simply pass it through to malloc.
 */

/* This structure appears at the start of each chunk.  */

struct objalloc_chunk {
	/* Next chunk.  */
	struct objalloc_chunk *next;
	/*
	 * If this chunk contains large objects,this is the value of
	 * current_ptr when this chunk was allocated.  If this chunk contains
	 * small objects,this is NULL.
	 */
	char           *current_ptr;
};

/* The aligned size of objalloc_chunk.  */

#define CHUNK_HEADER_SIZE					\
  ((sizeof (struct objalloc_chunk) + OBJALLOC_ALIGN - 1)	\
   &~ (OBJALLOC_ALIGN - 1))

/*
 * We ask for this much memory each time we create a chunk which is to hold
 * small objects.
 */

#define CHUNK_SIZE (4096 - 32)

/* A request for this amount or more is just passed through to malloc.  */

#define BIG_REQUEST (512)
/* Create an objalloc structure.  */
static struct objalloc *objalloc_create(void)
{
	struct objalloc *ret;
	struct objalloc_chunk *chunk;

	ret = (struct objalloc *)malloc(sizeof *ret);
	if (ret == NULL)
		return NULL;

	ret->chunks = (void *)malloc(CHUNK_SIZE);
	if (ret->chunks == NULL) {
		free(ret);
		return NULL;
	}
	chunk = (struct objalloc_chunk *)ret->chunks;
	chunk->next = NULL;
	chunk->current_ptr = NULL;

	ret->current_ptr = (char *)chunk + CHUNK_HEADER_SIZE;
	ret->current_space = CHUNK_SIZE - CHUNK_HEADER_SIZE;

	return ret;
}

/* Allocate space from an objalloc structure.  */
static void    *_objalloc_alloc(struct objalloc *o,unsigned long original_len)
{
	unsigned long	len = original_len;

	/*
	 * We avoid confusion from zero sized objects by always allocating at
	 * least 1 byte.
	 */
	if (len == 0)
		len = 1;

	len = (len + OBJALLOC_ALIGN - 1) & ~(OBJALLOC_ALIGN - 1);

	/*
	 * Check for overflow in the alignment operation above and the malloc
	 * argument below.
	 */
	if (len + CHUNK_HEADER_SIZE < original_len)
		return NULL;

	if (len <= o->current_space) {
		o->current_ptr += len;
		o->current_space -= len;
		return (void *)(o->current_ptr - len);
	}
	if (len >= BIG_REQUEST) {
		char           *ret;
		struct objalloc_chunk *chunk;

		ret = (char *)malloc(CHUNK_HEADER_SIZE + len);
		if (ret == NULL)
			return NULL;

		chunk = (struct objalloc_chunk *)ret;
		chunk->next = (struct objalloc_chunk *)o->chunks;
		chunk->current_ptr = o->current_ptr;

		o->chunks = (void *)chunk;

		return (void *)(ret + CHUNK_HEADER_SIZE);
	} else {
		struct objalloc_chunk *chunk;

		chunk = (struct objalloc_chunk *)malloc(CHUNK_SIZE);
		if (chunk == NULL)
			return NULL;
		chunk->next = (struct objalloc_chunk *)o->chunks;
		chunk->current_ptr = NULL;

		o->current_ptr = (char *)chunk + CHUNK_HEADER_SIZE;
		o->current_space = CHUNK_SIZE - CHUNK_HEADER_SIZE;

		o->chunks = (void *)chunk;

		return objalloc_alloc(o,len);
	}
}
static void    *bfd_alloc(bfd * abfd,size_t size)
{
	void           *ret;
	unsigned long	ul_size = (unsigned long)size;

	if (size != ul_size
	/* Note - although objalloc_alloc takes an unsigned long as its
	 * argument,internally the size is treated as a signed long.  This can
	 * lead to problems where,for example,a request to allocate -1 bytes
	 * can result in just 1 byte being allocated,rather than ((unsigned
	 * long) -1) bytes.  Also memory checkers will often complain about
	 * attempts to allocate a negative amount of memory. So to stop these
	 * problems we fail if the size is negative.  */
	    || ((signed long)ul_size) < 0) {
		bfd_set_error(bfd_error_no_memory);
		return NULL;
	}
	ret = objalloc_alloc((struct objalloc *)abfd->memory,ul_size);
	if (ret == NULL)
		bfd_set_error(bfd_error_no_memory);
	else
		abfd->alloc_size += size;
	return ret;
}
static void    *bfd_zalloc(bfd * abfd,size_t size)
{
	void           *r = bfd_alloc(abfd,size);
	if (r)
		memset(r,0,size);
	return r;
}

/* Free an entire objalloc structure.  */
static void	objalloc_free(struct objalloc *o)
{
	struct objalloc_chunk *l;

	l = (struct objalloc_chunk *)o->chunks;
	while (l != NULL) {
		struct objalloc_chunk *next;

		next = l->next;
		free(l);
		l = next;
	}

	free(o);
}

/*
 * Free a block from an objalloc structure.  This also frees all more recently
 * allocated blocks.
 */

static void	objalloc_free_block(struct objalloc *o,void *block)
{
	struct objalloc_chunk *p,*small;
	char           *b = (char *)block;

	/*
	 * First set P to the chunk which contains the block we are freeing,
	 * and set Q to the last small object chunk we see before P.
	 */
	small = NULL;
	for (p = (struct objalloc_chunk *)o->chunks; p != NULL; p = p->next) {
		if (p->current_ptr == NULL) {
			if (b > (char *)p && b < (char *)p + CHUNK_SIZE)
				break;
			small = p;
		} else {
			if (b == (char *)p + CHUNK_HEADER_SIZE)
				break;
		}
	}

	/* If we can't find the chunk,the caller has made a mistake.  */
	if (p == NULL)
		abort();

	if (p->current_ptr == NULL) {
		struct objalloc_chunk *q;
		struct objalloc_chunk *first;

		/*
		 * The block is in a chunk containing small objects.  We can
		 * free every chunk through SMALL,because they have certainly
		 * been allocated more recently.  After SMALL,we will not see
		 * any chunks containing small objects; we can free any big
		 * chunk if the current_ptr is greater than or equal to B.  We
		 * can then reset the new current_ptr to B.
		 */

		first = NULL;
		q = (struct objalloc_chunk *)o->chunks;
		while (q != p) {
			struct objalloc_chunk *next;

			next = q->next;
			if (small != NULL) {
				if (small == q)
					small = NULL;
				free(q);
			} else
				if (q->current_ptr > b)
					free(q);
				else
					if (first == NULL)
						first = q;

			q = next;
		}

		if (first == NULL)
			first = p;
		o->chunks = (void *)first;

		/* Now start allocating from this small block again.  */
		o->current_ptr = b;
		o->current_space = ((char *)p + CHUNK_SIZE) - b;
	} else {
		struct objalloc_chunk *q;
		char           *current_ptr;

		/*
		 * This block is in a large chunk by itself.  We can free
		 * everything on the list up to and including this block.  We
		 * then start allocating from the next chunk containing small
		 * objects,setting current_ptr from the value stored with the
		 * large chunk we are freeing.
		 */

		current_ptr = p->current_ptr;
		p = p->next;

		q = (struct objalloc_chunk *)o->chunks;
		while (q != p) {
			struct objalloc_chunk *next;

			next = q->next;
			free(q);
			q = next;
		}

		o->chunks = (void *)p;

		while (p->current_ptr != NULL)
			p = p->next;

		o->current_ptr = current_ptr;
		o->current_space = ((char *)p + CHUNK_SIZE) - current_ptr;
	}
}
static int	filename_cmp(const char *s1,const char *s2)
{
#if !defined(HAVE_DOS_BASED_FILE_SYSTEM) \
    && !defined(HAVE_CASE_INSENSITIVE_FILE_SYSTEM)
	return strcmp(s1,s2);
#else
	for (;;) {
		int		c1 = *s1;
		int		c2 = *s2;

#if defined (HAVE_CASE_INSENSITIVE_FILE_SYSTEM)
		c1 = TOLOWER(c1);
		c2 = TOLOWER(c2);
#endif

#if defined (HAVE_DOS_BASED_FILE_SYSTEM)
		/*
		 * On DOS-based file systems,the '/' and the '\' are
		 * equivalent.
		 */
		if (c1 == '/')
			c1 = '\\';
		if (c2 == '/')
			c2 = '\\';
#endif

		if (c1 != c2)
			return (c1 - c2);

		if (c1 == '\0')
			return 0;

		s1++;
		s2++;
	}
#endif
}

/*
 * @deftypefn Extension int filename_ncmp (const char *@var{s1},const char
 * *@var{s2},size_t @var{n})
 * 
 * Return zero if the two file names @var{s1} and @var{s2} are equivalent in range
 * @var{n}. If not equivalent,the returned value is similar to what
 * @code{strncmp} would return.  In other words,it returns a negative value if
 * @var{s1} is less than @var{s2},or a positive value if @var{s2} is greater
 * than @var{s2}.
 * 
 * This function does not normalize file names.  As a result,this function will
 * treat filenames that are spelled differently as different even in the case
 * when the two filenames point to the same underlying file. However,it does
 * handle the fact that on DOS-like file systems,forward and backward slashes
 * are equal.
 * 
 * @end deftypefn
 * 
 */

static int	filename_ncmp(const char *s1,const char *s2,size_t n)
{
#if !defined(HAVE_DOS_BASED_FILE_SYSTEM) \
    && !defined(HAVE_CASE_INSENSITIVE_FILE_SYSTEM)
	return strncmp(s1,s2,n);
#else
	if (!n)
		return 0;
	for (; n > 0; --n) {
		int		c1 = *s1;
		int		c2 = *s2;

#if defined (HAVE_CASE_INSENSITIVE_FILE_SYSTEM)
		c1 = TOLOWER(c1);
		c2 = TOLOWER(c2);
#endif

#if defined (HAVE_DOS_BASED_FILE_SYSTEM)
		/*
		 * On DOS-based file systems,the '/' and the '\' are
		 * equivalent.
		 */
		if (c1 == '/')
			c1 = '\\';
		if (c2 == '/')
			c2 = '\\';
#endif

		if (c1 == '\0' || c1 != c2)
			return (c1 - c2);

		s1++;
		s2++;
	}
	return 0;
#endif
}
/*
 * Libiberty basename.  Like basename,but is not overridden by the system C
 * library.
 */

/*
 * @deftypefn Replacement {const char*} lbasename (const char *@var{name})
 * 
 * Given a pointer to a string containing a typical pathname
 * (@samp{/usr/src/cmd/ls/ls.c} for example),returns a pointer to the last
 * component of the pathname (@samp{ls.c} in this case).  The returned pointer
 * is guaranteed to lie within the original string.  This latter fact is not
 * true of many vendor C libraries,which return special strings or modify the
 * passed strings for particular input.
 * 
 * In particular,the empty string returns the same empty string,and a path
 * ending in @code{/} returns the empty string after it.
 * 
 * @end deftypefn
 * 
 */

static const char *unix_lbasename(const char *name)
{
	const char     *base;

	for (base = name; *name; name++)
		if (IS_DIR_SEPARATOR(*name))
			base = name + 1;

	return base;
}

static const char *lbasename(const char *name)
{
	return unix_lbasename(name);
}

/* The program name if set.  */
static const char *ProgramName = "";

static void	xmalloc_set_program_name(const char *s)
{
	ProgramName = s;
}

static void	xmalloc_failed(size_t size)
{
	fprintf(stderr,
		"\n%s%sout of memory allocating %lu bytes\n",
		ProgramName,*ProgramName ? ": " : "",
		(unsigned long)size);
	xexit(1);
}

static void    *xmalloc(size_t size)
{
	void           *newmem;

	if (size == 0)
		size = 1;
	newmem = malloc(size);
	if (!newmem)
		xmalloc_failed(size);

	return (newmem);
}

static void    *xcalloc(size_t nelem,size_t elsize)
{
	void           *newmem;

	if (nelem == 0 || elsize == 0)
		nelem = elsize = 1;

	newmem = calloc(nelem,elsize);
	if (!newmem)
		xmalloc_failed(nelem * elsize);

	return (newmem);
}

static void    *xrealloc(void *oldmem,size_t size)
{
	void           *newmem;

	if (size == 0)
		size = 1;
	if (!oldmem)
		newmem = malloc(size);
	else
		newmem = realloc(oldmem,size);
	if (!newmem)
		xmalloc_failed(size);

	return (newmem);
}
/* Concatenate variable number of strings. */
/*
 * Concatenate zero or more of strings and return the result in freshly
 * @code{xmalloc}ed memory.  The argument list is terminated by the first
 * @code{NULL} pointer encountered.  Pointers to empty strings are ignored.
 * 
 */
static inline unsigned long vconcat_length(const char *,va_list);
static inline unsigned long vconcat_length(const char *first,va_list args)
{
	unsigned long	length = 0;
	const char     *arg;

	for (arg = first; arg; arg = va_arg(args,const char *))
		length += strlen(arg);

	return length;
}

static inline char *vconcat_copy(char *dst,const char *first,va_list args)
{
	char           *end = dst;
	const char     *arg;

	for (arg = first; arg; arg = va_arg(args,const char *)) {
		unsigned long	length = strlen(arg);
		memcpy(end,arg,length);
		end += length;
	}
	*end = '\000';

	return dst;
}

static char    *concat(const char *first,...)
{
	char           *newstr;
	va_list		args;

	/* First compute the size of the result and get sufficient memory.  */
	va_start(args,first);
	newstr = XNEWVEC(char,vconcat_length(first,args) + 1);
	va_end(args);

	/* Now copy the individual pieces to the result string. */
	va_start(args,first);
	vconcat_copy(newstr,first,args);
	va_end(args);

	return newstr;
}

#ifndef R_OK
#define R_OK 4
#define W_OK 2
#define X_OK 1
#endif

#ifndef DIR_SEPARATOR
#define DIR_SEPARATOR '/'
#endif

#if defined (_WIN32) || defined (__MSDOS__) \
    || defined (__DJGPP__) || defined (__OS2__)
#define HAVE_DOS_BASED_FILE_SYSTEM
#define HAVE_HOST_EXECUTABLE_SUFFIX
#define HOST_EXECUTABLE_SUFFIX ".exe"
#ifndef DIR_SEPARATOR_2
#define DIR_SEPARATOR_2 '\\'
#endif
#define PATH_SEPARATOR ';'
#else
#define PATH_SEPARATOR ':'
#endif

#ifndef DIR_SEPARATOR_2
#undef IS_DIR_SEPARATOR
#define IS_DIR_SEPARATOR(ch) ((ch) == DIR_SEPARATOR)
#else
#define IS_DIR_SEPARATOR(ch) \
	(((ch) == DIR_SEPARATOR) || ((ch) == DIR_SEPARATOR_2))
#endif

#define DIR_UP ".."

/*
 * Virtually every UN*X system now in common use (except for pre-4.3-tahoe BSD
 * systems) now provides getcwd as called for by POSIX.  Allow for the few
 * exceptions to the general rule here.
 */
#if !defined(HAVE_GETCWD) && defined(HAVE_GETWD)
/* Prototype in case the system headers doesn't provide it. */
extern char    *getwd();
#define getcwd(buf,len) getwd(buf)
#endif

#ifdef MAXPATHLEN
#define GUESSPATHLEN (MAXPATHLEN + 1)
#else
#define GUESSPATHLEN 100
#endif

#if !(defined (VMS) || (defined(_WIN32) && !defined(__CYGWIN__)))

/*
 * Get the working directory.  Use the PWD environment variable if it's set
 * correctly,since this is faster and gives more uniform answers to the user.
 * Yield the working directory if successful; otherwise,yield 0 and set errno.
 */
static char    *getpwd(void)
{
	static char    *pwd;
	static int	failure_errno;

	char           *p = pwd;
	size_t		s;
	struct stat	dotstat,pwdstat;

	if (!p && !(errno = failure_errno)) {
		if (!((p = getenv("PWD")) != 0
		      && *p == '/'
		      && stat(p,&pwdstat) == 0
		      && stat(".",&dotstat) == 0
		      && dotstat.st_ino == pwdstat.st_ino
		      && dotstat.st_dev == pwdstat.st_dev))
			/*
			 * The shortcut didn't work.  Try the slow,``sure''
			 * way.
			 */
			for (s = GUESSPATHLEN; !getcwd(p = XNEWVEC(char,s),s); s *= 2) {
				int		e = errno;
				free(p);
#ifdef ERANGE
				if (e != ERANGE)
#endif
				{
					errno = failure_errno = e;
					p = 0;
					break;
				}
			}

		/*
		 * Cache the result.  This assumes that the program does not
		 * invoke chdir between calls to getpwd.
		 */
		pwd = p;
	}
	return p;
}
#else				/* VMS || _WIN32 && !__CYGWIN__ */
#ifndef MAXPATHLEN
#define MAXPATHLEN 255
#endif

char           *getpwd(void)
{
	static char    *pwd = 0;

	if (!pwd)
		pwd = getcwd(XNEWVEC(char,MAXPATHLEN + 1),MAXPATHLEN + 1);
	return pwd;
}
#endif				/* VMS || _WIN32 && !__CYGWIN__ */
/* Return time used so far,in microseconds. */

/* There are several ways to get elapsed execution time; unfortunately no
 * single way is available for all host systems,nor are there reliable ways to
 * find out which way is correct for a given host.  */

#ifdef _SC_CLK_TCK
#define GNU_HZ  sysconf(_SC_CLK_TCK)
#endif

/*
 * @deftypefn Replacement long get_run_time (void)
 * 
 * Returns the time used so far,in microseconds.  If possible,this is the time
 * used by this process,else it is the elapsed time since the process started.
 * 
 * @end deftypefn
 * 
 */

static long	get_run_time(void)
{
	/* Fall back on clock and hope it's correctly implemented. */
	const long	clocks_per_sec = CLOCKS_PER_SEC;
	if (clocks_per_sec <= 1000000)
		return clock() * (1000000 / clocks_per_sec);
	else
		return clock() / clocks_per_sec;
}
/*
 * xstrerror.c -- jacket routine for more robust strerror() usage. Fri Jun 16
 * 18:30:00 1995  Pat Rankin  <rankin@eql.caltech.edu> This code is in the
 * public domain.
 */
/* If strerror returns NULL,we'll format the number into a static buffer.  */

#define ERRSTR_FMT "undocumented error #%d"
static char	xstrerror_buf[sizeof ERRSTR_FMT + 20];

/* Like strerror,but result is never a null pointer.  */
static char    *xstrerror(int errnum)
{
	char           *errstr;
	errstr = strerror(errnum);

	/* If `errnum' is out of range,result might be NULL.  We'll fix that.  */
	if (!errstr) {
		sprintf(xstrerror_buf,ERRSTR_FMT,errnum);
		errstr = xstrerror_buf;
	}
	return errstr;
}
/*
 * xmemdup.c -- Duplicate a memory buffer,using xmalloc. This trivial function
 * is in the public domain. Jeff Garzik,September 1999.
 */

/*
 * @deftypefn Replacement void* xmemdup (void *@var{input},@ size_t
 * @var{copy_size},size_t @var{alloc_size})
 * 
 * Duplicates a region of memory without fail.  First,@var{alloc_size} bytes are
 * allocated,then @var{copy_size} bytes from @var{input} are copied into it,
 * and the new memory is returned.  If fewer bytes are copied than were
 * allocated,the remaining memory is zeroed.
 * 
 * @end deftypefn
 * 
 */

static void    *xmemdup(const void *input,size_t copy_size,size_t alloc_size)
{
	void           *output = xmalloc(alloc_size);
	if (alloc_size > copy_size)
		memset((char *)output + copy_size,0,alloc_size - copy_size);
	return (void *)memcpy(output,input,copy_size);
}
/*
 * xexit.c -- Run any exit handlers,then exit. Replacement void xexit (int
 * code)
 * 
 * Terminates the program.  If any functions have been registered with the
 * @code{xatexit} replacement function,they will be called first. Termination
 * is handled via the system's normal @code{exit} call.
 * 
 * @end deftypefn
 * 
 */

/*
 * This variable is set by xatexit if it is called.  This way,xmalloc doesn't
 * drag xatexit into the link.
 */
static void     (*_xexit_cleanup) (void);
static void	xexit(int code)
{
	if (_xexit_cleanup != NULL)
		(*_xexit_cleanup) ();
	exit(code);
}
/* Libiberty realpath.  Like realpath,but more consistent behavior. */
/*
 * Replacement {const char*} lrealpath (const char *name)
 * 
 * Given a pointer to a string containing a pathname,returns a canonical version
 * of the filename.  Symlinks will be resolved,and ``.'' and ``..'' components
 * will be simplified.  The returned value will be allocated using
 * @code{malloc},or @code{NULL} will be returned on a memory allocation error.
 * 
 */
/* On GNU libc systems the declaration is only visible with _GNU_SOURCE.  */
#if defined(HAVE_CANONICALIZE_FILE_NAME) \
    && defined(NEED_DECLARATION_CANONICALIZE_FILE_NAME)
extern char    *canonicalize_file_name(const char *);
#endif

static void	xatexit_cleanup(void);

/* Pointer to function run by xexit.  */
static void     (*_xexit_cleanup) (void);

#define	XATEXIT_SIZE 32
struct xatexit {
	struct xatexit *next;	/* next in list */
	int		ind;	/* next index in this table */
	void            (*fns[XATEXIT_SIZE]) (void);	/* the table itself */
};

/*
 * Allocate one struct statically to guarantee that we can register at least a
 * few handlers.
 */
static struct xatexit xatexit_first;
/* Points to head of LIFO stack.  */
static struct xatexit *xatexit_head = &xatexit_first;
/*
 * Register function FN to be run by xexit. Return 0 if successful,-1 if not.
 */
static int	xatexit(void (*fn) (void))
{
	register struct xatexit *p;

	/* Tell xexit to call xatexit_cleanup.  */
	if (!_xexit_cleanup)
		_xexit_cleanup = xatexit_cleanup;

	p = xatexit_head;
	if (p->ind >= XATEXIT_SIZE) {
		if ((p = (struct xatexit *)malloc(sizeof *p)) == NULL)
			return -1;
		p->ind = 0;
		p->next = xatexit_head;
		xatexit_head = p;
	}
	p->fns[p->ind++] = fn;
	return 0;
}

/* Call any cleanup functions.  */
static void	xatexit_cleanup(void)
{
	register struct xatexit *p;
	register int	n;

	for (p = xatexit_head; p; p = p->next)
		for (n = p->ind; --n >= 0;)
			(*p->fns[n]) ();
}
/*
 * Create and destroy argument vectors.  An argument vector is simply an array
 * of string pointers,terminated by a NULL pointer.
 */

/* Routines imported from standard C runtime libraries. */
#ifndef EOS
#define EOS '\0'
#endif

#define INITIAL_MAXARGC 8	/* Number of args + NULL in initial argv */
bool		set_section_size(asection * sec,size_t val)
{
	/*
	 * Once you've started writing to any section you cannot create or
	 * change the size of any others.
	 */

	if (sec->owner == NULL || sec->owner->output_has_begun) {
		bfd_set_error(bfd_error_invalid_operation);
		return false;
	}
	sec->size = val;
	return true;
}
static void	map_over_sections(void (*operation) (asection *,void *),void *user_storage){
	asection       *sect;
	for (sect = stdoutput->sections; sect != NULL; sect = sect->next)
		(*operation) (sect,user_storage);
}
static void    *bfd_realloc(void *ptr,size_t size)
{
	void           *ret;
	size_t		sz = (size_t) size;

	if (ptr == NULL)
		return malloc(size);

	if (size != sz
	/* This is to pacify memory checkers like valgrind.  */
	    || sz > SSIZE_MAX) {
		bfd_set_error(bfd_error_no_memory);
		return NULL;
	}
	/*
	 * The behaviour of realloc(0) is implementation defined,but for this
	 * function we always allocate memory.
	 */
	ret = realloc(ptr,sz ? sz : 1);

	if (ret == NULL)
		bfd_set_error(bfd_error_no_memory);

	return ret;
}
void           *bfd_realloc_or_free(void *ptr,size_t size)
{
	void           *ret;

	/*
	 * The behaviour of realloc(0) is implementation defined,but for this
	 * function we treat it is always freeing the memory.
	 */
	if (size == 0) {
		free(ptr);
		return NULL;
	}
	ret = bfd_realloc(ptr,size);
	if (ret == NULL)
		free(ptr);

	return ret;
}
/*
 * Get the index of an entity in a hash table,adding it if it is not already
 * present.
 */
static size_t	strtab_add(struct elf_strtab_hash *tab,
			 		const		char  *str,
			 		bool		copy)
{
	register struct elf_strtab_hash_entry *entry;

	/*
	 * We handle this specially,since we don't want to do refcounting on
	 * it.
	 */
	if (*str == '\0')
		return 0;

	gas_assert(tab->sec_size == 0);
	entry = (struct elf_strtab_hash_entry *)
		bfd_hash_lookup(&tab->table,str,true,copy);

	if (entry == NULL)
		return (size_t) - 1;

	entry->refcount++;
	if (entry->len == 0) {
		entry->len = strlen(str) + 1;
		/* 2G strings lose.  */
		gas_assert(entry->len > 0);
		if (tab->size == tab->alloced) {
			size_t		amt = sizeof(struct elf_strtab_hash_entry *);
			tab->alloced *= 2;
			tab->array = (struct elf_strtab_hash_entry **)
				bfd_realloc_or_free(tab->array,tab->alloced * amt);
			if (tab->array == NULL)
				return (size_t) - 1;
		}
		entry->u.index = tab->size++;
		tab->array[entry->u.index] = entry;
	}
	return entry->u.index;
}
/*
 * Allocate and initialize a section-header for a new reloc section,containing
 * relocations against ASECT.  It is stored in RELDATA.  If USE_RELA_P is TRUE,
 * we use RELA relocations; otherwise,we use REL relocations.
 */
static bool	_bfd_elf_init_reloc_shdr(bfd * abfd ATTRIBUTE_UNUSED,
		       		struct	bfd_elf_section_reloc_data *reldata,
				   		const		char  *sec_name,
				     		bool		use_rela_p,
				   		bool		delay_st_name_p)
{
	Elf_Internal_Shdr *rel_hdr;
	gas_assert(reldata->hdr == NULL);
	rel_hdr = zmalloc(sizeof(*rel_hdr));
	if (rel_hdr == NULL)
		return false;
	reldata->hdr = rel_hdr;

	if (delay_st_name_p)
		rel_hdr->sh_name = (unsigned int)-1;
	char           *name = zmalloc(sizeof(".rela") + strlen(sec_name));
	sprintf(name,".rela%s",sec_name);
	rel_hdr->sh_name = (unsigned int)strtab_add(elf_shstrtab(stdoutput),name,1);
	if (rel_hdr->sh_name == (unsigned int)-1)
		return false;
	//if (!_bfd_elf_set_reloc_sh_name(abfd,rel_hdr,sec_name,use_rela_p))
		rel_hdr->sh_type = use_rela_p ? SHT_RELA : SHT_REL;
	rel_hdr->sh_entsize = sizeof(Elf64_External_Rela);
	rel_hdr->sh_addralign = 8;
	rel_hdr->sh_flags = 0;
	rel_hdr->sh_addr = 0;
	rel_hdr->sh_size = 0;
	rel_hdr->sh_offset = 0;

	return true;
}
/* Set up an ELF internal section header for a section.  */
static void	elf_fake_sections(asection * asect,void *fsarg)
{
	bfd            *abfd = stdoutput;
	struct fake_section_arg *arg = (struct fake_section_arg *)fsarg;
	//const struct elf_backend_data *bed = get_elf_backend_data(abfd);
	struct bfd_elf_section_data *esd = elf_section_data(asect);
	Elf_Internal_Shdr *this_hdr;
	unsigned int	sh_type;
	const char     *Name = asect->name;
	bool		delay_st_name_p = false;
	bfd_vma		Mask;

	if (arg->failed) {
		/*
		 * We already failed; just get out of the map_over_sections
		 * loop.
		 */
		return;
	}
	this_hdr = &esd->this_hdr;

	/* ld: compress DWARF debug sections with names: .debug_*.  */
	if (arg->link_info
	    && (abfd->flags & BFD_COMPRESS) != 0
	    && (asect->flags & SEC_DEBUGGING) != 0
	    && Name[1] == 'd'
	    && Name[6] == '_') {
		/*
		 * If this section will be compressed,delay adding section
		 * name to section name section after it is compressed in
		 * assign_file_positions_for_non_load.
		 */
		delay_st_name_p = true;
	}
	if (delay_st_name_p)
		this_hdr->sh_name = (unsigned int)-1;
	else {
		this_hdr->sh_name = (unsigned int)strtab_add(elf_shstrtab(abfd),
							     Name,true);
		if (this_hdr->sh_name == (unsigned int)-1) {
			arg->failed = true;
			return;
		}
	}

	/* Don't clear sh_flags. Assembler may set additional bits.  */

	if ((asect->flags & SEC_ALLOC) != 0 || asect->user_set_vma)
		this_hdr->sh_addr = asect->vma;
	else
		this_hdr->sh_addr = 0;

	this_hdr->sh_offset = 0;
	this_hdr->sh_size = asect->size;
	this_hdr->sh_link = 0;
	/* PR 17512: file: 0eb809fe,8b0535ee.  */
	if (asect->alignment_power >= (sizeof(bfd_vma) * 8) - 1) {
		error_handler(("%pB: error: alignment power %d of section `%pA' is too big"),
			      abfd,asect->alignment_power,asect);
		arg->failed = true;
		return;
	}
	/*
	 * Set sh_addralign to the highest power of two given by alignment
	 * consistent with the section VMA.  Linker scripts can force VMA.
	 */
	Mask = ((bfd_vma) 1 << asect->alignment_power)|this_hdr->sh_addr;
	this_hdr->sh_addralign = Mask & -Mask;
	/*
	 * The sh_entsize and sh_info fields may have been set already by
	 * copy_private_section_data.
	 */
	this_hdr->bfd_section = asect;
	this_hdr->contents = NULL;

	/* If the section type is unspecified,we set it based on asect->flags.  */
	if (asect->type != 0)
		sh_type = asect->type;
	else
		if ((asect->flags & SEC_GROUP) != 0)
			sh_type = SHT_GROUP;
		else
			sh_type = elf_get_default_section_type(asect->flags);

	if (this_hdr->sh_type == SHT_NULL)
		this_hdr->sh_type = sh_type;
	else
		if (this_hdr->sh_type == SHT_NOBITS && sh_type == SHT_PROGBITS
		    && (asect->flags & SEC_ALLOC) != 0) {
			/*
			 * Warn if we are changing a NOBITS section to
			 * PROGBITS,but allow the link to proceed.  This can
			 * happen when users link non-bss input sections to bss
			 * output sections,or emit data to a bss output
			 * section via a linker script.
			 */
			error_handler(("warning: section `%pA' type changed to PROGBITS"),asect);
			this_hdr->sh_type = sh_type;
		}
	switch (this_hdr->sh_type) {
	default:
		break;

	case SHT_STRTAB:
	case SHT_NOTE:
	case SHT_NOBITS:
	case SHT_PROGBITS:
		break;

	case SHT_INIT_ARRAY:
	case SHT_FINI_ARRAY:
	case SHT_PREINIT_ARRAY:
		this_hdr->sh_entsize = 64 / 8;
		//bed->s->arch_size / 8;
		break;

	case SHT_HASH:
		this_hdr->sh_entsize = 4;
		//bed->s->sizeof_hash_entry;
		break;

	case SHT_DYNSYM:
		this_hdr->sh_entsize = sizeof(Elf64_External_Sym);
		//bed->s->sizeof_sym;
		break;

	case SHT_RELA:
		//if (get_elf_backend_data(abfd)->may_use_rela_p)
			this_hdr->sh_entsize = sizeof(Elf64_External_Rela);
		//bed->s->sizeof_rela;
		break;

	case SHT_REL:
		//if (get_elf_backend_data(abfd)->may_use_rel_p)
			//this_hdr->sh_entsize = bed->s->sizeof_rel;
		break;

	case SHT_GNU_versym:
		this_hdr->sh_entsize = sizeof(Elf_External_Versym);
		break;

	case SHT_GNU_verdef:
		this_hdr->sh_entsize = 0;
		/*
		 * objcopy or strip will copy over sh_info,but may not set
		 * cverdefs.  The linker will set cverdefs,but sh_info will be
		 * zero.
		 */
		if (this_hdr->sh_info == 0)
			this_hdr->sh_info = elf_tdata(abfd)->cverdefs;
		else
			gas_assert(elf_tdata(abfd)->cverdefs == 0
			   || this_hdr->sh_info == elf_tdata(abfd)->cverdefs);
		break;

	case SHT_GNU_verneed:
		this_hdr->sh_entsize = 0;
		/* objcopy or strip will copy over sh_info,but may not set
		 * cverrefs.  The linker will set cverrefs,but sh_info will be
		 * zero.  */
		if (this_hdr->sh_info == 0)
			this_hdr->sh_info = elf_tdata(abfd)->cverrefs;
		else
			gas_assert(elf_tdata(abfd)->cverrefs == 0
			   || this_hdr->sh_info == elf_tdata(abfd)->cverrefs);
		break;

	case SHT_GROUP:
		this_hdr->sh_entsize = GRP_ENTRY_SIZE;
		break;

	case SHT_GNU_HASH:
		this_hdr->sh_entsize = 0;
		break;
	}

	if ((asect->flags & SEC_ALLOC) != 0)
		this_hdr->sh_flags |= SHF_ALLOC;
	if ((asect->flags & SEC_READONLY) == 0)
		this_hdr->sh_flags |= SHF_WRITE;
	if ((asect->flags & SEC_CODE) != 0)
		this_hdr->sh_flags |= SHF_EXECINSTR;
	if ((asect->flags & SEC_MERGE) != 0) {
		this_hdr->sh_flags |= SHF_MERGE;
		this_hdr->sh_entsize = asect->entsize;
	}
	if ((asect->flags & SEC_STRINGS) != 0)
		this_hdr->sh_flags |= SHF_STRINGS;
	if ((asect->flags & SEC_GROUP) == 0 && elf_group_name(asect) != NULL)
		this_hdr->sh_flags |= SHF_GROUP;
	/* If the section has relocs,set up a section header for the
	 * SHT_REL[A] section.  If two relocation sections are required for
	 * this section,it is up to the processor-specific back-end to create
	 * the other.  */
	if ((asect->flags & SEC_RELOC) != 0) {
		/* * When doing a relocatable link,create both REL and RELA
		 * sections if needed.  */
		if (!_bfd_elf_init_reloc_shdr(abfd,
					      (asect->use_rela_p
					       ? &esd->rela : &esd->rel),
					      ProgramName,
					      asect->use_rela_p,
					      delay_st_name_p)) {
			arg->failed = true;
			return;
		}
	}
	/* Check for processor-specific section types.  */
	sh_type = this_hdr->sh_type;
	if (sh_type == SHT_NOBITS && asect->size != 0) {
		/* Don't change the header type from NOBITS if we are being
		 * called for objcopy --only-keep-debug.  */
		this_hdr->sh_type = sh_type;
	}
}
/* Don't output section symbols for sections that are not going to be output,
 * that are duplicates or there is no BFD section.  */
static bool	ignore_section_sym(bfd * abfd,asymbol * sym)
{
	elf_symbol_type *type_ptr;

	if (sym == NULL)
		return false;
	if ((sym->flags & BSF_SECTION_SYM) == 0)
		return false;
	/* Ignore the section symbol if it isn't used.  */
	if ((sym->flags & BSF_SECTION_SYM_USED) == 0)
		return true;
	if (sym->section == NULL)
		return true;

	type_ptr = (elf_symbol_type *) (sym);
	return ((type_ptr != NULL && type_ptr->internal_elf_sym.st_shndx != 0
		 && bfd_is_abs_section(sym->section))
		|| !(sym->section->owner == abfd || (sym->section->output_section != NULL
				&& sym->section->output_section->owner == abfd
					  && sym->section->output_offset == 0)
		     || bfd_is_abs_section(sym->section)));
}
static bool	sym_is_global(asymbol * sym)
{
	/* If the backend has a special mapping,use it.  */
	return ((sym->flags & (BSF_GLOBAL|BSF_WEAK|BSF_GNU_UNIQUE)) != 0
		|| bfd_is_und_section(bfd_asymbol_section(sym))
		|| bfd_is_com_section(bfd_asymbol_section(sym)));
}
#define MAP_ONESYMTAB (SHN_HIOS + 1)
#define MAP_DYNSYMTAB (SHN_HIOS + 2)
#define MAP_STRTAB    (SHN_HIOS + 3)
#define MAP_SHSTRTAB  (SHN_HIOS + 4)
#define MAP_SYM_SHNDX (SHN_HIOS + 5)
/* Map symbol from it's internal number to the external number,moving all
 * local symbols to be at the head of the list.  */
static bool	elf_map_symbols(bfd * abfd,unsigned int *pnum_locals)
{
	unsigned int	symcount = bfd_get_symcount(abfd);
	asymbol       **syms = bfd_get_outsymbols(abfd);
	asymbol       **sect_syms;
	unsigned int	num_locals = 0;
	unsigned int	num_globals = 0;
	unsigned int	num_locals2 = 0;
	unsigned int	num_globals2 = 0;
	unsigned int	max_index = 0;
	unsigned int	idx;
	asection       *asect;
	asymbol       **new_syms;
	size_t		amt;

	for (asect = abfd->sections; asect; asect = asect->next) {
		if (max_index < asect->index)
			max_index = asect->index;
	}

	max_index++;
	amt = max_index * sizeof(asymbol *);
	sect_syms = (asymbol **) zmalloc(amt);
	if (sect_syms == NULL)
		return false;
	elf_section_syms(abfd) = sect_syms;
	elf_num_section_syms(abfd) = max_index;

	/* Init sect_syms entries for any section symbols we have already
	 * decided to output. */
	for (idx = 0; idx < symcount; idx++) {
		asymbol        *sym = syms[idx];

		if ((sym->flags & BSF_SECTION_SYM) != 0
		    && sym->value == 0
		    && sym->section != absolute_section) {
			asection       *Sec = sym->section;
			sect_syms[Sec->index] = syms[idx];
		}
	}

	/* Classify all of the symbols.  */
	for (idx = 0; idx < symcount; idx++) {
		if (sym_is_global(syms[idx]))
			num_globals++;
		else
			if (!ignore_section_sym(abfd,syms[idx]))
				num_locals++;
	}

	/* We will be adding a section symbol for each normal BFD section.
	 * Most sections will already have a section symbol in outsymbols,but
	 * eg. SHT_GROUP sections will not,and we need the section symbol
	 * mapped at least in that case.  */
	for (asect = abfd->sections; asect; asect = asect->next) {
		asymbol        *sym = asect->symbol;
		/* Don't include ignored section symbols.  */
		if (!ignore_section_sym(abfd,sym)
		    && sect_syms[asect->index] == NULL) {
			if (!sym_is_global(asect->symbol))
				num_locals++;
			else
				num_globals++;
		}
	}

	/* Now sort the symbols so the local symbols are first.  */
	amt = (num_locals + num_globals) * sizeof(asymbol *);
	new_syms = (asymbol **) bfd_alloc(abfd,amt);
	if (new_syms == NULL)
		return false;

	for (idx = 0; idx < symcount; idx++) {
		asymbol        *sym = syms[idx];
		unsigned int	i;

		if (sym_is_global(sym))
			i = num_locals + num_globals2++;
		/* Don't include ignored section symbols.  */
		else
			if (!ignore_section_sym(abfd,sym))
				i = num_locals2++;
			else
				continue;
		new_syms[i] = sym;
		sym->udata.i = i + 1;
	}
	for (asect = abfd->sections; asect; asect = asect->next) {
		asymbol        *sym = asect->symbol;
		if (!ignore_section_sym(abfd,sym)
		    && sect_syms[asect->index] == NULL) {
			unsigned int	i;

			sect_syms[asect->index] = sym;
			if (!sym_is_global(sym))
				i = num_locals2++;
			else
				i = num_locals + num_globals2++;
			new_syms[i] = sym;
			sym->udata.i = i + 1;
		}
	}

	bfd_set_symtab(abfd,new_syms,num_locals + num_globals);

	*pnum_locals = num_locals;
	return true;
}
/* Given a section,search the header to find them.  */
static unsigned	elf_section_from_bfd_section(bfd * abfd ATTRIBUTE_UNUSED,struct bfd_section *asect)
{
	unsigned int	sec_index;

	if (elf_section_data(asect) != NULL
	    && elf_section_data(asect)->this_idx != 0)
		return elf_section_data(asect)->this_idx;

	if (bfd_is_abs_section(asect))
		sec_index = SHN_ABS;
	else
		if (bfd_is_com_section(asect))
			sec_index = SHN_COMMON;
		else
			if (bfd_is_und_section(asect))
				sec_index = SHN_UNDEF;
			else
				sec_index = SHN_BAD;

	if (sec_index == SHN_BAD)
		bfd_set_error(bfd_error_nonrepresentable_section);

	return sec_index;
}
/* Given a section,search the header to find them.  */
static unsigned int _bfd_elf_section_from_bfd_section(bfd * abfd ATTRIBUTE_UNUSED,
					 		struct	bfd_section *asect)
{
	unsigned int	sec_index;

	if (elf_section_data(asect) != NULL
	    && elf_section_data(asect)->this_idx != 0)
		return elf_section_data(asect)->this_idx;

	if (bfd_is_abs_section(asect))
		sec_index = SHN_ABS;
	else
		if (bfd_is_com_section(asect))
			sec_index = SHN_COMMON;
		else
			if (bfd_is_und_section(asect))
				sec_index = SHN_UNDEF;
			else
				sec_index = SHN_BAD;

	if (sec_index == SHN_BAD)
		bfd_set_error(bfd_error_nonrepresentable_section);

	return sec_index;
}
/* Compare two elf_strtab_hash_entry structures.  Called via qsort. Won't ever
 * return zero as all entries differ,so there is no issue with qsort stability
 * here.  */
static int	strrevcmp(const void *a,const void *b)
{
	struct elf_strtab_hash_entry *A = *(struct elf_strtab_hash_entry **)a;
	struct elf_strtab_hash_entry *B = *(struct elf_strtab_hash_entry **)b;
	unsigned int	lenA = A->len;
	unsigned int	lenB = B->len;
	const unsigned char *s = (const unsigned char *)A->root.string + lenA - 1;
	const unsigned char *t = (const unsigned char *)B->root.string + lenB - 1;
	int		l = lenA < lenB ? lenA : lenB;

	while (l) {
		if (*s != *t)
			return (int)*s - (int)*t;
		s--;
		t--;
		l--;
	}
	return lenA - lenB;
}
static int	is_suffix(const struct elf_strtab_hash_entry *A,
		  		const		struct	elf_strtab_hash_entry *B)
{
	if (A->len <= B->len)
		/*
		 * B cannot be a suffix of A unless A is equal to B,which is
		 * guaranteed not to be equal by the hash table.
		 */
		return 0;

	return memcmp(A->root.string + (A->len - B->len),
		      B->root.string,B->len - 1) == 0;
}
/* This function assigns final string table offsets for used strings,merging
 * strings matching suffixes of longer strings if possible.  */
static void	_bfd_elf_strtab_finalize(struct elf_strtab_hash *tab)
{
	struct elf_strtab_hash_entry **array,**a,*e;
	size_t		amt    ,sec_size;
	size_t		size   ,i;

	/* Sort the strings by suffix and length.  */
	amt = tab->size;
	amt *= sizeof(struct elf_strtab_hash_entry *);
	array = (struct elf_strtab_hash_entry **)malloc(amt);
	if (array == NULL)
		goto alloc_failure;

	for (i = 1,a = array; i < tab->size; ++i) {
		e = tab->array[i];
		if (e->refcount) {
			*a++ = e;
			/*
			 * Adjust the length to not include the zero
			 * terminator.
			 */
			e->len -= 1;
		} else
			e->len = 0;
	}

	size = a - array;
	if (size != 0) {
		qsort(array,size,sizeof(struct elf_strtab_hash_entry *),strrevcmp);

		/*
		 * Loop over the sorted array and merge suffixes.  Start from
		 * the end because we want eg.
		 * 
		 * s1 -> "d" s2 -> "bcd" s3 -> "abcd"
		 * 
		 * to end up as
		 * 
		 * s3 -> "abcd" s2 _____^ s1 _______^
		 * 
		 * ie. we don't want s1 pointing into the old s2.
		 */
		e = *--a;
		e->len += 1;
		while (--a >= array) {
			struct elf_strtab_hash_entry *cmp = *a;

			cmp->len += 1;
			if (is_suffix(e,cmp)) {
				cmp->u.suffix = e;
				cmp->len = -cmp->len;
			} else
				e = cmp;
		}
	}
alloc_failure:
	free(array);

	/* Assign positions to the strings we want to keep.  */
	sec_size = 1;
	for (i = 1; i < tab->size; ++i) {
		e = tab->array[i];
		if (e->refcount && e->len > 0) {
			e->u.index = sec_size;
			sec_size += e->len;
		}
	}

	tab->sec_size = sec_size;

	/* Adjust the rest.  */
	for (i = 1; i < tab->size; ++i) {
		e = tab->array[i];
		if (e->refcount && e->len < 0)
			e->u.index = e->u.suffix->u.index + (e->u.suffix->len + e->len);
	}
}
static size_t	_bfd_elf_strtab_offset(struct elf_strtab_hash *tab,
				     		size_t	idx)
{
	struct elf_strtab_hash_entry *entry;

	if (idx == 0)
		return 0;
	gas_assert(idx < tab->size);
	gas_assert(tab->sec_size);
	entry = tab->array[idx];
	gas_assert(entry->refcount > 0);
	entry->refcount--;
	return tab->array[idx]->u.index;
}
/* Swap out the symbols.  */
static bool	swap_out_syms(bfd * abfd,struct elf_strtab_hash **sttp,
     		int		relocatable_p,void *info ATTRIBUTE_UNUSED)
{
	unsigned int	symcount;
	asymbol       **syms;
	struct elf_strtab_hash *stt;
	Elf_Internal_Shdr *symtab_hdr;
	Elf_Internal_Shdr *symtab_shndx_hdr;
	Elf_Internal_Shdr *symstrtab_hdr;
	struct elf_sym_strtab *symstrtab;
	bfd_byte       *outbound_syms;
	bfd_byte       *outbound_shndx;
	unsigned long	outbound_syms_index;
	unsigned int	idx;
	unsigned int	num_locals;
	size_t		amt;
	bool		name_local_sections;
	Elf64_External_Sym *dst;

	if (!elf_map_symbols(abfd,&num_locals))
		return false;

	/* Dump out the symtabs.  */
	stt = _bfd_elf_strtab_init();
	if (stt == NULL)
		return false;

	//bed = get_elf_backend_data(abfd);
	symcount = abfd->symcount;
	symtab_hdr = &elf_tdata(abfd)->symtab_hdr;
	symtab_hdr->sh_type = SHT_SYMTAB;
	symtab_hdr->sh_entsize = sizeof(Elf64_External_Sym);
	symtab_hdr->sh_size = symtab_hdr->sh_entsize * (symcount + 1);
	symtab_hdr->sh_info = num_locals + 1;
	symtab_hdr->sh_addralign = (bfd_vma) 1 << 3;

	symstrtab_hdr = &elf_tdata(abfd)->strtab_hdr;
	symstrtab_hdr->sh_type = SHT_STRTAB;

	/* Allocate buffer to swap out the .strtab section.  */
	if (_bfd_mul_overflow(symcount + 1,sizeof(*symstrtab),&amt)
	    || (symstrtab = (struct elf_sym_strtab *)malloc(amt)) == NULL) {
		bfd_set_error(bfd_error_no_memory);
		_bfd_elf_strtab_free(stt);
		return false;
	}
	if (_bfd_mul_overflow(symcount + 1,sizeof(*symstrtab),&amt)
	    || (outbound_syms = (bfd_byte *) bfd_alloc(abfd,amt)) == NULL) {
error_no_mem:
		bfd_set_error(bfd_error_no_memory);
error_return:
		free(symstrtab);
		_bfd_elf_strtab_free(stt);
		return false;
	}
	symtab_hdr->contents = outbound_syms;
	outbound_syms_index = 0;

	outbound_shndx = NULL;

	if (elf_symtab_shndx_list(abfd)) {
		symtab_shndx_hdr = &elf_symtab_shndx_list(abfd)->hdr;
		if (symtab_shndx_hdr->sh_name != 0) {
			if (_bfd_mul_overflow(symcount + 1,
					sizeof(Elf_External_Sym_Shndx),&amt))
				goto error_no_mem;
			outbound_shndx = (bfd_byte *) zmalloc(amt);
			if (outbound_shndx == NULL)
				goto error_return;

			symtab_shndx_hdr->contents = outbound_shndx;
			symtab_shndx_hdr->sh_type = SHT_SYMTAB_SHNDX;
			symtab_shndx_hdr->sh_size = amt;
			symtab_shndx_hdr->sh_addralign = sizeof(Elf_External_Sym_Shndx);
			symtab_shndx_hdr->sh_entsize = sizeof(Elf_External_Sym_Shndx);
		}
		/* FIXME: What about any other headers in the list ?  */
	}
	/* Now generate the data (for "contents").  */
	{
		/* Fill in zeroth symbol and swap it out.  */
		Elf_Internal_Sym sym;
		sym.st_name = 0;
		sym.st_value = 0;
		sym.st_size = 0;
		sym.st_info = 0;
		sym.st_other = 0;
		sym.st_shndx = SHN_UNDEF;
		sym.st_target_internal = 0;
		symstrtab[0].sym = sym;
		symstrtab[0].dest_index = outbound_syms_index;
		//symstrtab[0].destshndx_index = outbound_shndx_index;
		outbound_syms_index++;
	}

	name_local_sections = 0;
#if 0
	= (bed->elf_backend_name_local_section_symbols
	   && bed->elf_backend_name_local_section_symbols(abfd));
#endif

	syms = abfd->outsymbols;
	for (idx = 0; idx < symcount;) {
		Elf_Internal_Sym sym;
		bfd_vma		value = syms[idx]->value;
		elf_symbol_type *type_ptr;
		flagword	flags = syms[idx]->flags;
		int		type;

		if (!name_local_sections
		    && (flags & (BSF_SECTION_SYM|BSF_GLOBAL)) == BSF_SECTION_SYM) {
			/* Local section symbols have no name.  */
			sym.st_name = (unsigned long)-1;
		} else {
			/*
			 * Call _bfd_elf_strtab_offset after
			 * _bfd_elf_strtab_finalize to get the final offset for
			 * st_name.
			 */
			sym.st_name
				= (unsigned long)strtab_add(stt,syms[idx]->name,
							    false);
			if (sym.st_name == (unsigned long)-1)
				goto error_return;
		}

		type_ptr = (elf_symbol_type *) syms[idx];
		//elf_symbol_from(syms[idx]);

		if ((flags & BSF_SECTION_SYM) == 0
		    && bfd_is_com_section(syms[idx]->section)) {
			/*
			 * ELF common symbols put the alignment into the
			 * `value' field,and the size into the `size' field.
			 * This is backwards from how BFD handles it,so
			 * reverse it here.
			 */
			sym.st_size = value;
			if (type_ptr == NULL
			    || type_ptr->internal_elf_sym.st_value == 0)
				sym.st_value = value >= 16 ? 16 : (1 << bfd_log2(value));
			else
				sym.st_value = type_ptr->internal_elf_sym.st_value;
			sym.st_shndx = _bfd_elf_section_from_bfd_section
				(abfd,syms[idx]->section);
		} else {
			asection       *sec = syms[idx]->section;
			unsigned int	shndx;

			if (sec->output_section) {
				value += sec->output_offset;
				sec = sec->output_section;
			}
			/* Don't add in the section vma for relocatable output.  */
			if (!relocatable_p)
				value += sec->vma;
			sym.st_value = value;
			sym.st_size = type_ptr ? type_ptr->internal_elf_sym.st_size : 0;

			if (bfd_is_abs_section(sec)
			    && type_ptr != NULL
			    && type_ptr->internal_elf_sym.st_shndx != 0) {
				/*
				 * This symbol is in a real ELF section which
				 * we did not create as a BFD section.  Undo
				 * the mapping done by
				 * copy_private_symbol_data.
				 */
				shndx = type_ptr->internal_elf_sym.st_shndx;
				switch (shndx) {
				case MAP_ONESYMTAB:
					shndx = elf_onesymtab(abfd);
					break;
				case MAP_DYNSYMTAB:
					shndx = elf_dynsymtab(abfd);
					break;
				case MAP_STRTAB:
					shndx = elf_strtab_sec(abfd);
					break;
				case MAP_SHSTRTAB:
					shndx = elf_shstrtab_sec(abfd);
					break;
				case MAP_SYM_SHNDX:
					if (elf_symtab_shndx_list(abfd))
						shndx = elf_symtab_shndx_list(abfd)->ndx;
					break;
				case SHN_COMMON:
				case SHN_ABS:
					shndx = SHN_ABS;
					break;
				default:
					if (shndx >= SHN_LOPROC && shndx <= SHN_HIOS) {
						//if (bed->symbol_section_index)
							//shndx = bed->symbol_section_index(abfd,type_ptr);
						/*
						 * Otherwise just leave the
						 * index alone.
						 */
					} else {
						if (shndx > SHN_HIOS && shndx < SHN_HIRESERVE)
							error_handler(("%pB: \
Unable to handle section index %x in ELF symbol.  Using ABS instead."),
								 abfd,shndx);
						shndx = SHN_ABS;
					}
					break;
				}
			} else {
				shndx = elf_section_from_bfd_section(abfd,sec);

				if (shndx == SHN_BAD) {
					asection       *sec2;

				/* Writing this would be a hell of a lot easier if we had some decent
				 * documentation on bfd,and knew what to expect of the library,and what
				 * to demand of applications.  For example,it appears that `objcopy'
				 * might not set the section of a symbol to be a section that is
				 * actually in the output file.  */
					sec2 = bfd_get_section_by_name(abfd,sec->name);
					if (sec2 != NULL)
						shndx = _bfd_elf_section_from_bfd_section(abfd,sec2);
					if (shndx == SHN_BAD) {
						/* xgettext:c-format */
						error_handler
							(("unable to find equivalent output section"
							  " for symbol '%s' from section '%s'"),
							 syms[idx]->name ? syms[idx]->name : "<Local sym>",
							 sec->name);
						bfd_set_error(bfd_error_invalid_operation);
						goto error_return;
					}
				}
			}

			sym.st_shndx = shndx;
		}

		if ((flags & BSF_THREAD_LOCAL) != 0)
			type = STT_TLS;
		else
			if ((flags & BSF_GNU_INDIRECT_FUNCTION) != 0)
				type = STT_GNU_IFUNC;
			else
				if ((flags & BSF_FUNCTION) != 0)
					type = STT_FUNC;
				else
					if ((flags & BSF_OBJECT) != 0)
						type = STT_OBJECT;
					else
						if ((flags & BSF_RELC) != 0)
							type = STT_RELC;
						else
							if ((flags & BSF_SRELC) != 0)
								type = STT_SRELC;
							else
								type = STT_NOTYPE;

		if (syms[idx]->section->flags & SEC_THREAD_LOCAL)
			type = STT_TLS;

#if 0
		/* Processor-specific types.  */
		if (type_ptr != NULL
		    && bed->elf_backend_get_symbol_type)
			type = ((*bed->elf_backend_get_symbol_type)
				(&type_ptr->internal_elf_sym,type));
#endif
		if (flags & BSF_SECTION_SYM) {
			if (flags & BSF_GLOBAL)
				sym.st_info = ELF_ST_INFO(STB_GLOBAL,STT_SECTION);
			else
				sym.st_info = ELF_ST_INFO(STB_LOCAL,STT_SECTION);
		} else
			if (bfd_is_com_section(syms[idx]->section)) {
				if (type != STT_TLS) {
					if ((abfd->flags & BFD_CONVERT_ELF_COMMON))
						type = ((abfd->flags & BFD_USE_ELF_STT_COMMON)
						   ? STT_COMMON : STT_OBJECT);
					else
						type = ((flags & BSF_ELF_COMMON) != 0
						   ? STT_COMMON : STT_OBJECT);
				}
				sym.st_info = ELF_ST_INFO(STB_GLOBAL,type);
			} else
				if (bfd_is_und_section(syms[idx]->section))
					sym.st_info = ELF_ST_INFO(((flags & BSF_WEAK)
								   ? STB_WEAK
								: STB_GLOBAL),
								  type);
				else
					if (flags & BSF_FILE)
						sym.st_info = ELF_ST_INFO(STB_LOCAL,STT_FILE);
					else {
						int		bind = STB_LOCAL;

						if (flags & BSF_LOCAL)
							bind = STB_LOCAL;
						else
							if (flags & BSF_GNU_UNIQUE)
								bind = STB_GNU_UNIQUE;
							else
								if (flags & BSF_WEAK)
									bind = STB_WEAK;
								else
									if (flags & BSF_GLOBAL)
										bind = STB_GLOBAL;

						sym.st_info = ELF_ST_INFO(bind,type);
					}

		if (type_ptr != NULL) {
			sym.st_other = type_ptr->internal_elf_sym.st_other;
			sym.st_target_internal
				= type_ptr->internal_elf_sym.st_target_internal;
		} else {
			sym.st_other = 0;
			sym.st_target_internal = 0;
		}

		idx++;
		symstrtab[idx].sym = sym;
		symstrtab[idx].dest_index = outbound_syms_index;

		outbound_syms_index++;
	}

	/* Finalize the .strtab section.  */
	_bfd_elf_strtab_finalize(stt);

	/* Swap out the .strtab section.  */
	for (idx = 0; idx <= symcount; idx++) {
		struct elf_sym_strtab *elfsym = &symstrtab[idx];
		const Elf_Internal_Sym *src = &elfsym->sym;
		unsigned int	tmp;
		if (elfsym->sym.st_name == (unsigned long)-1)
			elfsym->sym.st_name = 0;
		else
			elfsym->sym.st_name = _bfd_elf_strtab_offset(stt,
							 elfsym->sym.st_name);
		dst = (Elf64_External_Sym *) (outbound_syms + (elfsym->dest_index * sizeof(Elf64_External_Sym)));
		bfd_putl32(src->st_name,dst->st_name);
		bfd_putl64(src->st_value,dst->st_value);
		bfd_putl64(src->st_size,dst->st_size);
		bfd_putl8(src->st_info,dst->st_info);
		bfd_putl8(src->st_other,dst->st_other);
		tmp = src->st_shndx;
		if (tmp >= (SHN_LORESERVE & 0xffff) && tmp < SHN_LORESERVE) {
			error_handler("Too many sections");
		}
		bfd_putl16(tmp,dst->st_shndx);
	}
	free(symstrtab);

	*sttp = stt;
	//symstrtab_hdr->sh_size = _bfd_elf_strtab_size(stt);
	symstrtab_hdr->sh_size = (stt->sec_size ? stt->sec_size : stt->size);
	symstrtab_hdr->sh_type = SHT_STRTAB;
	//symstrtab_hdr->sh_flags = bed->elf_strtab_flags;
	symstrtab_hdr->sh_addr = 0;
	symstrtab_hdr->sh_entsize = 0;
	symstrtab_hdr->sh_link = 0;
	symstrtab_hdr->sh_info = 0;
	symstrtab_hdr->sh_addralign = 1;

	return true;
}
static file_ptr	assign_file_position_for_section(Elf_Internal_Shdr * i_shdrp,
							file_ptr	offset,
					 		bool		align)
{
	if (align && i_shdrp->sh_addralign > 1)
		offset = BFD_ALIGN(offset,i_shdrp->sh_addralign & -i_shdrp->sh_addralign);
	i_shdrp->sh_offset = offset;
	if (i_shdrp->bfd_section != NULL)
		i_shdrp->bfd_section->filepos = offset;
	if (i_shdrp->sh_type != SHT_NOBITS)
		offset += i_shdrp->sh_size;
	return offset;
}
/* Work out the file positions of all the sections.  This is called by
 * compute_section_file_positions.  All the section sizes and VMAs must be
 * known before this is called.
 * 
 * Reloc sections come in two flavours: Those processed specially as
 * "side-channel" data attached to a section to which they apply,and those
 * that bfd doesn't process as relocations.  The latter sort are stored in a
 * normal bfd section by bfd_section_from_shdr.  We don't consider the former
 * sort here,unless they form part of the loadable image.  Reloc sections not
 * assigned here (and compressed debugging sections and CTF sections which
 * nothing else in the file can rely upon) will be handled later by
 * assign_file_positions_for_relocs.
 * 
 * We also don't set the positions of the .symtab and .strtab here.  */
static bool	assign_file_positions_except_relocs(bfd * abfd,
	    		struct	bfd_link_info *link_info ATTRIBUTE_UNUSED)
{
	Elf_Internal_Ehdr *i_ehdrp = elf_elfheader(abfd);

	{
		Elf_Internal_Shdr **const i_shdrpp = elf_elfsections(abfd);
		unsigned int	num_sec = elf_numsections(abfd);
		Elf_Internal_Shdr **hdrpp;
		unsigned int	i;
		file_ptr	off;

		/* Start after the ELF header.  */
		off = i_ehdrp->e_ehsize;

		/*
		 * We are not creating an executable,which means that we are
		 * not creating a program header,and that the actual order of
		 * the sections in the file is unimportant.
		 */
		for (i = 1,hdrpp = i_shdrpp + 1; i < num_sec; i++,hdrpp++) {
			Elf_Internal_Shdr *hdr;

			hdr = *hdrpp;
			if (((hdr->sh_type == SHT_REL || hdr->sh_type == SHT_RELA)
			     && hdr->bfd_section == NULL)
			/*
			 * Do not assign offsets for these sections yet: we
			 * don't know their sizes.
			 */
			    || (abfd->is_linker_output
				&& hdr->bfd_section != NULL
				&& (hdr->sh_name == -1u
				    || bfd_section_is_ctf(hdr->bfd_section)))
			    || i == elf_onesymtab(abfd)
			    || (elf_symtab_shndx_list(abfd) != NULL
			 && hdr == i_shdrpp[elf_symtab_shndx_list(abfd)->ndx])
			    || i == elf_strtab_sec(abfd)
			    || i == elf_shstrtab_sec(abfd)) {
				hdr->sh_offset = -1;
			} else
				off = assign_file_position_for_section(hdr,off,true);
		}

		elf_next_file_pos(abfd) = off;
		elf_program_header_size(abfd) = 0;
	}
	return true;
}
static bool	strtab_emit(register bfd * abfd,struct elf_strtab_hash *tab)
{
	size_t		off = 1;
	size_t		i;

	if (bfd_bwrite("",1,abfd) != 1)
		return false;

	for (i = 1; i < tab->size; ++i) {
		register const char *str;
		register unsigned int len;

		gas_assert(tab->array[i]->refcount == 0);
		len = tab->array[i]->len;
		if ((int)len < 0)
			continue;

		str = tab->array[i]->root.string;
		if (bfd_bwrite(str,len,abfd) != len)
			return false;

		off += len;
	}

	gas_assert(off == tab->sec_size);
	return true;
}
/* Compute the file positions we are going to put the sections at,and
 * otherwise prepare to begin writing out the ELF file.  If LINK_INFO is not
 * NULL,this is being called by the ELF backend linker. */
static bool	compute_section_file_positions(bfd * abfd,
					 		void         *link_info)
{
	//const struct elf_backend_data *bed = get_elf_backend_data(abfd);
	struct fake_section_arg fsargs;
	struct elf_strtab_hash *strtab = NULL;
	Elf_Internal_Shdr *shstrtab_hdr;
	bool		need_symtab;

	if (abfd->output_has_begun)
		return true;

	if (!elf_init_file_header(abfd,link_info))
		return false;

	fsargs.failed = false;
	fsargs.link_info = link_info;
	map_over_sections(elf_fake_sections,&fsargs);
	if (fsargs.failed)
		return false;

	if (!assign_section_numbers(abfd,link_info))
		return false;

	/* The backend linker builds symbol table information itself.  */
	need_symtab = (link_info == NULL
		       && (bfd_get_symcount(abfd) > 0
			   || ((abfd->flags & (EXEC_P|DYNAMIC|HAS_RELOC))
			       == HAS_RELOC)));
	if (need_symtab) {
		/* Non-zero if doing a relocatable link.  */
		//int		relocatable_p = !(abfd->flags & (EXEC_P|DYNAMIC));

		abfd->flags &= ~(EXEC_P|DYNAMIC);
		if (!swap_out_syms(abfd,&strtab,0,link_info))
			return false;
	}
	shstrtab_hdr = &elf_tdata(abfd)->shstrtab_hdr;
	/* sh_name was set in init_file_header.  */
	shstrtab_hdr->sh_type = SHT_STRTAB;
	shstrtab_hdr->sh_flags = 0;
	//bed->elf_strtab_flags;
	shstrtab_hdr->sh_addr = 0;
	/* sh_size is set in elf_assign_file_positions_for_non_load.  */
	shstrtab_hdr->sh_entsize = 0;
	shstrtab_hdr->sh_link = 0;
	shstrtab_hdr->sh_info = 0;
	/* sh_offset is set in elf_assign_file_positions_for_non_load.  */
	shstrtab_hdr->sh_addralign = 1;

	if (!assign_file_positions_except_relocs(abfd,link_info))
		return false;

	if (need_symtab) {
		file_ptr	off;
		Elf_Internal_Shdr *hdr;

		off = elf_next_file_pos(abfd);

		hdr = &elf_symtab_hdr(abfd);
		off = assign_file_position_for_section(hdr,off,true);

		if (elf_symtab_shndx_list(abfd) != NULL) {
			hdr = &elf_symtab_shndx_list(abfd)->hdr;
			if (hdr->sh_size != 0)
				off = assign_file_position_for_section(hdr,off,true);
			/*
			 * FIXME: What about other symtab_shndx sections in the
			 * list ?
			 */
		}
		hdr = &elf_tdata(abfd)->strtab_hdr;
		off = assign_file_position_for_section(hdr,off,true);

		elf_next_file_pos(abfd) = off;

		/*
		 * Now that we know where the .strtab section goes,write it
		 * out.
		 */
		if (Seek(abfd,hdr->sh_offset,SEEK_SET) != 0
		    || !strtab_emit(abfd,strtab))
			return false;
		_bfd_elf_strtab_free(strtab);
	}
	abfd->output_has_begun = true;

	return true;
}
/* This generic function can only be used in implementations where creating NEW
 * sections is disallowed.  It is useful in patching existing sections in
 * read-write files,though.  See other set_section_contents functions to see
 * why it doesn't work for new sections.  */
static bool	generic_set_section_contents(bfd * abfd,
					 		sec_ptr	section,
			       		const		void  *location,
					 		file_ptr	offset,
					 		size_t	count)
{
	if (count == 0)
		return true;

	if (Seek(abfd,section->filepos + offset,SEEK_SET) != 0
	    || bfd_bwrite(location,count,abfd) != count)
		return false;

	return true;
}
static bool	elf_set_section_contents(bfd * abfd,
				     		sec_ptr	section,
				   		const		void  *location,
				     		file_ptr	offset,
				     		size_t	count)
{
	Elf_Internal_Shdr *hdr;

	if (!abfd->output_has_begun
	    && !compute_section_file_positions(abfd,NULL))
		return false;

	if (!count)
		return true;

	hdr = &elf_section_data(section)->this_hdr;
	if (hdr->sh_offset == (file_ptr) - 1) {
		unsigned char  *contents;

		if (bfd_section_is_ctf(section))
			/*
			 * Nothing to do with this section: the contents are
			 * generated later.
			 */
			return true;

		if ((offset + count) > hdr->sh_size) {
			error_handler
				(("%pB:%pA: error: attempting to write"
				  " over the end of the section"),
				 abfd,section);

			bfd_set_error(bfd_error_invalid_operation);
			return false;
		}
		contents = hdr->contents;
		if (contents == NULL) {
			error_handler
				(("%pB:%pA: error: attempting to write"
				  " section into an empty buffer"),
				 abfd,section);

			bfd_set_error(bfd_error_invalid_operation);
			return false;
		}
		memcpy(contents + offset,location,count);
		return true;
	}
	return generic_set_section_contents(abfd,section,
					    location,offset,count);
}

static bool	set_section_contents(bfd * abfd,
				 		sec_ptr	section,
			       		const		void  *location,
				 		file_ptr	offset,
				 		size_t	count)
{
	size_t		sz;

	if (!(bfd_section_flags(section) & SEC_HAS_CONTENTS)) {
		bfd_set_error(bfd_error_no_contents);
		return false;
	}
	sz = section->size;
	if ((size_t) offset > sz
	    || count > sz - offset
	    || count != (size_t) count) {
		fprintf(stderr,"Bad value\n");
		return false;
	}
	/* Record a copy of the data in memory if desired.  */
	if (section->contents
	    && location != section->contents + offset)
		memcpy(section->contents + offset,location,(size_t) count);

	if (elf_set_section_contents(abfd,section,location,offset,count)) {
		abfd->output_has_begun = true;
		return true;
	}
	return false;
}

static void	_bfd_stab_cleanup(bfd * abfd ATTRIBUTE_UNUSED,void **pinfo);
static bool	elf_close_and_cleanup(bfd * abfd)
{
	struct elf_obj_tdata *tdata = elf_tdata(abfd);
	if (tdata != NULL) {
		if (elf_tdata(abfd)->o != NULL && elf_shstrtab(abfd) != NULL)
			_bfd_elf_strtab_free(elf_shstrtab(abfd));
#if 0
		_bfd_dwarf2_cleanup_debug_info(abfd,&tdata->dwarf2_find_line_info);
		_bfd_dwarf1_cleanup_debug_info(abfd,&tdata->dwarf1_find_line_info);
#endif
		_bfd_stab_cleanup(abfd,&tdata->line_info);
	}
	return true;
}
static bool	close_all_done(bfd * abfd)
{
	return  elf_close_and_cleanup(abfd);
}
//_bfd_elf_init_file_header:elf - strtab.c
static bool	elf_init_file_header(bfd * abfd,
		  		struct	bfd_link_info *info ATTRIBUTE_UNUSED)
{
	Elf_Internal_Ehdr *i_ehdrp;	/* Elf file header,internal form.  */
	struct elf_strtab_hash *shstrtab;
	//const struct elf_backend_data *bed = get_elf_backend_data(abfd);

	i_ehdrp = elf_elfheader(abfd);

	shstrtab = _bfd_elf_strtab_init();
	if (shstrtab == NULL)
		return false;

	elf_shstrtab(abfd) = shstrtab;

	i_ehdrp->e_ident[EI_MAG0] = ELFMAG0;
	i_ehdrp->e_ident[EI_MAG1] = ELFMAG1;
	i_ehdrp->e_ident[EI_MAG2] = ELFMAG2;
	i_ehdrp->e_ident[EI_MAG3] = ELFMAG3;

	i_ehdrp->e_ident[EI_CLASS] = 2;
	//bed->s->elfclass EI_CLASS == 4
	i_ehdrp->e_ident[EI_DATA] =
		bfd_big_endian(abfd) ? ELFDATA2MSB : ELFDATA2LSB;
	i_ehdrp->e_ident[EI_VERSION] = 1;
	//bed->s->ev_current;

	if ((abfd->flags & DYNAMIC) != 0)
		i_ehdrp->e_type = ET_DYN;
	else
		if ((abfd->flags & EXEC_P) != 0)
			i_ehdrp->e_type = ET_EXEC;
		else
			if (bfd_get_format(abfd) == bfd_core)
				i_ehdrp->e_type = ET_CORE;
			else
				i_ehdrp->e_type = ET_REL;

	switch (abfd->arch_info->arch) {
	case bfd_arch_unknown:
		i_ehdrp->e_machine = EM_NONE;
		break;

		/* There used to be a long list of cases here,each one setting
		 * e_machine to the same EM_* macro #defined as
		 * ELF_MACHINE_CODE in the corresponding bfd definition.  To
		 * avoid duplication,the switch was removed.  Machines that
		 * need special handling can generally do it in
		 * elf_backend_final_write_processing(),unless they need the
		 * information earlier than the final write. Such need can
		 * generally be supplied by replacing the tests for e_machine
		 * with the conditions used to determine it. */
	default:
		i_ehdrp->e_machine = EM_RISCV;
		//bed->elf_machine_code;
	}

	i_ehdrp->e_version = 1;
	//bed->s->ev_current;
	i_ehdrp->e_ehsize = 64;
	//bed->s->sizeof_ehdr;

	/* No program header,for now.  */
	i_ehdrp->e_phoff = 0;
	i_ehdrp->e_phentsize = 0;
	i_ehdrp->e_phnum = 0;

	/* Each bfd section is section header entry.  */
	i_ehdrp->e_entry = 0;
	//bfd_get_start_address(abfd);
	i_ehdrp->e_shentsize = 64;
	//bed->s->sizeof_shdr;

	elf_tdata(abfd)->symtab_hdr.sh_name =
		(unsigned int)strtab_add(shstrtab,".symtab",false);
	elf_tdata(abfd)->strtab_hdr.sh_name =
		(unsigned int)strtab_add(shstrtab,".strtab",false);
	elf_tdata(abfd)->shstrtab_hdr.sh_name =
		(unsigned int)strtab_add(shstrtab,".shstrtab",false);
	if (elf_tdata(abfd)->symtab_hdr.sh_name == (unsigned int)-1
	    || elf_tdata(abfd)->strtab_hdr.sh_name == (unsigned int)-1
	    || elf_tdata(abfd)->shstrtab_hdr.sh_name == (unsigned int)-1)
		return false;

	return true;
}
static void	strtab_addref(struct elf_strtab_hash *tab,size_t idx)
{
	if (idx == 0 || idx == (size_t) - 1)
		return;
	gas_assert(tab->sec_size == 0);
	gas_assert(idx < tab->size);
	++tab->array[idx]->refcount;
}
/*
 * Assign all ELF section numbers.  The dummy first section is handled here
 * too.  The link/info pointers for the standard section types are filled in
 * here too,while we're at it.  LINK_INFO will be 0 when arriving here for
 * gas,objcopy,and when using the generic ELF linker.
 */
static bool	assign_section_numbers(bfd * abfd,void *link_info)
{
	struct elf_obj_tdata *t = elf_tdata(abfd);
	asection       *sec;
	unsigned int	section_number;
	Elf_Internal_Shdr **i_shdrp;
	struct bfd_elf_section_data *d;
	bool		need_symtab;
	size_t		amt;

	section_number = 1;

	_bfd_elf_strtab_clear_all_refs(elf_shstrtab(abfd));

	/* SHT_GROUP sections are in relocatable files only.  */
	if (link_info == NULL) {
		size_t		reloc_count = 0;

		/* Put SHT_GROUP sections first.  */
		for (sec = abfd->sections; sec != NULL; sec = sec->next) {
			d = elf_section_data(sec);

			if (d->this_hdr.sh_type == SHT_GROUP) {
				d->this_idx = section_number++;
			}
			/* Count relocations.  */
			reloc_count += sec->reloc_count;
		}

		/* Set/clear HAS_RELOC depending on whether there are
		 * relocations.  */
		if (reloc_count == 0)
			abfd->flags &= ~HAS_RELOC;
		else
			abfd->flags |= HAS_RELOC;
	}
	for (sec = abfd->sections; sec; sec = sec->next) {
		d = elf_section_data(sec);

		if (d->this_hdr.sh_type != SHT_GROUP)
			d->this_idx = section_number++;
		if (d->this_hdr.sh_name != (unsigned int)-1)
#undef strtab_addref
			strtab_addref(elf_shstrtab(abfd),d->this_hdr.sh_name);
		if (d->rel.hdr) {
			d->rel.idx = section_number++;
			if (d->rel.hdr->sh_name != (unsigned int)-1)
				strtab_addref(elf_shstrtab(abfd),d->rel.hdr->sh_name);
		} else
			d->rel.idx = 0;

		if (d->rela.hdr) {
			d->rela.idx = section_number++;
			if (d->rela.hdr->sh_name != (unsigned int)-1)
				strtab_addref(elf_shstrtab(abfd),d->rela.hdr->sh_name);
		} else
			d->rela.idx = 0;
	}

	need_symtab = bfd_get_symcount(abfd) > 0;
	if (need_symtab) {
		elf_onesymtab(abfd) = section_number++;
		strtab_addref(elf_shstrtab(abfd),t->symtab_hdr.sh_name);
		if (section_number > ((SHN_LORESERVE - 2) & 0xFFFF)) {
			elf_section_list *entry;

			gas_assert(elf_symtab_shndx_list(abfd) == NULL);

			entry = zmalloc(sizeof(*entry));
			entry->ndx = section_number++;
			elf_symtab_shndx_list(abfd) = entry;
			entry->hdr.sh_name = (unsigned int)strtab_add(elf_shstrtab(abfd),
						      ".symtab_shndx",false);
			if (entry->hdr.sh_name == (unsigned int)-1)
				return false;
		}
		elf_strtab_sec(abfd) = section_number++;
		strtab_addref(elf_shstrtab(abfd),t->strtab_hdr.sh_name);
	}
	elf_shstrtab_sec(abfd) = section_number++;
	strtab_addref(elf_shstrtab(abfd),t->shstrtab_hdr.sh_name);
	elf_elfheader(abfd)->e_shstrndx = elf_shstrtab_sec(abfd);

	if (section_number >= SHN_LORESERVE) {
		/* xgettext:c-format */
		error_handler(("%pB: too many sections: %u"),
			      abfd,section_number);
		return false;
	}
	elf_numsections(abfd) = section_number;
	elf_elfheader(abfd)->e_shnum = section_number;

	/*
	 * Set up the list of section header pointers,in agreement with the
	 * indices.
	 */
	amt = section_number * sizeof(Elf_Internal_Shdr *);
	i_shdrp = (Elf_Internal_Shdr **) zmalloc(amt);
	if (i_shdrp == NULL)
		return false;

	i_shdrp[0] = (Elf_Internal_Shdr *) zmalloc(sizeof(Elf_Internal_Shdr));
	if (i_shdrp[0] == NULL) {
		bfd_release(abfd,i_shdrp);
		return false;
	}
	elf_elfsections(abfd) = i_shdrp;

	i_shdrp[elf_shstrtab_sec(abfd)] = &t->shstrtab_hdr;
	if (need_symtab) {
		i_shdrp[elf_onesymtab(abfd)] = &t->symtab_hdr;
		if (elf_numsections(abfd) > (SHN_LORESERVE & 0xFFFF)) {
			elf_section_list *entry = elf_symtab_shndx_list(abfd);
			gas_assert(entry != NULL);
			i_shdrp[entry->ndx] = &entry->hdr;
			entry->hdr.sh_link = elf_onesymtab(abfd);
		}
		i_shdrp[elf_strtab_sec(abfd)] = &t->strtab_hdr;
		t->symtab_hdr.sh_link = elf_strtab_sec(abfd);
	}
	for (sec = abfd->sections; sec; sec = sec->next) {
		asection       *s;

		d = elf_section_data(sec);

		i_shdrp[d->this_idx] = &d->this_hdr;
		if (d->rel.idx != 0)
			i_shdrp[d->rel.idx] = d->rel.hdr;
		if (d->rela.idx != 0)
			i_shdrp[d->rela.idx] = d->rela.hdr;

		/* Fill in the sh_link and sh_info fields while we're at it.  */

		/*
		 * sh_link of a reloc section is the section index of the
		 * symbol table.  sh_info is the section index of the section
		 * to which the relocation entries apply.
		 */
		if (d->rel.idx != 0) {
			d->rel.hdr->sh_link = elf_onesymtab(abfd);
			d->rel.hdr->sh_info = d->this_idx;
			d->rel.hdr->sh_flags |= SHF_INFO_LINK;
		}
		if (d->rela.idx != 0) {
			d->rela.hdr->sh_link = elf_onesymtab(abfd);
			d->rela.hdr->sh_info = d->this_idx;
			d->rela.hdr->sh_flags |= SHF_INFO_LINK;
		}

		switch (d->this_hdr.sh_type) {
		case SHT_REL:
		case SHT_RELA:
			gas_assert(0);
			break;

		case SHT_STRTAB:
			/*
			 * We assume that a section named .stab*str is a stabs
			 * string section.  We look for a section with the same
			 * name but without the trailing ``str'',and set its
			 * sh_link field to point to this section.
			 */
			if (startswith(sec->name,".stab")
			    && strcmp(sec->name + strlen(sec->name) - 3,"str") == 0) {
				size_t		len;
				char           *alc;

				len = strlen(sec->name);
				alc = (char *)malloc(len - 2);
				if (alc == NULL)
					return false;
				memcpy(alc,sec->name,len - 3);
				alc[len - 3] = '\0';
				s = bfd_get_section_by_name(abfd,alc);
				free(alc);
				if (s != NULL) {
					elf_section_data(s)->this_hdr.sh_link = d->this_idx;

					/* This is a .stab section.  */
					elf_section_data(s)->this_hdr.sh_entsize = 12;
				}
			}
			break;

		case SHT_DYNAMIC:
		case SHT_DYNSYM:
		case SHT_GNU_verneed:
		case SHT_GNU_verdef:
			/*
			 * sh_link is the section header index of the string
			 * table used for the dynamic entries,or the symbol
			 * table,or the version strings.
			 */
			s = bfd_get_section_by_name(abfd,".dynstr");
			if (s != NULL)
				d->this_hdr.sh_link = elf_section_data(s)->this_idx;
			break;

		case SHT_GNU_LIBLIST:
			/*
			 * sh_link is the section header index of the prelink
			 * library list used for the dynamic entries,or the
			 * symbol table,or the version strings.
			 */
			s = bfd_get_section_by_name(abfd,((sec->flags & SEC_ALLOC)
						? ".dynstr" : ".gnu.libstr"));
			if (s != NULL)
				d->this_hdr.sh_link = elf_section_data(s)->this_idx;
			break;

		case SHT_HASH:
		case SHT_GNU_HASH:
		case SHT_GNU_versym:
			/*
			 * sh_link is the section header index of the symbol
			 * table this hash table or version table is for.
			 */
			s = bfd_get_section_by_name(abfd,".dynsym");
			if (s != NULL)
				d->this_hdr.sh_link = elf_section_data(s)->this_idx;
			break;

		case SHT_GROUP:
			d->this_hdr.sh_link = elf_onesymtab(abfd);
		}
	}

	/*
	 * Delay setting sh_name to _bfd_elf_write_object_contents so that
	 * assign_file_positions_for_non_load can convert DWARF debug section
	 * name from .debug_* to .zdebug_* if needed.
	 */

	return true;
}
static int	Seek (bfd * abfd,file_ptr position,int direction)
{
	int		result;
	ufile_ptr	offset = 0;

	while (abfd->my_archive != NULL && !abfd->is_thin_archive) {
		offset += abfd->origin;
		abfd = abfd->my_archive;
	}
	offset += abfd->origin;


	/*
	 * For the time being,a BFD may not seek to it's end.  The problem is
	 * that we don't easily have a way to recognize the end of an element
	 * in an archive.
	 */
	gas_assert(direction == SEEK_SET || direction == SEEK_CUR);

	if (direction != SEEK_CUR)
		position += offset;

	result = fseeko(abfd->iostream,position,direction);
	if (result != 0) {
		/*
		 * An EINVAL error probably means that the file offset was
		 * absurd.
		 */
		if (errno == EINVAL)
			fprintf(stderr,"file_truncated\n");
		else
			fprintf(stderr,"error in system_call\n");
	} else {
		/* Adjust `where' field.  */
		if (direction == SEEK_CUR)
			abfd->where += position;
		else
			abfd->where = position;
	}

	return result;
}
static bool	generic_new_section_hook(bfd * abfd,asection * newsect)
{
	newsect->symbol = elf_make_empty_symbol(abfd);
	if (newsect->symbol == NULL)
		return false;

	newsect->symbol->name = newsect->name;
	newsect->symbol->value = 0;
	newsect->symbol->section = newsect;
	newsect->symbol->flags = BSF_SECTION_SYM;

	newsect->symbol_ptr_ptr = &newsect->symbol;
	return true;
}
static const struct bfd_elf_special_section *elf_get_special_section(const char *Name,
	     		const		struct	bfd_elf_special_section *spec,
				      		unsigned	int	rela)
{
	int		i;
	int		len;

	len = strlen(Name);

	for (i = 0; spec[i].prefix != NULL; i++) {
		int		suffix_len;
		int		prefix_len = spec[i].prefix_length;

		if (len < prefix_len)
			continue;
		if (memcmp(Name,spec[i].prefix,prefix_len) != 0)
			continue;

		suffix_len = spec[i].suffix_length;
		if (suffix_len <= 0) {
			if (Name[prefix_len] != 0) {
				if (suffix_len == 0)
					continue;
				if (Name[prefix_len] != '.'
				    && (suffix_len == -2
					|| (rela && spec[i].type == SHT_REL)))
					continue;
			}
		} else {
			if (len < prefix_len + suffix_len)
				continue;
			if (memcmp(Name + len - suffix_len,
				   spec[i].prefix + prefix_len,
				   suffix_len) != 0)
				continue;
		}
		return &spec[i];
	}

	return NULL;
}
static const struct bfd_elf_special_section *get_sec_type_attr(bfd * abfd ATTRIBUTE_UNUSED,asection * sec)
{
	int		i;
	const struct bfd_elf_special_section *spec;

	/* See if this is one of the special sections.  */
	if (sec->name == NULL)
		return NULL;


	if (sec->name[0] != '.')
		return NULL;

	i = sec->name[1] - 'b';
	if (i < 0 || i > 'z' - 'b')
		return NULL;

	spec = special_sections[i];

	if (spec == NULL)
		return NULL;

	return elf_get_special_section(sec->name,spec,sec->use_rela_p);
}
static int	section_id = 0x10;
static bool	new_section_hook(bfd * abfd,asection * sec)
{
	struct bfd_elf_section_data *sdata;
	//const struct elf_backend_data *bed;
	const struct bfd_elf_special_section *ssect;

	sdata = (struct bfd_elf_section_data *)sec->used_by_bfd;
	if (sdata == NULL) {
		sdata = (struct bfd_elf_section_data *)zmalloc(sizeof(*sdata));
		if (sdata == NULL)
			return false;
		sec->used_by_bfd = sdata;
	}
	/* Indicate whether or not this section should use RELA relocations.  */
	//bed = get_elf_backend_data(abfd);
	sec->use_rela_p = 1;

	/*
	 * Set up ELF section type and flags for newly created sections,if
	 * there is an ABI mandated section.
	 */
	ssect = get_sec_type_attr(abfd,sec);
//_bfd_elf_get_sec_type_attr elf.c:2814
		if (ssect != NULL) {
		elf_section_type(sec) = ssect->type;
		elf_section_flags(sec) = ssect->attr;
	}
	return generic_new_section_hook(abfd,sec);
}
static unsigned	_bfd_section_id = 0x10;
static asection *bfd_section_init(bfd * abfd,asection * newsect)
{
	newsect->id = _bfd_section_id;
	newsect->index = abfd->section_count;
	newsect->owner = abfd;

	if (!new_section_hook(abfd,newsect))
		return NULL;

	section_id++;
	abfd->section_count++;
	bfd_section_list_append(abfd,newsect);
	return newsect;
}
static asection *make_section_old_way(bfd * abfd,const char *Name)
{
	asection       *newsect;

	if (abfd->output_has_begun) {
		bfd_set_error(bfd_error_invalid_operation);
		return NULL;
	}
	if (strcmp(Name,BFD_ABS_SECTION_NAME) == 0)
		newsect = bfd_abs_section_ptr;
	else
		if (strcmp(Name,BFD_COM_SECTION_NAME) == 0)
			newsect = bfd_com_section_ptr;
		else
			if (strcmp(Name,BFD_UND_SECTION_NAME) == 0)
				newsect = bfd_und_section_ptr;
			else
				if (strcmp(Name,BFD_IND_SECTION_NAME) == 0)
					newsect = bfd_ind_section_ptr;
				else {
					struct section_hash_entry *sh;

					sh = (struct section_hash_entry *)bfd_hash_lookup(&abfd->section_htab,Name,true,false);
					if (sh == NULL)
						return NULL;

					newsect = &sh->section;
					if (newsect->name != NULL) {
						/* Section already exists.  */
						return newsect;
					}
					newsect->name = Name;
					return bfd_section_init(abfd,newsect);
				}

	/*
	 * Call new_section_hook when "creating" the standard abs,com,und and
	 * ind sections to tack on format specific section data. Also,create a
	 * proper section symbol.
	 */
	if (!new_section_hook(abfd,newsect))
		return NULL;
	return newsect;
}
#define section_hash_lookup(table,string,create,copy) \
  ((struct section_hash_entry *) \
   bfd_hash_lookup ((table),(string),(create),(copy)))
static sec_ptr	make_section_anyway_with_flags(bfd * abfd,const char *Name,
					      		flagword	flags)
{
	struct section_hash_entry *sh;
	asection       *newsect;

	if (abfd->output_has_begun) {
		bfd_set_error(bfd_error_invalid_operation);
		return NULL;
	}
	sh = section_hash_lookup(&abfd->section_htab,Name,true,false);
	if (sh == NULL)
		return NULL;

	newsect = &sh->section;
	if (newsect->name != NULL) {
		/*
		 * We are making a section of the same Name.  Put it in the
		 * section hash table.  Even though we can't find it directly
		 * by a hash lookup,we'll be able to find the section by
		 * traversing sh->root.next quicker than looking at all the bfd
		 * sections.
		 */
		struct section_hash_entry *new_sh;
		new_sh = (struct section_hash_entry *)
			bfd_section_hash_newfunc(NULL,&abfd->section_htab,Name);
		if (new_sh == NULL)
			return NULL;

		new_sh->root = sh->root;
		sh->root.next = &new_sh->root;
		newsect = &new_sh->section;
	}
	newsect->flags = flags;
	newsect->name = Name;
	return bfd_section_init(abfd,newsect);
}
static sec_ptr	make_section_anyway(bfd * abfd,const char *Name)
{
	return make_section_anyway_with_flags(abfd,Name,0);
}
static bool	is_local_label(asymbol * sym)
{
	/*
	 * The BSF_SECTION_SYM check is needed for IA-64,where every label
	 * that starts with '.' is local.  This would accidentally catch
	 * section names if we didn't reject them here.
	 */
	if ((sym->flags & (BSF_GLOBAL|BSF_WEAK|BSF_FILE|BSF_SECTION_SYM)) != 0)
		return false;
	if (sym->name == NULL)
		return false;
	return sym->name[0] == '.' && sym->name[1] == 'L';
}

static bool	is_local_label_name(const char *Name)
{
	return Name[0] == '.' && Name[1] == 'L';
}
static bool	_bfd_elf_set_reloc_sh_name(bfd * abfd,
				       		Elf_Internal_Shdr * rel_hdr,
				     		const		char  *sec_name,
				       		bool		use_rela_p)
{
	char           *Name = (char *)bfd_alloc(abfd,
					   sizeof ".rela" + strlen(sec_name));
	if (Name == NULL)
		return false;

	sprintf(Name,"%s%s",use_rela_p ? ".rela" : ".rel",sec_name);
	rel_hdr->sh_name =
		(unsigned int)strtab_add(elf_shstrtab(abfd),Name,
					 false);
	if (rel_hdr->sh_name == (unsigned int)-1)
		return false;

	return true;
}
/*
 * Align to the maximum file alignment that could be required for any ELF data
 * structure.
 */
static file_ptr	align_file_position(file_ptr off,int align)
{
	return (off + align - 1) & ~(align - 1);
}
static size_t	elf_strtab_size(struct elf_strtab_hash *tab)
{
	return tab->sec_size ? tab->sec_size : tab->size;
}
/*
 * Assign file positions for all the reloc sections which are not part of the
 * loadable file image,and the file position of section headers.
 */
static bool	assign_file_positions_for_non_load(bfd * abfd)
{
	file_ptr	off;
	Elf_Internal_Shdr **shdrpp,**end_shdrpp;
	Elf_Internal_Shdr *shdrp;
	Elf_Internal_Ehdr *i_ehdrp;

	off = elf_next_file_pos(abfd);

	shdrpp = elf_elfsections(abfd);
	end_shdrpp = shdrpp + elf_numsections(abfd);
	for (shdrpp++; shdrpp < end_shdrpp; shdrpp++) {
		shdrp = *shdrpp;
		if (shdrp->sh_offset == -1) {
			asection       *sec = shdrp->bfd_section;
			if (sec == NULL
			    || shdrp->sh_type == SHT_REL
			    || shdrp->sh_type == SHT_RELA);
			else
				if (bfd_section_is_ctf(sec)) {
					/* Update section size and contents.	 */
					shdrp->sh_size = sec->size;
					shdrp->contents = sec->contents;
				} else
					if (shdrp->sh_name == -1u) {
						const char     *Name = sec->name;
						struct bfd_elf_section_data *d;

						/*
						 * Compress DWARF debug
						 * sections.
						 */
						if (!bfd_compress_section(abfd,sec,shdrp->contents))
							return false;

						if (sec->compress_status == COMPRESS_SECTION_DONE
						    && (abfd->flags & BFD_COMPRESS_GABI) == 0
						    && Name[1] == 'd') {
							/*
							 * If section is
							 * compressed with
							 * zlib-gnu,convert
							 * section name from
							 * .debug_* to
							 * .zdebug_*.
							 */
							char           *new_name = bfd_debug_name_to_zdebug(abfd,Name);
							if (new_name == NULL)
								return false;
							Name = new_name;
						}
						/*
						 * Add section name to section
						 * name section.
						 */
						shdrp->sh_name
							= (unsigned int)strtab_add(elf_shstrtab(abfd),
								 Name,false);
						d = elf_section_data(sec);

						/*
						 * Add reloc section name to
						 * section name section.
						 */
						if (d->rel.hdr
						    && !_bfd_elf_set_reloc_sh_name(abfd,d->rel.hdr,
								 Name,false))
							return false;
						if (d->rela.hdr
						    && !_bfd_elf_set_reloc_sh_name(abfd,d->rela.hdr,
								  Name,true))
							return false;

						/*
						 * Update section size and
						 * contents.
						 */
						shdrp->sh_size = sec->size;
						shdrp->contents = sec->contents;
						sec->contents = NULL;
					}
			off = assign_file_position_for_section(shdrp,off,true);
		}
	}

	/*
	 * Place section name section after DWARF debug sections have been
	 * compressed.
	 */
	_bfd_elf_strtab_finalize(elf_shstrtab(abfd));
	shdrp = &elf_tdata(abfd)->shstrtab_hdr;
	shdrp->sh_size = elf_strtab_size(elf_shstrtab(abfd));
	off = assign_file_position_for_section(shdrp,off,true);

	/* Place the section headers.  */
	i_ehdrp = elf_elfheader(abfd);
	off = align_file_position(off,8);
	i_ehdrp->e_shoff = off;
	off += i_ehdrp->e_shnum * i_ehdrp->e_shentsize;
	elf_next_file_pos(abfd) = off;

	return true;
}
/*
 * Translate an ELF section header table entry in internal format into an ELF
 * section header table entry in external format.
 */
static void	elf_swap_shdr_out(bfd * abfd ATTRIBUTE_UNUSED,
			    		const		Elf_Internal_Shdr * src,
			      		Elf64_External_Shdr * dst)
{
	/*
	 * note that all elements of dst are *arrays of unsigned char*
	 * already...
	 */
	bfd_putl32(src->sh_name,dst->sh_name);
	bfd_putl32(src->sh_type,dst->sh_type);
	bfd_putl64(src->sh_flags,dst->sh_flags);
	bfd_putl64(src->sh_addr,dst->sh_addr);
	bfd_putl64(src->sh_offset,dst->sh_offset);
	bfd_putl64(src->sh_size,dst->sh_size);
	bfd_putl32(src->sh_link,dst->sh_link);
	bfd_putl32(src->sh_info,dst->sh_info);
	bfd_putl64(src->sh_addralign,dst->sh_addralign);
	bfd_putl64(src->sh_entsize,dst->sh_entsize);
}
/*
 * Translate an ELF file header in internal format into an ELF file header in
 * external format.
 */
static void	elf_swap_ehdr_out(bfd * abfd ATTRIBUTE_UNUSED,
			    		const		Elf_Internal_Ehdr * src,
			      		Elf64_External_Ehdr * dst)
{
	unsigned int	tmp;
	int		signed_vma = 0;
	//get_elf_backend_data(abfd)->sign_extend_vma;
	memcpy(dst->e_ident,src->e_ident,EI_NIDENT);
	/*
	 * note that all elements of dst are *arrays of unsigned char*
	 * already...
	 */
	bfd_putl16(src->e_type,dst->e_type);
	bfd_putl16(src->e_machine,dst->e_machine);
	bfd_putl32(src->e_version,dst->e_version);
	if (signed_vma)
		bfd_putl64(src->e_entry,dst->e_entry);
	else
		bfd_putl64(src->e_entry,dst->e_entry);
	bfd_putl64(src->e_phoff,dst->e_phoff);
	bfd_putl64(src->e_shoff,dst->e_shoff);
	bfd_putl32(src->e_flags,dst->e_flags);
	bfd_putl16(src->e_ehsize,dst->e_ehsize);
	bfd_putl16(src->e_phentsize,dst->e_phentsize);
	tmp = src->e_phnum;
	if (tmp > PN_XNUM)
		tmp = PN_XNUM;
	bfd_putl16(tmp,dst->e_phnum);
	bfd_putl16(src->e_shentsize,dst->e_shentsize);
	tmp = src->e_shnum;
	if (tmp >= (SHN_LORESERVE & 0xffff))
		tmp = SHN_UNDEF;
	bfd_putl16(tmp,dst->e_shnum);
	tmp = src->e_shstrndx;
	if (tmp >= (SHN_LORESERVE & 0xffff))
		tmp = SHN_XINDEX & 0xffff;
	bfd_putl16(tmp,dst->e_shstrndx);
}
//
#define Elf_External_Shdr	NAME(Elf,External_Shdr)
/* Write out the section headers and the ELF file header.  */
static bool	elf_write_shdrs_and_ehdr(bfd * abfd)
{
	Elf64_External_Ehdr x_ehdr;	/* Elf file header,external form */
	Elf_Internal_Ehdr *i_ehdrp;	/* Elf file header,internal form */
	Elf64_External_Shdr *x_shdrp;	/* Section header table,external form */
	Elf_Internal_Shdr **i_shdrp;	/* Section header table,internal form */
	unsigned int	count;
	size_t		amt;

	i_ehdrp = elf_elfheader(abfd);
	i_shdrp = elf_elfsections(abfd);

	/* swap the header before spitting it out...  */

	elf_swap_ehdr_out(abfd,i_ehdrp,&x_ehdr);
	amt = sizeof(x_ehdr);
	if (Seek(abfd,(file_ptr) 0,SEEK_SET) != 0
	    || bfd_bwrite(&x_ehdr,amt,abfd) != amt)
		return false;

	/* Some fields in the first section header handle overflow of ehdr
	 * fields.  */
	if (i_ehdrp->e_phnum >= PN_XNUM)
		i_shdrp[0]->sh_info = i_ehdrp->e_phnum;
	if (i_ehdrp->e_shnum >= (SHN_LORESERVE & 0xffff))
		i_shdrp[0]->sh_size = i_ehdrp->e_shnum;
	if (i_ehdrp->e_shstrndx >= (SHN_LORESERVE & 0xffff))
		i_shdrp[0]->sh_link = i_ehdrp->e_shstrndx;

	/* at this point we've concocted all the ELF sections...  */
	if (_bfd_mul_overflow(i_ehdrp->e_shnum,sizeof(*x_shdrp),&amt)) {
		bfd_set_error(bfd_error_no_memory);
		return false;
	}
	x_shdrp = (Elf64_External_Shdr *) bfd_alloc(abfd,amt);
	if (!x_shdrp)
		return false;

	for (count = 0; count < i_ehdrp->e_shnum; i_shdrp++,count++) {
		elf_swap_shdr_out(abfd,*i_shdrp,x_shdrp + count);
	}
	amt = (size_t) i_ehdrp->e_shnum * sizeof(*x_shdrp);
	if (Seek(abfd,(file_ptr) i_ehdrp->e_shoff,SEEK_SET) != 0
	    || bfd_bwrite(x_shdrp,amt,abfd) != amt)
		return false;

	/* need to dump the string table too...  */

	return true;
}
/*
 * Given a BFD symbol,return the index in the ELF symbol table,or -1 on
 * error.
 */
static int	_bfd_elf_symbol_from_bfd_symbol(bfd * abfd,asymbol ** asym_ptr_ptr)
{
	asymbol        *asym_ptr = *asym_ptr_ptr;
	int		idx;
	flagword	flags = asym_ptr->flags;

	/* When gas creates relocations against local labels,it creates its
	 * own symbol for the section,but does put the symbol into the symbol
	 * chain,so udata is 0.  When the linker is generating relocatable
	 * output,this section symbol may be for one of the input sections
	 * rather than the output section.  */
	if (asym_ptr->udata.i == 0
	    && (flags & BSF_SECTION_SYM)
	    && asym_ptr->section) {
		asection       *sec;

		sec = asym_ptr->section;
		if (sec->owner != abfd && sec->output_section != NULL)
			sec = sec->output_section;
		if (sec->owner == abfd
		    && sec->index < elf_num_section_syms(abfd)
		    && elf_section_syms(abfd)[sec->index] != NULL)
			asym_ptr->udata.i = elf_section_syms(abfd)[sec->index]->udata.i;
	}
	idx = asym_ptr->udata.i;

	if (idx == 0) {
		/*
		 * This case can occur when using --strip-symbol on a symbol
		 * which is used in a relocation entry.
		 */
		/* xgettext:c-format */
		fprintf(stderr,"%s: symbol `%s' required but not present",
			abfd->filename,bfd_asymbol_name(asym_ptr));
		bfd_set_error(bfd_error_no_symbols);
		return -1;
	}
	return idx;
}
static void	elf_write_relocs(asection * sec,void *data)
{
	bfd            *abfd = stdoutput;
	//const struct elf_backend_data *const bed = get_elf_backend_data(abfd);
	bool           *failedp = (bool *) data;
	Elf_Internal_Shdr *rela_hdr;
	bfd_vma		addr_offset;
	void            (*swap_out) (bfd *,const Elf_Internal_Rela *,bfd_byte *);
	size_t		extsize;
	bfd_byte       *dst_rela;
	unsigned int	idx;
	asymbol        *last_sym;
	int		last_sym_idx;
	size_t		amt;

	/* If we have already failed,don't do anything.  */
	if (*failedp)
		return;

	if ((sec->flags & SEC_RELOC) == 0)
		return;

	/* The linker backend writes the relocs out itself,and sets the
	 * reloc_count field to zero to inhibit writing them here.  Also,
	 * sometimes the SEC_RELOC flag gets set even when there aren't any
	 * relocs.  */
	if (sec->reloc_count == 0)
		return;

	/* If we have opened an existing file for update,reloc_count may be
	 * set even though we are not linking.  In that case we have nothing to
	 * do.  */
	if (sec->orelocation == NULL)
		return;

	rela_hdr = elf_section_data(sec)->rela.hdr;
	if (rela_hdr == NULL)
		rela_hdr = elf_section_data(sec)->rel.hdr;

	rela_hdr->sh_size = rela_hdr->sh_entsize * sec->reloc_count;
	if (_bfd_mul_overflow(sec->reloc_count,rela_hdr->sh_entsize,&amt)
	    || (rela_hdr->contents = bfd_alloc(abfd,amt)) == NULL) {
		bfd_set_error(bfd_error_no_memory);
		*failedp = true;
		return;
	}
	/* Figure out whether the relocations are RELA or REL relocations.  */
	if (rela_hdr->sh_type == SHT_RELA) {
		swap_out = bfd_elf64_swap_reloca_out;
		extsize = sizeof(Elf64_External_Rela);
	}
	else
		/* Every relocation section should be either an
		 * SHT_RELA or an SHT_REL section.  */
		abort();

	/* The address of an ELF reloc is section relative for an object file,
	 * and absolute for an executable file or shared library. The address
	 * of a BFD reloc is always section relative.  */
	addr_offset = 0;
	if ((abfd->flags & (EXEC_P|DYNAMIC)) != 0)
		addr_offset = sec->vma;

	/* orelocation has the data,reloc_count has the count...  */
	last_sym = 0;
	last_sym_idx = 0;
	dst_rela = rela_hdr->contents;

	for (idx = 0; idx < sec->reloc_count; idx++,dst_rela += extsize) {
		Elf_Internal_Rela src_rela;
		arelent        *ptr;
		asymbol        *sym;
		int		n;

		ptr = sec->orelocation[idx];
		sym = *ptr->sym_ptr_ptr;
		if (sym == last_sym)
			n = last_sym_idx;
		else
			if (bfd_is_abs_section(sym->section) && sym->value == 0)
				n = STN_UNDEF;
			else {
				last_sym = sym;
				n = _bfd_elf_symbol_from_bfd_symbol(abfd,&sym);
				if (n < 0) {
					*failedp = true;
					return;
				}
				last_sym_idx = n;
			}

		if (ptr->howto == NULL) {
			*failedp = true;
			return;
		}
		src_rela.r_offset = ptr->address + addr_offset;
		src_rela.r_info = ELF64_R_INFO(n,ptr->howto->type);
		src_rela.r_addend = ptr->addend;
		(*swap_out) (abfd,&src_rela,dst_rela);
	}

}
static bool	elf_write_object_contents(bfd * abfd)
{
	Elf_Internal_Shdr **i_shdrp;
	bool		failed;
	unsigned int	count,num_sec;
	struct elf_obj_tdata *t;

	if (!abfd->output_has_begun
	    && !compute_section_file_positions(abfd,NULL))
		return false;
	/* Do not rewrite ELF data when the BFD has been opened for update.
	 * abfd->output_has_begun was set to TRUE on opening,so creation of
	 * new sections,and modification of existing section sizes was
	 * restricted.  This means the ELF header,program headers and section
	 * headers can't have changed.  If the contents of any sections has
	 * been modified,then those changes have already been written to the
	 * BFD.  */
	else
		if (abfd->direction == both_direction) {
			gas_assert(abfd->output_has_begun);
			return true;
		}
	i_shdrp = elf_elfsections(abfd);

	failed = false;
	map_over_sections(elf_write_relocs,&failed);
	if (failed)
		return false;

	if (!assign_file_positions_for_non_load(abfd))
		return false;

	/* After writing the headers,we need to write the sections too...  */
	num_sec = elf_numsections(abfd);
	for (count = 1; count < num_sec; count++) {
		i_shdrp[count]->sh_name
			= _bfd_elf_strtab_offset(elf_shstrtab(abfd),
						 i_shdrp[count]->sh_name);
		if (i_shdrp[count]->contents) {
			size_t		amt = i_shdrp[count]->sh_size;

			if (Seek(abfd,i_shdrp[count]->sh_offset,SEEK_SET) != 0
			    || bfd_bwrite(i_shdrp[count]->contents,amt,abfd) != amt)
				return false;
		}
	}

	/* Write out the section header names.  */
	t = elf_tdata(abfd);
	if (elf_shstrtab(abfd) != NULL
	    && (Seek(abfd,t->shstrtab_hdr.sh_offset,SEEK_SET) != 0
		|| !strtab_emit(abfd,elf_shstrtab(abfd))))
		return false;

	if (!elf_write_shdrs_and_ehdr(abfd))
		return false;
	return true;
}
static asection *
		bfd_get_section_by_name_if(bfd * abfd,const char *name,
	    		bool          (*operation) (bfd *,asection *,void *),
			     		void         *user_storage)
{
	struct section_hash_entry *sh;
	unsigned long	hash;

	if (name == NULL)
		return NULL;

	sh = section_hash_lookup(&abfd->section_htab,name,false,false);
	if (sh == NULL)
		return NULL;

	hash = sh->root.hash;
	for (; sh != NULL; sh = (struct section_hash_entry *)sh->root.next)
		if (sh->root.hash == hash
		    && strcmp(sh->root.string,name) == 0
		    && (*operation) (abfd,&sh->section,user_storage))
			return &sh->section;

	return NULL;
}
static asection *
		bfd_get_section_by_name(bfd * abfd,const char *name)
{
	struct section_hash_entry *sh;

	if (name == NULL)
		return NULL;

	sh = section_hash_lookup(&abfd->section_htab,name,false,false);
	if (sh != NULL)
		return &sh->section;

	return NULL;
}

/* Special_function of RISCV_ADD and RISCV_SUB relocations. 
 * elfxx-riscv.c:999 */
static bfd_reloc_status_type riscv_elf_add_sub_reloc(bfd * abfd,
				       		arelent *	reloc_entry,
					    		asymbol *	symbol,
								void         *data,
				     		asection *	input_section,
							bfd *		output_bfd,
		      		char        **error_message ATTRIBUTE_UNUSED)
{
	reloc_howto_type *howto = reloc_entry->howto;
	bfd_vma		relocation;

	if (output_bfd != NULL
	    && (symbol->flags & BSF_SECTION_SYM) == 0
	    && (!reloc_entry->howto->partial_inplace || reloc_entry->addend == 0)) {
		reloc_entry->address += input_section->output_offset;
		return bfd_reloc_ok;
	}
	if (output_bfd != NULL)
		return bfd_reloc_continue;

	relocation = symbol->value + symbol->section->output_section->vma
		+ symbol->section->output_offset + reloc_entry->addend;

	size_t		octets = reloc_entry->address;
	if (!bfd_reloc_offset_in_range(reloc_entry->howto,abfd,
				       input_section,octets))
		return bfd_reloc_outofrange;

	bfd_vma		old_value = bfd_get(howto->bitsize,abfd,
				     data + reloc_entry->address);

	switch (howto->type) {
	case R_RISCV_ADD8:case R_RISCV_ADD16:case R_RISCV_ADD32:case R_RISCV_ADD64:
		relocation = old_value + relocation;
		break;
	case R_RISCV_SUB6:
		relocation = (old_value & ~howto->dst_mask)
			| (((old_value & howto->dst_mask) - relocation)
			   & howto->dst_mask);
		break;
	case R_RISCV_SUB8:case R_RISCV_SUB16:case R_RISCV_SUB32:case R_RISCV_SUB64:
		relocation = old_value - relocation;
		break;
	}
	bfd_put(howto->bitsize,abfd,relocation,data + reloc_entry->address);

	return bfd_reloc_ok;
}
/* Special handler for relocations which don't have to be relocated. This
 * function just simply return bfd_reloc_ok.  */
static bfd_reloc_status_type riscv_elf_ignore_reloc(bfd * abfd ATTRIBUTE_UNUSED,
				      		arelent *	reloc_entry,
			  		asymbol *	symbol ATTRIBUTE_UNUSED,
			      		void         *data ATTRIBUTE_UNUSED,
				    		asection *	input_section,
				       		bfd *		output_bfd,
		     		char        **error_message ATTRIBUTE_UNUSED)
{
	if (output_bfd != NULL)
		reloc_entry->address += input_section->output_offset;
	return bfd_reloc_ok;
}
/* ELF relocs are against symbols.  If we are producing relocatable output,and
 * the reloc is against an external symbol,and nothing has given us any
 * additional addend,the resulting reloc will also be against the same symbol.
 * In such a case,we don't want to change anything about the way the reloc is
 * handled,since it will all be done at final link time.  Rather than put
 * special case code into bfd_perform_relocation,all the reloc types use this
 * howto function,or should call this function for relocatable output.  */
static bfd_reloc_status_type bfd_elf_generic_reloc(bfd * abfd ATTRIBUTE_UNUSED,
				     		arelent *	reloc_entry,
					  		asymbol *	symbol,
			     		void         *data ATTRIBUTE_UNUSED,
				   		asection *	input_section,
				      		bfd *		output_bfd,
		    		char        **error_message ATTRIBUTE_UNUSED)
{
	if (output_bfd != NULL
	    && (symbol->flags & BSF_SECTION_SYM) == 0
	    && (!reloc_entry->howto->partial_inplace
		|| reloc_entry->addend == 0)) {
		reloc_entry->address += input_section->output_offset;
		return bfd_reloc_ok;
	}
	/* In some cases the relocation should be treated as output section
	 * relative,as when linking ELF DWARF into PE COFF.  Many ELF targets
	 * lack section relative relocations and instead use ordinary absolute
	 * relocations for references between DWARF sections.  That is arguably
	 * a bug in those targets but it happens to work for the usual case of
	 * linking to non-loaded ELF debug sections with VMAs forced to zero.
	 * PE COFF on the other hand doesn't allow a section VMA of zero.  */
	if (output_bfd == NULL
	    && !reloc_entry->howto->pc_relative
	    && (symbol->section->flags & SEC_DEBUGGING) != 0
	    && (input_section->flags & SEC_DEBUGGING) != 0)
		reloc_entry->addend -= symbol->section->output_section->vma;

	return bfd_reloc_continue;
}
#define MINUS_ONE ((bfd_vma)0 - 1)
/* The relocation table used for SHT_RELA sections.  */
static reloc_howto_type howto_table[] = {
	/* No relocation.  */
	HOWTO(R_RISCV_NONE,	/* type */
	      0,		/* rightshift */
	      0,		/* size */
	      0,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_NONE",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      0,		/* dst_mask */
	      false),		/* pcrel_offset */

	/* 32 bit relocation.  */
	HOWTO(R_RISCV_32,	/* type */
	      0,		/* rightshift */
	      4,		/* size */
	      32,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_32",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      0xffffffff,	/* dst_mask */
	      false),		/* pcrel_offset */

	/* 64 bit relocation.  */
	HOWTO(R_RISCV_64,	/* type */
	      0,		/* rightshift */
	      8,		/* size */
	      64,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_64",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      MINUS_ONE,	/* dst_mask */
	      false),		/* pcrel_offset */

	/* Relocation against a local symbol in a shared object.  */
	HOWTO(R_RISCV_RELATIVE,	/* type */
	      0,		/* rightshift */
	      4,		/* size */
	      32,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_RELATIVE",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      0xffffffff,	/* dst_mask */
	      false),		/* pcrel_offset */

	HOWTO(R_RISCV_COPY,	/* type */
	      0,		/* rightshift */
	      0,		/* this one is variable size */
	      0,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_bitfield,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_COPY",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      0,		/* dst_mask */
	      false),		/* pcrel_offset */

	HOWTO(R_RISCV_JUMP_SLOT,/* type */
	      0,		/* rightshift */
	      8,		/* size */
	      64,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_bitfield,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_JUMP_SLOT",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      0,		/* dst_mask */
	      false),		/* pcrel_offset */

	/* Dynamic TLS relocations.  */
	HOWTO(R_RISCV_TLS_DTPMOD32,	/* type */
	      0,		/* rightshift */
	      4,		/* size */
	      32,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_TLS_DTPMOD32",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      0xffffffff,	/* dst_mask */
	      false),		/* pcrel_offset */

	HOWTO(R_RISCV_TLS_DTPMOD64,	/* type */
	      0,		/* rightshift */
	      8,		/* size */
	      64,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_TLS_DTPMOD64",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      MINUS_ONE,	/* dst_mask */
	      false),		/* pcrel_offset */

	HOWTO(R_RISCV_TLS_DTPREL32,	/* type */
	      0,		/* rightshift */
	      4,		/* size */
	      32,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_TLS_DTPREL32",	/* name */
	      true,		/* partial_inplace */
	      0,		/* src_mask */
	      0xffffffff,	/* dst_mask */
	      false),		/* pcrel_offset */

	HOWTO(R_RISCV_TLS_DTPREL64,	/* type */
	      0,		/* rightshift */
	      8,		/* size */
	      64,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_TLS_DTPREL64",	/* name */
	      true,		/* partial_inplace */
	      0,		/* src_mask */
	      MINUS_ONE,	/* dst_mask */
	      false),		/* pcrel_offset */

	HOWTO(R_RISCV_TLS_TPREL32,	/* type */
	      0,		/* rightshift */
	      4,		/* size */
	      32,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_TLS_TPREL32",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      0xffffffff,	/* dst_mask */
	      false),		/* pcrel_offset */

	HOWTO(R_RISCV_TLS_TPREL64,	/* type */
	      0,		/* rightshift */
	      8,		/* size */
	      64,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_TLS_TPREL64",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      MINUS_ONE,	/* dst_mask */
	      false),		/* pcrel_offset */

	/* Reserved for future relocs that the dynamic linker must understand.  */
	EMPTY_HOWTO(12),
	EMPTY_HOWTO(13),
	EMPTY_HOWTO(14),
	EMPTY_HOWTO(15),

	/* 12-bit PC-relative branch offset.  */
	HOWTO(R_RISCV_BRANCH,	/* type */
	      0,		/* rightshift */
	      4,		/* size */
	      32,		/* bitsize */
	      true,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_signed,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_BRANCH",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      ENCODE_BTYPE_IMM(-1U),	/* dst_mask */
	      true),		/* pcrel_offset */

	/* 20-bit PC-relative jump offset.  */
	HOWTO(R_RISCV_JAL,	/* type */
	      0,		/* rightshift */
	      4,		/* size */
	      32,		/* bitsize */
	      true,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_JAL",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      ENCODE_JTYPE_IMM(-1U),	/* dst_mask */
	      true),		/* pcrel_offset */

	/* 32-bit PC-relative function call (AUIPC/JALR).  */
	HOWTO(R_RISCV_CALL,	/* type */
	      0,		/* rightshift */
	      8,		/* size */
	      64,		/* bitsize */
	      true,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_CALL",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      ENCODE_UTYPE_IMM(-1U)|((bfd_vma) ENCODE_ITYPE_IMM(-1U) << 32),
	/* dst_mask */
	      true),		/* pcrel_offset */

	/* Like R_RISCV_CALL,but not locally binding.  */
	HOWTO(R_RISCV_CALL_PLT,	/* type */
	      0,		/* rightshift */
	      8,		/* size */
	      64,		/* bitsize */
	      true,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_CALL_PLT",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      ENCODE_UTYPE_IMM(-1U)|((bfd_vma) ENCODE_ITYPE_IMM(-1U) << 32),
	/* dst_mask */
	      true),		/* pcrel_offset */

	/* High 20 bits of 32-bit PC-relative GOT access.  */
	HOWTO(R_RISCV_GOT_HI20,	/* type */
	      0,		/* rightshift */
	      4,		/* size */
	      32,		/* bitsize */
	      true,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_GOT_HI20",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      ENCODE_UTYPE_IMM(-1U),	/* dst_mask */
	      false),		/* pcrel_offset */

	/* High 20 bits of 32-bit PC-relative TLS IE GOT access.  */
	HOWTO(R_RISCV_TLS_GOT_HI20,	/* type */
	      0,		/* rightshift */
	      4,		/* size */
	      32,		/* bitsize */
	      true,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_TLS_GOT_HI20",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      ENCODE_UTYPE_IMM(-1U),	/* dst_mask */
	      false),		/* pcrel_offset */

	/* High 20 bits of 32-bit PC-relative TLS GD GOT reference.  */
	HOWTO(R_RISCV_TLS_GD_HI20,	/* type */
	      0,		/* rightshift */
	      4,		/* size */
	      32,		/* bitsize */
	      true,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_TLS_GD_HI20",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      ENCODE_UTYPE_IMM(-1U),	/* dst_mask */
	      false),		/* pcrel_offset */

	/* High 20 bits of 32-bit PC-relative reference.  */
	HOWTO(R_RISCV_PCREL_HI20,	/* type */
	      0,		/* rightshift */
	      4,		/* size */
	      32,		/* bitsize */
	      true,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_PCREL_HI20",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      ENCODE_UTYPE_IMM(-1U),	/* dst_mask */
	      true),		/* pcrel_offset */

	/* Low 12 bits of a 32-bit PC-relative load or add.  */
	HOWTO(R_RISCV_PCREL_LO12_I,	/* type */
	      0,		/* rightshift */
	      4,		/* size */
	      32,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_PCREL_LO12(",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      ENCODE_ITYPE_IMM(-1U),	/* dst_mask */
	      false),		/* pcrel_offset */

	/* Low 12 bits of a 32-bit PC-relative store.  */
	HOWTO(R_RISCV_PCREL_LO12_S,	/* type */
	      0,		/* rightshift */
	      4,		/* size */
	      32,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_PCREL_LO12(",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      ENCODE_STYPE_IMM(-1U),	/* dst_mask */
	      false),		/* pcrel_offset */

	/* High 20 bits of 32-bit absolute address.  */
	HOWTO(R_RISCV_HI20,	/* type */
	      0,		/* rightshift */
	      4,		/* size */
	      32,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_HI20",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      ENCODE_UTYPE_IMM(-1U),	/* dst_mask */
	      false),		/* pcrel_offset */

	/* High 12 bits of 32-bit load or add.  */
	HOWTO(R_RISCV_LO12_I,	/* type */
	      0,		/* rightshift */
	      4,		/* size */
	      32,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_LO12(",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      ENCODE_ITYPE_IMM(-1U),	/* dst_mask */
	      false),		/* pcrel_offset */

	/* High 12 bits of 32-bit store.  */
	HOWTO(R_RISCV_LO12_S,	/* type */
	      0,		/* rightshift */
	      4,		/* size */
	      32,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_LO12(",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      ENCODE_STYPE_IMM(-1U),	/* dst_mask */
	      false),		/* pcrel_offset */

	/* High 20 bits of TLS LE thread pointer offset.  */
	HOWTO(R_RISCV_TPREL_HI20,	/* type */
	      0,		/* rightshift */
	      4,		/* size */
	      32,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_signed,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_TPREL_HI20",	/* name */
	      true,		/* partial_inplace */
	      0,		/* src_mask */
	      ENCODE_UTYPE_IMM(-1U),	/* dst_mask */
	      false),		/* pcrel_offset */

	/* Low 12 bits of TLS LE thread pointer offset for loads and adds.  */
	HOWTO(R_RISCV_TPREL_LO12_I,	/* type */
	      0,		/* rightshift */
	      4,		/* size */
	      32,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_signed,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_TPREL_LO12(",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      ENCODE_ITYPE_IMM(-1U),	/* dst_mask */
	      false),		/* pcrel_offset */

	/* Low 12 bits of TLS LE thread pointer offset for stores.  */
	HOWTO(R_RISCV_TPREL_LO12_S,	/* type */
	      0,		/* rightshift */
	      4,		/* size */
	      32,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_signed,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_TPREL_LO12(",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      ENCODE_STYPE_IMM(-1U),	/* dst_mask */
	      false),		/* pcrel_offset */

	/* TLS LE thread pointer usage.  May be relaxed.  */
	HOWTO(R_RISCV_TPREL_ADD,/* type */
	      0,		/* rightshift */
	      0,		/* size */
	      0,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_TPREL_ADD",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      0,		/* dst_mask */
	      false),		/* pcrel_offset */

	/* 8-bit in-place addition,for local label subtraction.  */
	HOWTO(R_RISCV_ADD8,	/* type */
	      0,		/* rightshift */
	      1,		/* size */
	      8,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      riscv_elf_add_sub_reloc,	/* special_function */
	      "R_RISCV_ADD8",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      0xff,		/* dst_mask */
	      false),		/* pcrel_offset */

	/* 16-bit in-place addition,for local label subtraction.  */
	HOWTO(R_RISCV_ADD16,	/* type */
	      0,		/* rightshift */
	      2,		/* size */
	      16,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      riscv_elf_add_sub_reloc,	/* special_function */
	      "R_RISCV_ADD16",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      0xffff,		/* dst_mask */
	      false),		/* pcrel_offset */

	/* 32-bit in-place addition,for local label subtraction.  */
	HOWTO(R_RISCV_ADD32,	/* type */
	      0,		/* rightshift */
	      4,		/* size */
	      32,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      riscv_elf_add_sub_reloc,	/* special_function */
	      "R_RISCV_ADD32",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      0xffffffff,	/* dst_mask */
	      false),		/* pcrel_offset */

	/* 64-bit in-place addition,for local label subtraction.  */
	HOWTO(R_RISCV_ADD64,	/* type */
	      0,		/* rightshift */
	      8,		/* size */
	      64,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      riscv_elf_add_sub_reloc,	/* special_function */
	      "R_RISCV_ADD64",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      MINUS_ONE,	/* dst_mask */
	      false),		/* pcrel_offset */

	/* 8-bit in-place addition,for local label subtraction.  */
	HOWTO(R_RISCV_SUB8,	/* type */
	      0,		/* rightshift */
	      1,		/* size */
	      8,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      riscv_elf_add_sub_reloc,	/* special_function */
	      "R_RISCV_SUB8",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      0xff,		/* dst_mask */
	      false),		/* pcrel_offset */

	/* 16-bit in-place addition,for local label subtraction.  */
	HOWTO(R_RISCV_SUB16,	/* type */
	      0,		/* rightshift */
	      2,		/* size */
	      16,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      riscv_elf_add_sub_reloc,	/* special_function */
	      "R_RISCV_SUB16",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      0xffff,		/* dst_mask */
	      false),		/* pcrel_offset */

	/* 32-bit in-place addition,for local label subtraction.  */
	HOWTO(R_RISCV_SUB32,	/* type */
	      0,		/* rightshift */
	      4,		/* size */
	      32,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      riscv_elf_add_sub_reloc,	/* special_function */
	      "R_RISCV_SUB32",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      0xffffffff,	/* dst_mask */
	      false),		/* pcrel_offset */

	/* 64-bit in-place addition,for local label subtraction.  */
	HOWTO(R_RISCV_SUB64,	/* type */
	      0,		/* rightshift */
	      8,		/* size */
	      64,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      riscv_elf_add_sub_reloc,	/* special_function */
	      "R_RISCV_SUB64",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      MINUS_ONE,	/* dst_mask */
	      false),		/* pcrel_offset */

	/* 41 and 42 are reserved.  */
	EMPTY_HOWTO(0),
	EMPTY_HOWTO(0),

	/*
	 * Indicates an alignment statement.  The addend field encodes how many
	 * bytes of NOPs follow the statement.  The desired alignment is the
	 * addend rounded up to the next power of two.
	 */
	HOWTO(R_RISCV_ALIGN,	/* type */
	      0,		/* rightshift */
	      0,		/* size */
	      0,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_ALIGN",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      0,		/* dst_mask */
	      false),		/* pcrel_offset */

	/* 8-bit PC-relative branch offset.  */
	HOWTO(R_RISCV_RVC_BRANCH,	/* type */
	      0,		/* rightshift */
	      2,		/* size */
	      16,		/* bitsize */
	      true,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_signed,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_RVC_BRANCH",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      ENCODE_CBTYPE_IMM(-1U),	/* dst_mask */
	      true),		/* pcrel_offset */

	/* 11-bit PC-relative jump offset.  */
	HOWTO(R_RISCV_RVC_JUMP,	/* type */
	      0,		/* rightshift */
	      2,		/* size */
	      16,		/* bitsize */
	      true,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_RVC_JUMP",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      ENCODE_CJTYPE_IMM(-1U),	/* dst_mask */
	      true),		/* pcrel_offset */

	/* High 6 bits of 18-bit absolute address.  */
	HOWTO(R_RISCV_RVC_LUI,	/* type */
	      0,		/* rightshift */
	      2,		/* size */
	      16,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_RVC_LUI",/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      ENCODE_CITYPE_IMM(-1U),	/* dst_mask */
	      false),		/* pcrel_offset */

	/* GP-relative load.  */
	HOWTO(R_RISCV_GPREL_I,	/* type */
	      0,		/* rightshift */
	      4,		/* size */
	      32,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_GPREL(",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      ENCODE_ITYPE_IMM(-1U),	/* dst_mask */
	      false),		/* pcrel_offset */

	/* GP-relative store.  */
	HOWTO(R_RISCV_GPREL_S,	/* type */
	      0,		/* rightshift */
	      4,		/* size */
	      32,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_GPREL(",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      ENCODE_STYPE_IMM(-1U),	/* dst_mask */
	      false),		/* pcrel_offset */

	/* TP-relative TLS LE load.  */
	HOWTO(R_RISCV_TPREL_I,	/* type */
	      0,		/* rightshift */
	      4,		/* size */
	      32,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_signed,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_TPREL(",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      ENCODE_ITYPE_IMM(-1U),	/* dst_mask */
	      false),		/* pcrel_offset */

	/* TP-relative TLS LE store.  */
	HOWTO(R_RISCV_TPREL_S,	/* type */
	      0,		/* rightshift */
	      4,		/* size */
	      32,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_signed,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_TPREL(",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      ENCODE_STYPE_IMM(-1U),	/* dst_mask */
	      false),		/* pcrel_offset */

	/* The paired relocation may be relaxed.  */
	HOWTO(R_RISCV_RELAX,	/* type */
	      0,		/* rightshift */
	      0,		/* size */
	      0,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_RELAX",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      0,		/* dst_mask */
	      false),		/* pcrel_offset */

	/* 6-bit in-place addition,for local label subtraction.  */
	HOWTO(R_RISCV_SUB6,	/* type */
	      0,		/* rightshift */
	      1,		/* size */
	      8,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      riscv_elf_add_sub_reloc,	/* special_function */
	      "R_RISCV_SUB6",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      0x3f,		/* dst_mask */
	      false),		/* pcrel_offset */

	/* 6-bit in-place setting,for local label subtraction.  */
	HOWTO(R_RISCV_SET6,	/* type */
	      0,		/* rightshift */
	      1,		/* size */
	      8,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_SET6",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      0x3f,		/* dst_mask */
	      false),		/* pcrel_offset */

	/* 8-bit in-place setting,for local label subtraction.  */
	HOWTO(R_RISCV_SET8,	/* type */
	      0,		/* rightshift */
	      1,		/* size */
	      8,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_SET8",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      0xff,		/* dst_mask */
	      false),		/* pcrel_offset */

	/* 16-bit in-place setting,for local label subtraction.  */
	HOWTO(R_RISCV_SET16,	/* type */
	      0,		/* rightshift */
	      2,		/* size */
	      16,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_SET16",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      0xffff,		/* dst_mask */
	      false),		/* pcrel_offset */

	/* 32-bit in-place setting,for local label subtraction.  */
	HOWTO(R_RISCV_SET32,	/* type */
	      0,		/* rightshift */
	      4,		/* size */
	      32,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_SET32",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      0xffffffff,	/* dst_mask */
	      false),		/* pcrel_offset */

	/* 32-bit PC relative.  */
	HOWTO(R_RISCV_32_PCREL,	/* type */
	      0,		/* rightshift */
	      4,		/* size */
	      32,		/* bitsize */
	      true,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_32_PCREL",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      0xffffffff,	/* dst_mask */
	      false),		/* pcrel_offset */

	/* Relocation against a local ifunc symbol in a shared object.  */
	HOWTO(R_RISCV_IRELATIVE,/* type */
	      0,		/* rightshift */
	      4,		/* size */
	      32,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      bfd_elf_generic_reloc,	/* special_function */
	      "R_RISCV_IRELATIVE",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      0xffffffff,	/* dst_mask */
	      false),		/* pcrel_offset */

	/* Reserved for R_RISCV_PLT32.  */
	EMPTY_HOWTO(59),

	/* N-bit in-place setting,for unsigned-leb128 local label subtraction.  */
	HOWTO(R_RISCV_SET_ULEB128,	/* type */
	      0,		/* rightshift */
	      0,		/* size */
	      0,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      riscv_elf_ignore_reloc,	/* special_function */
	      "R_RISCV_SET_ULEB128",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      0,		/* dst_mask */
	      false),		/* pcrel_offset */

	/*
	 * N-bit in-place addition,for unsigned-leb128 local label
	 * subtraction.
	 */
	HOWTO(R_RISCV_SUB_ULEB128,	/* type */
	      0,		/* rightshift */
	      0,		/* size */
	      0,		/* bitsize */
	      false,		/* pc_relative */
	      0,		/* bitpos */
	      complain_overflow_dont,	/* complain_on_overflow */
	      riscv_elf_ignore_reloc,	/* special_function */
	      "R_RISCV_SUB_ULEB128",	/* name */
	      false,		/* partial_inplace */
	      0,		/* src_mask */
	      0,		/* dst_mask */
	      false),		/* pcrel_offset */
};
/* A mapping from BFD reloc types to RISC-V ELF reloc types.  */
struct elf_reloc_map {
	bfd_reloc_code_real_type bfd_val;
	enum elf_riscv_reloc_type elf_val;
};
static const struct elf_reloc_map riscv_reloc_map[] =
{
	{BFD_RELOC_NONE,R_RISCV_NONE},
	{BFD_RELOC_32,R_RISCV_32},
	{BFD_RELOC_64,R_RISCV_64},
	{BFD_RELOC_RISCV_ADD8,R_RISCV_ADD8},
	{BFD_RELOC_RISCV_ADD16,R_RISCV_ADD16},
	{BFD_RELOC_RISCV_ADD32,R_RISCV_ADD32},
	{BFD_RELOC_RISCV_ADD64,R_RISCV_ADD64},
	{BFD_RELOC_RISCV_SUB8,R_RISCV_SUB8},
	{BFD_RELOC_RISCV_SUB16,R_RISCV_SUB16},
	{BFD_RELOC_RISCV_SUB32,R_RISCV_SUB32},
	{BFD_RELOC_RISCV_SUB64,R_RISCV_SUB64},
	{BFD_RELOC_CTOR,R_RISCV_64},
	{BFD_RELOC_12_PCREL,R_RISCV_BRANCH},
	{BFD_RELOC_RISCV_HI20,R_RISCV_HI20},
	{BFD_RELOC_RISCV_LO12_I,R_RISCV_LO12_I},
	{BFD_RELOC_RISCV_LO12_S,R_RISCV_LO12_S},
	{BFD_RELOC_RISCV_PCREL_LO12_I,R_RISCV_PCREL_LO12_I},
	{BFD_RELOC_RISCV_PCREL_LO12_S,R_RISCV_PCREL_LO12_S},
	{BFD_RELOC_RISCV_CALL,R_RISCV_CALL},
	{BFD_RELOC_RISCV_CALL_PLT,R_RISCV_CALL_PLT},
	{BFD_RELOC_RISCV_PCREL_HI20,R_RISCV_PCREL_HI20},
	{BFD_RELOC_RISCV_JMP,R_RISCV_JAL},
	{BFD_RELOC_RISCV_GOT_HI20,R_RISCV_GOT_HI20},
	{BFD_RELOC_RISCV_TLS_DTPMOD32,R_RISCV_TLS_DTPMOD32},
	{BFD_RELOC_RISCV_TLS_DTPREL32,R_RISCV_TLS_DTPREL32},
	{BFD_RELOC_RISCV_TLS_DTPMOD64,R_RISCV_TLS_DTPMOD64},
	{BFD_RELOC_RISCV_TLS_DTPREL64,R_RISCV_TLS_DTPREL64},
	{BFD_RELOC_RISCV_TLS_TPREL32,R_RISCV_TLS_TPREL32},
	{BFD_RELOC_RISCV_TLS_TPREL64,R_RISCV_TLS_TPREL64},
	{BFD_RELOC_RISCV_TPREL_HI20,R_RISCV_TPREL_HI20},
	{BFD_RELOC_RISCV_TPREL_ADD,R_RISCV_TPREL_ADD},
	{BFD_RELOC_RISCV_TPREL_LO12_S,R_RISCV_TPREL_LO12_S},
	{BFD_RELOC_RISCV_TPREL_LO12_I,R_RISCV_TPREL_LO12_I},
	{BFD_RELOC_RISCV_TLS_GOT_HI20,R_RISCV_TLS_GOT_HI20},
	{BFD_RELOC_RISCV_TLS_GD_HI20,R_RISCV_TLS_GD_HI20},
	{BFD_RELOC_RISCV_ALIGN,R_RISCV_ALIGN},
	{BFD_RELOC_RISCV_RVC_BRANCH,R_RISCV_RVC_BRANCH},
	{BFD_RELOC_RISCV_RVC_JUMP,R_RISCV_RVC_JUMP},
	{BFD_RELOC_RISCV_RVC_LUI,R_RISCV_RVC_LUI},
	{BFD_RELOC_RISCV_GPREL_I,R_RISCV_GPREL_I},
	{BFD_RELOC_RISCV_GPREL_S,R_RISCV_GPREL_S},
	{BFD_RELOC_RISCV_TPREL_I,R_RISCV_TPREL_I},
	{BFD_RELOC_RISCV_TPREL_S,R_RISCV_TPREL_S},
	{BFD_RELOC_RISCV_RELAX,R_RISCV_RELAX},
	{BFD_RELOC_RISCV_SUB6,R_RISCV_SUB6},
	{BFD_RELOC_RISCV_SET6,R_RISCV_SET6},
	{BFD_RELOC_RISCV_SET8,R_RISCV_SET8},
	{BFD_RELOC_RISCV_SET16,R_RISCV_SET16},
	{BFD_RELOC_RISCV_SET32,R_RISCV_SET32},
	{BFD_RELOC_RISCV_32_PCREL,R_RISCV_32_PCREL},
	{BFD_RELOC_RISCV_SET_ULEB128,R_RISCV_SET_ULEB128},
	{BFD_RELOC_RISCV_SUB_ULEB128,R_RISCV_SUB_ULEB128},
};
/* Given a BFD reloc type,return a howto structure.  */
static reloc_howto_type *riscv_reloc_type_lookup(bfd * abfd ATTRIBUTE_UNUSED,
				 		bfd_reloc_code_real_type code)
{
	unsigned int	i;

	for (i = 0; i < ARRAY_SIZE(riscv_reloc_map); i++)
		if (riscv_reloc_map[i].bfd_val == code)
			return &howto_table[(int)riscv_reloc_map[i].elf_val];

	bfd_set_error(bfd_error_bad_value);
	return NULL;
}
static reloc_howto_type *riscv_reloc_name_lookup(bfd * abfd ATTRIBUTE_UNUSED,const char *r_name)
{
	unsigned int	i;

	for (i = 0; i < ARRAY_SIZE(howto_table); i++)
		if (howto_table[i].name && strcasecmp(howto_table[i].name,r_name) == 0)
			return &howto_table[i];

	return NULL;
}
/* Return the default section type based on the passed in section flags.  */
static int	elf_get_default_section_type(unsigned flags)
{
	if ((flags & (SEC_ALLOC|SEC_IS_COMMON)) != 0
	    && (flags & (SEC_LOAD|SEC_HAS_CONTENTS)) == 0)
		return SHT_NOBITS;
	return SHT_PROGBITS;
}
static void	error_handler(const char *fmt,...)
{
	va_list		ap;

	va_start(ap,fmt);
	vfprintf(stderr,fmt,ap);
	va_end(ap);
}

/* Each instruction belongs to an instruction class INSN_CLASS_*. Call
 * riscv_subset_supports to make sure that the instuction is valid.  */
static	bool riscv_multi_subset_supports(riscv_parse_subset_t * rps,
					enum		riscv_insn_class insn_class)
{
	switch (insn_class) {
	case INSN_CLASS_I: return riscv_subset_supports(rps,"i");
	case INSN_CLASS_ZICBOM: return riscv_subset_supports(rps,"zicbom");
	case INSN_CLASS_ZICBOP: return riscv_subset_supports(rps,"zicbop");
	case INSN_CLASS_ZICBOZ: return riscv_subset_supports(rps,"zicboz");
	case INSN_CLASS_ZICSR: return riscv_subset_supports(rps,"zicsr");
	case INSN_CLASS_ZIFENCEI: return riscv_subset_supports(rps,"zifencei");
	case INSN_CLASS_ZIHINTPAUSE: return riscv_subset_supports(rps,"zihintpause");
	case INSN_CLASS_M: return riscv_subset_supports(rps,"m");
	case INSN_CLASS_ZMMUL: return riscv_subset_supports(rps,"zmmul");
	case INSN_CLASS_A: return riscv_subset_supports(rps,"a");
	case INSN_CLASS_ZAWRS: return riscv_subset_supports(rps,"zawrs");
	case INSN_CLASS_F: return riscv_subset_supports(rps,"f");
	case INSN_CLASS_D: return riscv_subset_supports(rps,"d");
	case INSN_CLASS_Q: return riscv_subset_supports(rps,"q");
	case INSN_CLASS_C: return riscv_subset_supports(rps,"c");
	case INSN_CLASS_F_AND_C:
		return (riscv_subset_supports(rps,"f")
			&& riscv_subset_supports(rps,"c"));
	case INSN_CLASS_D_AND_C:
		return (riscv_subset_supports(rps,"d")
			&& riscv_subset_supports(rps,"c"));
	case INSN_CLASS_F_INX:
		return (riscv_subset_supports(rps,"f")
			|| riscv_subset_supports(rps,"zfinx"));
	case INSN_CLASS_D_INX:
		return (riscv_subset_supports(rps,"d")
			|| riscv_subset_supports(rps,"zdinx"));
	case INSN_CLASS_Q_INX:
		return (riscv_subset_supports(rps,"q")
			|| riscv_subset_supports(rps,"zqinx"));
	case INSN_CLASS_ZFH_INX:
		return (riscv_subset_supports(rps,"zfh")
			|| riscv_subset_supports(rps,"zhinx"));
	case INSN_CLASS_ZFHMIN:
		return riscv_subset_supports(rps,"zfhmin");
	case INSN_CLASS_ZFHMIN_INX:
		return (riscv_subset_supports(rps,"zfhmin")
			|| riscv_subset_supports(rps,"zhinxmin"));
	case INSN_CLASS_ZFHMIN_AND_D_INX:
		return ((riscv_subset_supports(rps,"zfhmin")
			 && riscv_subset_supports(rps,"d"))
			|| (riscv_subset_supports(rps,"zhinxmin")
			    && riscv_subset_supports(rps,"zdinx")));
	case INSN_CLASS_ZFHMIN_AND_Q_INX:
		return ((riscv_subset_supports(rps,"zfhmin")
			 && riscv_subset_supports(rps,"q"))
			|| (riscv_subset_supports(rps,"zhinxmin")
			    && riscv_subset_supports(rps,"zqinx")));
	case INSN_CLASS_ZBA: return riscv_subset_supports(rps,"zba");
	case INSN_CLASS_ZBB: return riscv_subset_supports(rps,"zbb");
	case INSN_CLASS_ZBC: return riscv_subset_supports(rps,"zbc");
	case INSN_CLASS_ZBS: return riscv_subset_supports(rps,"zbs");
	case INSN_CLASS_ZBKB: return riscv_subset_supports(rps,"zbkb");
	case INSN_CLASS_ZBKC: return riscv_subset_supports(rps,"zbkc");
	case INSN_CLASS_ZBKX: return riscv_subset_supports(rps,"zbkx");
	case INSN_CLASS_ZBB_OR_ZBKB:
		return (riscv_subset_supports(rps,"zbb")
			|| riscv_subset_supports(rps,"zbkb"));
	case INSN_CLASS_ZBC_OR_ZBKC:
		return (riscv_subset_supports(rps,"zbc")
			|| riscv_subset_supports(rps,"zbkc"));
	case INSN_CLASS_ZKND: return riscv_subset_supports(rps,"zknd");
	case INSN_CLASS_ZKNE: return riscv_subset_supports(rps,"zkne");
	case INSN_CLASS_ZKNH: return riscv_subset_supports(rps,"zknh");
	case INSN_CLASS_ZKND_OR_ZKNE:
		return (riscv_subset_supports(rps,"zknd")
			|| riscv_subset_supports(rps,"zkne"));
	case INSN_CLASS_ZKSED: return riscv_subset_supports(rps,"zksed");
	case INSN_CLASS_ZKSH: return riscv_subset_supports(rps,"zksh");
	case INSN_CLASS_V:
		return (riscv_subset_supports(rps,"v")
			|| riscv_subset_supports(rps,"zve64x")
			|| riscv_subset_supports(rps,"zve32x"));
	case INSN_CLASS_ZVEF:
		return (riscv_subset_supports(rps,"v")
			|| riscv_subset_supports(rps,"zve64d")
			|| riscv_subset_supports(rps,"zve64f")
			|| riscv_subset_supports(rps,"zve32f"));
	case INSN_CLASS_SVINVAL: return riscv_subset_supports(rps,"svinval");
	case INSN_CLASS_H: return riscv_subset_supports(rps,"h");
	case INSN_CLASS_XTHEADBA: return riscv_subset_supports(rps,"xtheadba");
	case INSN_CLASS_XTHEADBB: return riscv_subset_supports(rps,"xtheadbb");
	case INSN_CLASS_XTHEADBS: return riscv_subset_supports(rps,"xtheadbs");
	case INSN_CLASS_XTHEADCMO: return riscv_subset_supports(rps,"xtheadcmo");
	case INSN_CLASS_XTHEADCONDMOV: return riscv_subset_supports(rps,"xtheadcondmov");
	case INSN_CLASS_XTHEADFMEMIDX: return riscv_subset_supports(rps,"xtheadfmemidx");
	case INSN_CLASS_XTHEADFMV: return riscv_subset_supports(rps,"xtheadfmv");
	case INSN_CLASS_XTHEADINT: return riscv_subset_supports(rps,"xtheadint");
	case INSN_CLASS_XTHEADMAC: return riscv_subset_supports(rps,"xtheadmac");
	case INSN_CLASS_XTHEADMEMIDX: return riscv_subset_supports(rps,"xtheadmemidx");
	case INSN_CLASS_XTHEADMEMPAIR: return riscv_subset_supports(rps,"xtheadmempair");
	case INSN_CLASS_XTHEADSYNC: return riscv_subset_supports(rps,"xtheadsync");
	case INSN_CLASS_XVENTANACONDOPS: return riscv_subset_supports(rps,"xventanacondops");
	default:
		rps->error_handler("internal: unreachable INSN_CLASS_*");
		return false;
	}
}
static void	bfd_putl8(bfd_vma data,void *p)
{
	bfd_byte       *addr = (bfd_byte *) p;
	addr[0] = data & 0xff;
}
static void	bfd_putl16(bfd_vma data,void *p)
{
	bfd_byte       *addr = (bfd_byte *) p;
	addr[0] = data & 0xff;
	addr[1] = (data >> 8) & 0xff;
}
static void	bfd_putl32(bfd_vma data,void *p)
{
	bfd_byte       *addr = (bfd_byte *) p;
	addr[0] = data & 0xff;
	addr[1] = (data >> 8) & 0xff;
	addr[2] = (data >> 16) & 0xff;
	addr[3] = (data >> 24) & 0xff;
}

static void	bfd_putl64(bfd_vma data,void *p)
{
	bfd_byte       *addr = (bfd_byte *) p;
	addr[0] = data & 0xff;
	addr[1] = (data >> 8) & 0xff;
	addr[2] = (data >> 16) & 0xff;
	addr[3] = (data >> 24) & 0xff;
	addr[4] = (data >> 32) & 0xff;
	addr[5] = (data >> 40) & 0xff;
	addr[6] = (data >> 48) & 0xff;
	addr[7] = (data >> 56) & 0xff;
}
static bfd_vma	bfd_getl8(const void *p)
{
	const bfd_byte *addr = (const bfd_byte *)p;
	return *addr;
}
static bfd_vma	bfd_getl16(const void *p)
{
	const bfd_byte *addr = (const bfd_byte *)p;
	return (addr[1] << 8)|addr[0];
}
static bfd_vma	bfd_getl32(const void *p)
{
	const bfd_byte *addr = (const bfd_byte *)p;
	uint32_t	v;

	v = (uint32_t) addr[0];
	v |= (uint32_t) addr[1] << 8;
	v |= (uint32_t) addr[2] << 16;
	v |= (uint32_t) addr[3] << 24;
	return v;
}
static bfd_vma	bfd_getl64(const void *p)
{
	const bfd_byte *addr = (const bfd_byte *)p;
	uint64_t	v;

	v = (uint64_t) addr[0];
	v |= (uint64_t) addr[1] << 8;
	v |= (uint64_t) addr[2] << 16;
	v |= (uint64_t) addr[3] << 24;
	v |= (uint64_t) addr[4] << 32;
	v |= (uint64_t) addr[5] << 40;
	v |= (uint64_t) addr[6] << 48;
	v |= (uint64_t) addr[7] << 56;
	return v;
}
static bfd_vma	bfd_getl24(const void *p)
{
	const bfd_byte *addr = (const bfd_byte *)p;
	uint32_t	v;

	v = (uint32_t) addr[0];
	v |= (uint32_t) addr[1] << 8;
	v |= (uint32_t) addr[2] << 16;
	return v;
}
static void	bfd_putl24(bfd_vma data,void *p)
{
	bfd_byte       *addr = (bfd_byte *) p;
	addr[0] = data & 0xff;
	addr[1] = (data >> 8) & 0xff;
	addr[2] = (data >> 16) & 0xff;
}
/* Return the number of bytes needed by I in uleb128 format.  */
static int	uleb128_size(unsigned int i)
{
	int		size;
	size = 1;
	while (i >= 0x80) {
		i >>= 7;
		size++;
	}
	return size;
}
static bool	bfd_hash_table_init_n(struct bfd_hash_table *table,
    		struct	bfd_hash_entry *(*newfunc) (struct bfd_hash_entry *,
				      		struct	bfd_hash_table *,
				      		const		char  *),
						unsigned	int	entsize,
				  		unsigned	int	size)
{
	unsigned long	alloc;

	alloc = size;
	alloc *= sizeof(struct bfd_hash_entry *);
	if (alloc / sizeof(struct bfd_hash_entry *) != size) {
		bfd_set_error(bfd_error_no_memory);
		return false;
	}
	table->memory = (void *)objalloc_create();
	if (table->memory == NULL) {
		bfd_set_error(bfd_error_no_memory);
		return false;
	}
	table->table = (struct bfd_hash_entry **)
		objalloc_alloc((struct objalloc *)table->memory,alloc);
	if (table->table == NULL) {
		bfd_hash_table_free(table);
		bfd_set_error(bfd_error_no_memory);
		return false;
	}
	memset((void *)table->table,0,alloc);
	table->size = size;
	table->entsize = entsize;
	table->count = 0;
	table->frozen = 0;
	table->newfunc = newfunc;
	return true;
}
static void	bfd_sprintf_vma(bfd * abfd ATTRIBUTE_UNUSED,char *buf,bfd_vma value)
{
	sprintf(buf,"%016" PRIx64,(uint64_t) value);
}
/* Free a strtab.  */
static void	_bfd_elf_strtab_free(struct elf_strtab_hash *tab)
{
	bfd_hash_table_free(&tab->table);
	free(tab->array);
	free(tab);
}
static struct bfd_hash_entry *
		elf_strtab_hash_newfunc(struct bfd_hash_entry *entry,
			  		struct	bfd_hash_table *table,
			  		const		char  *string);
/* Create a new hash table.  */
struct elf_strtab_hash *_bfd_elf_strtab_init(void)
{
	struct elf_strtab_hash *table;
	size_t		amt = sizeof(struct elf_strtab_hash);

	table = (struct elf_strtab_hash *)malloc(amt);
	if (table == NULL)
		return NULL;

	if (!bfd_hash_table_init(&table->table,elf_strtab_hash_newfunc,
				 sizeof(struct elf_strtab_hash_entry))) {
		free(table);
		return NULL;
	}
	table->sec_size = 0;
	table->size = 1;
	table->alloced = 64;
	amt = sizeof(struct elf_strtab_hasn_entry *);
	table->array = ((struct elf_strtab_hash_entry **)
			malloc(table->alloced * amt));
	if (table->array == NULL) {
		free(table);
		return NULL;
	}
	table->array[0] = NULL;

	return table;
}
static size_t	bfd_bwrite(const void *ptr,size_t size,bfd * abfd)
{
	file_ptr	nwrote;

	nwrote = fwrite(ptr,1,size,abfd->iostream);
	if (nwrote != -1)
		abfd->where += nwrote;
	if ((size_t) nwrote != size) {
#ifdef ENOSPC
		errno = ENOSPC;
#endif
		bfd_set_error(bfd_error_system_call);
	}
	return nwrote;
}
/* Routine to create an entry in a section merge hashtab.  */
static struct bfd_hash_entry *
		elf_strtab_hash_newfunc(struct bfd_hash_entry *entry,
			  		struct	bfd_hash_table *table,
			  		const		char  *string)
{
	/* Allocate the structure if it has not already been allocated by a
	 * subclass.  */
	if (entry == NULL)
		entry = (struct bfd_hash_entry *)
		bfd_hash_allocate(table,sizeof(struct elf_strtab_hash_entry));
	if (entry == NULL)
		return NULL;

	/* Call the allocation method of the superclass.  */
	entry = bfd_hash_newfunc(entry,table,string);

	if (entry) {
		/* Initialize the local fields.  */
		struct elf_strtab_hash_entry *ret;

		ret = (struct elf_strtab_hash_entry *)entry;
		ret->u.index = -1;
		ret->refcount = 0;
		ret->len = 0;
	}
	return entry;
}
static void	_bfd_stab_cleanup(bfd * abfd ATTRIBUTE_UNUSED,void **pinfo)
{
	struct stab_find_info *info = (struct stab_find_info *)*pinfo;
	if (info == NULL)
		return;

	free(info->indextable);
	free(info->strs);
	free(info->stabs);
}
static void    *bfd_arch_default_fill(size_t count,bool is_bigendian ATTRIBUTE_UNUSED,
			   		bool		code	ATTRIBUTE_UNUSED)
{
	void           *fill = malloc(count);
	if (fill != NULL)
		memset(fill,0,count);
	return fill;
}
static void	bfd_release(bfd * abfd,void *block)
{
	objalloc_free_block((struct objalloc *)abfd->memory,block);
}
static void	bfd_hash_table_free(struct bfd_hash_table *table)
{
	objalloc_free((struct objalloc *)table->memory);
	table->memory = NULL;
}
static void	bfd_elf64_swap_reloca_out(bfd * abfd ATTRIBUTE_UNUSED,
			    		const		Elf_Internal_Rela * src,
				      		bfd_byte *	d)
{
	Elf64_External_Rela *dst = (Elf64_External_Rela *) d;
	bfd_putl64(src->r_offset,dst->r_offset);
	bfd_putl64(src->r_info,dst->r_info);
	bfd_putl64(src->r_addend,dst->r_addend);
}
static bool	bfd_hash_table_init(struct bfd_hash_table *table,
  		struct	bfd_hash_entry *(*newfunc) (struct bfd_hash_entry *,
				       		struct	bfd_hash_table *,
				       		const		char  *),
			      		unsigned	int	entsize)
{
	return bfd_hash_table_init_n(table,newfunc,entsize,4051);
}
static void	bfd_putb64(uint64_t data,void *p)
{
	bfd_byte       *addr = (bfd_byte *) p;
	addr[0] = (data >> (7 * 8)) & 0xff;
	addr[1] = (data >> (6 * 8)) & 0xff;
	addr[2] = (data >> (5 * 8)) & 0xff;
	addr[3] = (data >> (4 * 8)) & 0xff;
	addr[4] = (data >> (3 * 8)) & 0xff;
	addr[5] = (data >> (2 * 8)) & 0xff;
	addr[6] = (data >> (1 * 8)) & 0xff;
	addr[7] = (data >> (0 * 8)) & 0xff;
}
static void	_bfd_elf_strtab_clear_all_refs(struct elf_strtab_hash *tab)
{
	size_t		idx;

	for (idx = 1; idx < tab->size; idx++)
		tab->array[idx]->refcount = 0;
}
static void	bfd_rename_section(asection * sec,const char *newname)
{
	struct section_hash_entry *sh;

	sh = (struct section_hash_entry *)
		((char *)sec - offsetof(struct section_hash_entry,section));
	sh->section.name = newname;
	bfd_hash_rename(&sec->owner->section_htab,newname,&sh->root);
}
/* Compressed section support (intended for debug sections). */
#define MAX_COMPRESSION_HEADER_SIZE 24

/* FUNCTION bfd_update_compression_header compress.c:153
 * SYNOPSIS void bfd_update_compression_header (bfd *abfd,bfd_byte *contents,
 * asection *sec);
 * 
 * DESCRIPTION Set the compression header at CONTENTS of SEC in ABFD and update
 * elf_section_flags for compression.  */
static void	bfd_update_compression_header(bfd * abfd,bfd_byte * contents,
					  		asection *	sec)
{
	if ((abfd->flags & BFD_COMPRESS) == 0)
		abort();

	switch (bfd_get_flavour(abfd)) {
	case bfd_target_elf_flavour:
		if ((abfd->flags & BFD_COMPRESS_GABI) != 0) {
			struct bfd_elf_section_data *esd = elf_section_data(sec);
			enum compression_type ch_type = (abfd->flags & BFD_COMPRESS_ZSTD
							 ? ch_compress_zstd
							 : ch_compress_zlib);

			/* Set the SHF_COMPRESSED bit.  */
			elf_section_flags(sec) |= SHF_COMPRESSED;

			{
				Elf64_External_Chdr *echdr = (Elf64_External_Chdr *) contents;
				bfd_putl32(ch_type,&echdr->ch_type);
				bfd_putl32(0,&echdr->ch_reserved);
				bfd_putl64(sec->size,&echdr->ch_size);
				bfd_putl64(UINT64_C(1) << sec->alignment_power,
					   &echdr->ch_addralign);
				/* bfd_log2 (alignof (Elf64_Chdr)) */
				bfd_set_section_alignment(sec,3);
				esd->this_hdr.sh_addralign = 8;
			}
			break;
		}
		/* Clear the SHF_COMPRESSED bit.  */
		elf_section_flags(sec) &= ~SHF_COMPRESSED;
		/* Fall through.  */

	default:
		/* Write the zlib header.  It should be "ZLIB" followed by the
		 * uncompressed section size,8 bytes in big-endian order.  */
		memcpy(contents,"ZLIB",4);
		bfd_putb64(sec->size,contents + 4);
		/* No way to keep the original alignment,just use 1 always. */
		bfd_set_section_alignment(sec,0);
		break;
	}
}

static int	bfd_get_compression_header_size(bfd * abfd ATTRIBUTE_UNUSED,
			    		asection *	sec ATTRIBUTE_UNUSED)
{
	return 0;
}

static bool	bfd_compress_section(bfd * abfd ATTRIBUTE_UNUSED,
			      		sec_ptr	sec	ATTRIBUTE_UNUSED,
	 		bfd_byte *	uncompressed_bufferi ATTRIBUTE_UNUSED)
{
	return false;
}
static unsigned int bfd_log2(bfd_vma x)
{
	unsigned int	result = 0;

	if (x <= 1)
		return result;
	--x;
	do
		++result;
	while ((x >>= 1) != 0);
	return result;
}
static bool	bfd_default_scan(const bfd_arch_info_type * info ATTRIBUTE_UNUSED,
		    		const		char  *string ATTRIBUTE_UNUSED)
{
	abort();
	return false;
}
/* hash.c:687 */
static void	bfd_hash_rename(struct bfd_hash_table *table,
			    		const		char  *string,
			    		struct	bfd_hash_entry *ent)
{
	unsigned int	_index;
	struct bfd_hash_entry **pph;

	_index = ent->hash % table->size;
	for (pph = &table->table[_index]; *pph != NULL; pph = &(*pph)->next)
		if (*pph == ent)
			break;
	if (*pph == NULL) abort();

	*pph = ent->next;
	ent->string = string;
	ent->hash = bfd_hash_hash(string,NULL);
	_index = ent->hash % table->size;
	ent->next = table->table[_index];
	table->table[_index] = ent;
}
/* Add a int+string object attribute.  */
static void	elf_add_obj_attr_int_string(bfd * abfd,int vendor,unsigned int tag,
    		unsigned	int	i,const char *s,const char *end)
{
	obj_attribute  *attr;

	attr = elf_new_obj_attr(abfd,vendor,tag);
	attr->type = _bfd_elf_obj_attrs_arg_type(abfd,vendor,tag);
	attr->i = i;
	attr->s = elf_attr_strdup(abfd,s,end);
}

static void	bfd_elf_add_obj_attr_int_string(bfd * abfd,int vendor,unsigned int tag,
			 		unsigned	int	i,const char *s)
{
	elf_add_obj_attr_int_string(abfd,vendor,tag,i,s,NULL);
}
bool		bfd_default_set_arch_mach(bfd * abfd,
       		enum		bfd_architecture arch ATTRIBUTE_UNUSED,
				unsigned	long	mach ATTRIBUTE_UNUSED)
{
	abfd->arch_info = &bfd_riscv_arch;
	if (abfd->arch_info != NULL)
		return true;

	bfd_set_error(bfd_error_bad_value);
	return false;
}
